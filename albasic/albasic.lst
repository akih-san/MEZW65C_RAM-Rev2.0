     1                        	; Applesoft Lite
     2                        ;
     3                        ; Disassembled from the Apple II+ ROMs with da65 V2.12.0
     4                        ;
     5                        ; Most comments and label names from the S-C DocuMentor
     6                        ; by Bob Sander-Cederlof
     7                        ;
     8                        ; Adapted for the Replica-1 by Tom Greene
     9                        ; 7-May-2008
    10                        
    11                        
    12                        	pl	0
    13                        	pw      132
    14                        	chip    65C02
    15                        
    16                        
    17                        ; Zero Page locatinos used by Applesoft Lite
    18                        
    19                        	.page0
    20                        
    21             00000000   GOWARM		equ $0000	; Gets "jmp RESTART"
    22             00000003   GOSTROUTZ		equ $0003	; Gets "jmp STROUT"
    23             0000000D   CHARAC		equ $000D	; Alternate string terminator
    24             0000000E   ENDCHR		equ $000E	; String terminator
    25             0000000F   TKNCNTR		equ $000F	; Used in PARSE
    26             0000000F   EOLPNTR		equ $000F	; Used in NXLIN
    27             0000000F   NUMDIM		equ $000F	; Used in array routines
    28             00000010   DIMFLG		equ $0010	
    29             00000011   VALTYP		equ $0011	; $: VALTYP=$FF; %: VALTYP+1=$80
    30             00000013   DATAFLG		equ $0013	; Used in PARSE
    31             00000013   GARFLG		equ $0013	; Used in GARBAG
    32             00000014   SUBFLG		equ $0014
    33             00000015   INPUTFLG		equ $0015	; = $40 for GET, $98 for READ
    34             00000016   CPRMASK		equ $0016	; Receives CPRTYP in FRMEVL
    35                        
    36             00000033   PROMPT		equ $0033
    37             00000050   LINNUM		equ $0050	; Converted line #
    38             00000052   TEMPPT		equ $0052	; Last used temp string desc
    39             00000053   LASTPT		equ $0053	; Last used temp string pntr
    40             00000055   TEMPST		equ $0055	; Holds up to 3 descriptors
    41             0000005E   INDEX		equ $005E
    42             00000060   DEST		equ $0060
    43             00000062   RESULT		equ $0062	; Result of last * or /
    44             00000067   TXTTAB		equ $0067	; Start of program text
    45             00000069   VARTAB		equ $0069	; Start of variable storage
    46             0000006B   ARYTAB		equ $006B	; Start of array storage
    47             0000006D   STREND		equ $006D	; End of array storage
    48             0000006F   FRETOP		equ $006F	; Start of string storage
    49             00000071   FRESPC		equ $0071	; Temp pntr, string routines
    50             00000073   MEMSIZ		equ $0073	; End of string space (HIMEM)
    51             00000075   CURLIN		equ $0075	; Current line number
    52             00000077   OLDLIN		equ $0077	; Addr. of last line executed
    53             00000079   OLDTEXT		equ $0079
    54             0000007B   DATLIN		equ $007B	; Line # of current data stt.
    55             0000007D   DATPTR		equ $007D	; Addr of current data stt.
    56             0000007F   INPTR		equ $007F
    57             00000081   VARNAM		equ $0081	; Name of variable
    58             00000083   VARPNT		equ $0083	; Addr of variable
    59             00000085   FORPNT		equ $0085
    60             00000087   TXPSV		equ $0087	; Used in INPUT
    61             00000087   LASTOP		equ $0087	; Scratch flag used in FRMEVL
    62             00000089   CPRTYP		equ $0089	; >,=,< flag in FRMEVL
    63             0000008A   TEMP3		equ $008A
    64             0000008A   FNCNAM		equ $008A
    65             0000008C   DSCPTR		equ $008C
    66             0000008F   DSCLEN		equ $008F	; used in GARBAG
    67             00000090   JMPADRS		equ $0090	; gets "jmp ...."
    68             00000091   LENGTH		equ $0091	; used in GARBAG
    69             00000092   ARGEXTENSION	equ $0092	; FP extra precision
    70             00000093   TEMP1		equ $0093	; save areas for FAC
    71             00000094   ARYPNT		equ $0094	; used in GARBAG
    72             00000094   HIGHDS		equ $0094	; pntr for BLTU
    73             00000096   HIGHTR		equ $0096	; pntr for BLTU
    74             00000098   TEMP2		equ $0098
    75             00000099   TMPEXP		equ $0099	; used in FIN (EVAL)
    76             00000099   INDX		equ $0099	; used by array rtns
    77             0000009A   EXPON		equ $009A	;   "
    78             0000009B   DPFLG		equ $009B	; flags dec pnt in FIN
    79             0000009B   LOWTR		equ $009B
    80             0000009C   EXPSGN		equ $009C
    81             0000009D   FAC		equ $009D	; main floating point accumulator
    82             000000A0   VPNT		equ $00A0	; temp var ptr
    83             000000A2   FACSIGN		equ $00A2	; holds unpacked sign
    84             000000A3   SERLEN		equ $00A3	; holds length of series - 1
    85             000000A4   SHIFTSIGNEXT	equ $00A4	; sign extension, right shifts
    86             000000A5   ARG		equ $00A5	; secondary FP accumulator
    87             000000AA   ARGSIGN		equ $00AA
    88             000000AB   SGNCPR		equ $00AB	; flags opp sign in FP routines
    89             000000AC   FACEXTENSION	equ $00AC	; FAC extension byte
    90             000000AD   SERPNT		equ $00AD	; pntr to series data in FP
    91             000000AB   STRNG1		equ $00AB
    92             000000AD   STRNG2		equ $00AD
    93             000000AF   PRGEND		equ $00AF
    94             000000B1   CHRGET		equ $00B1
    95             000000B7   CHRGOT		equ $00B7
    96             000000B8   TXTPTR		equ $00B8
    97             000000C9   RNDSEED		equ $00C9
    98             000000D6   LOCK		equ $00D6	; no user access if > 127
    99             000000D8   ERRFLG		equ $00D8	; $80 if ON ERR active
   100             000000DA   ERRLIN		equ $00DA	; line # where error occurred
   101             000000DC   ERRPOS		equ $00DC	; TXTPTR save for HANDLERR
   102             000000DE   ERRNUM		equ $00DE	; which error occurrred
   103             000000DF   ERRSTK		equ $00DF	; stack pntr before error
   104             000000F2   TRCFLG		equ $00F2
   105             000000F4   TXTPSV		equ $00F4
   106             000000F6   CURLSV		equ $00F6	
   107             000000F8   REMSTK		equ $00F8	; stack pntr before each stt.
   108                        
   109                        
   110                        
   111             0000A000   PRG_B	equ	$A000
   112             00008000   memsize	equ	$8000
   113                        
   114                        	code
   115                        	org	PRG_B
   116                        
   117                        ; ----------------------------------------------------------------------------
   118             00000100   STACK		equ $0100
   119             00000200   INPUTBUFFER	equ $0200
   120                        
   121                        ; ----------------------------------------------------------------------------
   122                        ; Applesoft Tokens
   123                        ; ----------------------------------------------------------------------------
   124             00000081   TOKEN_FOR	equ $81
   125             00000083   TOKEN_DATA	equ $83
   126             00000088   TOKEN_POP	equ $88
   127             0000008E   TOKEN_GOTO	equ $8E
   128             00000092   TOKEN_GOSUB	equ $92
   129             00000094   TOKEN_REM	equ $94
   130             00000098   TOKEN_PRINT	equ $98
   131             000000A2   TOKEN_TO	equ $A2
   132             000000A3   TOKEN_SPC	equ $A3
   133             000000A4   TOKEN_THEN	equ $A4
   134             000000A5   TOKEN_NOT	equ $A5
   135             000000A6   TOKEN_STEP	equ $A6
   136             000000A7   TOKEN_PLUS	equ $A7
   137             000000A8   TOKEN_MINUS	equ $A8
   138             000000AE   TOKEN_GREATER	equ $AE
   139             000000AF   TOKEN_EQUAL	equ $AF
   140             000000B1   TOKEN_SGN	equ $B1
   141             000000BF   TOKEN_LEFTSTR	equ $BF
   142                        
   143                        ; ----------------------------------------------------------------------------
   144                        ; Cold and warm entry points at $E000 and E003
   145                        ; ----------------------------------------------------------------------------
   146                        ;--------- MEZW65C_RAM file header --------------------------
   147 00:A000: 4C 5E BE     	jmp	RESET
   148 00:A003: 4C 04 A3     	jmp	RESTART
   149                        
   150                        	; uinimon config data
   151                        	;
   152 00:A006: 00 00        	db	0,0
   153                        	; Unique ID
   154 00:A008: 4D 45 5A 57  mezID:	db	"MEZW65C",0
       00:A00C: 36 35 43 00 
   155                        	;start program address & load address
   156 00:A010: 00 A0        start_p:	dw	PRG_B		; load address (Low)
   157 00:A012: 00 00        	dw	0		; (high)
   158                        
   159                        	; define Common memory address
   160 00:A014: 00 00        PIC_IF:	dw	0	; reserve
   161 00:A016: 00 00        	dw	0		; (high)
   162                        
   163 00:A018: 00           SW_816:	db	0	; 0 : W65C02
   164                        			; 1 : W65C816 native mode 
   165 00:A019: 00           irq_sw	db	0	; reserve : standalone
   166 00:A01A: 00 00        reg_tp	dw	0	; reserve : standalone
   167 00:A01C: 00 00        reg_ts	dw	0	; reserve : standalone
   168 00:A01E: 00           nmi_sw	db	0	; reserve : standalone
   169 00:A01F: 01           bios_sw	db	1	; 0 : standalone program
   170                        			; 1 : program call bios command
   171                        			; 2 : monitor program (.SYS)
   172                        ;--------- MEZW65C_RAM file header --------------------------
   173                        ; ----------------------------------------------------------------------------
   174                        ; Branch Table for Tokens
   175                        ; ----------------------------------------------------------------------------
   176                        TOKEN_ADDRESS_TABLE:
   177 00:A020: EA A6        	dw	END-1	; $80... 128... END
   178 00:A022: F5 A5        	dw	FOR-1	; $81... 129... FOR
   179 00:A024: C5 AA        	dw	NEXT-1	; $82... 130... NEXT
   180 00:A026: AD A7        	dw	DATA-1	; $83... 131... DATA
   181 00:A028: 80 A9        	dw	INPUT-1	; $84... 132... INPUT
   182 00:A02A: 7E AD        	dw	DIM-1	; $85... 133... DIM
   183 00:A02C: B0 A9        	dw	READ-1	; $86... 134... READ
   184 00:A02E: 49 BD        	dw	CALL-1	; $87... 135... CALL
   185 00:A030: 83 A7        	dw	POP-1	; $88... 136... POP
   186 00:A032: 52 BD        	dw	HIMEM-1	; $89... 136... HIMEM:
   187 00:A034: 72 BD        	dw	LOMEM-1	; $8A... 137... LOMEM:
   188 00:A036: 97 BD        	dw	ONERR-1	; $8B... 138... ONERR
   189 00:A038: E4 BD        	dw	RESUME-1	; $8C... 139... RESUME
   190 00:A03A: 5E A8        	dw	LET-1	; $8D... 140... LET
   191 00:A03C: 56 A7        	dw	GOTO-1	; $8E... 141... GOTO
   192 00:A03E: 2A A7        	dw	RUN-1	; $8F... 142... RUN
   193 00:A040: E1 A7        	dw	IF-1	; $90... 143... IF
   194 00:A042: C0 A6        	dw	RESTORE-1	; $91... 144... RESTORE
   195 00:A044: 39 A7        	dw	GOSUB-1	; $92... 145... GOSUB
   196 00:A046: 83 A7        	dw	POP-1	; $93... 146... RETURN
   197 00:A048: F4 A7        	dw	REM-1	; $94... 147... REM
   198 00:A04A: E8 A6        	dw	STOP-1	; $95... 148... STOP
   199 00:A04C: 04 A8        	dw	ONGOTO-1	; $96... 149... ON
   200 00:A04E: 5D B4        	dw	POKE-1	; $97... 150... POKE
   201 00:A050: ED A8        	dw	PRINT-1	; $98... 151... PRINT
   202 00:A052: 10 A7        	dw	CONT-1	; $99... 152... CONT
   203 00:A054: 45 A5        	dw	LIST-1	; $9A... 153... LIST
   204 00:A056: 0A A5        	dw	CLEAR-1	; $9B... 154... CLEAR
   205 00:A058: 6F A9        	dw	GET-1	; $9C... 155... GET
   206 00:A05A: E9 A4        	dw	NEW-1	; $9D... 156... NEW
   207 00:A05C: 5B BE        	dw	CFFAMenu-1	; $9E... 157... MENU
   208 00:A05E: 5B BE        	dw	CFFASave-1	; $9F... 158... SAVE
   209 00:A060: 5B BE        	dw	CFFALoad-1	; $A0... 160... LOAD
   210 00:A062: 52 BE        	dw	CLS-1	; $A1... 161... CLS
   211                        ; ----------------------------------------------------------------------------
   212 00:A064: 52 B8        UNFNC:  dw	SGN		; $B1... 177... SGN
   213 00:A066: E2 B8        	dw	INT		; $B2... 178... INT
   214 00:A068: 71 B8        	dw	ABS		; $B3... 179... ABS
   215 00:A06A: 79 B0        	dw	FRE		; $B4... 180... FRE
   216 00:A06C: 4A BB        	dw	SQR		; $B5... 181... SQR
   217 00:A06E: 69 BC        	dw	RND		; $B6... 182... RND
   218 00:A070: 08 B6        	dw	LOG		; $B7... 183... LOG
   219 00:A072: C5 BB        	dw	EXP		; $B8... 184... EXP
   220 00:A074: 47 B4        	dw	PEEK		; $B9... 185... PEEK
   221 00:A076: B9 B3        	dw	LEN		; $BA... 186... LEN
   222 00:A078: A8 B0        	dw	STR		; $BB... 187... STR$
   223 00:A07A: EA B3        	dw	VAL		; $BC... 188... VAL
   224 00:A07C: C8 B3        	dw	ASC		; $BD... 189... ASC
   225 00:A07E: 29 B3        	dw	CHRSTR		; $BE... 190... CHR$
   226 00:A080: 3D B3        	dw	LEFTSTR		; $BF... 191... LEFT$
   227 00:A082: 69 B3        	dw	RIGHTSTR	; $C0... 192... RIGHT$
   228 00:A084: 74 B3        	dw	MIDSTR		; $C1... 193... MID$
   229                        
   230                        
   231                        ; ----------------------------------------------------------------------------
   232                        ; Math Operator Branch Table
   233                        ;
   234                        ; one-byte precedence code
   235                        ; two-byte address
   236                        ; ----------------------------------------------------------------------------
   237             00000046   POR		equ $46	; "OR" is lowest precedence
   238             00000050   PAND		equ $50
   239             00000064   PREL		equ $64	; Relational operators
   240             00000079   PADD		equ $79	; binary + and -
   241             0000007B   PMUL		equ $7B	; * and /
   242             0000007D   PPWR		equ $7D	; exponentiation
   243             0000007F   PNEQ		equ $7F	; unary - and comparison =
   244                        ; ----------------------------------------------------------------------------
   245                        MATHTBL:
   246 00:A086: 79           	db   PADD
   247 00:A087: 87 B4        	dw	FADDT-1	; $A7... 167... +
   248 00:A089: 79           	db	PADD
   249 00:A08A: 70 B4        	dw	FSUBT-1	; $A8... 168... -
   250 00:A08C: 7B           	db	PMUL
   251 00:A08D: 48 B6        	dw	FMULTT-1	; $A9... 169... *
   252 00:A08F: 7B           	db	PMUL
   253 00:A090: 2A B7        	dw	FDIVT-1	; $AA... 170... /
   254 00:A092: 7D           	db	PPWR
   255 00:A093: 53 BB        	dw	FPWRT-1	; $AB... 171... ^
   256 00:A095: 50           	db	PAND
   257 00:A096: 03 AD        	dw	TAND-1	; $AC... 172... AND
   258 00:A098: 46           	db	POR
   259 00:A099: FD AC        	dw	OR-1		; $AD... 173... OR
   260 00:A09B: 7F           M_NEG:	db	PNEQ
   261 00:A09C: 8B BB        	dw	NEGOP-1	; $AE... 174... >
   262 00:A09E: 7F           M_EQU:	db	PNEQ
   263 00:A09F: 64 AC        	dw	EQUOP-1	; $AF... 175... =
   264 00:A0A1: 64           M_REL:	db	PREL
   265 00:A0A2: 13 AD        	dw	RELOPS-1	; $B0... 176... <
   266                        
   267                        
   268                        ; ----------------------------------------------------------------------------
   269                        ; Token Name Table
   270                        ; ----------------------------------------------------------------------------
   271                        TOKEN_NAME_TABLE:
   272 00:A0A4: 45 4E C4     	db	"EN",#'D'+$80		; $80... 128
   273 00:A0A7: 46 4F D2     	db	"FO",#'R'+$80		; $81... 129
   274 00:A0AA: 4E 45 58 D4  	db	"NEX",#'T'+$80		; $82... 130
   275 00:A0AE: 44 41 54 C1  	db	"DAT",#'A'+$80		; $83... 131
   276 00:A0B2: 49 4E 50 55  	db	"INPU",#'T'+$80		; $84... 132
       00:A0B6: D4 
   277 00:A0B7: 44 49 CD     	db	"DI",#'M'+$80		; $85... 133
   278 00:A0BA: 52 45 41 C4  	db	"REA",#'D'+$80		; $86... 134
   279 00:A0BE: 43 41 4C CC  	db	"CAL",#'L'+$80		; $87... 135
   280 00:A0C2: 50 4F D0     	db	"PO",#'P'+$80		; $88... 136
   281 00:A0C5: 48 49 4D 45  	db	"HIMEM",#':'+$80		; $89... 137
       00:A0C9: 4D BA 
   282 00:A0CB: 4C 4F 4D 45  	db	"LOMEM",#':'+$80		; $8A... 138
       00:A0CF: 4D BA 
   283 00:A0D1: 4F 4E 45 52  	db	"ONER",#'R'+$80		; $8B... 139
       00:A0D5: D2 
   284 00:A0D6: 52 45 53 55  	db	"RESUM",#'E'+$80		; $8C... 140
       00:A0DA: 4D C5 
   285 00:A0DC: 4C 45 D4     	db	"LE",#'T'+$80		; $8D... 141
   286 00:A0DF: 47 4F 54 CF  	db	"GOT",#'O'+$80		; $8E... 142
   287 00:A0E3: 52 55 CE     	db	"RU",#'N'+$80		; $8F... 143
   288 00:A0E6: 49 C6        	db	'I',#'F'+$80		; $90... 144
   289 00:A0E8: 52 45 53 54  	db	"RESTOR",#'E'+$80	; $91... 145
       00:A0EC: 4F 52 C5 
   290 00:A0EF: 47 4F 53 55  	db	"GOSU",#'B'+$80		; $92... 146
       00:A0F3: C2 
   291 00:A0F4: 52 45 54 55  	db	"RETUR",#'N'+$80		; $93... 147
       00:A0F8: 52 CE 
   292 00:A0FA: 52 45 CD     	db	"RE",#'M'+$80		; $94... 148
   293 00:A0FD: 53 54 4F D0  	db	"STO",#'P'+$80		; $95... 149
   294 00:A101: 4F CE        	db	'O',#'N'+$80		; $96... 150
   295 00:A103: 50 4F 4B C5  	db	"POK",#'E'+$80		; $97... 151
   296 00:A107: 50 52 49 4E  	db	"PRIN",#'T'+$80		; $98... 152
       00:A10B: D4 
   297 00:A10C: 43 4F 4E D4  	db	"CON",#'T'+$80		; $99... 153
   298 00:A110: 4C 49 53 D4  	db	"LIS",#'T'+$80		; $9A... 154
   299 00:A114: 43 4C 45 41  	db	"CLEA",#'R'+$80		; $9B... 155
       00:A118: D2 
   300 00:A119: 47 45 D4     	db	"GE",#'T'+$80		; $9C... 156
   301 00:A11C: 4E 45 D7     	db	"NE",#'W'+$80		; $9D... 157
   302 00:A11F: 4D 45 4E D5  	db	"MEN",#'U'+$80		; $9E... 158   New tokens 
   303 00:A123: 53 41 56 C5  	db	"SAV",#'E'+$80		; $9F... 159   for
   304 00:A127: 4C 4F 41 C4  	db	"LOA",#'D'+$80		; $A0... 160   CFFA I/O
   305 00:A12B: 43 4C D3     	db	"CL",#'S'+$80		; $A1... 161   New token to clear screen
   306 00:A12E: 54 CF        	db	'T',#'O'+$80		; $A2... 162
   307 00:A130: 53 50 43 A8  	db	"SPC",#'('+$80		; $A3... 163
   308 00:A134: 54 48 45 CE  	db	"THE",#'N'+$80		; $A4... 164
   309 00:A138: 4E 4F D4     	db	"NO",#'T'+$80		; $A5... 165
   310 00:A13B: 53 54 45 D0  	db	"STE",#'P'+$80		; $A6... 166
   311 00:A13F: AB           	db	#'+'+$80		; $A7... 167
   312 00:A140: AD           	db	#'-'+$80		; $A8... 168
   313 00:A141: AA           	db	#'*'+$80		; $A9... 169
   314 00:A142: AF           	db	#'/'+$80		; $AA... 170
   315 00:A143: DE           	db	#'^'+$80		; $AB... 171
   316 00:A144: 41 4E C4     	db	"AN",#'D'+$80		; $AC... 172
   317 00:A147: 4F D2        	db	'O',#'R'+$80		; $AD... 173
   318 00:A149: BE           	db	#'>'+$80		; $AE... 174
   319 00:A14A: BD           	db	#'='+$80		; $AF... 175
   320 00:A14B: BC           	db	#'<'+$80		; $B0... 176
   321 00:A14C: 53 47 CE     	db	"SG",#'N'+$80		; $B1... 177
   322 00:A14F: 49 4E D4     	db	"IN",#'T'+$80		; $B2... 178
   323 00:A152: 41 42 D3     	db	"AB",#'S'+$80		; $B3... 179
   324 00:A155: 46 52 C5     	db	"FR",#'E'+$80		; $B4... 180
   325 00:A158: 53 51 D2     	db	"SQ",#'R'+$80		; $B5... 181
   326 00:A15B: 52 4E C4     	db	"RN",#'D'+$80		; $B6... 182
   327 00:A15E: 4C 4F C7     	db	"LO",#'G'+$80		; $B7... 183
   328 00:A161: 45 58 D0     	db	"EX",#'P'+$80		; $B8... 184
   329 00:A164: 50 45 45 CB  	db	"PEE",#'K'+$80		; $B9... 185
   330 00:A168: 4C 45 CE     	db	"LE",#'N'+$80		; $BA... 186
   331 00:A16B: 53 54 52 A4  	db	"STR",#'$'+$80		; $BB... 187
   332 00:A16F: 56 41 CC     	db	"VA",#'L'+$80		; $BC... 188
   333 00:A172: 41 53 C3     	db	"AS",#'C'+$80		; $BD... 189
   334 00:A175: 43 48 52 A4  	db	"CHR",#'$'+$80		; $BE... 190
   335 00:A179: 4C 45 46 54  	db	"LEFT",#'$'+$80		; $BF... 191
       00:A17D: A4 
   336 00:A17E: 52 49 47 48  	db	"RIGHT",#'$'+$80		; $C0... 192
       00:A182: 54 A4 
   337 00:A184: 4D 49 44 A4  	db	"MID",#'$'+$80		; $C1... 193
   338 00:A188: 00           	db	$00			; END OF TOKEN NAME TABLE
   339                        
   340                        
   341                        ; ----------------------------------------------------------------------------
   342                        ; Error Messages
   343                        ; ----------------------------------------------------------------------------
   344                        ERROR_MESSAGES:
   345                        
   346             00000000   ERR_NOFOR	equ $FF&(*-ERROR_MESSAGES)
   347 00:A189: 4E 4F 20 46  	db	"NO FO",#'R'+$80
       00:A18D: 4F D2 
   348                        
   349             00000006   ERR_SYNTAX	equ $FF&(*-ERROR_MESSAGES)
   350 00:A18F: 53 59 4E 54  	db	"SYNTA",#'X'+$80
       00:A193: 41 D8 
   351                        
   352             0000000C   ERR_NOGOSUB	equ $FF&(*-ERROR_MESSAGES)
   353 00:A195: 4E 4F 20 47  	db	"NO GOSU",#'B'+$80
       00:A199: 4F 53 55 C2 
   354                        
   355             00000014   ERR_NODATA	equ $FF&(*-ERROR_MESSAGES)
   356 00:A19D: 4F 55 54 20  	db	"OUT OF DAT",#'A'+$80
       00:A1A1: 4F 46 20 44 
       00:A1A5: 41 54 C1 
   357                        
   358             0000001F   ERR_ILLQTY	equ $FF&(*-ERROR_MESSAGES)
   359 00:A1A8: 49 4C 4C 45  	db	"ILLEG QT",#'Y'+$80
       00:A1AC: 47 20 51 54 
       00:A1B0: D9 
   360                        
   361             00000028   ERR_OVERFLOW	equ $FF&(*-ERROR_MESSAGES)
   362 00:A1B1: 4F 56 45 52  	db	"OVERFLO",#'W'+$80
       00:A1B5: 46 4C 4F D7 
   363                        
   364             00000030   ERR_MEMFULL	equ $FF&(*-ERROR_MESSAGES)
   365 00:A1B9: 4F 55 54 20  	db	"OUT OF ME",#'M'+$80
       00:A1BD: 4F 46 20 4D 
       00:A1C1: 45 CD 
   366                        
   367             0000003A   ERR_UNDEFSTAT	equ $FF&(*-ERROR_MESSAGES)
   368 00:A1C3: 55 4E 44 45  	db	"UNDEF LIN",#'E'+$80
       00:A1C7: 46 20 4C 49 
       00:A1CB: 4E C5 
   369                        
   370             00000044   ERR_BADSUBS	equ $FF&(*-ERROR_MESSAGES)
   371 00:A1CD: 42 41 44 20  	db	"BAD SUBSC",#'R'+$80
       00:A1D1: 53 55 42 53 
       00:A1D5: 43 D2 
   372                        
   373             0000004E   ERR_REDIMD	equ $FF&(*-ERROR_MESSAGES)
   374 00:A1D7: 52 45 44 49  	db	"REDI",#'M'+$80
       00:A1DB: CD 
   375                        
   376             00000053   ERR_ZERODIV	equ $FF&(*-ERROR_MESSAGES)
   377 00:A1DC: 44 49 56 20  	db	"DIV BY ",#'0'+$80
       00:A1E0: 42 59 20 B0 
   378                        
   379             0000005B   ERR_ILLDIR	equ $FF&(*-ERROR_MESSAGES)
   380 00:A1E4: 4E 4F 54 20  	db	"NOT DIREC",#'T'+$80
       00:A1E8: 44 49 52 45 
       00:A1EC: 43 D4 
   381                        
   382             00000065   ERR_BADTYPE	equ $FF&(*-ERROR_MESSAGES)
   383 00:A1EE: 57 52 4F 4E  	db	"WRONG TY",#'P'+$80
       00:A1F2: 47 20 54 59 
       00:A1F6: D0 
   384                        
   385             0000006E   ERR_STRLONG	equ $FF&(*-ERROR_MESSAGES)
   386 00:A1F7: 4C 4F 4E 47  	db	"LONG ST",#'R'+$80
       00:A1FB: 20 53 54 D2 
   387                        
   388             00000076   ERR_FRMCPX	equ $FF&(*-ERROR_MESSAGES)
   389 00:A1FF: 4C 4F 4E 47  	db	"LONG FORMUL",#'A'+$80
       00:A203: 20 46 4F 52 
       00:A207: 4D 55 4C C1 
   390                        
   391             00000082   ERR_CANTCONT	equ $FF&(*-ERROR_MESSAGES)
   392 00:A20B: 43 41 4E 27  	db	"CAN'T CON",#'T'+$80
       00:A20F: 54 20 43 4F 
       00:A213: 4E D4 
   393                        
   394             0000008C   ERR_NOCFFA	equ $FF&(*-ERROR_MESSAGES)	; New error message for CFFA1 I/O
   395 00:A215: 4E 4F 20 43  	db	"NO CFF",#'A'+$80
       00:A219: 46 46 C1 
   396                        ; ----------------------------------------------------------------------------
   397                        QT_ERROR:
   398 00:A21C: 20 45 52 52  	db	" ERR"
   399 00:A220: 00           	db	$00
   400 00:A221: 20 49 4E 20  QT_IN:	db	" IN "
   401 00:A225: 00           	db	$00
   402                        QT_BREAK:
   403 00:A226: 0D           	db	$0D
   404 00:A227: 42 52 45 41  	db	"BREAK"
       00:A22B: 4B 
   405 00:A22C: 00           	db	$00
   406                        
   407                        ; ----------------------------------------------------------------------------
   408                        ; CALLED BY "NEXT" AND "FOR" TO SCAN THROUGH
   409                        ; THE STACK FOR A FRAME WITH THE SAME VARIABLE.
   410                        ;
   411                        ; (FORPNT) = ADDRESS OF VARIABLE IF "FOR" OR "NEXT"
   412                        ; 	= $XXFF IF CALLED FROM "RETURN"
   413                        ; 	<<< BUG: SHOULD BE $FFXX >>>
   414                        ;
   415                        ;	RETURNS .NE. IF VARIABLE NOT FOUND,
   416                        ;	(X) = STACK PNTR AFTER SKIPPING ALL FRAMES
   417                        ;
   418                        ;	.EQ. IF FOUND
   419                        ;	(X) = STACK PNTR OF FRAME FOUND
   420                        ; ----------------------------------------------------------------------------
   421                        GTFORPNT:
   422 00:A22D: BA           	tsx
   423 00:A22E: E8           	inx
   424 00:A22F: E8           	inx
   425 00:A230: E8           	inx
   426 00:A231: E8           	inx
   427 00:A232: BD 01 01     GTF1:	lda	STACK+1,x	; "FOR" FRAME HERE?
   428 00:A235: C9 81        	cmp	#TOKEN_FOR
   429 00:A237: D0 21        	bne	GTF4		; NO
   430 00:A239: A5 86        	lda	FORPNT+1	; YES -- "NEXT" WITH NO VARIABLE?
   431 00:A23B: D0 0A        	bne	GTF2		; NO, VARIABLE SPECIFIED
   432 00:A23D: BD 02 01     	lda	STACK+2,x	; YES, SO USE THIS FRAME
   433 00:A240: 85 85        	sta	FORPNT
   434 00:A242: BD 03 01     	lda	STACK+3,x
   435 00:A245: 85 86        	sta	FORPNT+1
   436 00:A247: DD 03 01     GTF2:	cmp	STACK+3,x	; IS VARIABLE IN THIS FRAME?
   437 00:A24A: D0 07        	bne	GTF3		; NO
   438 00:A24C: A5 85        	lda	FORPNT		; LOOK AT 2ND BYTE TOO
   439 00:A24E: DD 02 01     	cmp	STACK+2,x	; SAME VARIABLE?
   440 00:A251: F0 07        	beq	GTF4		; YES
   441 00:A253: 8A           GTF3:	txa			; NO, SO TRY NEXT FRAME (IF ANY)
   442 00:A254: 18           	clc			; 18 BYTES PER FRAME
   443 00:A255: 69 12        	adc     #18
   444 00:A257: AA           	tax
   445 00:A258: D0 D8        	bne	GTF1		; ...ALWAYS?
   446 00:A25A: 60           GTF4:	rts
   447                        
   448                        
   449                        ; ----------------------------------------------------------------------------
   450                        ; MOVE BLOCK OF MEMORY UP
   451                        ;
   452                        ; ON ENTRY:
   453                        ;	(Y,A) = (HIGHDS) = DESTINATION END+1
   454                        ;	(LOWTR) = LOWEST ADDRESS OF SOURCE
   455                        ;	(HIGHTR) = HIGHEST SOURCE ADDRESS+1
   456                        ; ----------------------------------------------------------------------------
   457 00:A25B: 20 AB A2     BLTU:	jsr	REASON		; BE SURE (Y,A) < FRETOP
   458 00:A25E: 85 6D        	sta	STREND		; NEW TOP OF ARRAY STORAGE
   459 00:A260: 84 6E        	sty	STREND+1
   460 00:A262: 38           BLTU2:	sec
   461 00:A263: A5 96        	lda	HIGHTR		; COMPUTE # OF BYTES TO BE MOVED
   462 00:A265: E5 9B        	sbc	LOWTR		; 	(FROM LOWTR THRU HIGHTR-1)
   463 00:A267: 85 5E        	sta	INDEX		; PARTIAL PAGE AMOUNT
   464 00:A269: A8           	tay
   465 00:A26A: A5 97        	lda	HIGHTR+1
   466 00:A26C: E5 9C        	sbc	LOWTR+1
   467 00:A26E: AA           	tax			; # OF WHOLE PAGES IN X-REG
   468 00:A26F: E8           	inx
   469 00:A270: 98           	tya			; # BYTES IN PARTIAL PAGE
   470 00:A271: F0 23        	beq	BLT4		; NO PARTIAL PAGE
   471 00:A273: A5 96        	lda	HIGHTR		; BACK UP HIGHTR # BYTES IN PARTIAL PAGE
   472 00:A275: 38           	sec
   473 00:A276: E5 5E        	sbc	INDEX
   474 00:A278: 85 96        	sta	HIGHTR
   475 00:A27A: B0 03        	bcs	BLT1
   476 00:A27C: C6 97        	dec	HIGHTR+1
   477 00:A27E: 38           	sec
   478 00:A27F: A5 94        BLT1:	lda	HIGHDS		; BACK UP HIGHDS # BYTES IN PARTIAL PAGE
   479 00:A281: E5 5E        	sbc	INDEX
   480 00:A283: 85 94        	sta	HIGHDS
   481 00:A285: B0 08        	bcs	BLT3
   482 00:A287: C6 95        	dec	HIGHDS+1
   483 00:A289: 90 04        	bcc	BLT3		; ...ALWAYS
   484 00:A28B: B1 96        BLT2:	lda	(HIGHTR),y	; MOVE THE BYTES
   485 00:A28D: 91 94        	sta	(HIGHDS),y
   486 00:A28F: 88           BLT3:	dey
   487 00:A290: D0 F9        	bne	BLT2		; LOOP TO END OF THIS 256 BYTES
   488 00:A292: B1 96        	lda	(HIGHTR),y	; MOVE ONE MORE BYTE
   489 00:A294: 91 94        	sta	(HIGHDS),y
   490 00:A296: C6 97        BLT4:	dec	HIGHTR+1	; DOWN TO NEXT BLOCK OF 256
   491 00:A298: C6 95        	dec	HIGHDS+1
   492 00:A29A: CA           	dex			; ANOTHER BLOCK OF 256 TO MOVE?
   493 00:A29B: D0 F2        	bne	BLT3		; YES
   494 00:A29D: 60           	rts			; NO, FINISHED
   495                        
   496                        
   497                        ; ----------------------------------------------------------------------------
   498                        ; CHECK IF ENOUGH ROOM LEFT ON STACK
   499                        ; FOR "FOR", "GOSUB", OR EXPRESSION EVALUATION
   500                        ; ----------------------------------------------------------------------------
   501 00:A29E: 0A           CHKMEM:	asl	a
   502 00:A29F: 69 36        	adc	#54
   503 00:A2A1: B0 35        	bcs	MEMERR		; ...MEM FULL ERR
   504 00:A2A3: 85 5E        	sta	INDEX
   505 00:A2A5: BA           	tsx
   506 00:A2A6: E4 5E        	cpx	INDEX
   507 00:A2A8: 90 2E        	bcc	MEMERR		; ...MEM FULL ERR
   508 00:A2AA: 60           	rts
   509                        
   510                        
   511                        ; ----------------------------------------------------------------------------
   512                        ; CHECK IF ENOUGH ROOM BETWEEN ARRAYS AND STRINGS
   513                        ; (Y,A) = ADDR ARRAYS NEED TO GROW TO
   514                        ; ----------------------------------------------------------------------------
   515 00:A2AB: C4 70        REASON:	cpy	FRETOP+1	; HIGH BYTE
   516 00:A2AD: 90 28        	bcc	REA4		; PLENTY OF ROOM
   517 00:A2AF: D0 04        	bne	REA1		; NOT ENOUGH, TRY GARBAGE COLLECTION
   518 00:A2B1: C5 6F        	cmp	FRETOP		; LOW BYTE
   519 00:A2B3: 90 22        	bcc	REA4		; ENOUGH ROOM
   520 00:A2B5: 48           REA1:	pha			; SAVE (Y,A), TEMP1, AND TEMP2
   521 00:A2B6: A2 09        	ldx	#FAC-TEMP1-1
   522 00:A2B8: 98           	tya
   523 00:A2B9: 48           REA2:	pha
   524 00:A2BA: B5 93        	lda	TEMP1,x
   525 00:A2BC: CA           	dex
   526 00:A2BD: 10 FA        	bpl	REA2
   527 00:A2BF: 20 67 B1     	jsr	GARBAG		; MAKE AS MUCH ROOM AS POSSIBLE
   528 00:A2C2: A2 F7        	ldx	#$FF&(TEMP1-FAC+1)	; RESTORE TEMP1 AND TEMP2
   529 00:A2C4: 68           REA3:	pla			; AND (Y,A)
   530 00:A2C5: 95 9D        	sta	FAC,x
   531 00:A2C7: E8           	inx
   532 00:A2C8: 30 FA        	bmi	REA3
   533 00:A2CA: 68           	pla
   534 00:A2CB: A8           	tay
   535 00:A2CC: 68           	pla			; DID WE FIND ENOUGH ROOM?
   536 00:A2CD: C4 70        	cpy	FRETOP+1	; HIGH BYTE
   537 00:A2CF: 90 06        	bcc	REA4		; YES, AT LEAST A PAGE
   538 00:A2D1: D0 05        	bne	MEMERR		; NO, MEM FULL ERR
   539 00:A2D3: C5 6F        	cmp	FRETOP		; LOW BYTE
   540 00:A2D5: B0 01        	bcs	MEMERR		; NO, MEM FULL ERR
   541 00:A2D7: 60           REA4:	rts			; YES, RETURN
   542                        
   543                        ; ----------------------------------------------------------------------------
   544 00:A2D8: A2 30        MEMERR:	ldx	#ERR_MEMFULL
   545                        
   546                        
   547                        ; ----------------------------------------------------------------------------
   548                        ; HANDLE AN ERROR
   549                        ;
   550                        ; (X)=OFFSET IN ERROR MESSAGE TABLE
   551                        ; (ERRFLG) > 128 IF "ON ERR" TURNED ON
   552                        ; (CURLIN+1) = $FF IF IN DIRECT MODE
   553                        ; ----------------------------------------------------------------------------
   554 00:A2DA: 24 D8        ERROR:	bit	ERRFLG		; "ON ERR" TURNED ON?
   555 00:A2DC: 10 03        	bpl	ERRO1		; NO
   556 00:A2DE: 4C B6 BD     	jmp	HANDLERR	; YES
   557 00:A2E1: 20 46 BE     ERRO1:	jsr	CRDO		; PRINT <RETURN>
   558 00:A2E4: 20 42 BE     	jsr	OUTQUES		; PRINT "?"
   559 00:A2E7: BD 89 A1     ERRO2:	lda	ERROR_MESSAGES,x
   560 00:A2EA: 48           	pha			; PRINT MESSAGE
   561 00:A2EB: 20 4D BE     	jsr	OUTDO
   562 00:A2EE: E8           	inx
   563 00:A2EF: 68           	pla
   564 00:A2F0: 10 F5        	bpl	ERRO2
   565 00:A2F2: 20 24 A5     	jsr	STKINI		; FIX STACK, ET AL
   566 00:A2F5: A9 1C        	lda	#<QT_ERROR	; PRINT " ERROR" AND BELL
   567 00:A2F7: A0 A2        	ldy	#>QT_ERROR
   568                        
   569                        
   570                        ; ----------------------------------------------------------------------------
   571                        ; PRINT STRING AT (Y,A)
   572                        ; PRINT CURRENT LINE # UNLESS IN DIRECT MODE
   573                        ; FALL INTO WARM RESTART
   574                        ; ----------------------------------------------------------------------------
   575                        PRINT_ERROR_LINNUM:
   576 00:A2F9: 20 2B A9     	jsr	STROUT		; PRINT STRING AT (Y,A)
   577 00:A2FC: A4 76        	ldy	CURLIN+1	; RUNNING, OR DIRECT?
   578 00:A2FE: C8           	iny
   579 00:A2FF: F0 03        	beq	RESTART		; WAS $FF, SO DIRECT MODE
   580 00:A301: 20 D6 B9     	jsr	INPRT		; RUNNING, SO PRINT LINE NUMBER
   581                        
   582                        
   583                        ; ----------------------------------------------------------------------------
   584                        ; WARM RESTART ENTRY
   585                        ;
   586                        ; COME HERE FROM MONITOR BY CTL-C, 0G, 3D0G, OR E003G
   587                        ; ----------------------------------------------------------------------------
   588                        RESTART:
   589 00:A304: 20 46 BE     	jsr	CRDO		; PRINT <RETURN>
   590 00:A307: A2 DD        	ldx	#']'+$80	; PROMPT CHARACTER
   591 00:A309: 20 F6 A3     	jsr	INLIN2		; READ A LINE
   592 00:A30C: 86 B8        	stx	TXTPTR		; SET UP CHRGET TO SCAN THE LINE
   593 00:A30E: 84 B9        	sty	TXTPTR+1
   594 00:A310: 46 D8        	lsr	ERRFLG		; CLEAR FLAG
   595 00:A312: 20 B1 00     	jsr	CHRGET
   596 00:A315: AA           	tax
   597 00:A316: F0 EC        	beq	RESTART		; EMPTY LINE
   598 00:A318: A2 FF        	ldx	#$FF		; $FF IN HI-BYTE OF CURLIN MEANS
   599 00:A31A: 86 76        	stx	CURLIN+1	; WE ARE IN DIRECT MODE
   600 00:A31C: 90 06        	bcc	NUMBERED_LINE	; CHRGET SAW DIGIT, NUMBERED LINE
   601 00:A31E: 20 0B A4     	jsr	PARSE_INPUT_LINE	; NO NUMBER, SO PARSE IT
   602 00:A321: 4C 95 A6     	jmp	NEWSTT2		; AND TRY EXECUTING IT
   603                        
   604                        
   605                        ; ----------------------------------------------------------------------------
   606                        ; HANDLE NUMBERED LINE
   607                        ; ----------------------------------------------------------------------------
   608                        NUMBERED_LINE:
   609 00:A324: A6 AF        	ldx	PRGEND		; SQUASH VARIABLE TABLE
   610 00:A326: 86 69        	stx	VARTAB
   611 00:A328: A6 B0        	ldx	PRGEND+1
   612 00:A32A: 86 6A        	stx	VARTAB+1
   613 00:A32C: 20 25 A8     	jsr	LINGET		; GET LINE #
   614 00:A32F: 20 0B A4     	jsr	PARSE_INPUT_LINE	; AND PARSE THE INPUT LINE
   615 00:A332: 84 0F        	sty	EOLPNTR		; SAVE INDEX TO INPUT BUFFER
   616 00:A334: 20 BB A4     	jsr	FNDLIN		; IS THIS LINE # ALREADY IN PROGRAM?
   617 00:A337: 90 44        	bcc	PUT_NEW_LINE	; NO
   618 00:A339: A0 01        	ldy	#1		; YES, SO DELETE IT
   619 00:A33B: B1 9B        	lda	(LOWTR),y	; LOWTR POINTS AT LINE
   620 00:A33D: 85 5F        	sta	INDEX+1		; GET HIGH BYTE OF FORWARD PNTR
   621 00:A33F: A5 69        	lda	VARTAB
   622 00:A341: 85 5E        	sta	INDEX
   623 00:A343: A5 9C        	lda	LOWTR+1
   624 00:A345: 85 61        	sta	DEST+1
   625 00:A347: A5 9B        	lda	LOWTR
   626 00:A349: 88           	dey
   627 00:A34A: F1 9B        	sbc	(LOWTR),y
   628 00:A34C: 18           	clc
   629 00:A34D: 65 69        	adc	VARTAB
   630 00:A34F: 85 69        	sta	VARTAB
   631 00:A351: 85 60        	sta	DEST
   632 00:A353: A5 6A        	lda	VARTAB+1
   633 00:A355: 69 FF        	adc	#$FF
   634 00:A357: 85 6A        	sta	VARTAB+1
   635 00:A359: E5 9C        	sbc	LOWTR+1
   636 00:A35B: AA           	tax
   637 00:A35C: 38           	sec
   638 00:A35D: A5 9B        	lda	LOWTR
   639 00:A35F: E5 69        	sbc	VARTAB
   640 00:A361: A8           	tay
   641 00:A362: B0 03        	bcs	NUMB1
   642 00:A364: E8           	inx
   643 00:A365: C6 61        	dec	DEST+1
   644 00:A367: 18           NUMB1:	clc
   645 00:A368: 65 5E        	adc	INDEX
   646 00:A36A: 90 03        	bcc	NUMB2
   647 00:A36C: C6 5F        	dec	INDEX+1
   648 00:A36E: 18           	clc
   649                        ; ----------------------------------------------------------------------------
   650 00:A36F: B1 5E        NUMB2:	lda	(INDEX),y	; MOVE HIGHER LINES OF PROGRAM
   651 00:A371: 91 60        	sta	(DEST),y	; DOWN OVER THE DELETED LINE.
   652 00:A373: C8           	iny
   653 00:A374: D0 F9        	bne	NUMB2
   654 00:A376: E6 5F        	inc	INDEX+1
   655 00:A378: E6 61        	inc	DEST+1
   656 00:A37A: CA           	dex
   657 00:A37B: D0 F2        	bne	NUMB2
   658                        
   659                        
   660                        ; ----------------------------------------------------------------------------
   661                        PUT_NEW_LINE:
   662 00:A37D: AD 00 02     	lda	INPUTBUFFER	; ANY CHARACTERS AFTER LINE #?
   663 00:A380: F0 38        	beq	FIX_LINKS	; NO, SO NOTHING TO INSERT.
   664 00:A382: A5 73        	lda	MEMSIZ		; YES, SO MAKE ROOM AND INSERT LINE
   665 00:A384: A4 74        	ldy	MEMSIZ+1	; WIPE STRING AREA CLEAN
   666 00:A386: 85 6F        	sta	FRETOP
   667 00:A388: 84 70        	sty	FRETOP+1
   668 00:A38A: A5 69        	lda	VARTAB		; SET UP BLTU SUBROUTINE
   669 00:A38C: 85 96        	sta	HIGHTR		; INSERT NEW LINE.
   670 00:A38E: 65 0F        	adc	EOLPNTR
   671 00:A390: 85 94        	sta	HIGHDS
   672 00:A392: A4 6A        	ldy	VARTAB+1
   673 00:A394: 84 97        	sty	HIGHTR+1
   674 00:A396: 90 01        	bcc	PUT_1
   675 00:A398: C8           	iny
   676 00:A399: 84 95        PUT_1:	sty	HIGHDS+1
   677 00:A39B: 20 5B A2     	jsr	BLTU		; MAKE ROOM FOR THE LINE
   678 00:A39E: A5 50        	lda	LINNUM		; PUT LINE NUMBER IN LINE IMAGE
   679 00:A3A0: A4 51        	ldy	LINNUM+1
   680 00:A3A2: 8D FE 01     	sta	INPUTBUFFER-2
   681 00:A3A5: 8C FF 01     	sty	INPUTBUFFER-1
   682 00:A3A8: A5 6D        	lda	STREND
   683 00:A3AA: A4 6E        	ldy	STREND+1
   684 00:A3AC: 85 69        	sta	VARTAB
   685 00:A3AE: 84 6A        	sty	VARTAB+1
   686 00:A3B0: A4 0F        	ldy	EOLPNTR
   687                        ; ---COPY LINE INTO PROGRAM-------
   688 00:A3B2: B9 FB 01     PUT_2:	lda	INPUTBUFFER-5,y
   689 00:A3B5: 88           	dey
   690 00:A3B6: 91 9B        	sta	(LOWTR),y
   691 00:A3B8: D0 F8        	bne	PUT_2
   692                        
   693                        
   694                        ; ----------------------------------------------------------------------------
   695                        ; CLEAR ALL VARIABLES
   696                        ; RE-ESTABLISH ALL FORWARD LINKS
   697                        ; ----------------------------------------------------------------------------
   698                        FIX_LINKS:
   699 00:A3BA: 20 06 A5     	jsr	SETPTRS		; CLEAR ALL VARIABLES
   700 00:A3BD: A5 67        	lda	TXTTAB		; POINT INDEX AT START OF PROGRAM
   701 00:A3BF: A4 68        	ldy	TXTTAB+1
   702 00:A3C1: 85 5E        	sta	INDEX
   703 00:A3C3: 84 5F        	sty	INDEX+1
   704 00:A3C5: 18           	clc
   705 00:A3C6: A0 01        FIX_1:	ldy	#1		; HI-BYTE OF NEXT FORWARD PNTR
   706 00:A3C8: B1 5E        	lda	(INDEX),y	; END OF PROGRAM YET?
   707 00:A3CA: D0 0B        	bne	FIX_2		; NO, KEEP GOING
   708 00:A3CC: A5 69        	lda	VARTAB		; YES
   709 00:A3CE: 85 AF        	sta	PRGEND
   710 00:A3D0: A5 6A        	lda	VARTAB+1
   711 00:A3D2: 85 B0        	sta	PRGEND+1
   712 00:A3D4: 4C 04 A3     	jmp	RESTART
   713 00:A3D7: A0 04        FIX_2:	ldy	#4		; FIND END OF THIS LINE
   714 00:A3D9: C8           FIX_3:	iny			; (NOTE MAXIMUM LENGTH < 256)
   715 00:A3DA: B1 5E        	lda	(INDEX),y
   716 00:A3DC: D0 FB        	bne	FIX_3
   717 00:A3DE: C8           	iny			; COMPUTE ADDRESS OF NEXT LINE
   718 00:A3DF: 98           	tya
   719 00:A3E0: 65 5E        	adc	INDEX
   720 00:A3E2: AA           	tax
   721 00:A3E3: A0 00        	ldy	#0		; STORE FORWARD PNTR IN THIS LINE
   722 00:A3E5: 91 5E        	sta	(INDEX),y
   723 00:A3E7: A5 5F        	lda	INDEX+1
   724 00:A3E9: 69 00        	adc	#0		; (NOTE: THIS CLEARS CARRY)
   725 00:A3EB: C8           	iny
   726 00:A3EC: 91 5E        	sta	(INDEX),y
   727 00:A3EE: 86 5E        	stx	INDEX
   728 00:A3F0: 85 5F        	sta	INDEX+1
   729 00:A3F2: 90 D2        	bcc	FIX_1		; ...ALWAYS
   730                        
   731                        
   732                        ; ----------------------------------------------------------------------------
   733                        ; READ A LINE, AND STRIP OFF SIGN BITS
   734                        ; ----------------------------------------------------------------------------
   735 00:A3F4: A2 80        INLIN:	ldx	#$80		; NULL PROMPT
   736 00:A3F6: 86 33        INLIN2:	stx	PROMPT
   737 00:A3F8: 20 1F BE     	jsr	GETLN
   738 00:A3FB: E0 EF        	cpx	#239		; MAXIMUM LINE LENGTH
   739 00:A3FD: 90 02        	bcc	INLI1
   740 00:A3FF: A2 EF        	ldx	#239		; TRUNCATE AT 239 CHARS
   741 00:A401: A9 00        INLI1:	lda	#0		; MARK END OF LINE WITH $00 BYTE
   742 00:A403: 9D 00 02     	sta	INPUTBUFFER,x
   743                        ;	txa
   744                        ;	beq	INLI3		; NULL INPUT LINE
   745                        ;INLI2:	lda	INPUTBUFFER-1,x	; DROP SIGN BITS
   746                        ;	and	#$7F		;	already cleared by GETLN
   747                        ;	sta	INPUTBUFFER-1,x
   748                        ;	dex
   749                        ;	bne	INLI2
   750                        ;INLI3:	lda	#0		; (Y,X) POINTS AT BUFFER-1
   751 00:A406: A2 FF        	ldx	#<(INPUTBUFFER-1)
   752 00:A408: A0 01        	ldy	#>(INPUTBUFFER-1)
   753 00:A40A: 60           	rts
   754                        
   755                        ; ----------------------------------------------------------------------------
   756                        ; TOKENIZE THE INPUT LINE
   757                        ; ----------------------------------------------------------------------------
   758                        PARSE_INPUT_LINE:
   759 00:A40B: A6 B8        	ldx	TXTPTR		; INDEX INTO UNPARSED LINE
   760 00:A40D: CA           	dex			; PREPARE FOR INX AT "PARSE"
   761 00:A40E: A0 04        	ldy	#4		; INDEX TO PARSED OUTPUT LINE
   762 00:A410: 84 13        	sty	DATAFLG		; CLEAR SIGN-BIT OF DATAFLG
   763 00:A412: 24 D6        	bit	LOCK		; IS THIS PROGRAM LOCKED?
   764 00:A414: 10 08        	bpl	PARSE		; NO, GO AHEAD AND PARSE THE LINE
   765 00:A416: 68           	pla			; YES, IGNORE INPUT AND "RUN"
   766 00:A417: 68           	pla			;    THE PROGRAM
   767 00:A418: 20 06 A5     	jsr	SETPTRS		; CLEAR ALL VARIABLES
   768 00:A41B: 4C 62 A6     	jmp	NEWSTT		; START RUNNING
   769                        ; ----------------------------------------------------------------------------
   770 00:A41E: E8           PARSE:	inx			; NEXT INPUT CHARACTER
   771 00:A41F: BD 00 02     PARS1:	lda	INPUTBUFFER,x
   772 00:A422: 24 13        	bit	DATAFLG		; IN A "DATA" STATEMENT?
   773 00:A424: 70 04        	bvs	PARS2		; YES (DATAFLG = $49)
   774 00:A426: C9 20        	cmp	#' '		; IGNORE BLANKS
   775 00:A428: F0 F4        	beq	PARSE
   776 00:A42A: 85 0E        PARS2:	sta	ENDCHR
   777 00:A42C: C9 22        	cmp	#'"'		; START OF QUOTATION?
   778 00:A42E: F0 63        	beq	PARS13
   779 00:A430: 70 3C        	bvs	PARS9		; BRANCH IF IN "DATA" STATEMENT
   780 00:A432: C9 3F        	cmp	#'?'		; SHORTHAND FOR "PRINT"?
   781 00:A434: D0 04        	bne	PARS3		; NO
   782 00:A436: A9 98        	lda	#TOKEN_PRINT	; YES, REPLACE WITH "PRINT" TOKEN
   783 00:A438: D0 34        	bne	PARS9		; ...ALWAYS
   784 00:A43A: C9 30        PARS3:	cmp	#'0'		; IS IT A DIGIT, COLON, OR SEMI-COLON?
   785 00:A43C: 90 04        	bcc	PARS4		; NO, PUNCTUATION !"#$%&'()*+,-./
   786 00:A43E: C9 3C        	cmp	#';'+1
   787 00:A440: 90 2C        	bcc	PARS9		; YES, NOT A TOKEN
   788                        ; ----------------------------------------------------------------------------
   789                        ; SEARCH TOKEN NAME TABLE FOR MATCH STARTING
   790                        ; WITH CURRENT CHAR FROM INPUT LINE
   791                        ; ----------------------------------------------------------------------------
   792 00:A442: 84 AD        PARS4:	sty	STRNG2		; SAVE INDEX TO OUTPUT LINE
   793 00:A444: A9 A4        	lda	#<(TOKEN_NAME_TABLE-$100)
   794 00:A446: 85 9D        	sta	FAC		; MAKE PNTR FOR SEARCH
   795 00:A448: A9 9F        	lda	#>(TOKEN_NAME_TABLE-$100)
   796 00:A44A: 85 9E        	sta	FAC+1
   797 00:A44C: A0 00        	ldy	#0		; USE Y-REG WITH (FAC) TO ADDRESS TABLE
   798 00:A44E: 84 0F        	sty	TKNCNTR		; HOLDS CURRENT TOKEN-$80
   799 00:A450: 88           	dey			; PREPARE FOR "INY" A FEW LINES DOWN
   800 00:A451: 86 B8        	stx	TXTPTR		; SAVE POSITION IN INPUT LINE
   801 00:A453: CA           	dex			; PREPARE FOR "INX" A FEW LINES DOWN
   802 00:A454: C8           PARS5:	iny			; ADVANCE POINTER TO TOKEN TABLE
   803 00:A455: D0 02        	bne	PARS6		; Y=Y+1 IS ENOUGH
   804 00:A457: E6 9E        	inc	FAC+1		; ALSO NEED TO BUMP THE PAGE
   805 00:A459: E8           PARS6:	inx			; ADVANCE POINTER TO INPUT LINE
   806 00:A45A: BD 00 02     PARS7:	lda	INPUTBUFFER,x	; NEXT CHAR FROM INPUT LINE
   807 00:A45D: C9 20        	cmp	#' '		; THIS CHAR A BLANK?
   808 00:A45F: F0 F8        	beq	PARS6		; YES, IGNORE ALL BLANKS
   809 00:A461: 38           	sec			; NO, COMPARE TO CHAR IN TABLE
   810 00:A462: F1 9D        	sbc	(FAC),y		; SAME AS NEXT CHAR OF TOKEN NAME?
   811 00:A464: F0 EE        	beq	PARS5		; YES, CONTINUE MATCHING
   812 00:A466: C9 80        	cmp	#$80		; MAYBE; WAS IT SAME EXCEPT FOR BIT 7?
   813 00:A468: D0 30        	bne	PARS14		; NO, SKIP TO NEXT TOKEN
   814 00:A46A: 05 0F        	ora	TKNCNTR		; YES, END OF TOKEN; GET TOKEN #
   815                        ; ----------------------------------------------------------------------------
   816                        ; STORE CHARACTER OR TOKEN IN OUTPUT LINE
   817                        ; ----------------------------------------------------------------------------
   818 00:A46C: A4 AD        PARS8:	ldy	STRNG2		; GET INDEX TO OUTPUT LINE IN Y-REG
   819 00:A46E: E8           PARS9:	inx			; ADVANCE INPUT INDEX
   820 00:A46F: C8           	iny			; ADVANCE OUTPUT INDEX
   821 00:A470: 99 FB 01     	sta	INPUTBUFFER-5,y	; STORE CHAR OR TOKEN
   822 00:A473: B9 FB 01     	lda	INPUTBUFFER-5,y	; TEST FOR EOL OR EOS
   823 00:A476: F0 39        	beq	PARS17		; END OF LINE
   824 00:A478: 38           	sec
   825 00:A479: E9 3A        	sbc	#':'		; END OF STATEMENT?
   826 00:A47B: F0 04        	beq	PARS10		; YES, CLEAR DATAFLG
   827 00:A47D: C9 49        	cmp	#TOKEN_DATA-':'	; "DATA" TOKEN?
   828 00:A47F: D0 02        	bne	PARS11		; NO, LEAVE DATAFLG ALONE
   829 00:A481: 85 13        PARS10:	sta	DATAFLG		; DATAFLG = 0 OR $83-$3A = $49
   830 00:A483: 38           PARS11:	sec			; IS IT A "REM" TOKEN?
   831 00:A484: E9 5A        	sbc	#TOKEN_REM-':'
   832 00:A486: D0 97        	bne	PARS1		; NO, CONTINUE PARSING LINE
   833 00:A488: 85 0E        	sta	ENDCHR		; YES, CLEAR LITERAL FLAG
   834                        ; ----------------------------------------------------------------------------
   835                        ; HANDLE LITERAL (BETWEEN QUOTES) OR REMARK,
   836                        ; BY COPYING CHARS UP TO ENDCHR.
   837                        ; ----------------------------------------------------------------------------
   838 00:A48A: BD 00 02     PARS12:	lda	INPUTBUFFER,x
   839 00:A48D: F0 DF        	beq	PARS9		; END OF LINE
   840 00:A48F: C5 0E        	cmp	ENDCHR
   841 00:A491: F0 DB        	beq	PARS9		; FOUND ENDCHR
   842 00:A493: C8           PARS13:	iny			; NEXT OUTPUT CHAR
   843 00:A494: 99 FB 01     	sta	INPUTBUFFER-5,y
   844 00:A497: E8           	inx			; NEXT INPUT CHAR
   845 00:A498: D0 F0        	bne	PARS12		; ...ALWAYS
   846                        ; ----------------------------------------------------------------------------
   847                        ; ADVANCE POINTER TO NEXT TOKEN NAME
   848                        ; ----------------------------------------------------------------------------
   849 00:A49A: A6 B8        PARS14:	ldx	TXTPTR		; GET POINTER TO INPUT LINE IN X-REG
   850 00:A49C: E6 0F        	inc	TKNCNTR		;    BUMP (TOKEN # - $80)
   851 00:A49E: B1 9D        PARS15:	lda	(FAC),y		; SCAN THROUGH TABLE FOR BIT7 = 1
   852 00:A4A0: C8           	iny			; NEXT TOKEN ONE BEYOND THAT
   853 00:A4A1: D0 02        	bne	PARS16		; ...USUALLY ENOUGH TO BUMP Y-REG
   854 00:A4A3: E6 9E        	inc	FAC+1		; NEXT SET OF 256 TOKEN CHARS
   855 00:A4A5: 0A           PARS16:	asl	a		; SEE IF SIGN BIT SET ON CHAR
   856 00:A4A6: 90 F6        	bcc	PARS15		; NO, MORE IN THIS NAME
   857 00:A4A8: B1 9D        	lda	(FAC),y		; YES, AT NEXT NAME.  END OF TABLE?
   858 00:A4AA: D0 AE        	bne	PARS7		; NO, NOT END OF TABLE
   859 00:A4AC: BD 00 02     	lda	INPUTBUFFER,x	; YES, SO NOT A KEYWORD
   860 00:A4AF: 10 BB        	bpl	PARS8		; ...ALWAYS, COPY CHAR AS IS
   861                        ; ---END OF LINE------------------
   862 00:A4B1: 99 FD 01     PARS17:	sta	INPUTBUFFER-3,y	; STORE ANOTHER 00 ON END
   863 00:A4B4: C6 B9        	dec	TXTPTR+1	; SET TXTPTR = INPUTBUFFER-1
   864 00:A4B6: A9 FF        	lda	#<(INPUTBUFFER-1)
   865 00:A4B8: 85 B8        	sta	TXTPTR
   866 00:A4BA: 60           	rts
   867                        
   868                        
   869                        ; ----------------------------------------------------------------------------
   870                        ; SEARCH FOR LINE
   871                        ;
   872                        ; (LINNUM) = LINE # TO FIND
   873                        ; IF NOT FOUND:  CARRY = 0
   874                        ;	LOWTR POINTS AT NEXT LINE
   875                        ; IF FOUND:      CARRY = 1
   876                        ;	LOWTR POINTS AT LINE
   877                        ; ----------------------------------------------------------------------------
   878 00:A4BB: A5 67        FNDLIN:	lda	TXTTAB		; SEARCH FROM BEGINNING OF PROGRAM
   879 00:A4BD: A6 68        	ldx	TXTTAB+1
   880 00:A4BF: A0 01        FL1:	ldy	#1		; SEARCH FROM (X,A)
   881 00:A4C1: 85 9B        	sta	LOWTR
   882 00:A4C3: 86 9C        	stx	LOWTR+1
   883 00:A4C5: B1 9B        	lda	(LOWTR),y
   884 00:A4C7: F0 1F        	beq	FNDL3		; END OF PROGRAM, AND NOT FOUND
   885 00:A4C9: C8           	iny
   886 00:A4CA: C8           	iny
   887 00:A4CB: A5 51        	lda	LINNUM+1
   888 00:A4CD: D1 9B        	cmp	(LOWTR),y
   889 00:A4CF: 90 18        	bcc	RTS1		; IF NOT FOUND
   890 00:A4D1: F0 03        	beq	FNDL1
   891 00:A4D3: 88           	dey
   892 00:A4D4: D0 09        	bne	FNDL2
   893 00:A4D6: A5 50        FNDL1:	lda	LINNUM
   894 00:A4D8: 88           	dey
   895 00:A4D9: D1 9B        	cmp	(LOWTR),y
   896 00:A4DB: 90 0C        	bcc	RTS1		; PAST LINE, NOT FOUND
   897 00:A4DD: F0 0A        	beq	RTS1		; IF FOUND
   898 00:A4DF: 88           FNDL2:	dey
   899 00:A4E0: B1 9B        	lda	(LOWTR),y
   900 00:A4E2: AA           	tax
   901 00:A4E3: 88           	dey
   902 00:A4E4: B1 9B        	lda	(LOWTR),y
   903 00:A4E6: B0 D7        	bcs	FL1		; ALWAYS
   904 00:A4E8: 18           FNDL3:	clc			; RETURN CARRY = 0
   905 00:A4E9: 60           RTS1:	rts
   906                        
   907                        
   908                        ; ----------------------------------------------------------------------------
   909                        ; "NEW" STATEMENT
   910                        ; ----------------------------------------------------------------------------
   911 00:A4EA: D0 FD        NEW:	bne	RTS1		; IGNORE IF MORE TO THE STATEMENT
   912 00:A4EC: A9 00        SCRTCH:	lda	#0
   913 00:A4EE: 85 D6        	sta	LOCK
   914 00:A4F0: A8           	tay
   915 00:A4F1: 91 67        	sta	(TXTTAB),y
   916 00:A4F3: C8           	iny
   917 00:A4F4: 91 67        	sta	(TXTTAB),y
   918 00:A4F6: A5 67        	lda	TXTTAB
   919 00:A4F8: 69 02        	adc	#2		; (CARRY WASN'T CLEARED, SO "NEW" USUALLY
   920 00:A4FA: 85 69        	sta	VARTAB		; ADDS 3, WHEREAS "FP" ADDS 2.)
   921 00:A4FC: 85 AF        	sta	PRGEND
   922 00:A4FE: A5 68        	lda	TXTTAB+1
   923 00:A500: 69 00        	adc	#0
   924 00:A502: 85 6A        	sta	VARTAB+1
   925 00:A504: 85 B0        	sta	PRGEND+1
   926                        ; ----------------------------------------------------------------------------
   927                        SETPTRS:
   928 00:A506: 20 38 A5     	jsr	STXTPT		; SET TXTPTR TO TXTTAB - 1
   929 00:A509: A9 00        	lda	#0		; (THIS COULD HAVE BEEN ".byte $2C")
   930                        
   931                        
   932                        ; ----------------------------------------------------------------------------
   933                        ; "CLEAR" STATEMENT
   934                        ; ----------------------------------------------------------------------------
   935 00:A50B: D0 2A        CLEAR:	bne	RTS2		; IGNORE IF NOT AT END OF STATEMENT
   936 00:A50D: A5 73        CLEARC:	lda	MEMSIZ		; CLEAR STRING AREA
   937 00:A50F: A4 74        	ldy	MEMSIZ+1
   938 00:A511: 85 6F        	sta	FRETOP
   939 00:A513: 84 70        	sty	FRETOP+1
   940 00:A515: A5 69        	lda	VARTAB		; CLEAR ARRAY AREA
   941 00:A517: A4 6A        	ldy	VARTAB+1
   942 00:A519: 85 6B        	sta	ARYTAB
   943 00:A51B: 84 6C        	sty	ARYTAB+1
   944 00:A51D: 85 6D        	sta	STREND		; LOW END OF FREE SPACE
   945 00:A51F: 84 6E        	sty	STREND+1
   946 00:A521: 20 C1 A6     	jsr	RESTORE		; SET "DATA" POINTER TO BEGINNING
   947                        ; ----------------------------------------------------------------------------
   948 00:A524: A2 55        STKINI:	ldx	#TEMPST
   949 00:A526: 86 52        	stx	TEMPPT
   950 00:A528: 68           	pla			; SAVE RETURN ADDRESS
   951 00:A529: A8           	tay
   952 00:A52A: 68           	pla
   953 00:A52B: A2 F8        	ldx	#$F8		; START STACK AT $F8,
   954 00:A52D: 9A           	txs			;   LEAVING ROOM FOR PARSING LINES
   955 00:A52E: 48           	pha			; RESTORE RETURN ADDRESS
   956 00:A52F: 98           	tya
   957 00:A530: 48           	pha
   958 00:A531: A9 00        	lda	#0
   959 00:A533: 85 7A        	sta	OLDTEXT+1
   960 00:A535: 85 14        	sta	SUBFLG
   961 00:A537: 60           RTS2:	rts
   962                        
   963                        ; ----------------------------------------------------------------------------
   964                        ; SET TXTPTR TO BEGINNING OF PROGRAM
   965                        ; ----------------------------------------------------------------------------
   966 00:A538: 18           STXTPT:	clc			; TXTPTR = TXTTAB - 1
   967 00:A539: A5 67        	lda     TXTTAB
   968 00:A53B: 69 FF        	adc     #$FF
   969 00:A53D: 85 B8        	sta     TXTPTR
   970 00:A53F: A5 68        	lda     TXTTAB+1
   971 00:A541: 69 FF        	adc     #$FF
   972 00:A543: 85 B9        	sta     TXTPTR+1
   973 00:A545: 60           	rts
   974                        
   975                        ; ----------------------------------------------------------------------------
   976                        ; "LIST" STATEMENT
   977                        ; ----------------------------------------------------------------------------
   978 00:A546: 90 0A        LIST:	bcc	LIST_1		; NO  LINE # SPECIFIED
   979 00:A548: F0 08        	beq	LIST_1		; ---DITTO---
   980 00:A54A: C9 A8        	cmp	#TOKEN_MINUS	; IF DASH OR COMMA, START AT LINE 0
   981 00:A54C: F0 04        	beq	LIST_1		; IT IS A DASH
   982 00:A54E: C9 2C        	cmp	#','		; COMMA?
   983 00:A550: D0 E5        	bne	RTS2		; NO, ERROR
   984 00:A552: 20 25 A8     LIST_1:	jsr	LINGET		; CONVERT LINE NUMBER IF ANY
   985 00:A555: 20 BB A4     	jsr	FNDLIN		; POINT LOWTR TO 1ST LINE
   986 00:A558: 20 B7 00     	jsr	CHRGOT		; RANGE SPECIFIED?
   987 00:A55B: F0 10        	beq	LIST_3		; NO
   988 00:A55D: C9 A8        	cmp	#TOKEN_MINUS
   989 00:A55F: F0 04        	beq	LIST_2
   990 00:A561: C9 2C        	cmp	#','
   991 00:A563: D0 84        	bne	RTS1
   992 00:A565: 20 B1 00     LIST_2:	jsr	CHRGET		; GET NEXT CHAR
   993 00:A568: 20 25 A8     	jsr	LINGET		; CONVERT SECOND LINE #
   994 00:A56B: D0 CA        	bne	RTS2		; BRANCH IF SYNTAX ERR
   995 00:A56D: 68           LIST_3:	pla			; POP RETURN ADRESS
   996 00:A56E: 68           	pla			; (GET BACK BY "JMP NEWSTT")
   997 00:A56F: A5 50        	lda	LINNUM		; IF NO SECOND NUMBER, USE $FFFF
   998 00:A571: 05 51        	ora	LINNUM+1
   999 00:A573: D0 06        	bne	LIST0		; THERE WAS A SECOND NUMBER
  1000 00:A575: A9 FF        	lda	#$FF		; MAX END RANGE
  1001 00:A577: 85 50        	sta	LINNUM
  1002 00:A579: 85 51        	sta	LINNUM+1
  1003 00:A57B: A0 01        LIST0:	ldy	#1
  1004 00:A57D: B1 9B        	lda	(LOWTR),y	; HIGH BYTE OF LINK
  1005 00:A57F: F0 37        	beq	LIST3		; END OF PROGRAM
  1006 00:A581: 20 D0 A6     	jsr	ISCNTC		; CHECK IF CONTROL-C HAS BEEN TYPED
  1007 00:A584: 20 46 BE     	jsr	CRDO		; NO, PRINT <RETURN>
  1008 00:A587: C8           	iny
  1009 00:A588: B1 9B        	lda	(LOWTR),y	; GET LINE #, COMPARE WITH END RANGE
  1010 00:A58A: AA           	tax
  1011 00:A58B: C8           	iny
  1012 00:A58C: B1 9B        	lda	(LOWTR),y
  1013 00:A58E: C5 51        	cmp	LINNUM+1
  1014 00:A590: D0 04        	bne	LIST_5
  1015 00:A592: E4 50        	cpx	LINNUM
  1016 00:A594: F0 02        	beq	LIST_6		; ON LAST LINE OF RANGE
  1017 00:A596: B0 20        LIST_5:	bcs	LIST3		; FINISHED THE RANGE
  1018                        ; ---LIST ONE LINE----------------
  1019 00:A598: 84 85        LIST_6:	sty	FORPNT
  1020 00:A59A: 20 E1 B9     	jsr	LINPRT		; PRINT LINE # FROM X,A
  1021 00:A59D: A9 20        	lda	#' '		; PRINT SPACE AFTER LINE #
  1022 00:A59F: A4 85        LIST1:	ldy	FORPNT
  1023 00:A5A1: 29 7F        	and	#$7F
  1024 00:A5A3: 20 4D BE     LIST2:	jsr	OUTDO
  1025 00:A5A6: C8           LIST21:	iny
  1026 00:A5A7: B1 9B        	lda	(LOWTR),y
  1027 00:A5A9: D0 1B        	bne	LIST4		; NOT END OF LINE YET
  1028 00:A5AB: A8           	tay			; END OF LINE
  1029 00:A5AC: B1 9B        	lda	(LOWTR),y	; GET LINK TO NEXT LINE
  1030 00:A5AE: AA           	tax
  1031 00:A5AF: C8           	iny
  1032 00:A5B0: B1 9B        	lda	(LOWTR),y
  1033 00:A5B2: 86 9B        	stx	LOWTR		; POINT TO NEXT LINE
  1034 00:A5B4: 85 9C        	sta	LOWTR+1
  1035 00:A5B6: D0 C3        	bne	LIST0		; BRANCH IF NOT END OF PROGRAM
  1036 00:A5B8: 20 46 BE     LIST3:	jsr	CRDO		; PRINT <RETURN>
  1037 00:A5BB: 4C 62 A6     	jmp	NEWSTT		; TO NEXT STATEMENT
  1038                        ; ----------------------------------------------------------------------------
  1039 00:A5BE: C8           GETCHR:	iny			;  PICK UP CHAR FROM TABLE
  1040 00:A5BF: D0 02        	bne	GETCHR21
  1041 00:A5C1: E6 9E        	inc	FAC+1
  1042                        GETCHR21:
  1043 00:A5C3: B1 9D        	lda	(FAC),y
  1044 00:A5C5: 60           	rts
  1045                        ; ----------------------------------------------------------------------------
  1046 00:A5C6: 10 DB        LIST4:	bpl	LIST2		; BRANCH IF NOT A TOKEN
  1047 00:A5C8: 38           	sec
  1048 00:A5C9: E9 7F        	sbc	#$7F		; CONVERT TOKEN TO INDEX
  1049 00:A5CB: AA           	tax
  1050 00:A5CC: 84 85        	sty	FORPNT		; SAVE LINE POINTER
  1051 00:A5CE: A0 A4        	ldy	#<(TOKEN_NAME_TABLE-$100)
  1052 00:A5D0: 84 9D        	sty	FAC		; POINT FAC TO TABLE
  1053 00:A5D2: A0 9F        	ldy	#>(TOKEN_NAME_TABLE-$100)
  1054 00:A5D4: 84 9E        	sty	FAC+1
  1055 00:A5D6: A0 FF        	ldy	#$FF		; Y= -1
  1056 00:A5D8: CA           LIST41:	dex			; SKIP KEYWORDS UNTIL REACH THIS ONE
  1057 00:A5D9: F0 07        	beq	LIST43
  1058 00:A5DB: 20 BE A5     LIST42:	jsr	GETCHR		; BUMP Y, GET CHAR FROM TABLE
  1059 00:A5DE: 10 FB        	bpl	LIST42		; NOT AT END OF KEYWORD YET
  1060 00:A5E0: 30 F6        	bmi	LIST41		; END OF KEYWORD, ALWAYS BRANCHES
  1061 00:A5E2: 20 3E BE     LIST43:	jsr	OUTSP		; FOUND THE RIGHT KEYWORD, PRINT LEADING SPACE
  1062 00:A5E5: 20 BE A5     LIST44:	jsr	GETCHR		; PRINT THE KEYWORD
  1063 00:A5E8: 30 05        	bmi	LIST45		; LAST CHAR OF KEYWORD
  1064 00:A5EA: 20 4D BE     	jsr	OUTDO
  1065 00:A5ED: D0 F6        	bne	LIST44		; ...ALWAYS
  1066 00:A5EF: 20 4D BE     LIST45:	jsr	OUTDO		; PRINT LAST CHAR OF KEYWORD
  1067 00:A5F2: A9 20        	lda	#' '		; PRINT TRAILING SPACE
  1068 00:A5F4: D0 A9        	bne	LIST1		; ...ALWAYS, BACK TO ACTUAL LINE
  1069                        
  1070                        
  1071                        ; ----------------------------------------------------------------------------
  1072                        ; "FOR" STATEMENT
  1073                        ;
  1074                        ; FOR PUSHES 18 BYTES ON THE STACK:
  1075                        ; 2 -- TXTPTR
  1076                        ; 2 -- LINE NUMBER
  1077                        ; 5 -- INITIAL (CURRENT)  FOR VARIABLE VALUE
  1078                        ; 1 -- STEP SIGN
  1079                        ; 5 -- STEP VALUE
  1080                        ; 2 -- ADDRESS OF FOR VARIABLE IN VARTAB
  1081                        ; 1 -- FOR TOKEN ($81)
  1082                        ; ----------------------------------------------------------------------------
  1083 00:A5F6: A9 80        FOR:	lda	#$80
  1084 00:A5F8: 85 14        	sta	SUBFLG		; SUBSCRIPTS NOT ALLOWED
  1085 00:A5FA: 20 5F A8     	jsr	LET		; DO <VAR> = <EXP>, STORE ADDR IN FORPNT
  1086 00:A5FD: 20 2D A2     	jsr	GTFORPNT	; IS THIS FOR VARIABLE ACTIVE?
  1087 00:A600: D0 05        	bne	FOR_1		; NO
  1088 00:A602: 8A           	txa			; YES, CANCEL IT AND ENCLOSED LOOPS
  1089 00:A603: 69 0F        	adc	#15		; CARRY=1, THIS ADDS 16
  1090 00:A605: AA           	tax			; X WAS ALREADY S+2
  1091 00:A606: 9A           	txs
  1092 00:A607: 68           FOR_1:	pla			; POP RETURN ADDRESS TOO
  1093 00:A608: 68           	pla
  1094 00:A609: A9 09        	lda	#9		; BE CERTAIN ENOUGH ROOM IN STACK
  1095 00:A60B: 20 9E A2     	jsr	CHKMEM
  1096 00:A60E: 20 BC A7     	jsr	DATAN		; SCAN AHEAD TO NEXT STATEMENT
  1097 00:A611: 18           	clc			; PUSH STATEMENT ADDRESS ON STACK
  1098 00:A612: 98           	tya
  1099 00:A613: 65 B8        	adc	TXTPTR
  1100 00:A615: 48           	pha
  1101 00:A616: A5 B9        	lda	TXTPTR+1
  1102 00:A618: 69 00        	adc	#0
  1103 00:A61A: 48           	pha
  1104 00:A61B: A5 76        	lda	CURLIN+1	; PUSH LINE NUMBER ON STACK
  1105 00:A61D: 48           	pha
  1106 00:A61E: A5 75        	lda	CURLIN
  1107 00:A620: 48           	pha
  1108 00:A621: A9 A2        	lda	#TOKEN_TO
  1109 00:A623: 20 86 AC     	jsr	SYNCHR		; REQUIRE "TO"
  1110 00:A626: 20 37 AB     	jsr	CHKNUM		; <VAR> = <EXP> MUST BE NUMERIC
  1111 00:A629: 20 34 AB     	jsr	FRMNUM		; GET FINAL VALUE, MUST BE NUMERIC
  1112 00:A62C: A5 A2        	lda	FACSIGN		; PUT SIGN INTO VALUE IN FAC
  1113 00:A62E: 09 7F        	ora	#$7F
  1114 00:A630: 25 9E        	and	FAC+1
  1115 00:A632: 85 9E        	sta	FAC+1
  1116 00:A634: A9 3F        	lda	#<STEP		; SET UP FOR RETURN
  1117 00:A636: A0 A6        	ldy	#>STEP		; TO STEP
  1118 00:A638: 85 5E        	sta	INDEX
  1119 00:A63A: 84 5F        	sty	INDEX+1
  1120 00:A63C: 4C ED AB     	jmp	FRM_STACK3	; RETURNS BY "JMP (INDEX)"
  1121                        
  1122                        
  1123                        ; ----------------------------------------------------------------------------
  1124                        ; "STEP" PHRASE OF "FOR" STATEMENT
  1125                        ; ----------------------------------------------------------------------------
  1126 00:A63F: A9 DA        STEP:	lda	#<CON_ONE	; STEP DEFAULT=1
  1127 00:A641: A0 B5        	ldy	#>CON_ONE
  1128 00:A643: 20 BB B7     	jsr	LOAD_FAC_FROM_YA
  1129 00:A646: 20 B7 00     	jsr	CHRGOT
  1130 00:A649: C9 A6        	cmp	#TOKEN_STEP
  1131 00:A64B: D0 06        	bne	STEP_1		; USE DEFAULT VALUE OF 1.0
  1132 00:A64D: 20 B1 00     	jsr	CHRGET		; STEP SPECIFIED, GET IT
  1133 00:A650: 20 34 AB     	jsr	FRMNUM
  1134 00:A653: 20 44 B8     STEP_1:	jsr	SIGN
  1135 00:A656: 20 E2 AB     	jsr	FRM_STACK2
  1136 00:A659: A5 86        	lda	FORPNT+1
  1137 00:A65B: 48           	pha
  1138 00:A65C: A5 85        	lda	FORPNT
  1139 00:A65E: 48           	pha
  1140 00:A65F: A9 81        	lda	#TOKEN_FOR
  1141 00:A661: 48           	pha
  1142                        
  1143                        
  1144                        ; ----------------------------------------------------------------------------
  1145                        ; PERFORM NEXT STATEMENT
  1146                        ; ----------------------------------------------------------------------------
  1147 00:A662: BA           NEWSTT:	tsx			; REMEMBER THE STACK POSITION
  1148 00:A663: 86 F8        	stx	REMSTK
  1149 00:A665: 20 D0 A6     	jsr	ISCNTC		; SEE IF CONTROL-C HAS BEEN TYPED
  1150 00:A668: A5 B8        	lda	TXTPTR		; NO, KEEP EXECUTING
  1151 00:A66A: A4 B9        	ldy	TXTPTR+1
  1152 00:A66C: A6 76        	ldx	CURLIN+1	; =$FF IF IN DIRECT MODE
  1153 00:A66E: E8           	inx			; $FF TURNS INTO $00
  1154 00:A66F: F0 04        	beq	NEWSTT_1		; IN DIRECT MODE
  1155 00:A671: 85 79        	sta	OLDTEXT		; IN RUNNING MODE
  1156 00:A673: 84 7A        	sty	OLDTEXT+1
  1157                        NEWSTT_1:
  1158 00:A675: A0 00        	ldy	#0
  1159 00:A677: B1 B8        	lda	(TXTPTR),y	; END OF LINE YET?
  1160 00:A679: D0 3F        	bne	COLON		; NO
  1161 00:A67B: A0 02        	ldy	#2		; YES, SEE IF END OF PROGRAM
  1162 00:A67D: B1 B8        	lda	(TXTPTR),y
  1163 00:A67F: 18           	clc
  1164 00:A680: F0 1C        	beq	GOEND		; YES, END OF PROGRAM
  1165 00:A682: C8           	iny
  1166 00:A683: B1 B8        	lda	(TXTPTR),y	; GET LINE # OF NEXT LINE
  1167 00:A685: 85 75        	sta	CURLIN
  1168 00:A687: C8           	iny
  1169 00:A688: B1 B8        	lda	(TXTPTR),y
  1170 00:A68A: 85 76        	sta	CURLIN+1
  1171 00:A68C: 98           	tya			; ADJUST TXTPTR TO START
  1172 00:A68D: 65 B8        	adc	TXTPTR		; OF NEW LINE
  1173 00:A68F: 85 B8        	sta	TXTPTR
  1174 00:A691: 90 02        	bcc	NEWSTT_2
  1175 00:A693: E6 B9        	inc	TXTPTR+1
  1176                        NEWSTT_2:
  1177                        NEWSTT2:
  1178 00:A695: 20 B1 00     	jsr	CHRGET		; GET FIRST CHR OF STATEMENT
  1179 00:A698: 20 A0 A6     	jsr	EXECUTE_STATEMENT	; AND START PROCESSING
  1180 00:A69B: 4C 62 A6     	jmp	NEWSTT		; BACK FOR MORE
  1181                        ; ----------------------------------------------------------------------------
  1182 00:A69E: F0 65        GOEND:	beq	END4
  1183                        
  1184                        
  1185                        ; ----------------------------------------------------------------------------
  1186                        ; EXECUTE A STATEMENT
  1187                        ;
  1188                        ; (A) IS FIRST CHAR OF STATEMENT
  1189                        ; CARRY IS SET
  1190                        ; ----------------------------------------------------------------------------
  1191                        EXECUTE_STATEMENT:
  1192 00:A6A0: F0 2D        	beq	RTS3		; END OF LINE, NULL STATEMENT
  1193                        EXECUTE_STATEMENT1:
  1194 00:A6A2: E9 80        	sbc	#$80		; FIRST CHAR A TOKEN?
  1195 00:A6A4: 90 11        	bcc	EXECUTE_S1		; NOT TOKEN, MUST BE "LET"
  1196 00:A6A6: C9 40        	cmp	#$40		; STATEMENT-TYPE TOKEN?
  1197 00:A6A8: B0 14        	bcs	SYNERR1		; NO, SYNTAX ERROR
  1198 00:A6AA: 0A           	asl	a		; DOUBLE TO GET INDEX
  1199 00:A6AB: A8           	tay			; INTO ADDRESS TABLE
  1200 00:A6AC: B9 21 A0     	lda	TOKEN_ADDRESS_TABLE+1,y
  1201 00:A6AF: 48           	pha			; PUT ADDRESS ON STACK
  1202 00:A6B0: B9 20 A0     	lda	TOKEN_ADDRESS_TABLE,y
  1203 00:A6B3: 48           	pha
  1204 00:A6B4: 4C B1 00     	jmp	CHRGET		; GET NEXT CHR & RTS TO ROUTINE
  1205                        ; ----------------------------------------------------------------------------
  1206                        EXECUTE_S1:
  1207 00:A6B7: 4C 5F A8     	jmp	LET		; MUST BE <VAR> = <EXP>
  1208                        ; ----------------------------------------------------------------------------
  1209 00:A6BA: C9 3A        COLON:	cmp	#':'
  1210 00:A6BC: F0 D7        	beq	NEWSTT2
  1211                        SYNERR1:
  1212 00:A6BE: 4C 8F AC     	jmp	SYNERR
  1213                        
  1214                        
  1215                        ; ----------------------------------------------------------------------------
  1216                        ; "RESTORE" STATEMENT
  1217                        ; ----------------------------------------------------------------------------
  1218                        RESTORE:
  1219 00:A6C1: 38           	sec			; SET DATPTR TO BEGINNING OF PROGRAM
  1220 00:A6C2: A5 67        	lda	TXTTAB
  1221 00:A6C4: E9 01        	sbc	#1
  1222 00:A6C6: A4 68        	ldy	TXTTAB+1
  1223 00:A6C8: B0 01        	bcs	SETDA
  1224 00:A6CA: 88           	dey
  1225                        ; ---SET DATPTR TO Y,A------------
  1226 00:A6CB: 85 7D        SETDA:  sta	DATPTR
  1227 00:A6CD: 84 7E        	sty	DATPTR+1
  1228 00:A6CF: 60           RTS3:   rts
  1229                        
  1230                        
  1231                        ; ----------------------------------------------------------------------------
  1232                        ; SEE IF CONTROL-C TYPED
  1233                        ; ----------------------------------------------------------------------------
  1234                        ISCNTC:
  1235 00:A6D0: 20 FE BD     	jsr	CONST
  1236 00:A6D3: D0 01        	bne	ISC_0
  1237 00:A6D5: 60           	rts
  1238                        ISC_0:
  1239 00:A6D6: 20 FB BD     	jsr	RDKEY
  1240 00:A6D9: C9 03        	cmp	#$03
  1241 00:A6DB: F0 01        	beq	ISC_1
  1242 00:A6DD: 60           	rts
  1243                        
  1244                        ISC_1:
  1245                        CONTROL_C_TYPED:
  1246 00:A6DE: A2 FF        	ldx	#$FF		; CONTROL C ATTEMPTED
  1247 00:A6E0: 24 D8        	bit	ERRFLG		; "ON ERR" ENABLED?
  1248 00:A6E2: 10 03        	bpl	ISC_2		; NO
  1249 00:A6E4: 4C B6 BD     	jmp	HANDLERR	; YES, RETURN ERR CODE = 255
  1250 00:A6E7: C9 03        ISC_2:	cmp	#3		; SINCE IT IS CTRL-C, SET Z AND C BITS
  1251                        
  1252                        
  1253                        ; ----------------------------------------------------------------------------
  1254                        ; "STOP" STATEMENT
  1255                        ; ----------------------------------------------------------------------------
  1256 00:A6E9: B0 01        STOP:	bcs	END2		; CARRY=1 TO FORCE PRINTING "BREAK AT.."
  1257                        
  1258                        
  1259                        ; ----------------------------------------------------------------------------
  1260                        ; "END" STATEMENT
  1261                        ; ----------------------------------------------------------------------------
  1262 00:A6EB: 18           END:	clc			; CARRY=0 TO AVOID PRINTING MESSAGE
  1263 00:A6EC: D0 3C        END2:	bne     RTS4		; IF NOT END OF STATEMENT, DO NOTHING
  1264 00:A6EE: A5 B8        	lda     TXTPTR
  1265 00:A6F0: A4 B9        	ldy     TXTPTR+1
  1266 00:A6F2: A6 76        	ldx     CURLIN+1
  1267 00:A6F4: E8           	inx			; RUNNING?
  1268 00:A6F5: F0 0C        	beq     END21		; NO, DIRECT MODE
  1269 00:A6F7: 85 79        	sta     OLDTEXT
  1270 00:A6F9: 84 7A        	sty     OLDTEXT+1
  1271 00:A6FB: A5 75        	lda     CURLIN
  1272 00:A6FD: A4 76        	ldy     CURLIN+1
  1273 00:A6FF: 85 77        	sta     OLDLIN
  1274 00:A701: 84 78        	sty     OLDLIN+1
  1275 00:A703: 68           END21:	pla
  1276 00:A704: 68           	pla
  1277 00:A705: A9 26        END4:   lda     #<QT_BREAK	; " BREAK"
  1278 00:A707: A0 A2        	ldy     #>QT_BREAK
  1279 00:A709: 90 03        	bcc     END41
  1280 00:A70B: 4C F9 A2     	jmp     PRINT_ERROR_LINNUM
  1281 00:A70E: 4C 04 A3     END41:	jmp	RESTART
  1282                        
  1283                        
  1284                        ; ----------------------------------------------------------------------------
  1285                        ; "CONT" COMMAND
  1286                        ; ----------------------------------------------------------------------------
  1287 00:A711: D0 17        CONT:	bne	RTS4		; IF NOT END OF STATEMENT, DO NOTHING
  1288 00:A713: A2 82        	ldx	#ERR_CANTCONT
  1289 00:A715: A4 7A        	ldy	OLDTEXT+1	; MEANINGFUL RE-ENTRY?
  1290 00:A717: D0 03        	bne	CONT1		; YES
  1291 00:A719: 4C DA A2     	jmp	ERROR		; NO
  1292 00:A71C: A5 79        CONT1:	lda	OLDTEXT		; RESTORE TXTPTR
  1293 00:A71E: 85 B8        	sta	TXTPTR
  1294 00:A720: 84 B9        	sty	TXTPTR+1
  1295 00:A722: A5 77        	lda	OLDLIN		; RESTORE LINE NUMBER
  1296 00:A724: A4 78        	ldy	OLDLIN+1
  1297 00:A726: 85 75        	sta	CURLIN
  1298 00:A728: 84 76        	sty	CURLIN+1
  1299 00:A72A: 60           RTS4:	rts
  1300                        
  1301                        
  1302                        ; ----------------------------------------------------------------------------
  1303                        ; "RUN" COMMAND
  1304                        ; ----------------------------------------------------------------------------
  1305 00:A72B: 08           RUN:	php			; SAVE STATUS WHILE SUBTRACTING
  1306 00:A72C: C6 76        	dec	CURLIN+1	; IF WAS $FF (MEANING DIRECT MODE) MAKE IT "RUNNING MODE"
  1307 00:A72E: 28           	plp			; GET STATUS AGAIN (FROM CHRGET)
  1308 00:A72F: D0 03        	bne	RUN1		; PROBABLY A LINE NUMBER
  1309 00:A731: 4C 06 A5     	jmp	SETPTRS		; START AT BEGINNING OF PROGRAM
  1310 00:A734: 20 0D A5     RUN1:	jsr	CLEARC		; CLEAR VARIABLES
  1311 00:A737: 4C 4E A7     	jmp	GO_TO_LINE	; JOIN GOSUB STATEMENT
  1312                        
  1313                        
  1314                        ; ----------------------------------------------------------------------------
  1315                        ; "GOSUB" STATEMENT
  1316                        ;
  1317                        ; LEAVES 7 BYTES ON STACK:
  1318                        ; 2 -- RETURN ADDRESS (NEWSTT)
  1319                        ; 2 -- TXTPTR
  1320                        ; 2 -- LINE #
  1321                        ; 1 -- GOSUB TOKEN
  1322                        ; ----------------------------------------------------------------------------
  1323 00:A73A: A9 03        GOSUB:	lda	#3		; BE SURE ENOUGH ROOM ON STACK
  1324 00:A73C: 20 9E A2     	jsr	CHKMEM
  1325 00:A73F: A5 B9        	lda	TXTPTR+1
  1326 00:A741: 48           	pha
  1327 00:A742: A5 B8        	lda	TXTPTR
  1328 00:A744: 48           	pha
  1329 00:A745: A5 76        	lda	CURLIN+1
  1330 00:A747: 48           	pha
  1331 00:A748: A5 75        	lda	CURLIN
  1332 00:A74A: 48           	pha
  1333 00:A74B: A9 92        	lda	#TOKEN_GOSUB
  1334 00:A74D: 48           	pha
  1335                        GO_TO_LINE:
  1336 00:A74E: 20 B7 00     	jsr	CHRGOT
  1337 00:A751: 20 57 A7     	jsr	GOTO
  1338 00:A754: 4C 62 A6     	jmp	NEWSTT
  1339                        
  1340                        
  1341                        ; ----------------------------------------------------------------------------
  1342                        ; "GOTO" STATEMENT
  1343                        ; ALSO USED BY "RUN" AND "GOSUB"
  1344                        ; ----------------------------------------------------------------------------
  1345 00:A757: 20 25 A8     GOTO:	jsr	LINGET		; GET GOTO LINE
  1346 00:A75A: 20 BF A7     	jsr	REMN		; POINT Y TO EOL
  1347 00:A75D: A5 76        	lda	CURLIN+1	; IS CURRENT PAGE < GOTO PAGE?
  1348 00:A75F: C5 51        	cmp	LINNUM+1
  1349 00:A761: B0 0B        	bcs	GOTO1		; SEARCH FROM PROG START IF NOT
  1350 00:A763: 98           	tya			; OTHERWISE SEARCH FROM NEXT LINE
  1351 00:A764: 38           	sec
  1352 00:A765: 65 B8        	adc	TXTPTR
  1353 00:A767: A6 B9        	ldx	TXTPTR+1
  1354 00:A769: 90 07        	bcc	GOTO2
  1355 00:A76B: E8           	inx
  1356 00:A76C: B0 04        	bcs	GOTO2
  1357 00:A76E: A5 67        GOTO1:	lda	TXTTAB		; GET PROGRAM BEGINNING
  1358 00:A770: A6 68        	ldx	TXTTAB+1
  1359 00:A772: 20 BF A4     GOTO2:	jsr	FL1		; SEARCH FOR GOTO LINE
  1360 00:A775: 90 1E        	bcc	UNDERR		; ERROR IF NOT THERE
  1361 00:A777: A5 9B        	lda	LOWTR		; TXTPTR = START OF THE DESTINATION LINE
  1362 00:A779: E9 01        	sbc	#1
  1363 00:A77B: 85 B8        	sta	TXTPTR
  1364 00:A77D: A5 9C        	lda	LOWTR+1
  1365 00:A77F: E9 00        	sbc	#0
  1366 00:A781: 85 B9        	sta	TXTPTR+1
  1367 00:A783: 60           RTS5:	rts			; RETURN TO NEWSTT OR GOSUB
  1368                        
  1369                        
  1370                        ; ----------------------------------------------------------------------------
  1371                        ; "POP" AND "RETURN" STATEMENTS
  1372                        ; ----------------------------------------------------------------------------
  1373 00:A784: D0 FD        POP:	bne	RTS5
  1374 00:A786: A9 FF        	lda	#$FF
  1375 00:A788: 85 85        	sta	FORPNT		; <<< BUG: SHOULD BE FORPNT+1  SEE "ALL ABOUT APPLESOFT", PAGES 100,101>>>
  1376 00:A78A: 20 2D A2     	jsr	GTFORPNT	; TO CANCEL FOR/NEXT IN SUB
  1377 00:A78D: 9A           	txs
  1378 00:A78E: C9 92        	cmp	#TOKEN_GOSUB	; LAST GOSUB FOUND?
  1379 00:A790: F0 0B        	beq	RETURN
  1380 00:A792: A2 0C        	ldx	#ERR_NOGOSUB
  1381 00:A794: 2C           	db	$2C		; FAKE
  1382 00:A795: A2 3A        UNDERR:	ldx	#ERR_UNDEFSTAT
  1383 00:A797: 4C DA A2     	jmp	ERROR
  1384                        ; ----------------------------------------------------------------------------
  1385                        SYNERR2:
  1386 00:A79A: 4C 8F AC     	jmp	SYNERR
  1387                        ; ----------------------------------------------------------------------------
  1388 00:A79D: 68           RETURN:	pla			; DISCARD GOSUB TOKEN
  1389 00:A79E: 68           	pla
  1390 00:A79F: C0 10        	cpy	#<(TOKEN_POP*2)	; BRANCH IF A POP
  1391 00:A7A1: F0 3B        	beq	PULL3		; PULL LINE #
  1392 00:A7A3: 85 75        	sta	CURLIN
  1393 00:A7A5: 68           	pla
  1394 00:A7A6: 85 76        	sta	CURLIN+1
  1395 00:A7A8: 68           	pla
  1396 00:A7A9: 85 B8        	sta	TXTPTR		; PULL TXTPTR
  1397 00:A7AB: 68           	pla
  1398 00:A7AC: 85 B9        	sta	TXTPTR+1
  1399                        
  1400                        
  1401                        ; ----------------------------------------------------------------------------
  1402                        ; "DATA" STATEMENT
  1403                        ; EXECUTED BY SKIPPING TO NEXT COLON OR EOL
  1404                        ; ----------------------------------------------------------------------------
  1405 00:A7AE: 20 BC A7     DATA:	jsr	DATAN		; MOVE TO NEXT STATEMENT
  1406                        
  1407                        
  1408                        ; ----------------------------------------------------------------------------
  1409                        ; ADD (Y) TO TXTPTR
  1410                        ; ----------------------------------------------------------------------------
  1411 00:A7B1: 98           ADDON:	tya
  1412 00:A7B2: 18           	clc
  1413 00:A7B3: 65 B8        	adc	TXTPTR
  1414 00:A7B5: 85 B8        	sta	TXTPTR
  1415 00:A7B7: 90 02        	bcc	ADDON1
  1416 00:A7B9: E6 B9        	inc	TXTPTR+1
  1417                        ADDON1:
  1418 00:A7BB: 60           RTS6:	rts
  1419                        
  1420                        
  1421                        ; ----------------------------------------------------------------------------
  1422                        ; SCAN AHEAD TO NEXT ":" OR EOL
  1423                        ; ----------------------------------------------------------------------------
  1424 00:A7BC: A2 3A        DATAN:	ldx	#':'		; GET OFFSET IN Y TO EOL OR ":"
  1425 00:A7BE: 2C           	db	$2C		; FAKE
  1426                        ; ----------------------------------------------------------------------------
  1427 00:A7BF: A2 00        REMN:	ldx	#0		; TO EOL ONLY
  1428 00:A7C1: 86 0D        	stx	CHARAC
  1429 00:A7C3: A0 00        	ldy	#0
  1430 00:A7C5: 84 0E        	sty	ENDCHR
  1431 00:A7C7: A5 0E        REMN1:	lda	ENDCHR		; TRICK TO COUNT QUOTE PARITY
  1432 00:A7C9: A6 0D        	ldx	CHARAC
  1433 00:A7CB: 85 0D        	sta	CHARAC
  1434 00:A7CD: 86 0E        	stx	ENDCHR
  1435 00:A7CF: B1 B8        REMN2:	lda	(TXTPTR),y
  1436 00:A7D1: F0 E8        	beq	RTS6		; END OF LINE
  1437 00:A7D3: C5 0E        	cmp 	ENDCHR
  1438 00:A7D5: F0 E4        	beq	RTS6		; COLON IF LOOKING FOR COLONS
  1439 00:A7D7: C8           	iny
  1440 00:A7D8: C9 22        	cmp	#'"'
  1441 00:A7DA: D0 F3        	bne	REMN2
  1442 00:A7DC: F0 E9        	beq	REMN1		; ...ALWAYS
  1443                        ; ----------------------------------------------------------------------------
  1444 00:A7DE: 68           PULL3:	pla
  1445 00:A7DF: 68           	pla
  1446 00:A7E0: 68           	pla
  1447 00:A7E1: 60           	rts
  1448                        
  1449                        
  1450                        ; ----------------------------------------------------------------------------
  1451                        ; "IF" STATEMENT
  1452                        ; ----------------------------------------------------------------------------
  1453 00:A7E2: 20 48 AB     IF:	jsr	FRMEVL
  1454 00:A7E5: 20 B7 00     	jsr	CHRGOT
  1455 00:A7E8: C9 8E        	cmp	#TOKEN_GOTO
  1456 00:A7EA: F0 05        	beq	IF_1
  1457 00:A7EC: A9 A4        	lda	#TOKEN_THEN
  1458 00:A7EE: 20 86 AC     	jsr	SYNCHR
  1459 00:A7F1: A5 9D        IF_1:	lda	FAC		; CONDITION TRUE OR FALSE?
  1460 00:A7F3: D0 05        	bne	IF_TRUE		; BRANCH IF TRUE
  1461                        
  1462                        
  1463                        ; ----------------------------------------------------------------------------
  1464                        ; "REM" STATEMENT, OR FALSE "IF" STATEMENT
  1465                        ; ----------------------------------------------------------------------------
  1466 00:A7F5: 20 BF A7     REM:	jsr	REMN		; SKIP REST OF LINE
  1467 00:A7F8: F0 B7        	beq	ADDON		; ...ALWAYS
  1468                        ; ----------------------------------------------------------------------------
  1469                        IF_TRUE:
  1470 00:A7FA: 20 B7 00     	jsr	CHRGOT		; COMMAND OR NUMBER?
  1471 00:A7FD: B0 03        	bcs	IF_T1		; COMMAND
  1472 00:A7FF: 4C 57 A7     	jmp	GOTO		; NUMBER
  1473 00:A802: 4C A0 A6     IF_T1:	jmp	EXECUTE_STATEMENT
  1474                        
  1475                        
  1476                        ; ----------------------------------------------------------------------------
  1477                        ; "ON" STATEMENT
  1478                        ;
  1479                        ; ON <EXP> GOTO <LIST>
  1480                        ; ON <EXP> GOSUB <LIST>
  1481                        ; ----------------------------------------------------------------------------
  1482 00:A805: 20 DB B3     ONGOTO:	jsr	GETBYT		; EVALUATE <EXP>, AS BYTE IN FAC+4
  1483 00:A808: 48           	pha			; SAVE NEXT CHAR ON STACK
  1484 00:A809: C9 92        	cmp	#TOKEN_GOSUB
  1485 00:A80B: F0 04        	beq	ON2
  1486 00:A80D: C9 8E        ON1:	cmp	#TOKEN_GOTO
  1487 00:A80F: D0 89        	bne	SYNERR2
  1488 00:A811: C6 A1        ON2:	dec	FAC+4		; COUNTED TO RIGHT ONE YET?
  1489 00:A813: D0 04        	bne	ONG3		; NO, KEEP LOOKING
  1490 00:A815: 68           	pla			; YES, RETRIEVE CMD
  1491 00:A816: 4C A2 A6     	jmp	EXECUTE_STATEMENT1	; AND GO.
  1492 00:A819: 20 B1 00     ONG3:	jsr	CHRGET		; PRIME CONVERT SUBROUTINE
  1493 00:A81C: 20 25 A8     	jsr	LINGET		; CONVERT LINE #
  1494 00:A81F: C9 2C        	cmp	#','		; TERMINATE WITH COMMA?
  1495 00:A821: F0 EE        	beq	ON2		; YES
  1496 00:A823: 68           	pla			; NO, END OF LIST, SO IGNORE
  1497 00:A824: 60           RTS7:	rts
  1498                        
  1499                        
  1500                        ; ----------------------------------------------------------------------------
  1501                        ; CONVERT LINE NUMBER
  1502                        ; ----------------------------------------------------------------------------
  1503 00:A825: A2 00        LINGET:	ldx	#0		; ASC # TO HEX ADDRESS
  1504 00:A827: 86 50        	stx	LINNUM		; IN LINNUM.
  1505 00:A829: 86 51        	stx	LINNUM+1
  1506 00:A82B: B0 F7        LING1:	bcs	RTS7		; NOT A DIGIT
  1507 00:A82D: E9 2F        	sbc	#'0'-1		; CONVERT DIGIT TO BINARY
  1508 00:A82F: 85 0D        	sta	CHARAC		; SAVE THE DIGIT
  1509 00:A831: A5 51        	lda	LINNUM+1	; CHECK RANGE
  1510 00:A833: 85 5E        	sta	INDEX
  1511 00:A835: C9 19        	cmp	#>6400		; LINE # TOO LARGE?
  1512 00:A837: B0 D4        	bcs	ON1		; YES, > 63999, GO INDIRECTLY TO "SYNTAX ERROR".
  1513 00:A839: A5 50        	lda	LINNUM		; MULTIPLY BY TEN
  1514 00:A83B: 0A           	asl	a
  1515 00:A83C: 26 5E        	rol	INDEX
  1516 00:A83E: 0A           	asl	a
  1517 00:A83F: 26 5E        	rol	INDEX
  1518 00:A841: 65 50        	adc	LINNUM
  1519 00:A843: 85 50        	sta	LINNUM
  1520 00:A845: A5 5E        	lda	INDEX
  1521 00:A847: 65 51        	adc	LINNUM+1
  1522 00:A849: 85 51        	sta	LINNUM+1
  1523 00:A84B: 06 50        	asl	LINNUM
  1524 00:A84D: 26 51        	rol	LINNUM+1
  1525 00:A84F: A5 50        	lda	LINNUM
  1526 00:A851: 65 0D        	adc	CHARAC		; ADD DIGIT
  1527 00:A853: 85 50        	sta	LINNUM
  1528 00:A855: 90 02        	bcc	LING2
  1529 00:A857: E6 51        	inc	LINNUM+1
  1530 00:A859: 20 B1 00     LING2:	jsr	CHRGET		; GET NEXT CHAR
  1531 00:A85C: 4C 2B A8     	jmp	LING1		; MORE CONVERTING
  1532                        
  1533                        
  1534                        ; ----------------------------------------------------------------------------
  1535                        ; "LET" STATEMENT
  1536                        ;
  1537                        ; LET <VAR> = <EXP>
  1538                        ; <VAR> = <EXP>
  1539                        ; ----------------------------------------------------------------------------
  1540 00:A85F: 20 89 AD     LET:	jsr	PTRGET		; GET <VAR>
  1541 00:A862: 85 85        	sta	FORPNT
  1542 00:A864: 84 86        	sty	FORPNT+1
  1543 00:A866: A9 AF        	lda	#TOKEN_EQUAL
  1544 00:A868: 20 86 AC     	jsr	SYNCHR
  1545 00:A86B: A5 12        	lda	VALTYP+1	; SAVE VARIABLE TYPE
  1546 00:A86D: 48           	pha
  1547 00:A86E: A5 11        	lda	VALTYP
  1548 00:A870: 48           	pha
  1549 00:A871: 20 48 AB     	jsr	FRMEVL		; EVALUATE <EXP>
  1550 00:A874: 68           	pla
  1551 00:A875: 2A           	rol	a
  1552 00:A876: 20 3A AB     	jsr	CHKVAL
  1553 00:A879: D0 18        	bne	LETSTRING
  1554 00:A87B: 68           	pla
  1555                        ; ----------------------------------------------------------------------------
  1556 00:A87C: 10 12        LET2:	bpl	LET21		; REAL VARIABLE
  1557 00:A87E: 20 34 B8     	jsr	ROUND_FAC	; INTEGER VAR: ROUND TO 32 BITS
  1558 00:A881: 20 A8 AE     	jsr	AYINT		; TRUNCATE TO 16-BITS
  1559 00:A884: A0 00        	ldy	#0
  1560 00:A886: A5 A0        	lda	FAC+3
  1561 00:A888: 91 85        	sta	(FORPNT),y
  1562 00:A88A: C8           	iny
  1563 00:A88B: A5 A1        	lda	FAC+4
  1564 00:A88D: 91 85        	sta	(FORPNT),y
  1565 00:A88F: 60           	rts
  1566                        
  1567                        
  1568                        ; ----------------------------------------------------------------------------
  1569                        ; REAL VARIABLE = EXPRESSION
  1570                        ; ----------------------------------------------------------------------------
  1571 00:A890: 4C E9 B7     LET21:	jmp	SETFOR
  1572                        ; ----------------------------------------------------------------------------
  1573                        LETSTRING:
  1574 00:A893: 68           	pla
  1575                        
  1576                        
  1577                        ; ----------------------------------------------------------------------------
  1578                        ; INSTALL STRING, DESCRIPTOR ADDRESS IS AT FAC+3,4
  1579                        ; ----------------------------------------------------------------------------
  1580 00:A894: A0 02        PUTSTR:	ldy	#2		; STRING DATA ALREADY IN STRING AREA?
  1581 00:A896: B1 A0        	lda	(FAC+3),y	; (STRING AREA IS BTWN FRETOP
  1582 00:A898: C5 70        	cmp	FRETOP+1	; 	HIMEM)
  1583 00:A89A: 90 17        	bcc	PUTST2		; YES, DATA ALREADY UP THERE
  1584 00:A89C: D0 07        	bne	PUTST1		; NO
  1585 00:A89E: 88           	dey			; MAYBE, TEST LOW BYTE OF POINTER
  1586 00:A89F: B1 A0        	lda	(FAC+3),y
  1587 00:A8A1: C5 6F        	cmp	FRETOP
  1588 00:A8A3: 90 0E        	bcc	PUTST2		; YES, ALREADY THERE
  1589 00:A8A5: A4 A1        PUTST1:	ldy	FAC+4		; NO. DESCRIPTOR ALREADY AMONG VARIABLES?
  1590 00:A8A7: C4 6A        	cpy	VARTAB+1
  1591 00:A8A9: 90 08        	bcc	PUTST2		; NO
  1592 00:A8AB: D0 0D        	bne	PUTST3		; YES
  1593 00:A8AD: A5 A0        	lda	FAC+3		; MAYBE, COMPARE LO-BYTE
  1594 00:A8AF: C5 69        	cmp	VARTAB
  1595 00:A8B1: B0 07        	bcs	PUTST3		; YES, DESCRIPTOR IS AMONG VARIABLES
  1596 00:A8B3: A5 A0        PUTST2:	lda	FAC+3		; EITHER STRING ALREADY ON TOP, OR
  1597 00:A8B5: A4 A1        	ldy	FAC+4		; DESCRIPTOR IS NOT A VARIABLE
  1598 00:A8B7: 4C D0 A8     	jmp	PUTST4		; SO JUST STORE THE DESCRIPTOR
  1599                        ; ----------------------------------------------------------------------------
  1600                        ; STRING NOT YET IN STRING AREA,
  1601                        ; AND DESCRIPTOR IS A VARIABLE
  1602                        ; ----------------------------------------------------------------------------
  1603 00:A8BA: A0 00        PUTST3:	ldy	#0		; POINT AT LENGTH IN DESCRIPTOR
  1604 00:A8BC: B1 A0        	lda	(FAC+3),y	; GET LENGTH
  1605 00:A8BE: 20 B8 B0     	jsr	STRINI		; MAKE A STRING THAT LONG UP ABOVE
  1606 00:A8C1: A5 8C        	lda	DSCPTR		; SET UP SOURCE PNTR FOR MONINS
  1607 00:A8C3: A4 8D        	ldy	DSCPTR+1
  1608 00:A8C5: 85 AB        	sta	STRNG1
  1609 00:A8C7: 84 AC        	sty	STRNG1+1
  1610 00:A8C9: 20 B7 B2     	jsr	MOVINS		; MOVE STRING DATA TO NEW AREA
  1611 00:A8CC: A9 9D        	lda	#<FAC		; ADDRESS OF DESCRIPTOR IS IN FAC
  1612 00:A8CE: A0 00        	ldy	#>FAC
  1613 00:A8D0: 85 8C        PUTST4:	sta	DSCPTR
  1614 00:A8D2: 84 8D        	sty	DSCPTR+1
  1615 00:A8D4: 20 18 B3     	jsr	FRETMS		; DISCARD DESCRIPTOR IF 'TWAS TEMPORARY
  1616 00:A8D7: A0 00        	ldy	#0		; COPY STRING DESCRIPTOR
  1617 00:A8D9: B1 8C        	lda	(DSCPTR),y
  1618 00:A8DB: 91 85        	sta	(FORPNT),y
  1619 00:A8DD: C8           	iny
  1620 00:A8DE: B1 8C        	lda	(DSCPTR),y
  1621 00:A8E0: 91 85        	sta	(FORPNT),y
  1622 00:A8E2: C8           	iny
  1623 00:A8E3: B1 8C        	lda	(DSCPTR),y
  1624 00:A8E5: 91 85        	sta	(FORPNT),y
  1625 00:A8E7: 60           RTS8:	rts
  1626                        
  1627                        
  1628                        ; ----------------------------------------------------------------------------
  1629                        PRSTRING:
  1630 00:A8E8: 20 2E A9     	jsr	STRPRT
  1631 00:A8EB: 20 B7 00     	jsr	CHRGOT
  1632                        
  1633                        
  1634                        ; ----------------------------------------------------------------------------
  1635                        ; "PRINT" STATEMENT
  1636                        ; ----------------------------------------------------------------------------
  1637 00:A8EE: F0 1F        PRINT:	beq	GOCR		; NO MORE LIST, PRINT <RETURN>
  1638                        ; ----------------------------------------------------------------------------
  1639 00:A8F0: F0 F5        PRINT2: beq	RTS8		; NO MORE LIST, DON'T PRINT <RETURN>
  1640 00:A8F2: C9 A3        	cmp	#TOKEN_SPC
  1641 00:A8F4: 18           	clc
  1642 00:A8F5: F0 1B        	beq	PR_TAB_OR_SPC	; C=0 FOR SPC(
  1643 00:A8F7: C9 2C        	cmp	#','
  1644 00:A8F9: F0 25        	beq	PR_NEXT_CHAR
  1645 00:A8FB: C9 3B        	cmp	#';'
  1646 00:A8FD: F0 21        	beq	PR_NEXT_CHAR
  1647 00:A8FF: 20 48 AB     	jsr	FRMEVL		; EVALUATE EXPRESSION
  1648 00:A902: 24 11        	bit	VALTYP		; STRING OR FP VALUE?
  1649 00:A904: 30 E2        	bmi	PRSTRING	; STRING
  1650 00:A906: 20 F1 B9     	jsr	FOUT		; FP: CONVERT INTO BUFFER
  1651 00:A909: 20 CA B0     	jsr	STRLIT		; 	MAKE BUFFER INTO STRING
  1652 00:A90C: 4C E8 A8     	jmp	PRSTRING	; 	PRINT THE STRING
  1653                        ; ----------------------------------------------------------------------------
  1654 00:A90F: 4C 46 BE     GOCR:	jmp	CRDO
  1655                        
  1656                        ; ----------------------------------------------------------------------------
  1657                        PR_TAB_OR_SPC:
  1658 00:A912: 20 D8 B3     	jsr	GTBYTC		; GET VALUE
  1659 00:A915: C9 29        	cmp	#')'		; TRAILING PARENTHESIS
  1660 00:A917: F0 03        	beq	PR_TAB_2		; GOOD
  1661 00:A919: 4C 8F AC     	jmp	SYNERR		; NO, SYNTAX ERROR
  1662                        PR_TAB_2:
  1663 00:A91C: E8           	inx
  1664 00:A91D: CA           NXSPC:  dex
  1665 00:A91E: D0 06        	bne	DOSPC		; MORE SPACES TO PRINT
  1666                        ; ----------------------------------------------------------------------------
  1667                        PR_NEXT_CHAR:
  1668 00:A920: 20 B1 00     	jsr	CHRGET
  1669 00:A923: 4C F0 A8     	jmp	PRINT2		; CONTINUE PARSING PRINT LIST
  1670                        ; ----------------------------------------------------------------------------
  1671 00:A926: 20 3E BE     DOSPC:	jsr	OUTSP
  1672 00:A929: D0 F2        	bne	NXSPC		; ...ALWAYS
  1673                        
  1674                        
  1675                        ; ----------------------------------------------------------------------------
  1676                        ; PRINT STRING AT (Y,A)
  1677                        ; ----------------------------------------------------------------------------
  1678 00:A92B: 20 CA B0     STROUT:	jsr	STRLIT		; MAKE (Y,A) PRINTABLE
  1679                        
  1680                        
  1681                        ; ----------------------------------------------------------------------------
  1682                        ; PRINT STRING AT (FACMO,FACLO)
  1683                        ; ----------------------------------------------------------------------------
  1684 00:A92E: 20 E3 B2     STRPRT:	jsr	FREFAC		; GET ADDRESS INTO INDEX, (A)=LENGTH
  1685 00:A931: AA           	tax			; USE X-REG FOR COUNTER
  1686 00:A932: A0 00        	ldy	#0		; USE Y-REG FOR SCANNER
  1687 00:A934: E8           	inx
  1688 00:A935: CA           STRP1:	dex
  1689 00:A936: F0 AF        	beq	RTS8		; FINISHED
  1690 00:A938: B1 5E        	lda	(INDEX),y	; NEXT CHAR FROM STRING
  1691 00:A93A: 20 4D BE     	jsr	OUTDO		; PRINT THE CHAR
  1692 00:A93D: C8           	iny
  1693 00:A93E: 4C 35 A9     	jmp	STRP1
  1694                        
  1695                        
  1696                        ; ----------------------------------------------------------------------------
  1697                        ; INPUT CONVERSION ERROR:  ILLEGAL CHARACTER
  1698                        ; IN NUMERIC FIELD.  MUST DISTINGUISH
  1699                        ; BETWEEN INPUT, READ, AND GET
  1700                        ; ----------------------------------------------------------------------------
  1701                        INPUTERR:
  1702 00:A941: A5 15        	lda	INPUTFLG
  1703 00:A943: F0 12        	beq	RESPERR		; TAKEN IF INPUT
  1704 00:A945: 30 04        	bmi	READERR		; TAKEN IF READ
  1705 00:A947: A0 FF        	ldy	#$FF		; FROM A GET
  1706 00:A949: D0 04        	bne	ERLIN		;  ...ALWAYS
  1707                        ; ----------------------------------------------------------------------------
  1708                        READERR:
  1709 00:A94B: A5 7B        	lda	DATLIN		; TELL WHERE THE "DATA" IS, RATHER
  1710 00:A94D: A4 7C        	ldy	DATLIN+1	; THAN THE "READ"
  1711                        ; ----------------------------------------------------------------------------
  1712 00:A94F: 85 75        ERLIN:	sta	CURLIN
  1713 00:A951: 84 76        	sty	CURLIN+1
  1714 00:A953: 4C 8F AC     	jmp	SYNERR
  1715                        ; ----------------------------------------------------------------------------
  1716 00:A956: 68           INPERR:	pla
  1717                        ; ----------------------------------------------------------------------------
  1718                        RESPERR:
  1719 00:A957: 24 D8        	bit	ERRFLG		; "ON ERR" TURNED ON?
  1720 00:A959: 10 05        	bpl	RESPE1		; NO, GIVE REENTRY A TRY
  1721 00:A95B: A2 FE        	ldx	#254		; ERROR CODE = 254
  1722 00:A95D: 4C B6 BD     	jmp	HANDLERR
  1723 00:A960: A9 BC        RESPE1:	lda	#<ERRREENTRY	; "?REENTER"
  1724 00:A962: A0 AA        	ldy	#>ERRREENTRY
  1725 00:A964: 20 2B A9     	jsr	STROUT
  1726 00:A967: A5 79        	lda	OLDTEXT		; RE-EXECUTE THE WHOLE INPUT STATEMENT
  1727 00:A969: A4 7A        	ldy	OLDTEXT+1
  1728 00:A96B: 85 B8        	sta	TXTPTR
  1729 00:A96D: 84 B9        	sty	TXTPTR+1
  1730 00:A96F: 60           	rts
  1731                        
  1732                        
  1733                        ; ----------------------------------------------------------------------------
  1734                        ; "GET" STATEMENT
  1735                        ; ----------------------------------------------------------------------------
  1736 00:A970: 20 9E B0     GET:	jsr	ERRDIR		; ILLEGAL IF IN DIRECT MODE
  1737 00:A973: A2 01        	ldx	#<(INPUTBUFFER+1)	; SIMULATE INPUT
  1738 00:A975: A0 02        	ldy	#>(INPUTBUFFER+1)
  1739 00:A977: A9 00        	lda	#0
  1740 00:A979: 8D 01 02     	sta	INPUTBUFFER+1
  1741 00:A97C: A9 40        	lda	#$40		; SET UP INPUTFLG
  1742 00:A97E: 4C BA A9     	jmp	PROCESS_INPUT_LIST
  1743                        
  1744                        
  1745                        ; ----------------------------------------------------------------------------
  1746                        ; "INPUT" STATEMENT
  1747                        ; ----------------------------------------------------------------------------
  1748 00:A981: C9 22        INPUT:	cmp	#'"'		; CHECK FOR OPTIONAL PROMPT STRING
  1749 00:A983: D0 0E        	bne	INPU_1		; NO, PRINT "?" PROMPT
  1750 00:A985: 20 4E AC     	jsr	STRTXT		; MAKE A PRINTABLE STRING OUT OF IT
  1751 00:A988: A9 3B        	lda	#';'		; MUST HAVE ; NOW
  1752 00:A98A: 20 86 AC     	jsr	SYNCHR
  1753 00:A98D: 20 2E A9     	jsr	STRPRT		; PRINT THE STRING
  1754 00:A990: 4C 96 A9     	jmp	INPU_2
  1755 00:A993: 20 42 BE     INPU_1:	jsr	OUTQUES		; NO STRING, PRINT "?"
  1756 00:A996: 20 9E B0     INPU_2:	jsr	ERRDIR		; ILLEGAL IF IN DIRECT MODE
  1757 00:A999: A9 2C        	lda	#','		; PRIME THE BUFFER
  1758 00:A99B: 8D FF 01     	sta	INPUTBUFFER-1
  1759 00:A99E: 20 F4 A3     	jsr	INLIN
  1760 00:A9A1: AD 00 02     	lda	INPUTBUFFER
  1761 00:A9A4: C9 03        	cmp	#$03		; CONTROL C?
  1762 00:A9A6: D0 10        	bne	INPUTFLAGZERO	; NO
  1763 00:A9A8: 4C DE A6     	jmp	CONTROL_C_TYPED
  1764                        ; ----------------------------------------------------------------------------
  1765 00:A9AB: 20 42 BE     NXIN:	jsr	OUTQUES		; PRINT "?"
  1766 00:A9AE: 4C F4 A3     	jmp	INLIN
  1767                        
  1768                        
  1769                        ; ----------------------------------------------------------------------------
  1770                        ; "READ" STATEMENT
  1771                        ; ----------------------------------------------------------------------------
  1772 00:A9B1: A6 7D        READ:	ldx	DATPTR		; Y,X POINTS AT NEXT DATA STATEMENT
  1773 00:A9B3: A4 7E        	ldy	DATPTR+1
  1774 00:A9B5: A9 98        	lda	#$98		; SET INPUTFLG = $98
  1775 00:A9B7: 2C           	db	$2C		; TRICK TO PROCESS_INPUT_LIST
  1776                        ; ----------------------------------------------------------------------------
  1777                        INPUTFLAGZERO:
  1778 00:A9B8: A9 00        	lda	#0		; SET INPUTFLG = $00
  1779                        
  1780                        
  1781                        ; ----------------------------------------------------------------------------
  1782                        ; PROCESS INPUT LIST
  1783                        ;
  1784                        ; (Y,X) IS ADDRESS OF INPUT DATA STRING
  1785                        ; (A) = VALUE FOR INPUTFLG:  $00 FOR INPUT
  1786                        ; 				$40 FOR GET
  1787                        ;				$98 FOR READ
  1788                        ; ----------------------------------------------------------------------------
  1789                        PROCESS_INPUT_LIST:
  1790 00:A9BA: 85 15        	sta	INPUTFLG
  1791 00:A9BC: 86 7F        	stx	INPTR		; ADDRESS OF INPUT STRING
  1792 00:A9BE: 84 80        	sty	INPTR+1
  1793                        
  1794                        ; ----------------------------------------------------------------------------
  1795                        PROCESS_INPUT_ITEM:
  1796 00:A9C0: 20 89 AD     	jsr	PTRGET		; GET ADDRESS OF VARIABLE
  1797 00:A9C3: 85 85        	sta	FORPNT
  1798 00:A9C5: 84 86        	sty	FORPNT+1
  1799 00:A9C7: A5 B8        	lda	TXTPTR		; SAVE CURRENT TXTPTR,
  1800 00:A9C9: A4 B9        	ldy	TXTPTR+1	; WHICH POINTS INTO PROGRAM
  1801 00:A9CB: 85 87        	sta	TXPSV
  1802 00:A9CD: 84 88        	sty	TXPSV+1
  1803 00:A9CF: A6 7F        	ldx	INPTR		; SET TXTPTR TO POINT AT INPUT BUFFER
  1804 00:A9D1: A4 80        	ldy	INPTR+1		; OR "DATA" LINE
  1805 00:A9D3: 86 B8        	stx	TXTPTR
  1806 00:A9D5: 84 B9        	sty	TXTPTR+1
  1807 00:A9D7: 20 B7 00     	jsr	CHRGOT		; GET CHAR AT PNTR
  1808 00:A9DA: D0 1C        	bne	INSTART		; NOT END OF LINE OR COLON
  1809 00:A9DC: 24 15        	bit	INPUTFLG	; DOING A "GET"?
  1810 00:A9DE: 50 0C        	bvc	PROCE1		; NO
  1811 00:A9E0: 20 FB BD     	jsr	RDKEY		; YES, GET CHAR
  1812 00:A9E3: 8D 00 02     	sta	INPUTBUFFER
  1813 00:A9E6: A2 FF        	ldx	#<(INPUTBUFFER-1)
  1814 00:A9E8: A0 01        	ldy	#>(INPUTBUFFER-1)
  1815 00:A9EA: D0 08        	bne	PROCE2		; ...ALWAYS
  1816                        ; ----------------------------------------------------------------------------
  1817 00:A9EC: 30 7F        PROCE1:	bmi	FINDATA		; DOING A "READ"
  1818 00:A9EE: 20 42 BE     	jsr	OUTQUES		; DOING AN "INPUT", PRINT "?"
  1819 00:A9F1: 20 AB A9     	jsr	NXIN		; PRINT ANOTHER "?", AND INPUT A LINE
  1820 00:A9F4: 86 B8        PROCE2:	stx	TXTPTR
  1821 00:A9F6: 84 B9        	sty	TXTPTR+1
  1822                        
  1823                        ; ----------------------------------------------------------------------------
  1824                        INSTART:
  1825 00:A9F8: 20 B1 00     	jsr	CHRGET		; GET NEXT INPUT CHAR
  1826 00:A9FB: 24 11        	bit	VALTYP		; STRING OR NUMERIC?
  1827 00:A9FD: 10 31        	bpl	INSTA5		; NUMERIC
  1828 00:A9FF: 24 15        	bit	INPUTFLG	; STRING -- NOW WHAT INPUT TYPE?
  1829 00:AA01: 50 09        	bvc	INSTA1		; NOT A "GET"
  1830 00:AA03: E8           	inx			; "GET"
  1831 00:AA04: 86 B8        	stx	TXTPTR
  1832 00:AA06: A9 00        	lda	#0
  1833 00:AA08: 85 0D        	sta	CHARAC		; NO OTHER TERMINATORS THAN $00
  1834 00:AA0A: F0 0C        	beq	INSTA2		; ...ALWAYS
  1835                        ; ----------------------------------------------------------------------------
  1836 00:AA0C: 85 0D        INSTA1:	sta	CHARAC
  1837 00:AA0E: C9 22        	cmp	#'"'		; TERMINATE ON $00 OR QUOTE
  1838 00:AA10: F0 07        	beq	INSTA3
  1839 00:AA12: A9 3A        	lda	#':'		; TERMINATE ON $00, COLON, OR COMMA
  1840 00:AA14: 85 0D        	sta	CHARAC
  1841 00:AA16: A9 2C        	lda	#','
  1842 00:AA18: 18           INSTA2:	clc
  1843 00:AA19: 85 0E        INSTA3:	sta	ENDCHR
  1844 00:AA1B: A5 B8        	lda	TXTPTR
  1845 00:AA1D: A4 B9        	ldy	TXTPTR+1
  1846 00:AA1F: 69 00        	adc	#0		; SKIP OVER QUOTATION MARK, IF
  1847 00:AA21: 90 01        	bcc	INSTA4		;    THERE WAS ONE
  1848 00:AA23: C8           	iny
  1849 00:AA24: 20 D0 B0     INSTA4:	jsr	STRLT2		; BUILD STRING STARTING AT (Y,A) TERMINATED BY $00, (CHARAC), OR (EN
                    DCHR)
  1850 00:AA27: 20 20 B4     	jsr	POINT		; SET TXTPTR TO POINT AT STRING
  1851 00:AA2A: 20 94 A8     	jsr	PUTSTR		; STORE STRING IN VARIABLE
  1852 00:AA2D: 4C 3F AA     	jmp	INPUT_MORE
  1853                        ; ----------------------------------------------------------------------------
  1854 00:AA30: 48           INSTA5:	pha
  1855 00:AA31: AD 00 02     	lda	INPUTBUFFER	; ANYTHING IN BUFFER?
  1856 00:AA34: F0 30        	beq	INPFIN		; NO, SEE IF READ OR INPUT
  1857                        
  1858                        ; ----------------------------------------------------------------------------
  1859                        INPUT_DATA:
  1860 00:AA36: 68           	pla			; "READ"
  1861 00:AA37: 20 09 B9     	jsr	FIN		; GET FP NUMBER AT TXTPTR
  1862 00:AA3A: A5 12        	lda	VALTYP+1
  1863 00:AA3C: 20 7C A8     	jsr	LET2		; STORE RESULT IN VARIABLE
  1864                        
  1865                        ; ----------------------------------------------------------------------------
  1866                        INPUT_MORE:
  1867 00:AA3F: 20 B7 00     	jsr	CHRGOT
  1868 00:AA42: F0 07        	beq	INPUT_M1		; END OF LINE OR COLON
  1869 00:AA44: C9 2C        	cmp	#','		; COMMA IN INPUT?
  1870 00:AA46: F0 03        	beq	INPUT_M1		; YES
  1871 00:AA48: 4C 41 A9     	jmp	INPUTERR	; NOTHING ELSE WILL DO
  1872                        INPUT_M1:
  1873 00:AA4B: A5 B8        	lda	TXTPTR		; SAVE POSITION IN INPUT BUFFER
  1874 00:AA4D: A4 B9        	ldy	TXTPTR+1
  1875 00:AA4F: 85 7F        	sta	INPTR
  1876 00:AA51: 84 80        	sty	INPTR+1
  1877 00:AA53: A5 87        	lda	TXPSV		; RESTORE PROGRAM POINTER
  1878 00:AA55: A4 88        	ldy	TXPSV+1
  1879 00:AA57: 85 B8        	sta	TXTPTR
  1880 00:AA59: 84 B9        	sty	TXTPTR+1
  1881 00:AA5B: 20 B7 00     	jsr	CHRGOT		; NEXT CHAR FROM PROGRAM
  1882 00:AA5E: F0 33        	beq	INPDONE		; END OF STATEMENT
  1883 00:AA60: 20 84 AC     	jsr	CHKCOM		; BETTER BE A COMMA THEN
  1884 00:AA63: 4C C0 A9     	jmp	PROCESS_INPUT_ITEM
  1885                        
  1886                        ; ----------------------------------------------------------------------------
  1887 00:AA66: A5 15        INPFIN:	lda	INPUTFLG	; "INPUT" OR "READ"
  1888 00:AA68: D0 CC        	bne	INPUT_DATA	; "READ"
  1889 00:AA6A: 4C 56 A9     	jmp	INPERR
  1890                        
  1891                        ; ----------------------------------------------------------------------------
  1892                        FINDATA:
  1893 00:AA6D: 20 BC A7     	jsr	DATAN		; GET OFFSET TO NEXT COLON OR EOL
  1894 00:AA70: C8           	iny			; TO FIRST CHAR OF NEXT LINE
  1895 00:AA71: AA           	tax			; WHICH:  EOL OR COLON?
  1896 00:AA72: D0 12        	bne	FINDA1		; COLON
  1897 00:AA74: A2 14        	ldx	#ERR_NODATA	; EOL: MIGHT BE OUT OF DATA
  1898 00:AA76: C8           	iny			; CHECK HI-BYTE OF FORWARD PNTR
  1899 00:AA77: B1 B8        	lda	(TXTPTR),y	; END OF PROGRAM?
  1900 00:AA79: F0 5F        	beq	GERR		; YES, WE ARE OUT OF DATA
  1901 00:AA7B: C8           	iny			; PICK UP THE LINE #
  1902 00:AA7C: B1 B8        	lda	(TXTPTR),y
  1903 00:AA7E: 85 7B        	sta	DATLIN
  1904 00:AA80: C8           	iny
  1905 00:AA81: B1 B8        	lda	(TXTPTR),y
  1906 00:AA83: C8           	iny			; POINT AT FIRST TEXT CHAR IN LINE
  1907 00:AA84: 85 7C        	sta	DATLIN+1
  1908 00:AA86: B1 B8        FINDA1:	lda	(TXTPTR),y	; GET 1ST TOKEN OF STATEMENT
  1909 00:AA88: AA           	tax			; SAVE TOKEN IN X-REG
  1910 00:AA89: 20 B1 A7     	jsr	ADDON		; ADD (Y) TO TXTPTR
  1911 00:AA8C: E0 83        	cpx	#TOKEN_DATA	; DID WE FIND A "DATA" STATEMENT?
  1912 00:AA8E: D0 DD        	bne	FINDATA		; NOT YET
  1913 00:AA90: 4C F8 A9     	jmp	INSTART		; YES, READ IT
  1914                        ; ---NO MORE INPUT REQUESTED------
  1915                        INPDONE:
  1916 00:AA93: A5 7F        	lda	INPTR		; GET POINTER IN CASE IT WAS "READ"
  1917 00:AA95: A4 80        	ldy	INPTR+1
  1918 00:AA97: A6 15        	ldx	INPUTFLG	; "READ" OR "INPUT"?
  1919 00:AA99: 10 03        	bpl	INPD1		; "INPUT"
  1920 00:AA9B: 4C CB A6     	jmp	SETDA		; "DATA", SO STORE (Y,X) AT DATPTR
  1921 00:AA9E: A0 00        INPD1:	ldy	#0		; "INPUT":  ANY MORE CHARS ON LINE?
  1922 00:AAA0: B1 7F        	lda	(INPTR),y
  1923 00:AAA2: F0 07        	beq	INPD2		; NO, ALL IS WELL
  1924 00:AAA4: A9 AC        	lda	#<ERREXTRA	; YES, ERROR
  1925 00:AAA6: A0 AA        	ldy	#>ERREXTRA	; "EXTRA IGNORED"
  1926 00:AAA8: 4C 2B A9     	jmp	STROUT
  1927 00:AAAB: 60           INPD2:	rts
  1928                        
  1929                        ; ----------------------------------------------------------------------------
  1930                        ERREXTRA:
  1931 00:AAAC: 3F 45 58 54  	db	"?EXTRA IGNORED",$0D,$00
       00:AAB0: 52 41 20 49 
       00:AAB4: 47 4E 4F 52 
       00:AAB8: 45 44 0D 00 
  1932                        ERRREENTRY:
  1933 00:AABC: 3F 52 45 45  	db	"?REENTER",$0D,$00
       00:AAC0: 4E 54 45 52 
       00:AAC4: 0D 00 
  1934                        
  1935                        
  1936                        ; ----------------------------------------------------------------------------
  1937                        ; "NEXT" STATEMENT
  1938                        ; ----------------------------------------------------------------------------
  1939 00:AAC6: D0 04        NEXT:	bne	NEXT1		; VARIABLE AFTER "NEXT"
  1940 00:AAC8: A0 00        	ldy	#0		; FLAG BY SETTING FORPNT+1 = 0
  1941 00:AACA: F0 03        	beq	NEXT2		; ...ALWAYS
  1942                        ; ----------------------------------------------------------------------------
  1943 00:AACC: 20 89 AD     NEXT1:	jsr	PTRGET		; GET PNTR TO VARIABLE IN (Y,A)
  1944 00:AACF: 85 85        NEXT2:	sta	FORPNT
  1945 00:AAD1: 84 86        	sty	FORPNT+1
  1946 00:AAD3: 20 2D A2     	jsr	GTFORPNT	; FIND FOR-FRAME FOR THIS VARIABLE
  1947 00:AAD6: F0 04        	beq	NEXT3		; FOUND IT
  1948 00:AAD8: A2 00        	ldx	#ERR_NOFOR	; NOT THERE, ABORT
  1949 00:AADA: F0 69        GERR:	beq	JERROR		; ...ALWAYS
  1950 00:AADC: 9A           NEXT3:	txs			; SET STACK PTR TO POINT TO THIS FRAME,
  1951 00:AADD: E8           	inx			;    WHICH TRIMS OFF ANY INNER LOOPS
  1952 00:AADE: E8           	inx
  1953 00:AADF: E8           	inx
  1954 00:AAE0: E8           	inx
  1955 00:AAE1: 8A           	txa			; LOW BYTE OF ADRS OF STEP VALUE
  1956 00:AAE2: E8           	inx
  1957 00:AAE3: E8           	inx
  1958 00:AAE4: E8           	inx
  1959 00:AAE5: E8           	inx
  1960 00:AAE6: E8           	inx
  1961 00:AAE7: E8           	inx
  1962 00:AAE8: 86 60        	stx	DEST		; LOW BYTE ADRS OF FOR VAR VALUE
  1963 00:AAEA: A0 01        	ldy	#>STACK		; (Y,A) IS ADDRESS OF STEP VALUE
  1964 00:AAEC: 20 BB B7     	jsr	LOAD_FAC_FROM_YA	; STEP TO FAC
  1965 00:AAEF: BA           	tsx
  1966 00:AAF0: BD 09 01     	lda	STACK+9,x
  1967 00:AAF3: 85 A2        	sta	FACSIGN
  1968 00:AAF5: A5 85        	lda	FORPNT
  1969 00:AAF7: A4 86        	ldy	FORPNT+1
  1970 00:AAF9: 20 85 B4     	jsr	FADD		; ADD TO FOR VALUE
  1971 00:AAFC: 20 E9 B7     	jsr	SETFOR		; PUT NEW VALUE BACK
  1972 00:AAFF: A0 01        	ldy	#>STACK		; (Y,A) IS ADDRESS OF END VALUE
  1973 00:AB01: 20 76 B8     	jsr	FCOMP2		; COMPARE TO END VALUE
  1974 00:AB04: BA           	tsx
  1975 00:AB05: 38           	sec
  1976 00:AB06: FD 09 01     	sbc	STACK+9,x	; SIGN OF STEP
  1977 00:AB09: F0 17        	beq	NEXT32		; BRANCH IF FOR COMPLETE
  1978 00:AB0B: BD 0F 01     	lda	STACK+15,x	; OTHERWISE SET UP
  1979 00:AB0E: 85 75        	sta	CURLIN		; FOR LINE #
  1980 00:AB10: BD 10 01     	lda	STACK+16,x
  1981 00:AB13: 85 76        	sta	CURLIN+1
  1982 00:AB15: BD 12 01     	lda	STACK+18,x	; AND SET TXTPTR TO JUST
  1983 00:AB18: 85 B8        	sta	TXTPTR		; AFTER FOR STATEMENT
  1984 00:AB1A: BD 11 01     	lda	STACK+17,x
  1985 00:AB1D: 85 B9        	sta	TXTPTR+1
  1986 00:AB1F: 4C 62 A6     NEXT31:	jmp	NEWSTT
  1987 00:AB22: 8A           NEXT32:	txa			; POP OFF FOR-FRAME, LOOP IS DONE
  1988 00:AB23: 69 11        	adc	#17		; CARRY IS SET, SO ADDS 18
  1989 00:AB25: AA           	tax
  1990 00:AB26: 9A           	txs
  1991 00:AB27: 20 B7 00     	jsr	CHRGOT		; CHAR AFTER VARIABLE
  1992 00:AB2A: C9 2C        	cmp	#','		; ANOTHER VARIABLE IN NEXT?
  1993 00:AB2C: D0 F1        	bne	NEXT31		; NO, GO TO NEXT STATEMENT
  1994 00:AB2E: 20 B1 00     	jsr	CHRGET		; YES, PRIME FOR NEXT VARIABLE
  1995 00:AB31: 20 CC AA     	jsr	NEXT1		; (DOES NOT RETURN)
  1996                        
  1997                        
  1998                        ; ----------------------------------------------------------------------------
  1999                        ; EVALUATE EXPRESSION, MAKE SURE IT IS NUMERIC
  2000                        ; ----------------------------------------------------------------------------
  2001 00:AB34: 20 48 AB     FRMNUM:	jsr	FRMEVL
  2002                        
  2003                        
  2004                        ; ----------------------------------------------------------------------------
  2005                        ; MAKE SURE (FAC) IS NUMERIC
  2006                        ; ----------------------------------------------------------------------------
  2007 00:AB37: 18           CHKNUM:	clc
  2008 00:AB38: 24           	db	$24		; DUMMY FOR SKIP
  2009                        
  2010                        
  2011                        ; ----------------------------------------------------------------------------
  2012                        ; MAKE SURE (FAC) IS STRING
  2013                        ; ----------------------------------------------------------------------------
  2014 00:AB39: 38           CHKSTR:	sec
  2015                        
  2016                        
  2017                        ; ----------------------------------------------------------------------------
  2018                        ; MAKE SURE (FAC) IS CORRECT TYPE
  2019                        ; IF C=0, TYPE MUST BE NUMERIC
  2020                        ; IF C=1, TYPE MUST BE STRING
  2021                        ; ----------------------------------------------------------------------------
  2022 00:AB3A: 24 11        CHKVAL:	bit     VALTYP		; $00 IF NUMERIC, $FF IF STRING
  2023 00:AB3C: 30 03        	bmi     CHKVAL2		; TYPE IS STRING
  2024 00:AB3E: B0 03        	bcs     CHKVAL3		; NOT STRING, BUT WE NEED STRING
  2025                        CHKVAL1:
  2026 00:AB40: 60           	rts			; TYPE IS CORRECT
  2027                        CHKVAL2:
  2028 00:AB41: B0 FD        	bcs     CHKVAL1		; IS STRING AND WE WANTED STRING
  2029                        CHKVAL3:
  2030 00:AB43: A2 65        	ldx     #ERR_BADTYPE	; TYPE MISMATCH
  2031 00:AB45: 4C DA A2     JERROR: jmp     ERROR
  2032                        
  2033                        
  2034                        ; ----------------------------------------------------------------------------
  2035                        ; EVALUATE THE EXPRESSION AT TXTPTR, LEAVING THE
  2036                        ; RESULT IN FAC.  WORKS FOR BOTH STRING AND NUMERIC
  2037                        ; EXPRESSIONS.
  2038                        ; ----------------------------------------------------------------------------
  2039 00:AB48: A6 B8        FRMEVL:	ldx	TXTPTR		; DECREMENT TXTPTR
  2040 00:AB4A: D0 02        	bne	FRMEVL11
  2041 00:AB4C: C6 B9        	dec	TXTPTR+1
  2042                        FRMEVL11:
  2043 00:AB4E: C6 B8        	dec	TXTPTR
  2044 00:AB50: A2 00        	ldx	#0		; START WITH PRECEDENCE = 0
  2045 00:AB52: 24           	db	$24		; TRICK TO SKIP FOLLOWING "PHA"
  2046                        ; ----------------------------------------------------------------------------
  2047                        FRMEVL1:
  2048 00:AB53: 48           	pha			; PUSH RELOPS FLAGS
  2049 00:AB54: 8A           	txa
  2050 00:AB55: 48           	pha			; SAVE LAST PRECEDENCE
  2051 00:AB56: A9 01        	lda	#1
  2052 00:AB58: 20 9E A2     	jsr	CHKMEM		; CHECK IF ENOUGH ROOM ON STACK
  2053 00:AB5B: 20 2D AC     	jsr	FRM_ELEMENT	; GET AN ELEMENT
  2054 00:AB5E: A9 00        	lda	#0
  2055 00:AB60: 85 89        	sta	CPRTYP		; CLEAR COMPARISON OPERATOR FLAGS
  2056                        ; ----------------------------------------------------------------------------
  2057                        FRMEVL2:
  2058 00:AB62: 20 B7 00     	jsr	CHRGOT		; CHECK FOR RELATIONAL OPERATORS
  2059                        FRMEVL21:
  2060 00:AB65: 38           	sec			; > IS $AE, = IS $AF, < IS $B0
  2061 00:AB66: E9 AE        	sbc	#TOKEN_GREATER	; > IS 0, = IS 1, < IS 2
  2062 00:AB68: 90 17        	bcc	FRMEVL22		; NOT RELATIONAL OPERATOR
  2063 00:AB6A: C9 03        	cmp	#3
  2064 00:AB6C: B0 13        	bcs	FRMEVL22		; NOT RELATIONAL OPERATOR
  2065 00:AB6E: C9 01        	cmp	#1		; SET CARRY IF "=" OR "<"
  2066 00:AB70: 2A           	rol	a		; NOW > IS 0, = IS 3, < IS 5
  2067 00:AB71: 49 01        	eor	#1		; NOW > IS 1, = IS 2, < IS 4
  2068 00:AB73: 45 89        	eor	CPRTYP		; SET BITS OF CPRTYP:  00000<=>
  2069 00:AB75: C5 89        	cmp	CPRTYP		; CHECK FOR ILLEGAL COMBINATIONS
  2070 00:AB77: 90 61        	bcc	SNTXERR		; IF LESS THAN, A RELOP WAS REPEATED
  2071 00:AB79: 85 89        	sta	CPRTYP
  2072 00:AB7B: 20 B1 00     	jsr	CHRGET		; ANOTHER OPERATOR?
  2073 00:AB7E: 4C 65 AB     	jmp	FRMEVL21		; CHECK FOR <,=,> AGAIN
  2074                        ; ----------------------------------------------------------------------------
  2075                        FRMEVL22:
  2076 00:AB81: A6 89        	ldx	CPRTYP		; DID WE FIND A RELATIONAL OPERATOR?
  2077 00:AB83: D0 2C        	bne	FRM_RELATIONAL	; YES
  2078 00:AB85: B0 7B        	bcs	NOTMATH		; NO, AND NEXT TOKEN IS > $D1
  2079 00:AB87: 69 07        	adc	#TOKEN_GREATER-TOKEN_PLUS	; NO, AND NEXT TOKEN < $CF
  2080 00:AB89: 90 77        	bcc	NOTMATH		; IF NEXT TOKEN < "+"
  2081 00:AB8B: 65 11        	adc	VALTYP		; + AND LAST RESULT A STRING?
  2082 00:AB8D: D0 03        	bne	FRMEVL23		; BRANCH IF NOT
  2083 00:AB8F: 4C 7A B2     	jmp	CAT		; CONCATENATE IF SO.
  2084                        ; ----------------------------------------------------------------------------
  2085                        FRMEVL23:
  2086 00:AB92: 69 FF        	adc	#$FF		; +-*/ IS 0123
  2087 00:AB94: 85 5E        	sta	INDEX
  2088 00:AB96: 0A           	asl	a		; MULTIPLY BY 3
  2089 00:AB97: 65 5E        	adc	INDEX		; +-*/ IS 0,3,6,9
  2090 00:AB99: A8           	tay
  2091                        
  2092                        ; ----------------------------------------------------------------------------
  2093                        FRM_PRECEDENCE_TEST:
  2094 00:AB9A: 68           	pla			; GET LAST PRECEDENCE
  2095 00:AB9B: D9 86 A0     	cmp	MATHTBL,y
  2096 00:AB9E: B0 67        	bcs	FRM_PERFORM1	; DO NOW IF HIGHER PRECEDENCE
  2097 00:ABA0: 20 37 AB     	jsr	CHKNUM		; WAS LAST RESULT A #?
  2098 00:ABA3: 48           NXOP:	pha			; YES, SAVE PRECEDENCE ON STACK
  2099 00:ABA4: 20 CA AB     SAVOP:	jsr	FRM_RECURSE	; SAVE REST, CALL FRMEVL RECURSIVELY
  2100 00:ABA7: 68           	pla
  2101 00:ABA8: A4 87        	ldy	LASTOP
  2102 00:ABAA: 10 17        	bpl	PREFNC
  2103 00:ABAC: AA           	tax
  2104 00:ABAD: F0 56        	beq	GOEX		; EXIT IF NO MATH IN EXPRESSION
  2105 00:ABAF: D0 5F        	bne	FRM_PERFORM2	; ...ALWAYS
  2106                        
  2107                        
  2108                        ; ----------------------------------------------------------------------------
  2109                        ; FOUND ONE OR MORE RELATIONAL OPERATORS <,=,>
  2110                        ; ----------------------------------------------------------------------------
  2111                        FRM_RELATIONAL:
  2112 00:ABB1: 46 11        	lsr	VALTYP		; (VALTYP) = 0 (NUMERIC), = $FF (STRING)
  2113 00:ABB3: 8A           	txa			; SET CPRTYP TO 0000<=>C
  2114 00:ABB4: 2A           	rol	a		; WHERE C=0 IF #, C=1 IF STRING
  2115 00:ABB5: A6 B8        	ldx	TXTPTR		; BACK UP TXTPTR
  2116 00:ABB7: D0 02        	bne	FRM_R1
  2117 00:ABB9: C6 B9        	dec	TXTPTR+1
  2118 00:ABBB: C6 B8        FRM_R1:	dec	TXTPTR
  2119 00:ABBD: A0 1B        	ldy	#M_REL-MATHTBL	; POINT AT RELOPS ENTRY
  2120 00:ABBF: 85 89        	sta	CPRTYP
  2121 00:ABC1: D0 D7        	bne	FRM_PRECEDENCE_TEST	; ...ALWAYS
  2122                        ; ----------------------------------------------------------------------------
  2123 00:ABC3: D9 86 A0     PREFNC:	cmp	MATHTBL,y
  2124 00:ABC6: B0 48        	bcs	FRM_PERFORM2	; DO NOW IF HIGHER PRECEDENCE
  2125 00:ABC8: 90 D9        	bcc	NXOP		; ...ALWAYS
  2126                        
  2127                        
  2128                        ; ----------------------------------------------------------------------------
  2129                        ; STACK THIS OPERATION AND CALL FRMEVL FOR
  2130                        ; ANOTHER ONE
  2131                        ; ----------------------------------------------------------------------------
  2132                        FRM_RECURSE:
  2133 00:ABCA: B9 88 A0     	lda	MATHTBL+2,y
  2134 00:ABCD: 48           	pha			; PUSH ADDRESS OF OPERATION PERFORMER
  2135 00:ABCE: B9 87 A0     	lda	MATHTBL+1,y
  2136 00:ABD1: 48           	pha
  2137 00:ABD2: 20 DD AB     	jsr	FRM_STACK1	; STACK FAC.SIGN AND FAC
  2138 00:ABD5: A5 89        	lda	CPRTYP		; A=RELOP FLAGS, X=PRECEDENCE BYTE
  2139 00:ABD7: 4C 53 AB     	jmp	FRMEVL1		; RECURSIVELY CALL FRMEVL
  2140                        ; ----------------------------------------------------------------------------
  2141                        SNTXERR:
  2142 00:ABDA: 4C 8F AC     	jmp	SYNERR
  2143                        
  2144                        
  2145                        ; ----------------------------------------------------------------------------
  2146                        ; STACK (FAC)
  2147                        ; THREE ENTRY POINTS:
  2148                        ; 	1, FROM FRMEVL
  2149                        ;	2, FROM "STEP"
  2150                        ;	3, FROM "FOR"
  2151                        ; ----------------------------------------------------------------------------
  2152                        FRM_STACK1:
  2153 00:ABDD: A5 A2        	lda	FACSIGN		; GET FAC.SIGN TO PUSH IT
  2154 00:ABDF: BE 86 A0     	ldx	MATHTBL,y	; PRECEDENCE BYTE FROM MATHTBL
  2155                        
  2156                        
  2157                        ; ----------------------------------------------------------------------------
  2158                        ; ENTER HERE FROM "STEP", TO PUSH STEP SIGN AND VALUE
  2159                        ; ----------------------------------------------------------------------------
  2160                        FRM_STACK2:
  2161 00:ABE2: A8           	tay			; FAC.SIGN OR SGN(STEP VALUE)
  2162 00:ABE3: 68           	pla			; PULL RETURN ADDRESS AND ADD 1
  2163 00:ABE4: 85 5E        	sta	INDEX		; <<< ASSUMES NOT ON PAGE BOUNDARY! >>>
  2164 00:ABE6: E6 5E        	inc	INDEX		; PLACE BUMPED RETURN ADDRESS IN
  2165 00:ABE8: 68           	pla			; 	INDEX,INDEX+1
  2166 00:ABE9: 85 5F        	sta	INDEX+1
  2167 00:ABEB: 98           	tya			; FAC.SIGN OR SGN(STEP VALUE)
  2168 00:ABEC: 48           	pha			; PUSH FAC.SIGN OR SGN(STEP VALUE)
  2169                        
  2170                        
  2171                        ; ----------------------------------------------------------------------------
  2172                        ; ENTER HERE FROM "FOR", WITH (INDEX) = STEP,
  2173                        ; TO PUSH INITIAL VALUE OF "FOR" VARIABLE
  2174                        ; ----------------------------------------------------------------------------
  2175             0000005E   IN_INDEX	equ	INDEX
  2176                        
  2177                        FRM_STACK3:
  2178 00:ABED: 20 34 B8     	jsr	ROUND_FAC	; ROUND TO 32 BITS
  2179 00:ABF0: A5 A1        	lda	FAC+4		; PUSH (FAC)
  2180 00:ABF2: 48           	pha
  2181 00:ABF3: A5 A0        	lda	FAC+3
  2182 00:ABF5: 48           	pha
  2183 00:ABF6: A5 9F        	lda	FAC+2
  2184 00:ABF8: 48           	pha
  2185 00:ABF9: A5 9E        	lda	FAC+1
  2186 00:ABFB: 48           	pha
  2187 00:ABFC: A5 9D        	lda	FAC
  2188 00:ABFE: 48           	pha
  2189 00:ABFF: 6C 5E 00     	jmp	(IN_INDEX)		; DO RTS FUNNY WAY
  2190                        
  2191                        
  2192                        ; ----------------------------------------------------------------------------
  2193                        NOTMATH:
  2194 00:AC02: A0 FF        	ldy	#$FF		; SET UP TO EXIT ROUTINE
  2195 00:AC04: 68           	pla
  2196 00:AC05: F0 23        GOEX:	beq	EXIT		; EXIT IF NO MATH TO DO
  2197                        
  2198                        
  2199                        ; ----------------------------------------------------------------------------
  2200                        ; PERFORM STACKED OPERATION
  2201                        ;
  2202                        ; (A) = PRECEDENCE BYTE
  2203                        ; STACK:  1 -- CPRMASK
  2204                        ;	5 -- (ARG)
  2205                        ;	2 -- ADDR OF PERFORMER
  2206                        ; ----------------------------------------------------------------------------
  2207                        FRM_PERFORM1:
  2208 00:AC07: C9 64        	cmp	#PREL		; WAS IT RELATIONAL OPERATOR?
  2209 00:AC09: F0 03        	beq	FRM_P1		; YES, ALLOW STRING COMPARE
  2210 00:AC0B: 20 37 AB     	jsr	CHKNUM		; MUST BE NUMERIC VALUE
  2211 00:AC0E: 84 87        FRM_P1:	sty	LASTOP
  2212                        FRM_PERFORM2:
  2213 00:AC10: 68           	pla			; GET 0000<=>C FROM STACK
  2214 00:AC11: 4A           	lsr	a		; SHIFT TO 00000<=> FORM
  2215 00:AC12: 85 16        	sta	CPRMASK		; 00000<=>
  2216 00:AC14: 68           	pla
  2217 00:AC15: 85 A5        	sta	ARG		; GET FLOATING POINT VALUE OFF STACK,
  2218 00:AC17: 68           	pla			; AND PUT IT IN ARG
  2219 00:AC18: 85 A6        	sta	ARG+1
  2220 00:AC1A: 68           	pla
  2221 00:AC1B: 85 A7        	sta	ARG+2
  2222 00:AC1D: 68           	pla
  2223 00:AC1E: 85 A8        	sta	ARG+3
  2224 00:AC20: 68           	pla
  2225 00:AC21: 85 A9        	sta	ARG+4
  2226 00:AC23: 68           	pla
  2227 00:AC24: 85 AA        	sta	ARG+5
  2228 00:AC26: 45 A2        	eor	FACSIGN		; SAVE EOR OF SIGNS OF THE OPERANDS,
  2229 00:AC28: 85 AB        	sta	SGNCPR		; IN CASE OF MULTIPLY OR DIVIDE
  2230 00:AC2A: A5 9D        EXIT:	lda	FAC		; FAC EXPONENT IN A-REG / STATUS .EQ. IF (FAC)=0
  2231 00:AC2C: 60           	rts			; RTS GOES TO PERFORM OPERATION
  2232                        
  2233                        
  2234                        ; ----------------------------------------------------------------------------
  2235                        ; GET ELEMENT IN EXPRESSION
  2236                        ;
  2237                        ; GET VALUE OF VARIABLE OR NUMBER AT TXTPNT, OR POINT
  2238                        ; TO STRING DESCRIPTOR IF A STRING, AND PUT IN FAC.
  2239                        ; ----------------------------------------------------------------------------
  2240                        FRM_ELEMENT:
  2241 00:AC2D: A9 00        	lda	#0		; ASSUME NUMERIC
  2242 00:AC2F: 85 11        	sta	VALTYP
  2243 00:AC31: 20 B1 00     FRM_E1:	jsr	CHRGET
  2244 00:AC34: B0 03        	bcs	FRM_E3		; NOT A DIGIT
  2245 00:AC36: 4C 09 B9     FRM_E2:	jmp	FIN		; NUMERIC CONSTANT
  2246 00:AC39: 20 19 AE     FRM_E3:	jsr	ISLETC		; VARIABLE NAME?
  2247 00:AC3C: B0 5D        	bcs	FRM_VARIABLE	; YES
  2248 00:AC3E: C9 2E        	cmp	#'.'		; DECIMAL POINT
  2249 00:AC40: F0 F4        	beq	FRM_E2		; YES, NUMERIC CONSTANT
  2250 00:AC42: C9 A8        	cmp	#TOKEN_MINUS	; UNARY MINUS?
  2251 00:AC44: F0 4E        	beq	MIN		; YES
  2252 00:AC46: C9 A7        	cmp	#TOKEN_PLUS	; UNARY PLUS
  2253 00:AC48: F0 E7        	beq	FRM_E1		; YES
  2254 00:AC4A: C9 22        	cmp	#'"'		; STRING CONSTANT?
  2255 00:AC4C: D0 0F        	bne	NOT_		; NO
  2256                        
  2257                        
  2258                        ; ----------------------------------------------------------------------------
  2259                        ; STRING CONSTANT ELEMENT
  2260                        ;
  2261                        ; SET Y,A = (TXTPTR)+CARRY
  2262                        ; ----------------------------------------------------------------------------
  2263 00:AC4E: A5 B8        STRTXT:	lda	TXTPTR		; ADD (CARRY) TO GET ADDRESS OF 1ST CHAR
  2264 00:AC50: A4 B9        	ldy	TXTPTR+1	;    OF STRING IN Y,A
  2265 00:AC52: 69 00        	adc	#0
  2266 00:AC54: 90 01        	bcc	STRTXT1
  2267 00:AC56: C8           	iny
  2268                        STRTXT1:
  2269 00:AC57: 20 CA B0     	jsr	STRLIT		; BUILD DESCRIPTOR TO STRING / GET ADDRESS OF DESCRIPTOR IN FAC
  2270 00:AC5A: 4C 20 B4     	jmp	POINT		; POINT TXTPTR AFTER TRAILING QUOTE
  2271                        
  2272                        
  2273                        ; ----------------------------------------------------------------------------
  2274                        ; "NOT" FUNCTION
  2275                        ; IF FAC=0, RETURN FAC=1
  2276                        ; IF FAC<>0, RETURN FAC=0
  2277                        ; ----------------------------------------------------------------------------
  2278 00:AC5D: C9 A5        NOT_:	cmp	#TOKEN_NOT
  2279 00:AC5F: D0 10        	bne	SGN_		; NOT "NOT", TRY "SGN"
  2280 00:AC61: A0 18        	ldy	#M_EQU-MATHTBL	; POINT AT = COMPARISON
  2281 00:AC63: D0 31        	bne	EQUL		; ...ALWAYS
  2282                        
  2283                        
  2284                        ; ----------------------------------------------------------------------------
  2285                        ; COMPARISON FOR EQUALITY (= OPERATOR)
  2286                        ; ALSO USED TO EVALUATE "NOT" FUNCTION
  2287                        ; ----------------------------------------------------------------------------
  2288 00:AC65: A5 9D        EQUOP:	lda	FAC		; SET "TRUE" IF (FAC) = ZERO
  2289 00:AC67: D0 03        	bne	EQUOP1		; FALSE
  2290 00:AC69: A0 01        	ldy	#1		; TRUE
  2291 00:AC6B: 2C           	db	$2C		; TRICK TO SKIP NEXT 2 BYTES
  2292 00:AC6C: A0 00        EQUOP1:	ldy	#0		; FALSE
  2293 00:AC6E: 4C 9A B0     	jmp	SNGFLT
  2294                        ; ----------------------------------------------------------------------------
  2295 00:AC71: C9 B1        SGN_:	cmp	#TOKEN_SGN
  2296 00:AC73: 90 03        	bcc	PARCHK
  2297 00:AC75: 4C BF AC     	jmp	UNARY
  2298                        
  2299                        
  2300                        ; ----------------------------------------------------------------------------
  2301                        ; EVALUATE "(EXPRESSION)"
  2302                        ; ----------------------------------------------------------------------------
  2303 00:AC78: 20 81 AC     PARCHK:	jsr	CHKOPN		; IS THERE A '(' AT TXTPTR?
  2304 00:AC7B: 20 48 AB     	jsr	FRMEVL		; YES, EVALUATE EXPRESSION
  2305                        ; ----------------------------------------------------------------------------
  2306 00:AC7E: A9 29        CHKCLS:	lda	#')'		; CHECK FOR ')'
  2307 00:AC80: 2C           	db	$2C		; TRICK
  2308                        ; ----------------------------------------------------------------------------
  2309 00:AC81: A9 28        CHKOPN:	lda	#'('
  2310 00:AC83: 2C           	db   $2C		; TRICK
  2311                        ; ----------------------------------------------------------------------------
  2312 00:AC84: A9 2C        CHKCOM:	lda	#','		; COMMA AT TXTPTR?
  2313                        
  2314                        
  2315                        ; ----------------------------------------------------------------------------
  2316                        ; UNLESS CHAR AT TXTPTR = (A), SYNTAX ERROR
  2317                        ; ----------------------------------------------------------------------------
  2318 00:AC86: A0 00        SYNCHR:	ldy	#0
  2319 00:AC88: D1 B8        	cmp	(TXTPTR),y
  2320 00:AC8A: D0 03        	bne	SYNERR
  2321 00:AC8C: 4C B1 00     	jmp	CHRGET		; MATCH, GET NEXT CHAR & RETURN
  2322                        ; ----------------------------------------------------------------------------
  2323 00:AC8F: A2 06        SYNERR:	ldx	#ERR_SYNTAX
  2324 00:AC91: 4C DA A2     	jmp	ERROR
  2325                        ; ----------------------------------------------------------------------------
  2326 00:AC94: A0 15        MIN:	ldy     #M_NEG-MATHTBL	; POINT AT UNARY MINUS
  2327 00:AC96: 68           EQUL:	pla
  2328 00:AC97: 68           	pla
  2329 00:AC98: 4C A4 AB     	jmp	SAVOP
  2330                        ; ----------------------------------------------------------------------------
  2331                        FRM_VARIABLE:
  2332 00:AC9B: 20 89 AD     	jsr	PTRGET
  2333                        
  2334             0000AC9D   FRM_VARIABLE_CALL	equ *-1	; SO PTRGET CAN TELL WE CALLED
  2335                        
  2336 00:AC9E: 85 A0        	sta	VPNT		; ADDRESS OF VARIABLE
  2337 00:ACA0: 84 A1        	sty	VPNT+1
  2338 00:ACA2: A6 11        	ldx	VALTYP		; NUMERIC OR STRING?
  2339 00:ACA4: F0 05        	beq	FRM_V1		; NUMERIC
  2340 00:ACA6: A2 00        	ldx	#0		; STRING
  2341 00:ACA8: 86 AC        	stx	STRNG1+1
  2342 00:ACAA: 60           	rts
  2343 00:ACAB: A6 12        FRM_V1:	ldx	VALTYP+1	; NUMERIC, WHICH TYPE?
  2344 00:ACAD: 10 0D        	bpl	FRM_V2		; FLOATING POINT
  2345 00:ACAF: A0 00        	ldy	#0		; INTEGER
  2346 00:ACB1: B1 A0        	lda	(VPNT),y
  2347 00:ACB3: AA           	tax			; GET VALUE IN A,Y
  2348 00:ACB4: C8           	iny
  2349 00:ACB5: B1 A0        	lda	(VPNT),y
  2350 00:ACB7: A8           	tay
  2351 00:ACB8: 8A           	txa
  2352 00:ACB9: 4C 8D B0     	jmp	GIVAYF		; CONVERT A,Y TO FLOATING POINT
  2353 00:ACBC: 4C BB B7     FRM_V2:	jmp	LOAD_FAC_FROM_YA
  2354                        
  2355                        
  2356                        ; ----------------------------------------------------------------------------
  2357 00:ACBF: 0A           UNARY:	asl	a		; DOUBLE TOKEN TO GET INDEX
  2358 00:ACC0: 48           	pha
  2359 00:ACC1: AA           	tax
  2360 00:ACC2: 20 B1 00     	jsr	CHRGET
  2361 00:ACC5: E0 7D        	cpx	#<(TOKEN_LEFTSTR*2-1)	; LEFT$, RIGHT$, AND MID$
  2362 00:ACC7: 90 20        	bcc	UNARY1		; NOT ONE OF THE STRING FUNCTIONS
  2363 00:ACC9: 20 81 AC     	jsr	CHKOPN		; STRING FUNCTION, NEED "("
  2364 00:ACCC: 20 48 AB     	jsr	FRMEVL		; EVALUATE EXPRESSION FOR STRING
  2365 00:ACCF: 20 84 AC     	jsr	CHKCOM		; REQUIRE A COMMA
  2366 00:ACD2: 20 39 AB     	jsr	CHKSTR		; MAKE SURE EXPRESSION IS A STRING
  2367 00:ACD5: 68           	pla
  2368 00:ACD6: AA           	tax			; RETRIEVE ROUTINE POINTER
  2369 00:ACD7: A5 A1        	lda	VPNT+1		; STACK ADDRESS OF STRING
  2370 00:ACD9: 48           	pha
  2371 00:ACDA: A5 A0        	lda	VPNT
  2372 00:ACDC: 48           	pha
  2373 00:ACDD: 8A           	txa
  2374 00:ACDE: 48           	pha			; STACK DOUBLED TOKEN
  2375 00:ACDF: 20 DB B3     	jsr	GETBYT		; CONVERT NEXT EXPRESSION TO BYTE IN X-REG
  2376 00:ACE2: 68           	pla			; GET DOUBLED TOKEN OFF STACK
  2377 00:ACE3: A8           	tay			; USE AS INDEX TO BRANCH
  2378 00:ACE4: 8A           	txa			; VALUE OF SECOND PARAMETER
  2379 00:ACE5: 48           	pha			; PUSH 2ND PARAM
  2380 00:ACE6: 4C EE AC     	jmp	UNARY2		; JOIN UNARY FUNCTIONS
  2381 00:ACE9: 20 78 AC     UNARY1:	jsr	PARCHK		; REQUIRE "(EXPRESSION)"
  2382 00:ACEC: 68           	pla
  2383 00:ACED: A8           	tay			; INDEX INTO FUNCTION ADDRESS TABLE
  2384 00:ACEE: B9 02 A0     UNARY2:	lda	UNFNC-TOKEN_SGN-TOKEN_SGN+$100,y
  2385 00:ACF1: 85 91        	sta	JMPADRS+1	; PREPARE TO JSR TO ADDRESS
  2386 00:ACF3: B9 03 A0     	lda	UNFNC-TOKEN_SGN-TOKEN_SGN+$101,y
  2387 00:ACF6: 85 92        	sta	JMPADRS+2
  2388 00:ACF8: 20 90 00     	jsr	JMPADRS		; DOES NOT RETURN FOR CHR$, LEFT$, RIGHT$, OR MID$
  2389 00:ACFB: 4C 37 AB     	jmp	CHKNUM		; REQUIRE NUMERIC RESULT
  2390                        ; ----------------------------------------------------------------------------
  2391 00:ACFE: A5 A5        OR:	lda	ARG		; "OR" OPERATOR
  2392 00:AD00: 05 9D        	ora	FAC		; IF RESULT NONZERO, IT IS TRUE
  2393 00:AD02: D0 0B        	bne	TRUE
  2394                        ; ----------------------------------------------------------------------------
  2395 00:AD04: A5 A5        TAND:	lda	ARG		; "AND" OPERATOR
  2396 00:AD06: F0 04        	beq	FALSE		; IF EITHER IS ZERO, RESULT IS FALSE
  2397 00:AD08: A5 9D        	lda	FAC
  2398 00:AD0A: D0 03        	bne	TRUE
  2399                        ; ----------------------------------------------------------------------------
  2400 00:AD0C: A0 00        FALSE:	ldy	#0		; RETURN FAC=0
  2401 00:AD0E: 2C           	db	$2C		; TRICK
  2402                        ; ----------------------------------------------------------------------------
  2403 00:AD0F: A0 01        TRUE:	ldy	#1		; RETURN FAC=1
  2404 00:AD11: 4C 9A B0     	jmp	SNGFLT
  2405                        
  2406                        
  2407                        ; ----------------------------------------------------------------------------
  2408                        ; PERFORM RELATIONAL OPERATIONS
  2409                        ; ----------------------------------------------------------------------------
  2410 00:AD14: 20 3A AB     RELOPS:	jsr	CHKVAL		; MAKE SURE FAC IS CORRECT TYPE
  2411 00:AD17: B0 13        	bcs	STRCMP		; TYPE MATCHES, BRANCH IF STRINGS
  2412 00:AD19: A5 AA        	lda	ARGSIGN		; NUMERIC COMPARISON
  2413 00:AD1B: 09 7F        	ora	#$7F		; RE-PACK VALUE IN ARG FOR FCOMP
  2414 00:AD1D: 25 A6        	and	ARG+1
  2415 00:AD1F: 85 A6        	sta	ARG+1
  2416 00:AD21: A9 A5        	lda	#<ARG
  2417 00:AD23: A0 00        	ldy	#>ARG
  2418 00:AD25: 20 74 B8     	jsr	FCOMP		; RETURN A-REG = -1,0,1
  2419 00:AD28: AA           	tax			; AS ARG <,=,> FAC
  2420 00:AD29: 4C 5F AD     	jmp	NUMCMP
  2421                        
  2422                        
  2423                        ; ----------------------------------------------------------------------------
  2424                        ; STRING COMPARISON
  2425                        ; ----------------------------------------------------------------------------
  2426 00:AD2C: A9 00        STRCMP:	lda	#0		; SET RESULT TYPE TO NUMERIC
  2427 00:AD2E: 85 11        	sta	VALTYP
  2428 00:AD30: C6 89        	dec	CPRTYP		; MAKE CPRTYP 0000<=>0
  2429 00:AD32: 20 E3 B2     	jsr	FREFAC
  2430 00:AD35: 85 9D        	sta	FAC		; STRING LENGTH
  2431 00:AD37: 86 9E        	stx	FAC+1
  2432 00:AD39: 84 9F        	sty	FAC+2
  2433 00:AD3B: A5 A8        	lda	ARG+3
  2434 00:AD3D: A4 A9        	ldy	ARG+4
  2435 00:AD3F: 20 E7 B2     	jsr	FRETMP
  2436 00:AD42: 86 A8        	stx	ARG+3
  2437 00:AD44: 84 A9        	sty	ARG+4
  2438 00:AD46: AA           	tax			; LEN (ARG) STRING
  2439 00:AD47: 38           	sec
  2440 00:AD48: E5 9D        	sbc	FAC		; SET X TO SMALLER LEN
  2441 00:AD4A: F0 08        	beq	STRCMP11
  2442 00:AD4C: A9 01        	lda	#1
  2443 00:AD4E: 90 04        	bcc	STRCMP11
  2444 00:AD50: A6 9D        	ldx	FAC
  2445 00:AD52: A9 FF        	lda	#$FF
  2446                        STRCMP11:
  2447 00:AD54: 85 A2        	sta	FACSIGN		; FLAG WHICH SHORTER
  2448 00:AD56: A0 FF        	ldy	#$FF
  2449 00:AD58: E8           	inx
  2450                        STRCMP1:
  2451 00:AD59: C8           	iny
  2452 00:AD5A: CA           	dex
  2453 00:AD5B: D0 07        	bne	STRCMP2		; MORE CHARS IN BOTH STRINGS
  2454 00:AD5D: A6 A2        	ldx	FACSIGN		; IF = SO FAR, DECIDE BY LENGTH
  2455                        ; ----------------------------------------------------------------------------
  2456 00:AD5F: 30 0F        NUMCMP:	bmi	CMPDONE
  2457 00:AD61: 18           	clc
  2458 00:AD62: 90 0C        	bcc	CMPDONE		; ...ALWAYS
  2459                        ; ----------------------------------------------------------------------------
  2460                        STRCMP2:
  2461 00:AD64: B1 A8        	lda	(ARG+3),y
  2462 00:AD66: D1 9E        	cmp	(FAC+1),y
  2463 00:AD68: F0 EF        	beq	STRCMP1		; SAME, KEEP COMPARING
  2464 00:AD6A: A2 FF        	ldx	#$FF		; IN CASE ARG GREATER
  2465 00:AD6C: B0 02        	bcs	CMPDONE		; IT IS
  2466 00:AD6E: A2 01        	ldx	#1		; FAC GREATER
  2467                        ; ----------------------------------------------------------------------------
  2468                        CMPDONE:
  2469 00:AD70: E8           	inx			; CONVERT FF,0,1 TO 0,1,2
  2470 00:AD71: 8A           	txa
  2471 00:AD72: 2A           	rol	a		; AND TO 0,2,4 IF C=0, ELSE 1,2,5
  2472 00:AD73: 25 16        	and	CPRMASK		; 00000<=>
  2473 00:AD75: F0 02        	beq	CMPDONE1		; IF NO MATCH: FALSE
  2474 00:AD77: A9 01        	lda	#1		; AT LEAST ONE MATCH: TRUE
  2475                        CMPDONE1:
  2476 00:AD79: 4C 55 B8     	jmp	FLOAT
  2477                        
  2478                        
  2479                        ; ----------------------------------------------------------------------------
  2480                        ; "DIM" STATEMENT
  2481                        ; ----------------------------------------------------------------------------
  2482 00:AD7C: 20 84 AC     NXDIM:	jsr	CHKCOM		; SEPARATED BY COMMAS
  2483 00:AD7F: AA           DIM:	tax			; NON-ZERO, FLAGS PTRGET DIM CALLED
  2484 00:AD80: 20 8E AD     	jsr	PTRGET2		; ALLOCATE THE ARRAY
  2485 00:AD83: 20 B7 00     	jsr	CHRGOT		; NEXT CHAR
  2486 00:AD86: D0 F4        	bne	NXDIM		; NOT END OF STATEMENT
  2487 00:AD88: 60           	rts
  2488                        
  2489                        
  2490                        ; ----------------------------------------------------------------------------
  2491                        ; PTRGET -- GENERAL VARIABLE SCAN
  2492                        ;
  2493                        ; SCANS VARIABLE NAME AT TXTPTR, AND SEARCHES THE
  2494                        ; VARTAB AND ARYTAB FOR THE NAME.
  2495                        ; IF NOT FOUND, CREATE VARIABLE OF APPROPRIATE TYPE.
  2496                        ; RETURN WITH ADDRESS IN VARPNT AND Y,A
  2497                        ;
  2498                        ; ACTUAL ACTIVITY CONTROLLED SOMEWHAT BY TWO FLAGS:
  2499                        ;	DIMFLG -- NONZERO IF CALLED FROM "DIM"
  2500                        ;		ELSE = 0
  2501                        ;
  2502                        ;	SUBFLG -- = $00
  2503                        ;		= $40 IF CALLED FROM "GETARYPT"
  2504                        ; ----------------------------------------------------------------------------
  2505 00:AD89: A2 00        PTRGET:	ldx	#0
  2506 00:AD8B: 20 B7 00     	jsr	CHRGOT		; GET FIRST CHAR OF VARIABLE NAME
  2507                        ; ----------------------------------------------------------------------------
  2508                        PTRGET2:
  2509 00:AD8E: 86 10        	stx	DIMFLG		; X IS NONZERO IF FROM DIM
  2510                        ; ----------------------------------------------------------------------------
  2511                        PTRGET3:
  2512 00:AD90: 85 81        	sta	VARNAM
  2513 00:AD92: 20 B7 00     	jsr	CHRGOT
  2514 00:AD95: 20 19 AE     	jsr	ISLETC		; IS IT A LETTER?
  2515 00:AD98: B0 03        	bcs	NAMOK		; YES, OKAY SO FAR
  2516 00:AD9A: 4C 8F AC     BADNAM:	jmp	SYNERR		; NO, SYNTAX ERROR
  2517 00:AD9D: A2 00        NAMOK:	ldx	#0
  2518 00:AD9F: 86 11        	stx	VALTYP
  2519 00:ADA1: 86 12        	stx	VALTYP+1
  2520                        ; ----------------------------------------------------------------------------
  2521                        PTRGET4:
  2522 00:ADA3: 20 B1 00     	jsr	CHRGET		; SECOND CHAR OF VARIABLE NAME
  2523 00:ADA6: 90 05        	bcc	PTRGET41		; NUMERIC
  2524 00:ADA8: 20 19 AE     	jsr	ISLETC		; LETTER?
  2525 00:ADAB: 90 0B        	bcc	PTRGET43		; NO, END OF NAME
  2526                        PTRGET41:
  2527 00:ADAD: AA           	tax			; SAVE SECOND CHAR OF NAME IN X
  2528                        PTRGET42:
  2529 00:ADAE: 20 B1 00     	jsr	CHRGET		; SCAN TO END OF VARIABLE NAME
  2530 00:ADB1: 90 FB        	bcc	PTRGET42		; NUMERIC
  2531 00:ADB3: 20 19 AE     	jsr	ISLETC
  2532 00:ADB6: B0 F6        	bcs	PTRGET42		; ALPHA
  2533                        PTRGET43:
  2534 00:ADB8: C9 24        	cmp	#'$'		; STRING?
  2535 00:ADBA: D0 06        	bne	PTRGET44		; NO
  2536 00:ADBC: A9 FF        	lda	#$FF
  2537 00:ADBE: 85 11        	sta	VALTYP
  2538 00:ADC0: D0 10        	bne	PTRGET45		; ...ALWAYS
  2539                        PTRGET44:
  2540 00:ADC2: C9 25        	cmp	#'%'		; INTEGER?
  2541 00:ADC4: D0 13        	bne	PTRGET46		; NO
  2542 00:ADC6: A5 14        	lda	SUBFLG		; YES; INTEGER VARIABLE ALLOWED?
  2543 00:ADC8: 30 D0        	bmi	BADNAM		; NO, SYNTAX ERROR
  2544 00:ADCA: A9 80        	lda	#$80		; YES
  2545 00:ADCC: 85 12        	sta	VALTYP+1	; FLAG INTEGER MODE
  2546 00:ADCE: 05 81        	ora	VARNAM
  2547 00:ADD0: 85 81        	sta	VARNAM		; SET SIGN BIT ON VARNAME
  2548                        PTRGET45:
  2549 00:ADD2: 8A           	txa			; SECOND CHAR OF NAME
  2550 00:ADD3: 09 80        	ora	#$80		; SET SIGN
  2551 00:ADD5: AA           	tax
  2552 00:ADD6: 20 B1 00     	jsr	CHRGET		; GET TERMINATING CHAR
  2553                        PTRGET46:
  2554 00:ADD9: 86 82        	stx	VARNAM+1	; STORE SECOND CHAR OF NAME
  2555 00:ADDB: 38           	sec
  2556 00:ADDC: 05 14        	ora	SUBFLG		; $00 OR $40 IF SUBSCRIPTS OK, ELSE $80
  2557 00:ADDE: E9 28        	sbc	#'('		; IF SUBFLG=$00 AND CHAR="("...
  2558 00:ADE0: D0 03        	bne	PTRGET48		; NOPE
  2559                        PTRGET47:
  2560 00:ADE2: 4C BA AE     	jmp	ARRAY		; YES
  2561                        PTRGET48:
  2562 00:ADE5: 24 14        	bit	SUBFLG		; CHECK TOP TWO BITS OF SUBFLG
  2563 00:ADE7: 30 02        	bmi	PTRGET49		; $80
  2564 00:ADE9: 70 F7        	bvs	PTRGET47		; $40, CALLED FROM GETARYPT
  2565                        PTRGET49:
  2566 00:ADEB: A9 00        	lda	#0		; CLEAR SUBFLG
  2567 00:ADED: 85 14        	sta	SUBFLG
  2568 00:ADEF: A5 69        	lda	VARTAB		; START LOWTR AT SIMPLE VARIABLE TABLE
  2569 00:ADF1: A6 6A        	ldx	VARTAB+1
  2570 00:ADF3: A0 00        	ldy	#0
  2571                        PTRGET410:
  2572 00:ADF5: 86 9C        	stx	LOWTR+1
  2573                        PTRGET411:
  2574 00:ADF7: 85 9B        	sta	LOWTR
  2575 00:ADF9: E4 6C        	cpx	ARYTAB+1	; END OF SIMPLE VARIABLES?
  2576 00:ADFB: D0 04        	bne	PTRGET412		; NO, GO ON
  2577 00:ADFD: C5 6B        	cmp	ARYTAB		; YES; END OF ARRAYS?
  2578 00:ADFF: F0 21        	beq	NAMENOTFOUND	; YES, MAKE ONE
  2579                        PTRGET412:
  2580 00:AE01: A5 81        	lda	VARNAM		; SAME FIRST LETTER?
  2581 00:AE03: D1 9B        	cmp	(LOWTR),y
  2582 00:AE05: D0 08        	bne	PTRGET413		; NOT SAME FIRST LETTER
  2583 00:AE07: A5 82        	lda	VARNAM+1	; SAME SECOND LETTER?
  2584 00:AE09: C8           	iny
  2585 00:AE0A: D1 9B        	cmp	(LOWTR),y
  2586 00:AE0C: F0 6B        	beq	SET_VARPNT_AND_YA	; YES, SAME VARIABLE NAME
  2587 00:AE0E: 88           	dey			; NO, BUMP TO NEXT NAME
  2588                        PTRGET413:
  2589 00:AE0F: 18           	clc
  2590 00:AE10: A5 9B        	lda	LOWTR
  2591 00:AE12: 69 07        	adc	#7
  2592 00:AE14: 90 E1        	bcc	PTRGET411
  2593 00:AE16: E8           	inx
  2594 00:AE17: D0 DC        	bne	PTRGET410		; ...ALWAYS
  2595                        
  2596                        
  2597                        ; ----------------------------------------------------------------------------
  2598                        ; CHECK IF (A) IS ASCII LETTER A-Z
  2599                        ;
  2600                        ; RETURN CARRY = 1 IF A-Z
  2601                        ;	= 0 IF NOT
  2602                        ; ----------------------------------------------------------------------------
  2603 00:AE19: C9 5B        ISLETC:	cmp	#'Z'+1		; COMPARE HI END
  2604 00:AE1B: B0 03        	bcs	ISLETC1		; ABOVE A-Z
  2605 00:AE1D: C9 41        	cmp	#'A'		; COMPARE LO END
  2606 00:AE1F: 60           	rts			; C=0 IF LO, C=1 IF A-Z
  2607                        ISLETC1:
  2608 00:AE20: 18           	clc			; C=0 IF HI
  2609 00:AE21: 60           	rts
  2610                        
  2611                        
  2612                        ; ----------------------------------------------------------------------------
  2613                        ; VARIABLE NOT FOUND, SO MAKE ONE
  2614                        ; ----------------------------------------------------------------------------
  2615                        NAMENOTFOUND:
  2616 00:AE22: 68           	pla			; LOOK AT RETURN ADDRESS ON STACK TO
  2617 00:AE23: 48           	pha			; SEE IF CALLED FROM FRM.VARIABLE
  2618 00:AE24: C9 9D        	cmp	#<FRM_VARIABLE_CALL
  2619 00:AE26: D0 0F        	bne	MAKENEWVARIABLE	; NO
  2620 00:AE28: BA           	tsx
  2621 00:AE29: BD 02 01     	lda	STACK+2,x
  2622 00:AE2C: C9 AC        	cmp	#>FRM_VARIABLE_CALL
  2623 00:AE2E: D0 07        	bne	MAKENEWVARIABLE	; NO
  2624 00:AE30: A9 35        	lda	#<C_ZERO	; YES, CALLED FROM FRM.VARIABLE
  2625 00:AE32: A0 AE        	ldy	#>C_ZERO	; POINT TO A CONSTANT ZERO
  2626 00:AE34: 60           	rts			; NEW VARIABLE USED IN EXPRESSION = 0
  2627                        
  2628                        ; ----------------------------------------------------------------------------
  2629 00:AE35: 00 00        C_ZERO:	dw	$0000		; INTEGER OR REAL ZERO, OR NULL STRING
  2630                        
  2631                        
  2632                        ; ----------------------------------------------------------------------------
  2633                        ; MAKE A NEW SIMPLE VARIABLE
  2634                        ;
  2635                        ; MOVE ARRAYS UP 7 BYTES TO MAKE ROOM FOR NEW VARIABLE
  2636                        ; ENTER 7-BYTE VARIABLE DATA IN THE HOLE
  2637                        ; ----------------------------------------------------------------------------
  2638                        MAKENEWVARIABLE:
  2639 00:AE37: A5 6B        	lda	ARYTAB		; SET UP CALL TO BLTU TO
  2640 00:AE39: A4 6C        	ldy	ARYTAB+1	; TO MOVE FROM ARYTAB THRU STREND-1
  2641 00:AE3B: 85 9B        	sta	LOWTR		; 7 BYTES HIGHER
  2642 00:AE3D: 84 9C        	sty	LOWTR+1
  2643 00:AE3F: A5 6D        	lda	STREND
  2644 00:AE41: A4 6E        	ldy	STREND+1
  2645 00:AE43: 85 96        	sta	HIGHTR
  2646 00:AE45: 84 97        	sty	HIGHTR+1
  2647 00:AE47: 18           	clc
  2648 00:AE48: 69 07        	adc	#7
  2649 00:AE4A: 90 01        	bcc	MAKENE1
  2650 00:AE4C: C8           	iny
  2651                        MAKENE1:
  2652 00:AE4D: 85 94        	sta	ARYPNT
  2653 00:AE4F: 84 95        	sty	ARYPNT+1
  2654 00:AE51: 20 5B A2     	jsr	BLTU		; MOVE ARRAY BLOCK UP
  2655 00:AE54: A5 94        	lda	ARYPNT		; STORE NEW START OF ARRAYS
  2656 00:AE56: A4 95        	ldy	ARYPNT+1
  2657 00:AE58: C8           	iny
  2658 00:AE59: 85 6B        	sta	ARYTAB
  2659 00:AE5B: 84 6C        	sty	ARYTAB+1
  2660 00:AE5D: A0 00        	ldy	#0
  2661 00:AE5F: A5 81        	lda	VARNAM		; FIRST CHAR OF NAME
  2662 00:AE61: 91 9B        	sta	(LOWTR),y
  2663 00:AE63: C8           	iny
  2664 00:AE64: A5 82        	lda	VARNAM+1	; SECOND CHAR OF NAME
  2665 00:AE66: 91 9B        	sta	(LOWTR),y
  2666 00:AE68: A9 00        	lda	#0		; SET FIVE-BYTE VALUE TO 0
  2667 00:AE6A: C8           	iny
  2668 00:AE6B: 91 9B        	sta	(LOWTR),y
  2669 00:AE6D: C8           	iny
  2670 00:AE6E: 91 9B        	sta	(LOWTR),y
  2671 00:AE70: C8           	iny
  2672 00:AE71: 91 9B        	sta	(LOWTR),y
  2673 00:AE73: C8           	iny
  2674 00:AE74: 91 9B        	sta	(LOWTR),y
  2675 00:AE76: C8           	iny
  2676 00:AE77: 91 9B        	sta	(LOWTR),y
  2677                        
  2678                        
  2679                        ; ----------------------------------------------------------------------------
  2680                        ; PUT ADDRESS OF VALUE OF VARIABLE IN VARPNT AND Y,A
  2681                        ; ----------------------------------------------------------------------------
  2682                        SET_VARPNT_AND_YA:
  2683 00:AE79: A5 9B        	lda	LOWTR		; LOWTR POINTS AT NAME OF VARIABLE,
  2684 00:AE7B: 18           	clc			; SO ADD 2 TO GET TO VALUE
  2685 00:AE7C: 69 02        	adc	#2
  2686 00:AE7E: A4 9C        	ldy	LOWTR+1
  2687 00:AE80: 90 01        	bcc	SET_VA1
  2688 00:AE82: C8           	iny
  2689                        SET_VA1:
  2690 00:AE83: 85 83        	sta	VARPNT		; ADDRESS IN VARPNT AND Y,A
  2691 00:AE85: 84 84        	sty	VARPNT+1
  2692 00:AE87: 60           	rts
  2693                        
  2694                        
  2695                        ; ----------------------------------------------------------------------------
  2696                        ; COMPUTE ADDRESS OF FIRST VALUE IN ARRAY
  2697                        ; ARYPNT = (LOWTR) + #DIMS*2 + 5
  2698                        ; ----------------------------------------------------------------------------
  2699 00:AE88: A5 0F        GETARY:	lda	NUMDIM		; GET # OF DIMENSIONS
  2700 00:AE8A: 0A           	asl	a		; #DIMS*2 (SIZE OF EACH DIM IN 2 BYTES)
  2701 00:AE8B: 69 05        	adc	#5		; + 5 (2 FOR NAME, 2 FOR OFFSET TO NEXT ARRAY, AND 1 FOR #DIMS
  2702 00:AE8D: 65 9B        	adc	LOWTR		; ADDRESS OF TH IS ARRAY IN ARYTAB
  2703 00:AE8F: A4 9C        	ldy	LOWTR+1
  2704 00:AE91: 90 01        	bcc	GETARY1
  2705 00:AE93: C8           	iny
  2706                        GETARY1:
  2707 00:AE94: 85 94        	sta	ARYPNT		; ADDRESS OF FIRST VALUE IN ARRAY
  2708 00:AE96: 84 95        	sty	ARYPNT+1
  2709 00:AE98: 60           	rts
  2710                        
  2711                        
  2712                        ; ----------------------------------------------------------------------------
  2713                        NEG32768:
  2714 00:AE99: 90 80 00 00  	db   $90,$80,$00,$00,$00	; -32768 IN FLOATING POINT
       00:AE9D: 00 
  2715                        ; ----------------------------------------------------------------------------
  2716                        
  2717                        
  2718                        ; ----------------------------------------------------------------------------
  2719                        ; EVALUATE NUMERIC FORMULA AT TXTPTR
  2720                        ; CONVERTING RESULT TO INTEGER 0 <= X <= 32767
  2721                        ; IN FAC+3,4
  2722                        ; ----------------------------------------------------------------------------
  2723 00:AE9E: 20 B1 00     MAKINT:	jsr	CHRGET
  2724 00:AEA1: 20 34 AB     	jsr	FRMNUM
  2725                        
  2726                        
  2727                        ; ----------------------------------------------------------------------------
  2728                        ; CONVERT FAC TO INTEGER
  2729                        ; MUST BE POSITIVE AND LESS THAN 32768
  2730                        ; ----------------------------------------------------------------------------
  2731 00:AEA4: A5 A2        MKINT:	lda	FACSIGN		; ERROR IF -
  2732 00:AEA6: 30 0D        	bmi	MI1
  2733                        
  2734                        
  2735                        ; ----------------------------------------------------------------------------
  2736                        ; CONVERT FAC TO INTEGER
  2737                        ; MUST BE -32767 <= FAC <= 32767
  2738                        ; ----------------------------------------------------------------------------
  2739 00:AEA8: A5 9D        AYINT:	lda	FAC		; EXPONENT OF VALUE IN FAC
  2740 00:AEAA: C9 90        	cmp	#$90		; ABS(VALUE) < 32768?
  2741 00:AEAC: 90 09        	bcc	MI2		; YES, OK FOR INTEGER
  2742 00:AEAE: A9 99        	lda	#<NEG32768	; NO
  2743 00:AEB0: A0 AE        	ldy	#>NEG32768
  2744 00:AEB2: 20 74 B8     	jsr	FCOMP
  2745                        ; ----------------------------------------------------------------------------
  2746 00:AEB5: D0 7E        MI1:	bne	IQERR		; ILLEGAL QUANTITY
  2747 00:AEB7: 4C B1 B8     MI2:	jmp	QINT		; CONVERT TO INTEGER
  2748                        
  2749                        
  2750                        ; ----------------------------------------------------------------------------
  2751                        ; LOCATE ARRAY ELEMENT OR CREATE AN ARRAY
  2752                        ; ----------------------------------------------------------------------------
  2753 00:AEBA: A5 14        ARRAY:  lda	SUBFLG		; SUBSCRIPTS GIVEN?
  2754 00:AEBC: D0 47        	bne	ARRAY2		; NO
  2755                        ; ----------------------------------------------------------------------------
  2756                        ; PARSE THE SUBSCRIPT LIST
  2757                        ; ----------------------------------------------------------------------------
  2758 00:AEBE: A5 10        	lda	DIMFLG		; YES
  2759 00:AEC0: 05 12        	ora	VALTYP+1	; SET HIGH BIT IF %
  2760 00:AEC2: 48           	pha			; SAVE VALTYP AND DIMFLG ON STACK
  2761 00:AEC3: A5 11        	lda	VALTYP
  2762 00:AEC5: 48           	pha
  2763 00:AEC6: A0 00        	ldy	#0		; COUNT # DIMENSIONS IN Y-REG
  2764 00:AEC8: 98           ARRAY1:	tya			; SAVE #DIMS ON STACK
  2765 00:AEC9: 48           	pha
  2766 00:AECA: A5 82        	lda	VARNAM+1	; SAVE VARIABLE NAME ON STACK
  2767 00:AECC: 48           	pha
  2768 00:AECD: A5 81        	lda	VARNAM
  2769 00:AECF: 48           	pha
  2770 00:AED0: 20 9E AE     	jsr	MAKINT		; EVALUATE SUBSCRIPT AS INTEGER
  2771 00:AED3: 68           	pla			; RESTORE VARIABLE NAME
  2772 00:AED4: 85 81        	sta	VARNAM
  2773 00:AED6: 68           	pla
  2774 00:AED7: 85 82        	sta	VARNAM+1
  2775 00:AED9: 68           	pla			; RESTORE # DIMS TO Y-REG
  2776 00:AEDA: A8           	tay
  2777 00:AEDB: BA           	tsx			; COPY VALTYP AND DIMFLG ON STACK
  2778 00:AEDC: BD 02 01     	lda	STACK+2,x	; TO LEAVE ROOM FOR THE SUBSCRIPT
  2779 00:AEDF: 48           	pha
  2780 00:AEE0: BD 01 01     	lda	STACK+1,x
  2781 00:AEE3: 48           	pha
  2782 00:AEE4: A5 A0        	lda	FAC+3		; GET SUBSCRIPT VALUE AND PLACE IN THE
  2783 00:AEE6: 9D 02 01     	sta	STACK+2,x	; STACK WHERE VALTYP & DIMFLG WERE
  2784 00:AEE9: A5 A1        	lda	FAC+4
  2785 00:AEEB: 9D 01 01     	sta	STACK+1,x
  2786 00:AEEE: C8           	iny			; COUNT THE SUBSCRIPT
  2787 00:AEEF: 20 B7 00     	jsr	CHRGOT		; NEXT CHAR
  2788 00:AEF2: C9 2C        	cmp	#','
  2789 00:AEF4: F0 D2        	beq	ARRAY1		; COMMA, PARSE ANOTHER SUBSCRIPT
  2790 00:AEF6: 84 0F        	sty	NUMDIM		; NO MORE SUBSCRIPTS, SAVE #
  2791 00:AEF8: 20 7E AC     	jsr	CHKCLS		; NOW NEED ")"
  2792 00:AEFB: 68           	pla			; RESTORE VALTYPE AND DIMFLG
  2793 00:AEFC: 85 11        	sta	VALTYP
  2794 00:AEFE: 68           	pla
  2795 00:AEFF: 85 12        	sta	VALTYP+1
  2796 00:AF01: 29 7F        	and	#$7F		; ISOLATE DIMFLG
  2797 00:AF03: 85 10        	sta	DIMFLG
  2798                        ; ----------------------------------------------------------------------------
  2799                        ; SEARCH ARRAY TABLE FOR THIS ARRAY NAME
  2800                        ; ----------------------------------------------------------------------------
  2801 00:AF05: A6 6B        ARRAY2:	ldx	ARYTAB		; (A,X) = START OF ARRAY TABLE
  2802 00:AF07: A5 6C        	lda	ARYTAB+1
  2803 00:AF09: 86 9B        ARRAY3:	stx	LOWTR		; USE LOWTR FOR RUNNING POINTER
  2804 00:AF0B: 85 9C        	sta	LOWTR+1
  2805 00:AF0D: C5 6E        	cmp	STREND+1	; DID WE REACH THE END OF ARRAYS YET?
  2806 00:AF0F: D0 04        	bne	ARRAY4		; NO, KEEP SEARCHING
  2807 00:AF11: E4 6D        	cpx	STREND
  2808 00:AF13: F0 3F        	beq	MAKE_NEW_ARRAY	; YES, THIS IS A NEW ARRAY NAME
  2809 00:AF15: A0 00        ARRAY4:	ldy	#0		; POINT AT 1ST CHAR OF ARRAY NAME
  2810 00:AF17: B1 9B        	lda	(LOWTR),y	; GET 1ST CHAR OF NAME
  2811 00:AF19: C8           	iny			; POINT AT 2ND CHAR
  2812 00:AF1A: C5 81        	cmp	VARNAM		; 1ST CHAR SAME?
  2813 00:AF1C: D0 06        	bne	ARRAY5		; NO, MOVE TO NEXT ARRAY
  2814 00:AF1E: A5 82        	lda	VARNAM+1	; YES, TRY 2ND CHAR
  2815 00:AF20: D1 9B        	cmp	(LOWTR),y	; SAME?
  2816 00:AF22: F0 16        	beq	USE_OLD_ARRAY	; YES, ARRAY FOUND
  2817 00:AF24: C8           ARRAY5:	iny			; POINT AT OFFSET TO NEXT ARRAY
  2818 00:AF25: B1 9B        	lda	(LOWTR),y	; ADD OFFSET TO RUNNING POINTER
  2819 00:AF27: 18           	clc
  2820 00:AF28: 65 9B        	adc	LOWTR
  2821 00:AF2A: AA           	tax
  2822 00:AF2B: C8           	iny
  2823 00:AF2C: B1 9B        	lda	(LOWTR),y
  2824 00:AF2E: 65 9C        	adc	LOWTR+1
  2825 00:AF30: 90 D7        	bcc	ARRAY3		; ...ALWAYS
  2826                        
  2827                        
  2828                        ; ----------------------------------------------------------------------------
  2829                        ; ERROR:  BAD SUBSCRIPTS
  2830                        ; ----------------------------------------------------------------------------
  2831 00:AF32: A2 44        SUBERR:	ldx	#ERR_BADSUBS
  2832 00:AF34: 2C           	db	$2C		; TRICK TO SKIP NEXT LINE
  2833                        
  2834                        
  2835                        ; ----------------------------------------------------------------------------
  2836                        ; ERROR:  ILLEGAL QUANTITY
  2837                        ; ----------------------------------------------------------------------------
  2838 00:AF35: A2 1F        IQERR:	ldx	#ERR_ILLQTY
  2839 00:AF37: 4C DA A2     JER:	jmp	ERROR
  2840                        
  2841                        
  2842                        ; ----------------------------------------------------------------------------
  2843                        ; FOUND THE ARRAY
  2844                        ; ----------------------------------------------------------------------------
  2845                        USE_OLD_ARRAY:
  2846 00:AF3A: A2 4E        	ldx	#ERR_REDIMD	; SET UP FOR REDIM'D ARRAY ERROR
  2847 00:AF3C: A5 10        	lda	DIMFLG		; CALLED FROM "DIM" STATEMENT?
  2848 00:AF3E: D0 F7        	bne	JER		; YES, ERROR
  2849 00:AF40: A5 14        	lda	SUBFLG		; NO, CHECK IF ANY SUBSCRIPTS
  2850 00:AF42: F0 02        	beq	USE_O1		; YES, NEED TO CHECK THE NUMBER
  2851 00:AF44: 38           	sec			; NO, SIGNAL ARRAY FOUND
  2852 00:AF45: 60           	rts
  2853                        ; ----------------------------------------------------------------------------
  2854 00:AF46: 20 88 AE     USE_O1:	jsr	GETARY		; SET (ARYPNT) = ADDR OF FIRST ELEMENT
  2855 00:AF49: A5 0F        	lda	TKNCNTR		; COMPARE NUMBER OF DIMENSIONS
  2856 00:AF4B: A0 04        	ldy	#4
  2857 00:AF4D: D1 9B        	cmp	(LOWTR),y
  2858 00:AF4F: D0 E1        	bne	SUBERR		; NOT SAME, SUBSCRIPT ERROR
  2859 00:AF51: 4C E6 AF     	jmp	FIND_ARRAY_ELEMENT
  2860                        
  2861                        
  2862                        ; ----------------------------------------------------------------------------
  2863                        ; CREATE A NEW ARRAY, UNLESS CALLED FROM GETARYPT
  2864                        ; ----------------------------------------------------------------------------
  2865                        MAKE_NEW_ARRAY:
  2866 00:AF54: A5 14        	lda	SUBFLG		; CALLED FROM GETARYPT?
  2867 00:AF56: F0 05        	beq	MAKE_NE1		; NO
  2868 00:AF58: A2 14        	ldx	#ERR_NODATA	; YES, GIVE "OUT OF DATA" ERROR
  2869 00:AF5A: 4C DA A2     	jmp	ERROR
  2870                        MAKE_NE1:
  2871 00:AF5D: 20 88 AE     	jsr	GETARY		; PUT ADDR OF 1ST ELEMENT IN ARYPNT
  2872 00:AF60: 20 AB A2     	jsr	REASON		; MAKE SURE ENOUGH MEMORY LEFT
  2873 00:AF63: A0 00        	ldy	#0		; POINT Y-REG AT VARIABLE NAME SLOT
  2874 00:AF65: 84 AE        	sty	STRNG2+1	; START SIZE COMPUTATION
  2875 00:AF67: A2 05        	ldx	#5		; ASSUME 5-BYTES PER ELEMENT
  2876 00:AF69: A5 81        	lda	VARNAM		; STUFF VARIABLE NAME IN ARRAY
  2877 00:AF6B: 91 9B        	sta	(LOWTR),y
  2878 00:AF6D: 10 01        	bpl	MAKE_NE2		; NOT INTEGER ARRAY
  2879 00:AF6F: CA           	dex			; INTEGER ARRAY, DECR. SIZE TO 4-BYTES
  2880                        MAKE_NE2:
  2881 00:AF70: C8           	iny			; POINT Y-REG AT NEXT CHAR OF NAME
  2882 00:AF71: A5 82        	lda	VARNAM+1	; REST OF ARRAY NAME
  2883 00:AF73: 91 9B        	sta	(LOWTR),y
  2884 00:AF75: 10 02        	bpl	MAKE_NE3		; REAL ARRAY, STICK WITH SIZE = 5 BYTES
  2885 00:AF77: CA           	dex			; INTEGER OR STRING ARRAY, ADJUST SIZE
  2886 00:AF78: CA           	dex			; TO INTEGER=3, STRING=2 BYTES
  2887                        MAKE_NE3:
  2888 00:AF79: 86 AD        	stx	STRNG2		; STORE LOW-BYTE OF ARRAY ELEMENT SIZE
  2889 00:AF7B: A5 0F        	lda	NUMDIM		; STORE NUMBER OF DIMENSIONS
  2890 00:AF7D: C8           	iny			; IN 5TH BYTE OF ARRAY
  2891 00:AF7E: C8           	iny
  2892 00:AF7F: C8           	iny
  2893 00:AF80: 91 9B        	sta	(LOWTR),y
  2894                        MAKE_NE4:
  2895 00:AF82: A2 0B        	ldx	#11		; DEFAULT DIMENSION = 11 ELEMENTS
  2896 00:AF84: A9 00        	lda	#0		; FOR HI-BYTE OF DIMENSION IF DEFAULT
  2897 00:AF86: 24 10        	bit	DIMFLG		; DIMENSIONED ARRAY?
  2898 00:AF88: 50 08        	bvc	MAKE_NE5		; NO, USE DEFAULT VALUE
  2899 00:AF8A: 68           	pla			; GET SPECIFIED DIM IN A,X
  2900 00:AF8B: 18           	clc			; # ELEMENTS IS 1 LARGER THAN
  2901 00:AF8C: 69 01        	adc	#1		; DIMENSION VALUE
  2902 00:AF8E: AA           	tax
  2903 00:AF8F: 68           	pla
  2904 00:AF90: 69 00        	adc	#0
  2905                        MAKE_NE5:
  2906 00:AF92: C8           	iny			; ADD THIS DIMENSION TO ARRAY DESCRIPTOR
  2907 00:AF93: 91 9B        	sta	(LOWTR),y
  2908 00:AF95: C8           	iny
  2909 00:AF96: 8A           	txa
  2910 00:AF97: 91 9B        	sta	(LOWTR),y
  2911 00:AF99: 20 48 B0     	jsr	MULTIPLY_SUBSCRIPT	; MULTIPLY THIS DIMENSION BY RUNNING SIZE ((LOWTR)) * (STRNG2) --> A
                    ,X
  2912 00:AF9C: 86 AD        	stx	STRNG2		; STORE RUNNING SIZE IN STRNG2
  2913 00:AF9E: 85 AE        	sta	STRNG2+1
  2914 00:AFA0: A4 5E        	ldy	INDEX		; RETRIEVE Y SAVED BY MULTIPLY.SUBSCRIPT
  2915 00:AFA2: C6 0F        	dec	NUMDIM		; COUNT DOWN # DIMS
  2916 00:AFA4: D0 DC        	bne	MAKE_NE4		; LOOP TILL DONE
  2917                        ; ----------------------------------------------------------------------------
  2918                        ; NOW A,X HAS TOTAL # BYTES OF ARRAY ELEMENTS
  2919                        ; ----------------------------------------------------------------------------
  2920 00:AFA6: 65 95        	adc	ARYPNT+1	; COMPUTE ADDRESS OF END OF THIS ARRAY
  2921 00:AFA8: B0 5D        	bcs	GME		; ...TOO LARGE, ERROR
  2922 00:AFAA: 85 95        	sta	ARYPNT+1
  2923 00:AFAC: A8           	tay
  2924 00:AFAD: 8A           	txa
  2925 00:AFAE: 65 94        	adc	ARYPNT
  2926 00:AFB0: 90 03        	bcc	MAKE_NE6
  2927 00:AFB2: C8           	iny
  2928 00:AFB3: F0 52        	beq	GME		; ...TOO LARGE, ERROR
  2929                        MAKE_NE6:
  2930 00:AFB5: 20 AB A2     	jsr	REASON		; MAKE SURE THERE IS ROOM UP TO Y,A
  2931 00:AFB8: 85 6D        	sta	STREND		; THERE IS ROOM SO SAVE NEW END OF TABLE
  2932 00:AFBA: 84 6E        	sty	STREND+1	;     AND ZERO THE ARRAY
  2933 00:AFBC: A9 00        	lda	#0
  2934 00:AFBE: E6 AE        	inc	STRNG2+1	; PREPARE FOR FAST ZEROING LOOP
  2935 00:AFC0: A4 AD        	ldy	STRNG2		; # BYTES MOD 256
  2936 00:AFC2: F0 05        	beq	MAKE_NE8		; FULL PAGE
  2937                        MAKE_NE7:
  2938 00:AFC4: 88           	dey			; CLEAR PAGE FULL
  2939 00:AFC5: 91 94        	sta	(ARYPNT),y
  2940 00:AFC7: D0 FB        	bne	MAKE_NE7
  2941                        MAKE_NE8:
  2942 00:AFC9: C6 95        	dec	ARYPNT+1	; POINT TO NEXT PAGE
  2943 00:AFCB: C6 AE        	dec	STRNG2+1	; COUNT THE PAGES
  2944 00:AFCD: D0 F5        	bne	MAKE_NE7		; STILL MORE TO CLEAR
  2945 00:AFCF: E6 95        	inc	ARYPNT+1	; RECOVER LAST DEC, POINT AT 1ST ELEMENT
  2946 00:AFD1: 38           	sec
  2947 00:AFD2: A5 6D        	lda	STREND		; COMPUTE OFFSET TO END OF ARRAYS
  2948 00:AFD4: E5 9B        	sbc	LOWTR		; AND STORE IN ARRAY DESCRIPTOR
  2949 00:AFD6: A0 02        	ldy	#2
  2950 00:AFD8: 91 9B        	sta	(LOWTR),y
  2951 00:AFDA: A5 6E        	lda	STREND+1
  2952 00:AFDC: C8           	iny
  2953 00:AFDD: E5 9C        	sbc	LOWTR+1
  2954 00:AFDF: 91 9B        	sta	(LOWTR),y
  2955 00:AFE1: A5 10        	lda	DIMFLG		; WAS THIS CALLED FROM "DIM" STATEMENT?
  2956 00:AFE3: D0 62        	bne	RTS9		; YES, WE ARE FINISHED
  2957 00:AFE5: C8           	iny			; NO, NOW NEED TO FIND THE ELEMENT
  2958                        
  2959                        
  2960                        ; ----------------------------------------------------------------------------
  2961                        ; FIND SPECIFIED ARRAY ELEMENT
  2962                        ;
  2963                        ; (LOWTR),Y POINTS AT # OF DIMS IN ARRAY DESCRIPTOR
  2964                        ; THE SUBSCRIPTS ARE ALL ON THE STACK AS INTEGERS
  2965                        ; ----------------------------------------------------------------------------
  2966                        FIND_ARRAY_ELEMENT:
  2967 00:AFE6: B1 9B        	lda	(LOWTR),y	; GET # OF DIMENSIONS
  2968 00:AFE8: 85 0F        	sta	NUMDIM
  2969 00:AFEA: A9 00        	lda	#0		; ZERO SUBSCRIPT ACCUMULATOR
  2970 00:AFEC: 85 AD        	sta	STRNG2
  2971 00:AFEE: 85 AE        FAE1:	sta	STRNG2+1
  2972 00:AFF0: C8           	iny
  2973 00:AFF1: 68           	pla			; PULL NEXT SUBSCRIPT FROM STACK
  2974 00:AFF2: AA           	tax			; SAVE IN FAC+3,4
  2975 00:AFF3: 85 A0        	sta	FAC+3		; AND COMPARE WITH DIMENSIONED SIZE
  2976 00:AFF5: 68           	pla
  2977 00:AFF6: 85 A1        	sta	FAC+4
  2978 00:AFF8: D1 9B        	cmp	(LOWTR),y
  2979 00:AFFA: 90 0E        	bcc	FAE2		; SUBSCRIPT NOT TOO LARGE
  2980 00:AFFC: D0 06        	bne	GSE		; SUBSCRIPT IS TOO LARGE
  2981 00:AFFE: C8           	iny			; CHECK LOW-BYTE OF SUBSCRIPT
  2982 00:AFFF: 8A           	txa
  2983 00:B000: D1 9B        	cmp	(LOWTR),y
  2984 00:B002: 90 07        	bcc	FAE3		; NOT TOO LARGE
  2985                        ; ----------------------------------------------------------------------------
  2986 00:B004: 4C 32 AF     GSE:	jmp	SUBERR		; BAD SUBSCRIPTS ERROR
  2987 00:B007: 4C D8 A2     GME:	jmp	MEMERR		; MEM FULL ERROR
  2988                        ; ----------------------------------------------------------------------------
  2989 00:B00A: C8           FAE2:	iny			; BUMP POINTER INTO DESCRIPTOR
  2990 00:B00B: A5 AE        FAE3:	lda	STRNG2+1	; BYPASS MULTIPLICATION IF VALUE SO
  2991 00:B00D: 05 AD        	ora	STRNG2		; FAR = 0
  2992 00:B00F: 18           	clc
  2993 00:B010: F0 0A        	beq	FIND_A1		; IT IS ZERO SO FAR
  2994 00:B012: 20 48 B0     	jsr	MULTIPLY_SUBSCRIPT	; NOT ZERO, SO MULTIPLY
  2995 00:B015: 8A           	txa			; ADD CURRENT SUBSCRIPT
  2996 00:B016: 65 A0        	adc	FAC+3
  2997 00:B018: AA           	tax
  2998 00:B019: 98           	tya
  2999 00:B01A: A4 5E        	ldy	INDEX		; RETRIEVE Y SAVED BY MULTIPLY.SUBSCRIPT
  3000                        FIND_A1:
  3001 00:B01C: 65 A1        	adc	FAC+4		; FINISH ADDING CURRENT SUBSCRIPT
  3002 00:B01E: 86 AD        	stx	STRNG2		; STORE ACCUMULATED OFFSET
  3003 00:B020: C6 0F        	dec	NUMDIM		; LAST SUBSCRIPT YET?
  3004 00:B022: D0 CA        	bne	FAE1		; NO, LOOP TILL DONE
  3005 00:B024: 85 AE        	sta	STRNG2+1	; YES, NOW MULTIPLY BE ELEMENT SIZE
  3006 00:B026: A2 05        	ldx	#5		; START WITH SIZE = 5
  3007 00:B028: A5 81        	lda	VARNAM		; DETERMINE VARIABLE TYPE
  3008 00:B02A: 10 01        	bpl	FIND_A2		; NOT INTEGER
  3009 00:B02C: CA           	dex			; INTEGER, BACK DOWN SIZE TO 4 BYTES
  3010                        FIND_A2:
  3011 00:B02D: A5 82        	lda	VARNAM+1	; DISCRIMINATE BETWEEN REAL AND STR
  3012 00:B02F: 10 02        	bpl	FIND_A3		; IT IS REAL
  3013 00:B031: CA           	dex			; SIZE = 3 IF STRING, =2 IF INTEGER
  3014 00:B032: CA           	dex
  3015                        FIND_A3:
  3016 00:B033: 86 64        	stx	RESULT+2	; SET UP MULTIPLIER
  3017 00:B035: A9 00        	lda	#0		; HI-BYTE OF MULTIPLIER
  3018 00:B037: 20 51 B0     	jsr	MULTIPLY_SUBS1	; (STRNG2) BY ELEMENT SIZE
  3019 00:B03A: 8A           	txa			; ADD ACCUMULATED OFFSET
  3020 00:B03B: 65 94        	adc	ARYPNT		; TO ADDRESS OF 1ST ELEMENT
  3021 00:B03D: 85 83        	sta	VARPNT		; TO GET ADDRESS OF SPECIFIED ELEMENT
  3022 00:B03F: 98           	tya
  3023 00:B040: 65 95        	adc	ARYPNT+1
  3024 00:B042: 85 84        	sta	VARPNT+1
  3025 00:B044: A8           	tay			; RETURN WITH ADDR IN VARPNT
  3026 00:B045: A5 83        	lda	VARPNT		; AND IN Y,A
  3027 00:B047: 60           RTS9:	rts
  3028                        
  3029                        
  3030                        ; ----------------------------------------------------------------------------
  3031                        ; MULTIPLY (STRNG2) BY ((LOWTR),Y)
  3032                        ; LEAVING PRODUCT IN A,X.  (HI-BYTE ALSO IN Y.)
  3033                        ; USED ONLY BY ARRAY SUBSCRIPT ROUTINES
  3034                        ; ----------------------------------------------------------------------------
  3035                        MULTIPLY_SUBSCRIPT:
  3036 00:B048: 84 5E        	sty	INDEX		; SAVE Y-REG
  3037 00:B04A: B1 9B        	lda	(LOWTR),y	; GET MULTIPLIER
  3038 00:B04C: 85 64        	sta	RESULT+2	; SAVE IN RESULT+2,3
  3039 00:B04E: 88           	dey
  3040 00:B04F: B1 9B        	lda	(LOWTR),y
  3041                        ; ----------------------------------------------------------------------------
  3042                        MULTIPLY_SUBS1:
  3043 00:B051: 85 65        	sta	RESULT+3	; LOW BYTE OF MULTIPLIER
  3044 00:B053: A9 10        	lda	#16		; MULTIPLY 16 BITS
  3045 00:B055: 85 99        	sta	INDX
  3046 00:B057: A2 00        	ldx	#0		; PRODUCT = 0 INITIALLY
  3047 00:B059: A0 00        	ldy	#0
  3048                        MULTIP1:
  3049 00:B05B: 8A           	txa			; DOUBLE PRODUCT
  3050 00:B05C: 0A           	asl	a		; LOW BYTE
  3051 00:B05D: AA           	tax
  3052 00:B05E: 98           	tya			; HIGH BYTE
  3053 00:B05F: 2A           	rol	a		; IF TOO LARGE, SET CARRY
  3054 00:B060: A8           	tay
  3055 00:B061: B0 A4        	bcs	GME		; TOO LARGE, "MEM FULL ERROR"
  3056 00:B063: 06 AD        	asl	STRNG2		; NEXT BIT OF MUTLPLICAND
  3057 00:B065: 26 AE        	rol	STRNG2+1	;	INTO CARRY
  3058 00:B067: 90 0B        	bcc	MULTIP2		; BIT=0, DON'T NEED TO ADD
  3059 00:B069: 18           	clc			; BIT=1, ADD INTO PARTIAL PRODUCT
  3060 00:B06A: 8A           	txa
  3061 00:B06B: 65 64        	adc	RESULT+2
  3062 00:B06D: AA           	tax
  3063 00:B06E: 98           	tya
  3064 00:B06F: 65 65        	adc	RESULT+3
  3065 00:B071: A8           	tay
  3066 00:B072: B0 93        	bcs	GME		; TOO LARGE, "MEM FULL ERROR"
  3067                        MULTIP2:
  3068 00:B074: C6 99        	dec	INDX		; 16-BITS YET?
  3069 00:B076: D0 E3        	bne	MULTIP1		; NO, KEEP SHUFFLING
  3070 00:B078: 60           	rts			; YES, PRODUCT IN Y,X AND A,X
  3071                        
  3072                        
  3073                        ; ----------------------------------------------------------------------------
  3074                        ; "FRE" FUNCTION
  3075                        ;
  3076                        ; COLLECTS GARBAGE AND RETURNS # BYTES OF MEMORY LEFT
  3077                        ; ----------------------------------------------------------------------------
  3078 00:B079: A5 11        FRE:	lda	VALTYP		; LOOK AT VALUE OF ARGUMENT
  3079 00:B07B: F0 03        	beq	FRE_1		; =0 MEANS REAL, =$FF MEANS STRING
  3080 00:B07D: 20 E3 B2     	jsr	FREFAC		; STRING, SO SET IT FREE IS TEMP
  3081 00:B080: 20 67 B1     FRE_1:	jsr	GARBAG		; COLLECT ALL THE GARBAGE IN SIGHT
  3082 00:B083: 38           	sec			; COMPUTE SPACE BETWEEN ARRAYS AND
  3083 00:B084: A5 6F        	lda	FRETOP		; STRING TEMP AREA
  3084 00:B086: E5 6D        	sbc	STREND
  3085 00:B088: A8           	tay
  3086 00:B089: A5 70        	lda	FRETOP+1
  3087 00:B08B: E5 6E        	sbc	STREND+1	; FREE SPACE IN Y,A
  3088                        ; FALL INTO GIVAYF TO FLOAT THE VALUE
  3089                        ; NOTE THAT VALUES OVER 32767 WILL RETURN AS NEGATIVE
  3090                        
  3091                        
  3092                        ; ----------------------------------------------------------------------------
  3093                        ; FLOAT THE SIGNED INTEGER IN A,Y
  3094                        ; ----------------------------------------------------------------------------
  3095 00:B08D: A2 00        GIVAYF:	ldx	#0		; MARK FAC VALUE TYPE REAL
  3096 00:B08F: 86 11        	stx	VALTYP
  3097 00:B091: 85 9E        	sta	FAC+1		; SAVE VALUE FROM A,Y IN MANTISSA
  3098 00:B093: 84 9F        	sty	FAC+2
  3099 00:B095: A2 90        	ldx	#$90		; SET EXPONENT TO 2^16
  3100 00:B097: 4C 5D B8     	jmp	FLOAT1		; CONVERT TO SIGNED FP
  3101                        
  3102                        
  3103                        ; ----------------------------------------------------------------------------
  3104                        ; FLOAT (Y) INTO FAC, GIVING VALUE 0-255
  3105                        ; ----------------------------------------------------------------------------
  3106 00:B09A: A9 00        SNGFLT:	lda	#0		; MSB = 0
  3107 00:B09C: F0 EF        	beq	GIVAYF		; ...ALWAYS
  3108                        
  3109                        
  3110                        ; ----------------------------------------------------------------------------
  3111                        ; CHECK FOR DIRECT OR RUNNING MODE
  3112                        ; GIVING ERROR IF DIRECT MODE
  3113                        ; ----------------------------------------------------------------------------
  3114 00:B09E: A6 76        ERRDIR:	ldx	CURLIN+1	; =$FF IF DIRECT MODE
  3115 00:B0A0: E8           	inx			; MAKES $FF INTO ZERO
  3116 00:B0A1: D0 A4        	bne	RTS9		; RETURN IF RUNNING MODE
  3117 00:B0A3: A2 5B        	ldx	#ERR_ILLDIR	; DIRECT MODE, GIVE ERROR
  3118 00:B0A5: 4C DA A2     	jmp	ERROR
  3119                        
  3120                        
  3121                        ; ----------------------------------------------------------------------------
  3122                        ; "STR$" FUNCTION
  3123                        ; ----------------------------------------------------------------------------
  3124 00:B0A8: 20 37 AB     STR:	jsr	CHKNUM		; EXPRESSION MUST BE NUMERIC
  3125 00:B0AB: A0 00        	ldy	#0		; START STRING AT STACK-1 ($00FF) SO STRLIT CAN DIFFRENTIATE STR$ CALLS
  3126 00:B0AD: 20 F3 B9     	jsr	FOUT1		; CONVERT FAC TO STRING
  3127 00:B0B0: 68           	pla			; POP RETURN OFF STACK
  3128 00:B0B1: 68           	pla
  3129 00:B0B2: A9 FF        	lda	#<(STACK-1)	; POINT TO STACK-1
  3130 00:B0B4: A0 00        	ldy	#>(STACK-1)	; (WHICH=0)
  3131 00:B0B6: F0 12        	beq	STRLIT		; ...ALWAYS, CREATE DESC & MOVE STRING
  3132                        
  3133                        
  3134                        ; ----------------------------------------------------------------------------
  3135                        ; GET SPACE AND MAKE DESCRIPTOR FOR STRING WHOSE
  3136                        ; ADDRESS IS IN FAC+3,4 AND WHOSE LENGTH IS IN A-REG
  3137                        ; ----------------------------------------------------------------------------
  3138 00:B0B8: A6 A0        STRINI:	ldx	FAC+3		; Y,X = STRING ADDRESS
  3139 00:B0BA: A4 A1        	ldy	FAC+4
  3140 00:B0BC: 86 8C        	stx	DSCPTR
  3141 00:B0BE: 84 8D        	sty	DSCPTR+1
  3142                        
  3143                        
  3144                        ; ----------------------------------------------------------------------------
  3145                        ; GET SPACE AND MAKE DESCRIPTOR FOR STRING WHOSE
  3146                        ; ADDRESS IS IN Y,X AND WHOSE LENGTH IS IN A-REG
  3147                        ; ----------------------------------------------------------------------------
  3148 00:B0C0: 20 35 B1     STRSPA:	jsr	GETSPA		; A HOLDS LENGTH
  3149 00:B0C3: 86 9E        	stx	FAC+1		; SAVE DESCRIPTOR IN FAC
  3150 00:B0C5: 84 9F        	sty	FAC+2		; ---FAC--- --FAC+1-- --FAC+2--
  3151 00:B0C7: 85 9D        	sta	FAC		; <LENGTH>  <ADDR-LO> <ADDR-HI>
  3152 00:B0C9: 60           	rts
  3153                        
  3154                        
  3155                        ; ----------------------------------------------------------------------------
  3156                        ; BUILD A DESCRIPTOR FOR STRING STARTING AT Y,A
  3157                        ; AND TERMINATED BY $00 OR QUOTATION MARK
  3158                        ; RETURN WITH DESCRIPTOR IN A TEMPORARY
  3159                        ; AND ADDRESS OF DESCRIPTOR IN FAC+3,4
  3160                        ; ----------------------------------------------------------------------------
  3161 00:B0CA: A2 22        STRLIT:	ldx	#'"'		; SET UP LITERAL SCAN TO STOP ON
  3162 00:B0CC: 86 0D        	stx	CHARAC		; QUOTATION MARK OR $00
  3163 00:B0CE: 86 0E        	stx	ENDCHR
  3164                        
  3165                        
  3166                        ; ----------------------------------------------------------------------------
  3167                        ; BUILD A DESCRIPTOR FOR STRING STARTING AT Y,A
  3168                        ; AND TERMINATED BY $00, (CHARAC), OR (ENDCHR)
  3169                        ;
  3170                        ; RETURN WITH DESCRIPTOR IN A TEMPORARY
  3171                        ; AND ADDRESS OF DESCRIPTOR IN FAC+3,4
  3172                        ; ----------------------------------------------------------------------------
  3173 00:B0D0: 85 AB        STRLT2:	sta	STRNG1		; SAVE ADDRESS OF STRING
  3174 00:B0D2: 84 AC        	sty	STRNG1+1
  3175 00:B0D4: 85 9E        	sta	FAC+1		; ...AGAIN
  3176 00:B0D6: 84 9F        	sty	FAC+2
  3177 00:B0D8: A0 FF        	ldy	#$FF
  3178                        STRLT21:
  3179 00:B0DA: C8           	iny			; FIND END OF STRING
  3180 00:B0DB: B1 AB        	lda	(STRNG1),y	; NEXT STRING CHAR
  3181 00:B0DD: F0 0C        	beq	STRLT23		; END OF STRING
  3182 00:B0DF: C5 0D        	cmp	CHARAC		; ALTERNATE TERMINATOR # 1?
  3183 00:B0E1: F0 04        	beq	STRLT22		; YES
  3184 00:B0E3: C5 0E        	cmp	ENDCHR		; ALTERNATE TERMINATOR # 2?
  3185 00:B0E5: D0 F3        	bne	STRLT21		; NO, KEEP SCANNING
  3186                        STRLT22:
  3187 00:B0E7: C9 22        	cmp	#'"'		; IS STRING ENDED WITH QUOTE MARK?
  3188 00:B0E9: F0 01        	beq	STRLT24		; YES, C=1 TO INCLUDE " IN STRING
  3189                        STRLT23:
  3190 00:B0EB: 18           	clc
  3191                        STRLT24:
  3192 00:B0EC: 84 9D        	sty	FAC		; SAVE LENGTH
  3193 00:B0EE: 98           	tya
  3194 00:B0EF: 65 AB        	adc	STRNG1		; COMPUTE ADDRESS OF END OF STRING
  3195 00:B0F1: 85 AD        	sta	STRNG2		;	(OF 00 BYTE, OR JUST AFTER ")
  3196 00:B0F3: A6 AC        	ldx	STRNG1+1
  3197 00:B0F5: 90 01        	bcc	STRLT25
  3198 00:B0F7: E8           	inx
  3199                        STRLT25:
  3200 00:B0F8: 86 AE        	stx	STRNG2+1
  3201 00:B0FA: A5 AC        	lda	STRNG1+1	; WHERE DOES THE STRING START?
  3202 00:B0FC: F0 04        	beq	STRLT26		; PAGE 0, MUST BE FROM STR$ FUNCTION
  3203 00:B0FE: C9 02        	cmp	#2		; PAGE 2?
  3204 00:B100: D0 0B        	bne	PUTNEW		; NO, NOT PAGE 0 OR 2
  3205                        STRLT26:
  3206 00:B102: 98           	tya			; LENGTH OF STRING
  3207 00:B103: 20 B8 B0     	jsr	STRINI		; MAKE SPACE FOR STRING
  3208 00:B106: A6 AB        	ldx	STRNG1
  3209 00:B108: A4 AC        	ldy	STRNG1+1
  3210 00:B10A: 20 C5 B2     	jsr	MOVSTR		; MOVE IT IN
  3211                        
  3212                        
  3213                        ; ----------------------------------------------------------------------------
  3214                        ; STORE DESCRIPTOR IN TEMPORARY DESCRIPTOR STACK
  3215                        ;
  3216                        ; THE DESCRIPTOR IS NOW IN FAC, FAC+1, FAC+2
  3217                        ; PUT ADDRESS OF TEMP DESCRIPTOR IN FAC+3,4
  3218                        ; ----------------------------------------------------------------------------
  3219 00:B10D: A6 52        PUTNEW:	ldx	TEMPPT		; POINTER TO NEXT TEMP STRING SLOT
  3220 00:B10F: E0 5E        	cpx	#TEMPST+9	; MAX OF 3 TEMP STRINGS
  3221 00:B111: D0 05        	bne	PUTEMP		; ROOM FOR ANOTHER ONE
  3222 00:B113: A2 76        	ldx	#ERR_FRMCPX	; TOO MANY, FORMULA TOO COMPLEX
  3223 00:B115: 4C DA A2     JERR:	jmp	ERROR
  3224                        ; ----------------------------------------------------------------------------
  3225 00:B118: A5 9D        PUTEMP:	lda	FAC		; COPY TEMP DESCRIPTOR INTO TEMP STACK
  3226 00:B11A: 95 00        	sta	<0,x
  3227 00:B11C: A5 9E        	lda	FAC+1
  3228 00:B11E: 95 01        	sta	<1,x
  3229 00:B120: A5 9F        	lda	FAC+2
  3230 00:B122: 95 02        	sta	<2,x
  3231 00:B124: A0 00        	ldy	#0
  3232 00:B126: 86 A0        	stx	FAC+3		; ADDRESS OF TEMP DESCRIPTOR
  3233 00:B128: 84 A1        	sty	FAC+4		; IN Y,X AND FAC+3,4
  3234 00:B12A: 88           	dey			; Y=$FF
  3235 00:B12B: 84 11        	sty	VALTYP		; FLAG (FAC ) AS STRING
  3236 00:B12D: 86 53        	stx	LASTPT		; INDEX OF LAST POINTER
  3237 00:B12F: E8           	inx			; UPDATE FOR NEXT TEMP ENTRY
  3238 00:B130: E8           	inx
  3239 00:B131: E8           	inx
  3240 00:B132: 86 52        	stx	TEMPPT
  3241 00:B134: 60           	rts
  3242                        
  3243                        
  3244                        ; ----------------------------------------------------------------------------
  3245                        ; MAKE SPACE FOR STRING AT BOTTOM OF STRING SPACE
  3246                        ; (A)=# BYTES SPACE TO MAKE
  3247                        ;
  3248                        ; RETURN WITH (A) SAME,
  3249                        ;	AND Y,X = ADDRESS OF SPACE ALLOCATED
  3250                        ; ----------------------------------------------------------------------------
  3251 00:B135: 46 13        GETSPA:	lsr	GARFLG		; CLEAR SIGNBIT OF FLAG
  3252                        GETSPA1:
  3253 00:B137: 48           	pha			; A HOLDS LENGTH
  3254 00:B138: 49 FF        	eor	#$FF		; GET -LENGTH
  3255 00:B13A: 38           	sec
  3256 00:B13B: 65 6F        	adc	FRETOP		; COMPUTE STARTING ADDRESS OF SPACE
  3257 00:B13D: A4 70        	ldy	FRETOP+1	; FOR THE STRING
  3258 00:B13F: B0 01        	bcs	GETSPA2
  3259 00:B141: 88           	dey
  3260                        GETSPA2:
  3261 00:B142: C4 6E        	cpy	STREND+1	; SEE IF FITS IN REMAINING MEMORY
  3262 00:B144: 90 11        	bcc	GETSPA4		; NO, TRY GARBAGE
  3263 00:B146: D0 04        	bne	GETSPA3		; YES, IT FITS
  3264 00:B148: C5 6D        	cmp	STREND		; HAVE TO CHECK LOWER BYTES
  3265 00:B14A: 90 0B        	bcc	GETSPA4		; NOT ENUF ROOM YET
  3266                        GETSPA3:
  3267 00:B14C: 85 6F        	sta	FRETOP		; THERE IS ROOM SO SAVE NEW FRETOP
  3268 00:B14E: 84 70        	sty	FRETOP+1
  3269 00:B150: 85 71        	sta	FRESPC
  3270 00:B152: 84 72        	sty	FRESPC+1
  3271 00:B154: AA           	tax			; ADDR IN Y,X
  3272 00:B155: 68           	pla			; LENGTH IN A
  3273 00:B156: 60           	rts
  3274                        GETSPA4:
  3275 00:B157: A2 30        	ldx	#ERR_MEMFULL
  3276 00:B159: A5 13        	lda	GARFLG		; GARBAGE DONE YET?
  3277 00:B15B: 30 B8        	bmi	JERR		; YES, MEMORY IS REALLY FULL
  3278 00:B15D: 20 67 B1     	jsr	GARBAG		; NO, TRY COLLECTING NOW
  3279 00:B160: A9 80        	lda	#$80		; FLAG THAT COLLECTED GARBAGE ALREADY
  3280 00:B162: 85 13        	sta	GARFLG
  3281 00:B164: 68           	pla			; GET STRING LENGTH AGAIN
  3282 00:B165: D0 D0        	bne	GETSPA1		; ...ALWAYS
  3283                        
  3284                        
  3285                        ; ----------------------------------------------------------------------------
  3286                        ; SHOVE ALL REFERENCED STRINGS AS HIGH AS POSSIBLE
  3287                        ; IN MEMORY (AGAINST HIMEM), FREEING UP SPACE
  3288                        ; BELOW STRING AREA DOWN TO STREND.
  3289                        ; ----------------------------------------------------------------------------
  3290 00:B167: A6 73        GARBAG:	ldx	MEMSIZ		; COLLECT FROM TOP DOWN
  3291 00:B169: A5 74        	lda	MEMSIZ+1
  3292                        FINDHIGHESTSTRING:
  3293 00:B16B: 86 6F        	stx	FRETOP		; ONE PASS THROUGH ALL VARS
  3294 00:B16D: 85 70        	sta	FRETOP+1	; FOR EACH ACTIVE STRING!
  3295 00:B16F: A0 00        	ldy	#0
  3296 00:B171: 84 8B        	sty	FNCNAM+1	; FLAG IN CASE NO STRINGS TO COLLECT
  3297 00:B173: A5 6D        	lda	STREND
  3298 00:B175: A6 6E        	ldx	STREND+1
  3299 00:B177: 85 9B        	sta	LOWTR
  3300 00:B179: 86 9C        	stx	LOWTR+1
  3301                        ; ----------------------------------------------------------------------------
  3302                        ; START BY COLLECTING TEMPORARIES
  3303                        ; ----------------------------------------------------------------------------
  3304 00:B17B: A9 55        	lda	#<TEMPST
  3305 00:B17D: A2 00        	ldx	#>TEMPST
  3306 00:B17F: 85 5E        	sta	INDEX
  3307 00:B181: 86 5F        	stx	INDEX+1
  3308                        GARBAG1:
  3309 00:B183: C5 52        	cmp	TEMPPT		; FINISHED WITH TEMPS YET?
  3310 00:B185: F0 05        	beq	GARBAG2		; YES, NOW DO SIMPLE VARIABLES
  3311 00:B187: 20 06 B2     	jsr	CHECK_VARIABLE	; DO A TEMP
  3312 00:B18A: F0 F7        	beq	GARBAG1		; ...ALWAYS
  3313                        ; ----------------------------------------------------------------------------
  3314                        ; NOW COLLECT SIMPLE VARIABLES
  3315                        ; ----------------------------------------------------------------------------
  3316                        GARBAG2:
  3317 00:B18C: A9 07        	lda	#7		; LENGTH OF EACH VARIABLE IS 7 BYTES
  3318 00:B18E: 85 8F        	sta	DSCLEN
  3319 00:B190: A5 69        	lda	VARTAB		; START AT BEGINNING OF VARTAB
  3320 00:B192: A6 6A        	ldx	VARTAB+1
  3321 00:B194: 85 5E        	sta	INDEX
  3322 00:B196: 86 5F        	stx	INDEX+1
  3323                        GARBAG3:
  3324 00:B198: E4 6C        	cpx	ARYTAB+1	; FINISHED WITH SIMPLE VARIABLES?
  3325 00:B19A: D0 04        	bne	GARBAG4		; NO
  3326 00:B19C: C5 6B        	cmp	ARYTAB		; MAYBE, CHECK LO-BYTE
  3327 00:B19E: F0 05        	beq	GARBAG5		; YES, NOW DO ARRAYS
  3328                        GARBAG4:
  3329 00:B1A0: 20 FC B1     	jsr	CHECK_SIMPLE_VARIABLE
  3330 00:B1A3: F0 F3        	beq	GARBAG3		; ...ALWAYS
  3331                        ; ----------------------------------------------------------------------------
  3332                        ; NOW COLLECT ARRAY VARIABLES
  3333                        ; ----------------------------------------------------------------------------
  3334                        GARBAG5:
  3335 00:B1A5: 85 94        	sta	ARYPNT
  3336 00:B1A7: 86 95        	stx	ARYPNT+1
  3337 00:B1A9: A9 03        	lda	#3		; DESCRIPTORS IN ARRAYS ARE 3-BYTES EACH
  3338 00:B1AB: 85 8F        	sta	DSCLEN
  3339                        GARBAG6:
  3340 00:B1AD: A5 94        	lda	ARYPNT		; COMPARE TO END OF ARRAYS
  3341 00:B1AF: A6 95        	ldx	ARYPNT+1
  3342                        GARBAG7:
  3343 00:B1B1: E4 6E        	cpx	STREND+1	; FINISHED WITH ARRAYS YET?
  3344 00:B1B3: D0 07        	bne	GARBAG8		; NOT YET
  3345 00:B1B5: C5 6D        	cmp	STREND		; MAYBE, CHECK LO-BYTE
  3346 00:B1B7: D0 03        	bne	GARBAG8		; NOT FINISHED YET
  3347 00:B1B9: 4C 45 B2     	jmp	MOVE_HIGHEST_STRING_TO_TOP	; FINISHED
  3348                        GARBAG8:
  3349 00:B1BC: 85 5E        	sta	INDEX		; SET UP PNTR TO START OF ARRAY
  3350 00:B1BE: 86 5F        	stx	INDEX+1
  3351 00:B1C0: A0 00        	ldy	#0		; POINT AT NAME OF ARRAY
  3352 00:B1C2: B1 5E        	lda	(INDEX),y
  3353 00:B1C4: AA           	tax			; 1ST LETTER OF NAME IN X-REG
  3354 00:B1C5: C8           	iny
  3355 00:B1C6: B1 5E        	lda	(INDEX),y
  3356 00:B1C8: 08           	php			; STATUS FROM SECOND LETTER OF NAME
  3357 00:B1C9: C8           	iny
  3358 00:B1CA: B1 5E        	lda	(INDEX),y	; OFFSET TO NEXT ARRAY
  3359 00:B1CC: 65 94        	adc	ARYPNT		; (CARRY ALWAYS CLEAR)
  3360 00:B1CE: 85 94        	sta	ARYPNT		; CALCULATE START OF NEXT ARRAY
  3361 00:B1D0: C8           	iny
  3362 00:B1D1: B1 5E        	lda	(INDEX),y	; HI-BYTE OF OFFSET
  3363 00:B1D3: 65 95        	adc	ARYPNT+1
  3364 00:B1D5: 85 95        	sta	ARYPNT+1
  3365 00:B1D7: 28           	plp			; GET STATUS FROM 2ND CHAR OF NAME
  3366 00:B1D8: 10 D3        	bpl	GARBAG6		; NOT A STRING ARRAY
  3367 00:B1DA: 8A           	txa			; SET STATUS WITH 1ST CHAR OF NAME
  3368 00:B1DB: 30 D0        	bmi	GARBAG6		; NOT A STRING ARRAY
  3369 00:B1DD: C8           	iny
  3370 00:B1DE: B1 5E        	lda	(INDEX),y	; # OF DIMENSIONS FOR THIS ARRAY
  3371 00:B1E0: A0 00        	ldy	#0
  3372 00:B1E2: 0A           	asl	a		; PREAMBLE SIZE = 2*#DIMS + 5
  3373 00:B1E3: 69 05        	adc	#5
  3374 00:B1E5: 65 5E        	adc	INDEX		; MAKE INDEX POINT AT FIRST ELEMENT
  3375 00:B1E7: 85 5E        	sta	INDEX		; 	IN THE ARRAY
  3376 00:B1E9: 90 02        	bcc	GARBAG9
  3377 00:B1EB: E6 5F        	inc	INDEX+1
  3378                        GARBAG9:
  3379 00:B1ED: A6 5F        	ldx	INDEX+1		; STEP THRU EACH STRING IN THIS ARRAY
  3380                        GARBAG10:
  3381 00:B1EF: E4 95        	cpx	ARYPNT+1	; ARRAY DONE?
  3382 00:B1F1: D0 04        	bne	GARBAG11		; NO, PROCESS NEXT ELEMENT
  3383 00:B1F3: C5 94        	cmp	ARYPNT		; MAYBE, CHECK LO-BYTE
  3384 00:B1F5: F0 BA        	beq	GARBAG7		; YES, MOVE TO NEXT ARRAY
  3385                        GARBAG11:
  3386 00:B1F7: 20 06 B2     	jsr	CHECK_VARIABLE	; PROCESS THE ARRAY
  3387 00:B1FA: F0 F3        	beq	GARBAG10		; ...ALWAYS
  3388                        
  3389                        
  3390                        ; ----------------------------------------------------------------------------
  3391                        ; PROCESS A SIMPLE VARIABLE
  3392                        ; ----------------------------------------------------------------------------
  3393                        CHECK_SIMPLE_VARIABLE:
  3394 00:B1FC: B1 5E        	lda	(INDEX),y	; LOOK AT 1ST CHAR OF NAME
  3395 00:B1FE: 30 35        	bmi	CHECK_BUMP	; NOT A STRING VARIABLE
  3396 00:B200: C8           	iny
  3397 00:B201: B1 5E        	lda	(INDEX),y	; LOOK AT 2ND CHAR OF NAME
  3398 00:B203: 10 30        	bpl	CHECK_BUMP	; NOT A STRING VARIABLE
  3399 00:B205: C8           	iny
  3400                        
  3401                        
  3402                        ; ----------------------------------------------------------------------------
  3403                        ; IF STRING IS NOT EMPTY, CHECK IF IT IS HIGHEST
  3404                        ; ----------------------------------------------------------------------------
  3405                        CHECK_VARIABLE:
  3406 00:B206: B1 5E        	lda	(INDEX),y	; GET LENGTH OF STRING
  3407 00:B208: F0 2B        	beq	CHECK_BUMP	; IGNORE STRING IF LENGTH IS ZERO
  3408 00:B20A: C8           	iny
  3409 00:B20B: B1 5E        	lda	(INDEX),y	; GET ADDRESS OF STRING
  3410 00:B20D: AA           	tax
  3411 00:B20E: C8           	iny
  3412 00:B20F: B1 5E        	lda	(INDEX),y
  3413 00:B211: C5 70        	cmp	FRETOP+1	; CHECK IF ALREADY COLLECTED
  3414 00:B213: 90 06        	bcc	CHECK_V1		; NO, BELOW FRETOP
  3415 00:B215: D0 1E        	bne	CHECK_BUMP	; YES, ABOVE FRETOP
  3416 00:B217: E4 6F        	cpx	FRETOP		; MAYBE, CHECK LO-BYTE
  3417 00:B219: B0 1A        	bcs	CHECK_BUMP	; YES, ABOVE FRETOP
  3418                        CHECK_V1:
  3419 00:B21B: C5 9C        	cmp	LOWTR+1		; ABOVE HIGHEST STRING FOUND?
  3420 00:B21D: 90 16        	bcc	CHECK_BUMP	; NO, IGNORE FOR NOW
  3421 00:B21F: D0 04        	bne	CHECK_V2		; YES, THIS IS THE NEW HIGHEST
  3422 00:B221: E4 9B        	cpx	LOWTR		; MAYBE, TRY LO-BYTE
  3423 00:B223: 90 10        	bcc	CHECK_BUMP	; NO, IGNORE FOR NOW
  3424                        CHECK_V2:
  3425 00:B225: 86 9B        	stx	LOWTR		; MAKE THIS THE HIGHEST STRING
  3426 00:B227: 85 9C        	sta	LOWTR+1
  3427 00:B229: A5 5E        	lda	INDEX		; SAVE ADDRESS OF DESCRIPTOR TOO
  3428 00:B22B: A6 5F        	ldx	INDEX+1
  3429 00:B22D: 85 8A        	sta	FNCNAM
  3430 00:B22F: 86 8B        	stx	FNCNAM+1
  3431 00:B231: A5 8F        	lda	DSCLEN
  3432 00:B233: 85 91        	sta	LENGTH
  3433                        
  3434                        
  3435                        ; ----------------------------------------------------------------------------
  3436                        ; ADD (DSCLEN) TO PNTR IN INDEX
  3437                        ; RETURN WITH Y=0, PNTR ALSO IN X,A
  3438                        ; ----------------------------------------------------------------------------
  3439                        CHECK_BUMP:
  3440 00:B235: A5 8F        	lda	DSCLEN		; BUMP TO NEXT VARIABLE
  3441 00:B237: 18           	clc
  3442 00:B238: 65 5E        	adc	INDEX
  3443 00:B23A: 85 5E        	sta	INDEX
  3444 00:B23C: 90 02        	bcc	CHECK_EXIT
  3445 00:B23E: E6 5F        	inc	INDEX+1
  3446                        ; ----------------------------------------------------------------------------
  3447                        CHECK_EXIT:
  3448 00:B240: A6 5F        	ldx	INDEX+1
  3449 00:B242: A0 00        	ldy	#0
  3450 00:B244: 60           	rts
  3451                        
  3452                        
  3453                        ; ----------------------------------------------------------------------------
  3454                        ; FOUND HIGHEST NON-EMPTY STRING, SO MOVE IT
  3455                        ; TO TOP AND GO BACK FOR ANOTHER
  3456                        ; ----------------------------------------------------------------------------
  3457                        MOVE_HIGHEST_STRING_TO_TOP:
  3458 00:B245: A6 8B        	ldx	FNCNAM+1	; ANY STRING FOUND?
  3459 00:B247: F0 F7        	beq	CHECK_EXIT	; NO, RETURN
  3460 00:B249: A5 91        	lda	LENGTH		; GET LENGTH OF VARIABLE ELEMENT
  3461 00:B24B: 29 04        	and	#4		; WAS 7 OR 3, MAKE 4 OR 0
  3462 00:B24D: 4A           	lsr	a		; 2 0R 0; IN SIMPLE VARIABLES,
  3463 00:B24E: A8           	tay			; NAME PRECEDES DESCRIPTOR
  3464 00:B24F: 85 91        	sta	LENGTH		; 2 OR 0
  3465 00:B251: B1 8A        	lda	(FNCNAM),y	; GET LENGTH FROM DESCRIPTOR
  3466 00:B253: 65 9B        	adc	LOWTR		; CARRY ALREADY CLEARED BY LSR
  3467 00:B255: 85 96        	sta	HIGHTR		; STRING IS BTWN (LOWTR) AND (HIGHTR)
  3468 00:B257: A5 9C        	lda	LOWTR+1
  3469 00:B259: 69 00        	adc	#0
  3470 00:B25B: 85 97        	sta	HIGHTR+1
  3471 00:B25D: A5 6F        	lda	FRETOP		; HIGH END DESTINATION
  3472 00:B25F: A6 70        	ldx	FRETOP+1
  3473 00:B261: 85 94        	sta	HIGHDS
  3474 00:B263: 86 95        	stx	HIGHDS+1
  3475 00:B265: 20 62 A2     	jsr	BLTU2		; MOVE STRING UP
  3476 00:B268: A4 91        	ldy	LENGTH		; FIX ITS DESCRIPTOR
  3477 00:B26A: C8           	iny			; POINT AT ADDRESS IN DESCRIPTOR
  3478 00:B26B: A5 94        	lda	HIGHDS		; STORE NEW ADDRESS
  3479 00:B26D: 91 8A        	sta	(FNCNAM),y
  3480 00:B26F: AA           	tax
  3481 00:B270: E6 95        	inc	HIGHDS+1	; CORRECT BLTU'S OVERSHOOT
  3482 00:B272: A5 95        	lda	HIGHDS+1
  3483 00:B274: C8           	iny
  3484 00:B275: 91 8A        	sta	(FNCNAM),y
  3485 00:B277: 4C 6B B1     	jmp	FINDHIGHESTSTRING
  3486                        
  3487                        
  3488                        ; ----------------------------------------------------------------------------
  3489                        ; CONCATENATE TWO STRINGS
  3490                        ; ----------------------------------------------------------------------------
  3491 00:B27A: A5 A1        CAT:	lda	FAC+4		; SAVE ADDRESS OF FIRST DESCRIPTOR
  3492 00:B27C: 48           	pha
  3493 00:B27D: A5 A0        	lda	FAC+3
  3494 00:B27F: 48           	pha
  3495 00:B280: 20 2D AC     	jsr	FRM_ELEMENT	; GET SECOND STRING ELEMENT
  3496 00:B283: 20 39 AB     	jsr	CHKSTR		; MUST BE A STRING
  3497 00:B286: 68           	pla			; RECOVER ADDRES OF 1ST DESCRIPTOR
  3498 00:B287: 85 AB        	sta	STRNG1
  3499 00:B289: 68           	pla
  3500 00:B28A: 85 AC        	sta	STRNG1+1
  3501 00:B28C: A0 00        	ldy	#0
  3502 00:B28E: B1 AB        	lda	(STRNG1),y	; ADD LENGTHS, GET CONCATENATED SIZE
  3503 00:B290: 18           	clc
  3504 00:B291: 71 A0        	adc	(FAC+3),y
  3505 00:B293: 90 05        	bcc	CAT_1		; OK IF < $100
  3506 00:B295: A2 6E        	ldx	#ERR_STRLONG
  3507 00:B297: 4C DA A2     	jmp	ERROR
  3508 00:B29A: 20 B8 B0     CAT_1:	jsr	STRINI		; GET SPACE FOR CONCATENATED STRINGS
  3509 00:B29D: 20 B7 B2     	jsr	MOVINS		; MOVE 1ST STRING
  3510 00:B2A0: A5 8C        	lda	DSCPTR
  3511 00:B2A2: A4 8D        	ldy	DSCPTR+1
  3512 00:B2A4: 20 E7 B2     	jsr	FRETMP
  3513 00:B2A7: 20 C9 B2     	jsr	MOVSTR1		; MOVE 2ND STRING
  3514 00:B2AA: A5 AB        	lda	STRNG1
  3515 00:B2AC: A4 AC        	ldy	STRNG1+1
  3516 00:B2AE: 20 E7 B2     	jsr	FRETMP
  3517 00:B2B1: 20 0D B1     	jsr	PUTNEW		; SET UP DESCRIPTOR
  3518 00:B2B4: 4C 62 AB     	jmp	FRMEVL2		; FINISH EXPRESSION
  3519                        
  3520                        
  3521                        ; ----------------------------------------------------------------------------
  3522                        ; GET STRING DESCRIPTOR POINTED AT BY (STRNG1)
  3523                        ; AND MOVE DESCRIBED STRING TO (FRESPC)
  3524                        ; ----------------------------------------------------------------------------
  3525 00:B2B7: A0 00        MOVINS:	ldy	#0
  3526 00:B2B9: B1 AB        	lda	(STRNG1),y
  3527 00:B2BB: 48           	pha			; LENGTH
  3528 00:B2BC: C8           	iny
  3529 00:B2BD: B1 AB        	lda	(STRNG1),y
  3530 00:B2BF: AA           	tax			; PUT STRING POINTER IN X,Y
  3531 00:B2C0: C8           	iny
  3532 00:B2C1: B1 AB        	lda	(STRNG1),y
  3533 00:B2C3: A8           	tay
  3534 00:B2C4: 68           	pla			; RETRIEVE LENGTH
  3535                        
  3536                        
  3537                        ; ----------------------------------------------------------------------------
  3538                        ; MOVE STRING AT (Y,X) WITH LENGTH (A)
  3539                        ; TO DESTINATION WHOSE ADDRESS IS IN FRESPC,FRESPC+1
  3540                        ; ----------------------------------------------------------------------------
  3541 00:B2C5: 86 5E        MOVSTR:	stx	INDEX		; PUT POINTER IN INDEX
  3542 00:B2C7: 84 5F        	sty	INDEX+1
  3543                        MOVSTR1:
  3544 00:B2C9: A8           	tay			; LENGTH TO Y-REG
  3545 00:B2CA: F0 0A        	beq	MOVSTR2		; IF LENGTH IS ZERO, FINISHED
  3546 00:B2CC: 48           	pha			; SAVE LENGTH ON STACK
  3547                        MOVSTR11:
  3548 00:B2CD: 88           	dey			; MOVE BYTES FROM (INDEX) TO (FRESPC)
  3549 00:B2CE: B1 5E        	lda	(INDEX),y
  3550 00:B2D0: 91 71        	sta	(FRESPC),y
  3551 00:B2D2: 98           	tya			; TEST IF ANY LEFT TO MOVE
  3552 00:B2D3: D0 F8        	bne	MOVSTR11		; YES, KEEP MOVING
  3553 00:B2D5: 68           	pla			; NO, FINISHED.  GET LENGTH
  3554                        MOVSTR2:
  3555 00:B2D6: 18           	clc			; AND ADD TO FRESPC, SO
  3556 00:B2D7: 65 71        	adc	FRESPC		; FRESPC POINTS TO NEXT HIGHER
  3557 00:B2D9: 85 71        	sta	FRESPC		; BYTE.  (USED BY CONCATENATION)
  3558 00:B2DB: 90 02        	bcc	MOVSTR4
  3559 00:B2DD: E6 72        	inc	FRESPC+1
  3560 00:B2DF: 60           MOVSTR4:	rts
  3561                        
  3562                        
  3563                        ; ----------------------------------------------------------------------------
  3564                        ; IF (FAC) IS A TEMPORARY STRING, RELEASE DESCRIPTOR
  3565                        ; ----------------------------------------------------------------------------
  3566 00:B2E0: 20 39 AB     FRESTR:	jsr	CHKSTR		; LAST RESULT A STRING?
  3567                        
  3568                        
  3569                        ; ----------------------------------------------------------------------------
  3570                        ; IF STRING DESCRIPTOR POINTED TO BY FAC+3,4 IS
  3571                        ; A TEMPORARY STRING, RELEASE IT.
  3572                        ; ----------------------------------------------------------------------------
  3573 00:B2E3: A5 A0        FREFAC:	lda	FAC+3		; GET DESCRIPTOR POINTER
  3574 00:B2E5: A4 A1        	ldy	FAC+4
  3575                        
  3576                        
  3577                        ; ----------------------------------------------------------------------------
  3578                        ; IF STRING DESCRIPTOR WHOSE ADDRESS IS IN Y,A IS
  3579                        ; A TEMPORARY STRING, RELEASE IT.
  3580                        ; ----------------------------------------------------------------------------
  3581 00:B2E7: 85 5E        FRETMP:	sta	INDEX		; SAVE THE ADDRESS OF THE DESCRIPTOR
  3582 00:B2E9: 84 5F        	sty	INDEX+1
  3583 00:B2EB: 20 18 B3     	jsr	FRETMS		; FREE DESCRIPTOR IF IT IS TEMPORARY
  3584 00:B2EE: 08           	php			; REMEMBER IF TEMP
  3585 00:B2EF: A0 00        	ldy	#0		; POINT AT LENGTH OF STRING
  3586 00:B2F1: B1 5E        	lda	(INDEX),y
  3587 00:B2F3: 48           	pha			; SAVE LENGTH ON STACK
  3588 00:B2F4: C8           	iny
  3589 00:B2F5: B1 5E        	lda	(INDEX),y
  3590 00:B2F7: AA           	tax			; GET ADDRESS OF STRING IN Y,X
  3591 00:B2F8: C8           	iny
  3592 00:B2F9: B1 5E        	lda	(INDEX),y
  3593 00:B2FB: A8           	tay
  3594 00:B2FC: 68           	pla			; LENGTH IN A
  3595 00:B2FD: 28           	plp			; RETRIEVE STATUS, Z=1 IF TEMP
  3596 00:B2FE: D0 13        	bne	FRETMP2		; NOT A TEMPORARY STRING
  3597 00:B300: C4 70        	cpy	FRETOP+1	; IS IT THE LOWEST STRING?
  3598 00:B302: D0 0F        	bne	FRETMP2		; NO
  3599 00:B304: E4 6F        	cpx	FRETOP
  3600 00:B306: D0 0B        	bne	FRETMP2		; NO
  3601 00:B308: 48           	pha			; YES, PUSH LENGTH AGAIN
  3602 00:B309: 18           	clc			; RECOVER THE SPACE USED BY
  3603 00:B30A: 65 6F        	adc	FRETOP		; THE STRING
  3604 00:B30C: 85 6F        	sta	FRETOP
  3605 00:B30E: 90 02        	bcc	FRETMP1
  3606 00:B310: E6 70        	inc	FRETOP+1
  3607                        FRETMP1:
  3608 00:B312: 68           	pla			; RETRIEVE LENGTH AGAIN
  3609                        FRETMP2:
  3610 00:B313: 86 5E        	stx	INDEX		; ADDRESS OF STRING IN Y,X
  3611 00:B315: 84 5F        	sty	INDEX+1		; LENGTH OF STRING IN A-REG
  3612 00:B317: 60           	rts
  3613                        
  3614                        
  3615                        ; ----------------------------------------------------------------------------
  3616                        ; RELEASE TEMPORARY DESCRIPTOR IF Y,A = LASTPT
  3617                        ; ----------------------------------------------------------------------------
  3618 00:B318: C4 54        FRETMS:	cpy	LASTPT+1	; COMPARE Y,A TO LATEST TEMP
  3619 00:B31A: D0 0C        	bne	FRETMS1		; NOT SAME ONE, CANNOT RELEASE
  3620 00:B31C: C5 53        	cmp	LASTPT
  3621 00:B31E: D0 08        	bne	FRETMS1		; NOT SAME ONE, CANNOT RELEASE
  3622 00:B320: 85 52        	sta	TEMPPT		; UPDATE TEMPT FOR NEXT TEMP
  3623 00:B322: E9 03        	sbc	#3		; BACK OFF LASTPT
  3624 00:B324: 85 53        	sta	LASTPT
  3625 00:B326: A0 00        	ldy	#0		; NOW Y,A POINTS TO TOP TEMP
  3626                        FRETMS1:
  3627 00:B328: 60           	rts			; Z=0 IF NOT TEMP, Z=1 IF TEMP
  3628                        
  3629                        
  3630                        ; ----------------------------------------------------------------------------
  3631                        ; "CHR$" FUNCTION
  3632                        ; ----------------------------------------------------------------------------
  3633 00:B329: 20 DE B3     CHRSTR:	jsr	CONINT		; CONVERT ARGUMENT TO BYTE IN X
  3634 00:B32C: 8A           	txa
  3635 00:B32D: 48           	pha			; SAVE IT
  3636 00:B32E: A9 01        	lda	#1		; GET SPACE FOR STRING OF LENGTH 1
  3637 00:B330: 20 C0 B0     	jsr	STRSPA
  3638 00:B333: 68           	pla			; RECALL THE CHARACTER
  3639 00:B334: A0 00        	ldy	#0		; PUT IN STRING
  3640 00:B336: 91 9E        	sta	(FAC+1),y
  3641 00:B338: 68           	pla			; POP RETURN ADDRESS
  3642 00:B339: 68           	pla
  3643 00:B33A: 4C 0D B1     	jmp	PUTNEW		; MAKE IT A TEMPORARY STRING
  3644                        
  3645                        
  3646                        ; ----------------------------------------------------------------------------
  3647                        ; "LEFT$" FUNCTION
  3648                        ; ----------------------------------------------------------------------------
  3649                        LEFTSTR:
  3650 00:B33D: 20 9C B3     	jsr	SUBSTRING_SETUP
  3651 00:B340: D1 8C        	cmp	(DSCPTR),y	; COMPARE 1ST PARAMETER TO LENGTH
  3652 00:B342: 98           	tya			; Y=A=0
  3653                        SUBSTRING1:
  3654 00:B343: 90 04        	bcc	LEFTSTR1		; 1ST PARAMETER SMALLER, USE IT
  3655 00:B345: B1 8C        	lda	(DSCPTR),y	; 1ST IS LONGER, USE STRING LENGTH
  3656 00:B347: AA           	tax			; IN X-REG
  3657 00:B348: 98           	tya			; Y=A=0 AGAIN
  3658                        LEFTSTR1:
  3659 00:B349: 48           	pha			; PUSH LEFT END OF SUBSTRING
  3660                        SUBSTRING2:
  3661 00:B34A: 8A           	txa
  3662                        SUBSTRING3:
  3663 00:B34B: 48           	pha			; PUSH LENGTH OF SUBSTRING
  3664 00:B34C: 20 C0 B0     	jsr	STRSPA		; MAKE ROOM FOR STRING OF (A) BYTES
  3665 00:B34F: A5 8C        	lda	DSCPTR		; RELEASE PARAMETER STRING IF TEMP
  3666 00:B351: A4 8D        	ldy	DSCPTR+1
  3667 00:B353: 20 E7 B2     	jsr	FRETMP
  3668 00:B356: 68           	pla			; GET LENGTH OF SUBSTRING
  3669 00:B357: A8           	tay			; IN Y-REG
  3670 00:B358: 68           	pla			; GET LEFT END OF SUBSTRING
  3671 00:B359: 18           	clc			; ADD TO POINTER TO STRING
  3672 00:B35A: 65 5E        	adc	INDEX
  3673 00:B35C: 85 5E        	sta	INDEX
  3674 00:B35E: 90 02        	bcc	SUBSTRING31
  3675 00:B360: E6 5F        	inc	INDEX+1
  3676                        SUBSTRING31:
  3677 00:B362: 98           	tya			; LENGTH
  3678 00:B363: 20 C9 B2     	jsr	MOVSTR1		; COPY STRING INTO SPACE
  3679 00:B366: 4C 0D B1     	jmp	PUTNEW		; ADD TO TEMPS
  3680                        
  3681                        
  3682                        ; ----------------------------------------------------------------------------
  3683                        ; "RIGHT$" FUNCTION
  3684                        ; ----------------------------------------------------------------------------
  3685                        RIGHTSTR:
  3686 00:B369: 20 9C B3     	jsr	SUBSTRING_SETUP
  3687 00:B36C: 18           	clc			; COMPUTE LENGTH-WIDTH OF SUBSTRING
  3688 00:B36D: F1 8C        	sbc	(DSCPTR),y	; TO GET STARTING POINT IN STRING
  3689 00:B36F: 49 FF        	eor	#$FF
  3690 00:B371: 4C 43 B3     	jmp	SUBSTRING1	; JOIN LEFT$
  3691                        
  3692                        
  3693                        ; ----------------------------------------------------------------------------
  3694                        ; "MID$" FUNCTION
  3695                        ; ----------------------------------------------------------------------------
  3696 00:B374: A9 FF        MIDSTR:	lda	#$FF		; FLAG WHETHER 2ND PARAMETER
  3697 00:B376: 85 A1        	sta	FAC+4
  3698 00:B378: 20 B7 00     	jsr	CHRGOT		; SEE IF ")" YET
  3699 00:B37B: C9 29        	cmp	#')'
  3700 00:B37D: F0 06        	beq	MIDSTR1		; YES, NO 2ND PARAMETER
  3701 00:B37F: 20 84 AC     	jsr	CHKCOM		; NO, MUST HAVE COMMA
  3702 00:B382: 20 DB B3     	jsr	GETBYT		; GET 2ND PARAM IN X-REG
  3703                        MIDSTR1:
  3704 00:B385: 20 9C B3     	jsr	SUBSTRING_SETUP
  3705 00:B388: CA           	dex			; 1ST PARAMETER - 1
  3706 00:B389: 8A           	txa
  3707 00:B38A: 48           	pha
  3708 00:B38B: 18           	clc
  3709 00:B38C: A2 00        	ldx	#0
  3710 00:B38E: F1 8C        	sbc	(DSCPTR),y
  3711 00:B390: B0 B8        	bcs	SUBSTRING2
  3712 00:B392: 49 FF        	eor	#$FF
  3713 00:B394: C5 A1        	cmp	FAC+4		; USE SMALLER OF TWO
  3714 00:B396: 90 B3        	bcc	SUBSTRING3
  3715 00:B398: A5 A1        	lda	FAC+4
  3716 00:B39A: B0 AF        	bcs	SUBSTRING3	; ...ALWAYS
  3717                        
  3718                        
  3719                        ; ----------------------------------------------------------------------------
  3720                        ; COMMON SETUP ROUTINE FOR LEFT$, RIGHT$, MID$:
  3721                        ; REQUIRE ")"; POP RETURN ADRS, GET DESCRIPTOR
  3722                        ; ADDRESS, GET 1ST PARAMETER OF COMMAND
  3723                        ; ----------------------------------------------------------------------------
  3724                        SUBSTRING_SETUP:
  3725 00:B39C: 20 7E AC     	jsr	CHKCLS		; REQUIRE ")"
  3726 00:B39F: 68           	pla			; SAVE RETURN ADDRESS
  3727 00:B3A0: A8           	tay			; IN Y-REG AND LENGTH
  3728 00:B3A1: 68           	pla
  3729 00:B3A2: 85 91        	sta	LENGTH
  3730 00:B3A4: 68           	pla			; POP PREVIOUS RETURN ADDRESS
  3731 00:B3A5: 68           	pla			; (FROM GOROUT).
  3732 00:B3A6: 68           	pla			; RETRIEVE 1ST PARAMETER
  3733 00:B3A7: AA           	tax
  3734 00:B3A8: 68           	pla			; GET ADDRESS OF STRING DESCRIPTOR
  3735 00:B3A9: 85 8C        	sta	DSCPTR
  3736 00:B3AB: 68           	pla
  3737 00:B3AC: 85 8D        	sta	DSCPTR+1
  3738 00:B3AE: A5 91        	lda	LENGTH		; RESTORE RETURN ADDRESS
  3739 00:B3B0: 48           	pha
  3740 00:B3B1: 98           	tya
  3741 00:B3B2: 48           	pha
  3742 00:B3B3: A0 00        	ldy	#0
  3743 00:B3B5: 8A           	txa			; GET 1ST PARAMETER IN A-REG
  3744 00:B3B6: F0 1D        	beq	GOIQ		; ERROR IF 0
  3745 00:B3B8: 60           	rts
  3746                        
  3747                        
  3748                        ; ----------------------------------------------------------------------------
  3749                        ; "LEN" FUNCTION
  3750                        ; ----------------------------------------------------------------------------
  3751 00:B3B9: 20 BF B3     LEN:	jsr	GETSTR		; GET LENTGH IN Y-REG, MAKE FAC NUMERIC
  3752 00:B3BC: 4C 9A B0     	jmp	SNGFLT		; FLOAT Y-REG INTO FAC
  3753                        
  3754                        
  3755                        ; ----------------------------------------------------------------------------
  3756                        ; IF LAST RESULT IS A TEMPORARY STRING, FREE IT
  3757                        ; MAKE VALTYP NUMERIC, RETURN LENGTH IN Y-REG
  3758                        ; ----------------------------------------------------------------------------
  3759 00:B3BF: 20 E0 B2     GETSTR:	jsr	FRESTR		; IF LAST RESULT IS A STRING, FREE IT
  3760 00:B3C2: A2 00        	ldx	#0		; MAKE VALTYP NUMERIC
  3761 00:B3C4: 86 11        	stx	VALTYP
  3762 00:B3C6: A8           	tay			; LENGTH OF STRING TO Y-REG
  3763 00:B3C7: 60           	rts
  3764                        
  3765                        
  3766                        ; ----------------------------------------------------------------------------
  3767                        ; "ASC" FUNCTION
  3768                        ; ----------------------------------------------------------------------------
  3769 00:B3C8: 20 BF B3     ASC:	jsr	GETSTR		; GET STRING, GET LENGTH IN Y-REG
  3770 00:B3CB: F0 08        	beq	GOIQ		; ERROR IF LENGTH 0
  3771 00:B3CD: A0 00        	ldy	#0
  3772 00:B3CF: B1 5E        	lda	(INDEX),y	; GET 1ST CHAR OF STRING
  3773 00:B3D1: A8           	tay
  3774 00:B3D2: 4C 9A B0     	jmp	SNGFLT		; FLOAT Y-REG INTO FAC
  3775                        ; ----------------------------------------------------------------------------
  3776 00:B3D5: 4C 35 AF     GOIQ:	jmp	IQERR		; ILLEGAL QUANTITY ERROR
  3777                        
  3778                        
  3779                        ; ----------------------------------------------------------------------------
  3780                        ; SCAN TO NEXT CHARACTER AND CONVERT EXPRESSION
  3781                        ; TO SINGLE BYTE IN X-REG
  3782                        ; ----------------------------------------------------------------------------
  3783 00:B3D8: 20 B1 00     GTBYTC:	jsr	CHRGET
  3784                        
  3785                        
  3786                        ; ----------------------------------------------------------------------------
  3787                        ; EVALUATE EXPRESSION AT TXTPTR, AND
  3788                        ; CONVERT IT TO SINGLE BYTE IN X-REG
  3789                        ; ----------------------------------------------------------------------------
  3790 00:B3DB: 20 34 AB     GETBYT:	jsr	FRMNUM
  3791                        
  3792                        
  3793                        ; ----------------------------------------------------------------------------
  3794                        ; CONVERT (FAC) TO SINGLE BYTE INTEGER IN X-REG
  3795                        ; ----------------------------------------------------------------------------
  3796 00:B3DE: 20 A4 AE     CONINT:	jsr	MKINT		; CONVERT IF IN RANGE -32767 TO +32767
  3797 00:B3E1: A6 A0        	ldx	FAC+3		; HI-BYTE MUST BE ZERO
  3798 00:B3E3: D0 F0        	bne	GOIQ		; VALUE > 255, ERROR
  3799 00:B3E5: A6 A1        	ldx	FAC+4		; VALUE IN X-REG
  3800 00:B3E7: 4C B7 00     	jmp	CHRGOT		; GET NEXT CHAR IN A-REG
  3801                        
  3802                        
  3803                        ; ----------------------------------------------------------------------------
  3804                        ; "VAL" FUNCTION
  3805                        ; ----------------------------------------------------------------------------
  3806 00:B3EA: 20 BF B3     VAL:	jsr	GETSTR		; GET POINTER TO STRING IN INDEX
  3807 00:B3ED: D0 03        	bne	VAL_1		; LENGTH NON-ZERO
  3808 00:B3EF: 4C 15 B5     	jmp	ZERO_FAC	; RETURN 0 IF LENGTH=0
  3809 00:B3F2: A6 B8        VAL_1:	ldx	TXTPTR		; SAVE CURRENT TXTPTR
  3810 00:B3F4: A4 B9        	ldy	TXTPTR+1
  3811 00:B3F6: 86 AD        	stx	STRNG2
  3812 00:B3F8: 84 AE        	sty	STRNG2+1
  3813 00:B3FA: A6 5E        	ldx	INDEX
  3814 00:B3FC: 86 B8        	stx	TXTPTR		; POINT TXTPTR TO START OF STRING
  3815 00:B3FE: 18           	clc
  3816 00:B3FF: 65 5E        	adc	INDEX		; ADD LENGTH
  3817 00:B401: 85 60        	sta	DEST		; POINT DEST TO END OF STRING + 1
  3818 00:B403: A6 5F        	ldx	INDEX+1
  3819 00:B405: 86 B9        	stx	TXTPTR+1
  3820 00:B407: 90 01        	bcc	VAL_2
  3821 00:B409: E8           	inx
  3822 00:B40A: 86 61        VAL_2:	stx	DEST+1
  3823 00:B40C: A0 00        	ldy	#0		; SAVE BYTE THAT FOLLOWS STRING
  3824 00:B40E: B1 60        	lda	(DEST),y	; ON STACK
  3825 00:B410: 48           	pha
  3826 00:B411: A9 00        	lda	#0		; AND STORE $00 IN ITS PLACE
  3827 00:B413: 91 60        	sta	(DEST),y
  3828 00:B415: 20 B7 00     	jsr	CHRGOT		; PRIME THE PUMP
  3829 00:B418: 20 09 B9     	jsr	FIN		; EVALUATE STRING
  3830 00:B41B: 68           	pla			; GET BYTE THAT SHOULD FOLLOW STRING
  3831 00:B41C: A0 00        	ldy	#0		; AND PUT IT BACK
  3832 00:B41E: 91 60        	sta	(DEST),y
  3833                        
  3834                        
  3835                        ; ----------------------------------------------------------------------------
  3836                        ; COPY STRNG2 INTO TXTPTR
  3837                        ; ----------------------------------------------------------------------------
  3838 00:B420: A6 AD        POINT:	ldx	STRNG2
  3839 00:B422: A4 AE        	ldy	STRNG2+1
  3840 00:B424: 86 B8        	stx	TXTPTR
  3841 00:B426: 84 B9        	sty	TXTPTR+1
  3842 00:B428: 60           	rts
  3843                        
  3844                        
  3845                        ; ----------------------------------------------------------------------------
  3846                        ; EVALUATE "EXP1,EXP2"
  3847                        ;
  3848                        ; CONVERT EXP1 TO 16-BIT NUMBER IN LINNUM
  3849                        ; CONVERT EXP2 TO 8-BIT NUMBER IN X-REG
  3850                        ; ----------------------------------------------------------------------------
  3851 00:B429: 20 34 AB     GTNUM:	jsr	FRMNUM
  3852 00:B42C: 20 35 B4     	jsr	GETADR
  3853                        
  3854                        
  3855                        ; ----------------------------------------------------------------------------
  3856                        ; EVALUATE ",EXPRESSION"
  3857                        ; CONVERT EXPRESSION TO SINGLE BYTE IN X-REG
  3858                        ; ----------------------------------------------------------------------------
  3859                        COMBYTE:
  3860 00:B42F: 20 84 AC     	jsr	CHKCOM		; MUST HAVE COMMA FIRST
  3861 00:B432: 4C DB B3     	jmp	GETBYT		; CONVERT EXPRESSION TO BYTE IN X-REG
  3862                        
  3863                        
  3864                        ; ----------------------------------------------------------------------------
  3865                        ; CONVERT (FAC) TO A 16-BIT VALUE IN LINNUM
  3866                        ; ----------------------------------------------------------------------------
  3867 00:B435: A5 9D        GETADR:	lda	FAC		; FAC < 2^16?
  3868 00:B437: C9 91        	cmp	#$91
  3869 00:B439: B0 9A        	bcs	GOIQ		; NO, ILLEGAL QUANTITY
  3870 00:B43B: 20 B1 B8     	jsr	QINT		; CONVERT TO INTEGER
  3871 00:B43E: A5 A0        	lda	FAC+3		; COPY IT INTO LINNUM
  3872 00:B440: A4 A1        	ldy	FAC+4
  3873 00:B442: 84 50        	sty	LINNUM		; TO LINNUM
  3874 00:B444: 85 51        	sta	LINNUM+1
  3875 00:B446: 60           	rts
  3876                        
  3877                        
  3878                        ; ----------------------------------------------------------------------------
  3879                        ; "PEEK" FUNCTION
  3880                        ; ----------------------------------------------------------------------------
  3881 00:B447: A5 50        PEEK:	lda	LINNUM		; SAVE (LINNUM) ON STACK DURING PEEK
  3882 00:B449: 48           	pha
  3883 00:B44A: A5 51        	lda	LINNUM+1
  3884 00:B44C: 48           	pha
  3885 00:B44D: 20 35 B4     	jsr	GETADR		; GET ADDRESS PEEKING AT
  3886 00:B450: A0 00        	ldy	#0
  3887 00:B452: B1 50        	lda	(LINNUM),y	; TAKE A QUICK LOOK
  3888 00:B454: A8           	tay			; VALUE IN Y-REG
  3889 00:B455: 68           	pla			; RESTORE LINNUM FROM STACK
  3890 00:B456: 85 51        	sta	LINNUM+1
  3891 00:B458: 68           	pla
  3892 00:B459: 85 50        	sta	LINNUM
  3893 00:B45B: 4C 9A B0     	jmp	SNGFLT		; FLOAT Y-REG INTO FAC
  3894                        
  3895                        
  3896                        ; ----------------------------------------------------------------------------
  3897                        ; "POKE" STATEMENT
  3898                        ; ----------------------------------------------------------------------------
  3899 00:B45E: 20 29 B4     POKE:	jsr	GTNUM		; GET THE ADDRESS AND VALUE
  3900 00:B461: 8A           	txa			; VALUE IN A,
  3901 00:B462: A0 00        	ldy	#0
  3902 00:B464: 91 50        	sta	(LINNUM),y	; STORE IT AWAY,
  3903 00:B466: 60           RTS10:	rts			; AND THAT'S ALL FOR TODAY
  3904                        
  3905                        
  3906                        ; ----------------------------------------------------------------------------
  3907                        ; ADD 0.5 TO FAC
  3908                        ; ----------------------------------------------------------------------------
  3909 00:B467: A9 21        FADDH_:	lda	#<CON_HALF	; FAC+1/2 -> FAC
  3910 00:B469: A0 BB        	ldy	#>CON_HALF
  3911 00:B46B: 4C 85 B4     	jmp	FADD
  3912                        
  3913                        
  3914                        ; ----------------------------------------------------------------------------
  3915                        ; FAC = (Y,A) - FAC
  3916                        ; ----------------------------------------------------------------------------
  3917 00:B46E: 20 A8 B6     FSUB:	jsr	LOAD_ARG_FROM_YA
  3918                        
  3919                        
  3920                        ; ----------------------------------------------------------------------------
  3921                        ; FAC = ARG - FAC
  3922                        ; ----------------------------------------------------------------------------
  3923 00:B471: A5 A2        FSUBT:	lda	FACSIGN		; COMPLEMENT FAC AND ADD
  3924 00:B473: 49 FF        	eor	#$FF
  3925 00:B475: 85 A2        	sta	FACSIGN
  3926 00:B477: 45 AA        	eor	ARGSIGN		; FIX SGNCPR TOO
  3927 00:B479: 85 AB        	sta	SGNCPR
  3928 00:B47B: A5 9D        	lda	FAC		; MAKE STATUS SHOW FAC EXPONENT
  3929 00:B47D: 4C 88 B4     	jmp	FADDT		; JOIN FADD
  3930                        
  3931                        
  3932                        ; ----------------------------------------------------------------------------
  3933                        ; SHIFT SMALLER ARGUMENT MORE THAN 7 BITS
  3934                        ; ----------------------------------------------------------------------------
  3935 00:B480: 20 B7 B5     FADD1:	jsr	SHIFT_RIGHT	; ALIGN RADIX BY SHIFTING
  3936 00:B483: 90 3C        	bcc	FADD3		; ...ALWAYS
  3937                        
  3938                        
  3939                        ; ----------------------------------------------------------------------------
  3940                        ; FAC = (Y,A) + FAC
  3941                        ; ----------------------------------------------------------------------------
  3942 00:B485: 20 A8 B6     FADD:	jsr	LOAD_ARG_FROM_YA
  3943                        
  3944                        
  3945                        ; ----------------------------------------------------------------------------
  3946                        ; FAC = ARG + FAC
  3947                        ; ----------------------------------------------------------------------------
  3948 00:B488: D0 03        FADDT:	bne	FADDT1		; FAC IS NON-ZERO
  3949 00:B48A: 4C 15 B8     	jmp	COPY_ARG_TO_FAC	; FAC = 0 + ARG
  3950 00:B48D: A6 AC        FADDT1:	ldx	FACEXTENSION
  3951 00:B48F: 86 92        	stx	ARGEXTENSION
  3952 00:B491: A2 A5        	ldx	#ARG		; SET UP TO SHIFT ARG
  3953 00:B493: A5 A5        	lda	ARG		; EXPONENT
  3954                        
  3955                        ; ----------------------------------------------------------------------------
  3956 00:B495: A8           FADD2:	tay
  3957 00:B496: F0 CE        	beq	RTS10		; IF ARG=0, WE ARE FINISHED
  3958 00:B498: 38           	sec
  3959 00:B499: E5 9D        	sbc	FAC		; GET DIFFNCE OF EXP
  3960 00:B49B: F0 24        	beq	FADD3		; GO ADD IF SAME EXP
  3961 00:B49D: 90 12        	bcc	FADD21		; ARG HAS SMALLER EXPONENT
  3962 00:B49F: 84 9D        	sty	FAC		; EXP HAS SMALLER EXPONENT
  3963 00:B4A1: A4 AA        	ldy	ARGSIGN
  3964 00:B4A3: 84 A2        	sty	FACSIGN
  3965 00:B4A5: 49 FF        	eor	#$FF		; COMPLEMENT SHIFT COUNT
  3966 00:B4A7: 69 00        	adc	#0		; CARRY WAS SET
  3967 00:B4A9: A0 00        	ldy	#0
  3968 00:B4AB: 84 92        	sty	ARGEXTENSION
  3969 00:B4AD: A2 9D        	ldx	#FAC		; SET UP TO SHIFT FAC
  3970 00:B4AF: D0 04        	bne	FADD22		; ...ALWAYS
  3971 00:B4B1: A0 00        FADD21:	ldy	#0
  3972 00:B4B3: 84 AC        	sty	FACEXTENSION
  3973 00:B4B5: C9 F9        FADD22:	cmp	#$F9		; SHIFT MORE THAN 7 BITS?
  3974 00:B4B7: 30 C7        	bmi	FADD1		; YES
  3975 00:B4B9: A8           	tay			; INDEX TO # OF SHIFTS
  3976 00:B4BA: A5 AC        	lda	FACEXTENSION
  3977 00:B4BC: 56 01        	lsr	<1,x		; START SHIFTING...
  3978 00:B4BE: 20 CE B5     	jsr	SHIFT_RIGHT4	; ...COMPLETE SHIFTING
  3979 00:B4C1: 24 AB        FADD3:  bit	SGNCPR		; DO FAC AND ARG HAVE SAME SIGNS?
  3980 00:B4C3: 10 57        	bpl	FADD4		; YES, ADD THE MANTISSAS
  3981 00:B4C5: A0 9D        	ldy	#FAC		; NO, SUBTRACT SMALLER FROM LARGER
  3982 00:B4C7: E0 A5        	cpx	#ARG		; WHICH WAS ADJUSTED?
  3983 00:B4C9: F0 02        	beq	FADD31		; IF ARG, DO FAC-ARG
  3984 00:B4CB: A0 A5        	ldy	#ARG		; IF FAC, DO ARG-FAC
  3985 00:B4CD: 38           FADD31:	sec			; SUBTRACT SMALLER FROM LARGER (WE HOPE)
  3986 00:B4CE: 49 FF        	eor	#$FF		; (IF EXPONENTS WERE EQUAL, WE MIGHT BE
  3987 00:B4D0: 65 92        	adc	ARGEXTENSION	; SUBTRACTING LARGER FROM SMALLER)
  3988 00:B4D2: 85 AC        	sta	FACEXTENSION
  3989 00:B4D4: B9 04 00     	lda	4,y
  3990 00:B4D7: F5 04        	sbc	<4,x
  3991 00:B4D9: 85 A1        	sta	FAC+4
  3992 00:B4DB: B9 03 00     	lda	3,y
  3993 00:B4DE: F5 03        	sbc	<3,x
  3994 00:B4E0: 85 A0        	sta	FAC+3
  3995 00:B4E2: B9 02 00     	lda	2,y
  3996 00:B4E5: F5 02        	sbc	<2,x
  3997 00:B4E7: 85 9F        	sta	FAC+2
  3998 00:B4E9: B9 01 00     	lda	1,y
  3999 00:B4EC: F5 01        	sbc	<1,x
  4000 00:B4EE: 85 9E        	sta	FAC+1
  4001                        
  4002                        
  4003                        ; ----------------------------------------------------------------------------
  4004                        ; NORMALIZE VALUE IN FAC
  4005                        ; ----------------------------------------------------------------------------
  4006                        NORMALIZE_FAC1:
  4007 00:B4F0: B0 03        	bcs	NORMALIZE_FAC2
  4008 00:B4F2: 20 65 B5     	jsr	COMPLEMENT_FAC
  4009                        ; ----------------------------------------------------------------------------
  4010                        NORMALIZE_FAC2:
  4011 00:B4F5: A0 00        	ldy	#0		; SHIFT UP SIGNIF DIGIT
  4012 00:B4F7: 98           	tya			; START A=0, COUNT SHIFTS IN A-REG
  4013 00:B4F8: 18           	clc
  4014                        NORMAL1:
  4015 00:B4F9: A6 9E        	ldx	FAC+1		; LOOK AT MOST SIGNIFICANT BYTE
  4016 00:B4FB: D0 4A        	bne	NORMALIZE_FAC4	; SOME 1-BITS HERE
  4017 00:B4FD: A6 9F        	ldx	FAC+2		; HI-BYTE OF MANTISSA STILL ZERO,
  4018 00:B4FF: 86 9E        	stx	FAC+1		; SO DO A FAST 8-BIT SHUFFLE
  4019 00:B501: A6 A0        	ldx	FAC+3
  4020 00:B503: 86 9F        	stx	FAC+2
  4021 00:B505: A6 A1        	ldx	FAC+4
  4022 00:B507: 86 A0        	stx	FAC+3
  4023 00:B509: A6 AC        	ldx	FACEXTENSION
  4024 00:B50B: 86 A1        	stx	FAC+4
  4025 00:B50D: 84 AC        	sty	FACEXTENSION	; ZERO EXTENSION BYTE
  4026 00:B50F: 69 08        	adc	#8		; BUMP SHIFT COUNT
  4027 00:B511: C9 20        	cmp	#32		; DONE 4 TIMES YET?
  4028 00:B513: D0 E4        	bne	NORMAL1		; NO, STILL MIGHT BE SOME 1'S (YES, VALUE OF FAC IS ZERO)
  4029                        
  4030                        
  4031                        ; ----------------------------------------------------------------------------
  4032                        ; SET FAC = 0
  4033                        ; (ONLY NECESSARY TO ZERO EXPONENT AND SIGN CELLS)
  4034                        ; ----------------------------------------------------------------------------
  4035                        ZERO_FAC:
  4036 00:B515: A9 00        	lda	#0
  4037                        ; ----------------------------------------------------------------------------
  4038                        STA_IN_FAC_SIGN_AND_EXP:
  4039 00:B517: 85 9D        	sta	FAC
  4040                        ; ----------------------------------------------------------------------------
  4041                        STA_IN_FAC_SIGN:
  4042 00:B519: 85 A2        	sta	FACSIGN
  4043 00:B51B: 60           	rts
  4044                        
  4045                        
  4046                        ; ----------------------------------------------------------------------------
  4047                        ; ADD MANTISSAS OF FAC AND ARG INTO FAC
  4048                        ; ----------------------------------------------------------------------------
  4049 00:B51C: 65 92        FADD4:	adc	ARGEXTENSION
  4050 00:B51E: 85 AC        	sta	FACEXTENSION
  4051 00:B520: A5 A1        	lda	FAC+4
  4052 00:B522: 65 A9        	adc	ARG+4
  4053 00:B524: 85 A1        	sta	FAC+4
  4054 00:B526: A5 A0        	lda	FAC+3
  4055 00:B528: 65 A8        	adc	ARG+3
  4056 00:B52A: 85 A0        	sta	FAC+3
  4057 00:B52C: A5 9F        	lda	FAC+2
  4058 00:B52E: 65 A7        	adc	ARG+2
  4059 00:B530: 85 9F        	sta	FAC+2
  4060 00:B532: A5 9E        	lda	FAC+1
  4061 00:B534: 65 A6        	adc	ARG+1
  4062 00:B536: 85 9E        	sta	FAC+1
  4063 00:B538: 4C 54 B5     	jmp	NORMALIZE_FAC5
  4064                        
  4065                        
  4066                        ; ----------------------------------------------------------------------------
  4067                        ; FINISH NORMALIZING FAC
  4068                        ; ----------------------------------------------------------------------------
  4069                        NORMALIZE_FAC3:
  4070 00:B53B: 69 01        	adc	#1		; COUNT BITS SHIFTED
  4071 00:B53D: 06 AC        	asl	FACEXTENSION
  4072 00:B53F: 26 A1        	rol	FAC+4
  4073 00:B541: 26 A0        	rol	FAC+3
  4074 00:B543: 26 9F        	rol	FAC+2
  4075 00:B545: 26 9E        	rol	FAC+1
  4076                        ; ----------------------------------------------------------------------------
  4077                        NORMALIZE_FAC4:
  4078 00:B547: 10 F2        	bpl	NORMALIZE_FAC3	; UNTIL TOP BIT = 1
  4079 00:B549: 38           	sec
  4080 00:B54A: E5 9D        	sbc	FAC		; ADJUST EXPONENT BY BITS SHIFTED
  4081 00:B54C: B0 C7        	bcs	ZERO_FAC	; UNDERFLOW, RETURN ZERO
  4082 00:B54E: 49 FF        	eor	#$FF
  4083 00:B550: 69 01        	adc	#1		; 2'S COMPLEMENT
  4084 00:B552: 85 9D        	sta	FAC		; CARRY=0 NOW
  4085                        ; ----------------------------------------------------------------------------
  4086                        NORMALIZE_FAC5:
  4087 00:B554: 90 0E        	bcc	RTS11		; UNLESS MANTISSA CARRIED
  4088                        ; ----------------------------------------------------------------------------
  4089                        NORMALIZE_FAC6:
  4090 00:B556: E6 9D        	inc	FAC		; MANTISSA CARRIED, SO SHIFT RIGHT
  4091 00:B558: F0 42        	beq	OVERFLOW	; OVERFLOW IF EXPONENT TOO BIG
  4092 00:B55A: 66 9E        	ror	FAC+1
  4093 00:B55C: 66 9F        	ror	FAC+2
  4094 00:B55E: 66 A0        	ror	FAC+3
  4095 00:B560: 66 A1        	ror	FAC+4
  4096 00:B562: 66 AC        	ror	FACEXTENSION
  4097 00:B564: 60           RTS11:	rts
  4098                        
  4099                        
  4100                        ; ----------------------------------------------------------------------------
  4101                        ; 2'S COMPLEMENT OF FAC
  4102                        ; ----------------------------------------------------------------------------
  4103                        COMPLEMENT_FAC:
  4104 00:B565: A5 A2        	lda	FACSIGN
  4105 00:B567: 49 FF        	eor	#$FF
  4106 00:B569: 85 A2        	sta	FACSIGN
  4107                        
  4108                        
  4109                        ; ----------------------------------------------------------------------------
  4110                        ; 2'S COMPLEMENT OF FAC MANTISSA ONLY
  4111                        ; ----------------------------------------------------------------------------
  4112                        COMPLEMENT_FAC_MANTISSA:
  4113 00:B56B: A5 9E        	lda	FAC+1
  4114 00:B56D: 49 FF        	eor	#$FF
  4115 00:B56F: 85 9E        	sta	FAC+1
  4116 00:B571: A5 9F        	lda	FAC+2
  4117 00:B573: 49 FF        	eor	#$FF
  4118 00:B575: 85 9F        	sta	FAC+2
  4119 00:B577: A5 A0        	lda	FAC+3
  4120 00:B579: 49 FF        	eor	#$FF
  4121 00:B57B: 85 A0        	sta	FAC+3
  4122 00:B57D: A5 A1        	lda	FAC+4
  4123 00:B57F: 49 FF        	eor	#$FF
  4124 00:B581: 85 A1        	sta	FAC+4
  4125 00:B583: A5 AC        	lda	FACEXTENSION
  4126 00:B585: 49 FF        	eor	#$FF
  4127 00:B587: 85 AC        	sta	FACEXTENSION
  4128 00:B589: E6 AC        	inc	FACEXTENSION	; START INCREMENTING MANTISSA
  4129 00:B58B: D0 0E        	bne	RTS12
  4130                        
  4131                        
  4132                        ; ----------------------------------------------------------------------------
  4133                        ; INCREMENT FAC MANTISSA
  4134                        ; ----------------------------------------------------------------------------
  4135                        INCREMENT_FAC_MANTISSA:
  4136 00:B58D: E6 A1        	inc	FAC+4		; ADD CARRY FROM EXTRA
  4137 00:B58F: D0 0A        	bne	RTS12
  4138 00:B591: E6 A0        	inc	FAC+3
  4139 00:B593: D0 06        	bne	RTS12
  4140 00:B595: E6 9F        	inc	FAC+2
  4141 00:B597: D0 02        	bne	RTS12
  4142 00:B599: E6 9E        	inc	FAC+1
  4143 00:B59B: 60           RTS12:	rts
  4144                        ; ----------------------------------------------------------------------------
  4145                        OVERFLOW:
  4146 00:B59C: A2 28        	ldx	#ERR_OVERFLOW
  4147 00:B59E: 4C DA A2     	jmp	ERROR
  4148                        
  4149                        
  4150                        ; ----------------------------------------------------------------------------
  4151                        ; SHIFT 1,X THRU 5,X RIGHT
  4152                        ; (A) = NEGATIVE OF SHIFT COUNT
  4153                        ; (X) = POINTER TO BYTES TO BE SHIFTED
  4154                        ;
  4155                        ; RETURN WITH (Y)=0, CARRY=0, EXTENSION BITS IN A-REG
  4156                        ; ----------------------------------------------------------------------------
  4157                        SHIFT_RIGHT1:
  4158 00:B5A1: A2 61        	ldx	#RESULT-1	; SHIFT RESULT RIGHT
  4159                        SHIFT_RIGHT2:
  4160 00:B5A3: B4 04        	ldy	<4,x		; SHIFT 8 BITS RIGHT
  4161 00:B5A5: 84 AC        	sty	FACEXTENSION
  4162 00:B5A7: B4 03        	ldy	<3,x
  4163 00:B5A9: 94 04        	sty	<4,x
  4164 00:B5AB: B4 02        	ldy	<2,x
  4165 00:B5AD: 94 03        	sty	<3,x
  4166 00:B5AF: B4 01        	ldy	<1,x
  4167 00:B5B1: 94 02        	sty	<2,x
  4168 00:B5B3: A4 A4        	ldy	SHIFTSIGNEXT	; $00 IF +, $FF IF -
  4169 00:B5B5: 94 01        	sty	<1,x
  4170                        
  4171                        
  4172                        ; ----------------------------------------------------------------------------
  4173                        ; MAIN ENTRY TO RIGHT SHIFT SUBROUTINE
  4174                        ; ----------------------------------------------------------------------------
  4175                        SHIFT_RIGHT:
  4176 00:B5B7: 69 08        	adc	#8
  4177 00:B5B9: 30 E8        	bmi	SHIFT_RIGHT2	; STILL MORE THAN 8 BITS TO GO
  4178 00:B5BB: F0 E6        	beq	SHIFT_RIGHT2	; EXACTLY 8 MORE BITS TO GO
  4179 00:B5BD: E9 08        	sbc	#8		; UNDO ADC ABOVE
  4180 00:B5BF: A8           	tay			; REMAINING SHIFT COUNT
  4181 00:B5C0: A5 AC        	lda	FACEXTENSION
  4182 00:B5C2: B0 14        	bcs	SHIFT_RIGHT5	; FINISHED SHIFTING
  4183                        SHIFT_RIGHT3:
  4184 00:B5C4: 16 01        	asl	<1,x		; SIGN -> CARRY (SIGN EXTENSION)
  4185 00:B5C6: 90 02        	bcc	SHIFT_R1		; SIGN +
  4186 00:B5C8: F6 01        	inc	<1,x		; PUT SIGN IN LSB
  4187                        SHIFT_R1:
  4188 00:B5CA: 76 01        	ror	<1,x		; RESTORE VALUE, SIGN STILL IN CARRY
  4189 00:B5CC: 76 01        	ror	<1,x		; START RIGHT SHIFT, INSERTING SIGN
  4190                        
  4191                        
  4192                        ; ----------------------------------------------------------------------------
  4193                        ; ENTER HERE FOR SHORT SHIFTS WITH NO SIGN EXTENSION
  4194                        ; ----------------------------------------------------------------------------
  4195                        SHIFT_RIGHT4:
  4196 00:B5CE: 76 02        	ror	<2,x
  4197 00:B5D0: 76 03        	ror	<3,x
  4198 00:B5D2: 76 04        	ror	<4,x
  4199 00:B5D4: 6A           	ror	a		; EXTENSION
  4200 00:B5D5: C8           	iny			; COUNT THE SHIFT
  4201 00:B5D6: D0 EC        	bne	SHIFT_RIGHT3
  4202                        SHIFT_RIGHT5:
  4203 00:B5D8: 18           	clc			; RETURN WITH CARRY CLEAR
  4204 00:B5D9: 60           	rts
  4205                        
  4206                        
  4207                        ; ----------------------------------------------------------------------------
  4208                        CON_ONE:
  4209 00:B5DA: 81 00 00 00  	db	$81,$00,$00,$00,$00
       00:B5DE: 00 
  4210                        ; ----------------------------------------------------------------------------
  4211                        POLY_LOG:
  4212 00:B5DF: 03           	db	$03			; # OF COEFFICIENTS - 1
  4213 00:B5E0: 7F 5E 56 CB  	db	$7F,$5E,$56,$CB,$79	; * X^7 +
       00:B5E4: 79 
  4214 00:B5E5: 80 13 9B 0B  	db	$80,$13,$9B,$0B,$64	; * X^5 +
       00:B5E9: 64 
  4215 00:B5EA: 80 76 38 93  	db	$80,$76,$38,$93,$16	; * X^3 +
       00:B5EE: 16 
  4216 00:B5EF: 82 38 AA 3B  	db	$82,$38,$AA,$3B,$20	; * X
       00:B5F3: 20 
  4217                        ; ----------------------------------------------------------------------------
  4218                        CON_SQR_HALF:
  4219 00:B5F4: 80 35 04 F3  	db	$80,$35,$04,$F3,$34
       00:B5F8: 34 
  4220                        CON_SQR_TWO:
  4221 00:B5F9: 81 35 04 F3  	db	$81,$35,$04,$F3,$34
       00:B5FD: 34 
  4222                        CON_NEG_HALF:
  4223 00:B5FE: 80 80 00 00  	db	$80,$80,$00,$00,$00
       00:B602: 00 
  4224                        CON_LOG_TWO:
  4225 00:B603: 80 31 72 17  	db	$80,$31,$72,$17,$F8
       00:B607: F8 
  4226                        
  4227                        
  4228                        ; ----------------------------------------------------------------------------
  4229                        ; "LOG" FUNCTION
  4230                        ; ----------------------------------------------------------------------------
  4231 00:B608: 20 44 B8     LOG:    jsr     SIGN		; GET -1,0,+1 IN A-REG FOR FAC
  4232 00:B60B: F0 02                beq     GIQ		; LOG (0) IS ILLEGAL
  4233 00:B60D: 10 03                bpl     LOG2		; >0 IS OK
  4234 00:B60F: 4C 35 AF     GIQ:    jmp     IQERR		; <= 0 IS NO GOOD
  4235 00:B612: A5 9D        LOG2:   lda     FAC		; FIRST GET LOG BASE 2
  4236 00:B614: E9 7F                sbc     #$7F		; SAVE UNBIASED EXPONENT
  4237 00:B616: 48                   pha
  4238 00:B617: A9 80                lda     #$80		; NORMALIZE BETWEEN .5 AND 1
  4239 00:B619: 85 9D                sta     FAC
  4240 00:B61B: A9 F4                lda     #<CON_SQR_HALF
  4241 00:B61D: A0 B5                ldy     #>CON_SQR_HALF
  4242 00:B61F: 20 85 B4             jsr     FADD		; COMPUTE VIA SERIES OF ODD
  4243 00:B622: A9 F9                lda     #<CON_SQR_TWO	; POWERS OF
  4244 00:B624: A0 B5                ldy     #>CON_SQR_TWO	; (SQR(2)X-1)/(SQR(2)X+1)
  4245 00:B626: 20 28 B7             jsr     FDIV
  4246 00:B629: A9 DA                lda     #<CON_ONE
  4247 00:B62B: A0 B5                ldy     #>CON_ONE
  4248 00:B62D: 20 6E B4             jsr     FSUB
  4249 00:B630: A9 DF                lda     #<POLY_LOG
  4250 00:B632: A0 B5                ldy     #>POLY_LOG
  4251 00:B634: 20 17 BC             jsr     POLYNOMIAL_ODD
  4252 00:B637: A9 FE                lda     #<CON_NEG_HALF
  4253 00:B639: A0 B5                ldy     #>CON_NEG_HALF
  4254 00:B63B: 20 85 B4             jsr     FADD
  4255 00:B63E: 68                   pla
  4256 00:B63F: 20 93 B9             jsr     ADDACC		; ADD ORIGINAL EXPONENT
  4257 00:B642: A9 03                lda     #<CON_LOG_TWO	; MULTIPLY BY LOG(2) TO FORM
  4258 00:B644: A0 B6                ldy     #>CON_LOG_TWO	; NATURAL LOG OF X
  4259                        
  4260                        
  4261                        ; ----------------------------------------------------------------------------
  4262                        ; FAC = (Y,A) * FAC
  4263                        ; ----------------------------------------------------------------------------
  4264 00:B646: 20 A8 B6     FMULT:	jsr	LOAD_ARG_FROM_YA
  4265                        
  4266                        
  4267                        ; ----------------------------------------------------------------------------
  4268                        ; FAC = ARG * FAC
  4269                        ; ----------------------------------------------------------------------------
  4270 00:B649: D0 01        FMULTT:	bne	FMULTT1		; FAC .NE. ZERO
  4271 00:B64B: 60           	rts			; FAC = 0 * ARG = 0
  4272                        FMULTT1:
  4273 00:B64C: 20 D3 B6     	jsr	ADD_EXPONENTS
  4274 00:B64F: A9 00        	lda	#0
  4275 00:B651: 85 62        	sta	RESULT		; INIT PRODUCT = 0
  4276 00:B653: 85 63        	sta	RESULT+1
  4277 00:B655: 85 64        	sta	RESULT+2
  4278 00:B657: 85 65        	sta	RESULT+3
  4279 00:B659: A5 AC        	lda	FACEXTENSION
  4280 00:B65B: 20 75 B6     	jsr	MULTIPLY1
  4281 00:B65E: A5 A1        	lda	FAC+4
  4282 00:B660: 20 75 B6     	jsr	MULTIPLY1
  4283 00:B663: A5 A0        	lda	FAC+3
  4284 00:B665: 20 75 B6     	jsr	MULTIPLY1
  4285 00:B668: A5 9F        	lda	FAC+2
  4286 00:B66A: 20 75 B6     	jsr	MULTIPLY1
  4287 00:B66D: A5 9E        	lda	FAC+1
  4288 00:B66F: 20 7A B6     	jsr	MULTIPLY2
  4289 00:B672: 4C A8 B7     	jmp	COPY_RESULT_INTO_FAC
  4290                        
  4291                        
  4292                        ; ----------------------------------------------------------------------------
  4293                        ; MULTIPLY ARG BY (A) INTO RESULT
  4294                        ; ----------------------------------------------------------------------------
  4295                        MULTIPLY1:
  4296 00:B675: D0 03        	bne	MULTIPLY2	; THIS BYTE NON-ZERO
  4297 00:B677: 4C A1 B5     	jmp	SHIFT_RIGHT1	; (A)=0, JUST SHIFT ARG RIGHT 8
  4298                        ; ----------------------------------------------------------------------------
  4299                        MULTIPLY2:
  4300 00:B67A: 4A           	lsr 	a		; SHIFT BIT INTO CARRY
  4301 00:B67B: 09 80        	ora	#$80		; SUPPLY SENTINEL BIT
  4302                        MULTIPLY21:
  4303 00:B67D: A8           	tay			; REMAINING MULTIPLIER TO Y
  4304 00:B67E: 90 19        	bcc	MULTIPLY22		; THIS MULTIPLIER BIT = 0
  4305 00:B680: 18           	clc			; = 1, SO ADD ARG TO RESULT
  4306 00:B681: A5 65        	lda	RESULT+3
  4307 00:B683: 65 A9        	adc	ARG+4
  4308 00:B685: 85 65        	sta	RESULT+3
  4309 00:B687: A5 64        	lda	RESULT+2
  4310 00:B689: 65 A8        	adc	ARG+3
  4311 00:B68B: 85 64        	sta	RESULT+2
  4312 00:B68D: A5 63        	lda	RESULT+1
  4313 00:B68F: 65 A7        	adc	ARG+2
  4314 00:B691: 85 63        	sta	RESULT+1
  4315 00:B693: A5 62        	lda	RESULT
  4316 00:B695: 65 A6        	adc	ARG+1
  4317 00:B697: 85 62        	sta	RESULT
  4318                        MULTIPLY22:
  4319 00:B699: 66 62        	ror	RESULT		; SHIFT RESULT RIGHT 1
  4320 00:B69B: 66 63        	ror	RESULT+1
  4321 00:B69D: 66 64        	ror	RESULT+2
  4322 00:B69F: 66 65        	ror	RESULT+3
  4323 00:B6A1: 66 AC        	ror	FACEXTENSION
  4324 00:B6A3: 98           	tya			; REMAINING MULTIPLIER
  4325 00:B6A4: 4A           	lsr	a		; LSB INTO CARRY
  4326 00:B6A5: D0 D6        	bne	MULTIPLY21		; IF SENTINEL STILL HERE, MULTIPLY
  4327 00:B6A7: 60           	rts			; 8 X 32 COMPLETED
  4328                        
  4329                        
  4330                        ; ----------------------------------------------------------------------------
  4331                        ; UNPACK NUMBER AT (Y,A) INTO ARG
  4332                        ; ----------------------------------------------------------------------------
  4333                        LOAD_ARG_FROM_YA:
  4334 00:B6A8: 85 5E        	sta	INDEX		; USE INDEX FOR PNTR
  4335 00:B6AA: 84 5F        	sty	INDEX+1
  4336 00:B6AC: A0 04        	ldy	#4		; FIVE BYTES TO MOVE
  4337 00:B6AE: B1 5E        	lda	(INDEX),y
  4338 00:B6B0: 85 A9        	sta	ARG+4
  4339 00:B6B2: 88           	dey
  4340 00:B6B3: B1 5E        	lda	(INDEX),y
  4341 00:B6B5: 85 A8        	sta	ARG+3
  4342 00:B6B7: 88           	dey
  4343 00:B6B8: B1 5E        	lda	(INDEX),y
  4344 00:B6BA: 85 A7        	sta	ARG+2
  4345 00:B6BC: 88           	dey
  4346 00:B6BD: B1 5E        	lda	(INDEX),y
  4347 00:B6BF: 85 AA        	sta	ARGSIGN
  4348 00:B6C1: 45 A2        	eor	FACSIGN		; SET COMBINED SIGN FOR MULT/DIV
  4349 00:B6C3: 85 AB        	sta	SGNCPR
  4350 00:B6C5: A5 AA        	lda	ARGSIGN		; TURN ON NORMALIZED INVISIBLE BIT
  4351 00:B6C7: 09 80        	ora	#$80		; TO COMPLETE MANTISSA
  4352 00:B6C9: 85 A6        	sta	ARG+1
  4353 00:B6CB: 88           	dey
  4354 00:B6CC: B1 5E        	lda	(INDEX),y
  4355 00:B6CE: 85 A5        	sta	ARG		; EXPONENT
  4356 00:B6D0: A5 9D        	lda	FAC		; SET STATUS BITS ON FAC EXPONENT
  4357 00:B6D2: 60           	rts
  4358                        
  4359                        
  4360                        ; ----------------------------------------------------------------------------
  4361                        ; ADD EXPONENTS OF ARG AND FAC
  4362                        ; (CALLED BY FMULT AND FDIV)
  4363                        ;
  4364                        ; ALSO CHECK FOR OVERFLOW, AND SET RESULT SIGN
  4365                        ; ----------------------------------------------------------------------------
  4366                        ADD_EXPONENTS:
  4367 00:B6D3: A5 A5        	lda	ARG
  4368                        ; ----------------------------------------------------------------------------
  4369                        ADD_EXPONENTS1:
  4370 00:B6D5: F0 1C        	beq	ZERO		; IF ARG=0, RESULT IS ZERO
  4371 00:B6D7: 18           	clc
  4372 00:B6D8: 65 9D        	adc	FAC
  4373 00:B6DA: 90 04        	bcc	ADD_EXP1		; IN RANGE
  4374 00:B6DC: 30 1A        	bmi	JOV		; OVERFLOW
  4375 00:B6DE: 18           	clc
  4376 00:B6DF: 2C           	db	$2C		; TRICK TO SKIP
  4377                        ADD_EXP1:
  4378 00:B6E0: 10 11        	bpl	ZERO		; OVERFLOW
  4379 00:B6E2: 69 80        	adc	#$80		; RE-BIAS
  4380 00:B6E4: 85 9D        	sta	FAC		; RESULT
  4381 00:B6E6: F0 02        	beq	ADD_EXP3
  4382                        ;ADD_EXP2:
  4383 00:B6E8: A5 AB        	lda	SGNCPR		; SET SIGN OF RESULT
  4384                        ADD_EXP3:
  4385 00:B6EA: 85 A2        	sta	FACSIGN
  4386 00:B6EC: 60           	rts
  4387                        
  4388                        
  4389                        ; ----------------------------------------------------------------------------
  4390                        ; IF (FAC) IS POSITIVE, GIVE "OVERFLOW" ERROR
  4391                        ; IF (FAC) IS NEGATIVE, SET FAC=0, POP ONE RETURN, AND RTS
  4392                        ; CALLED FROM "EXP" FUNCTION
  4393                        ; ----------------------------------------------------------------------------
  4394                        OUTOFRNG:
  4395 00:B6ED: A5 A2        	lda	FACSIGN
  4396 00:B6EF: 49 FF        	eor	#$FF
  4397 00:B6F1: 30 05        	bmi	JOV		; ERROR IF POSITIVE #
  4398                        
  4399                        
  4400                        ; ----------------------------------------------------------------------------
  4401                        ; POP RETURN ADDRESS AND SET FAC=0
  4402                        ; ----------------------------------------------------------------------------
  4403 00:B6F3: 68           ZERO:	pla
  4404 00:B6F4: 68           	pla
  4405 00:B6F5: 4C 15 B5     	jmp	ZERO_FAC
  4406                        ; ----------------------------------------------------------------------------
  4407 00:B6F8: 4C 9C B5     JOV:	jmp	OVERFLOW
  4408                        
  4409                        
  4410                        ; ----------------------------------------------------------------------------
  4411                        ; MULTIPLY FAC BY 10
  4412                        ; ----------------------------------------------------------------------------
  4413 00:B6FB: 20 25 B8     MUL10:	jsr	COPY_FAC_TO_ARG_ROUNDED
  4414 00:B6FE: AA           	tax			; TEXT FAC EXPONENT
  4415 00:B6FF: F0 10        	beq	MUL101		; FINISHED IF FAC=0
  4416 00:B701: 18           	clc
  4417 00:B702: 69 02        	adc	#2		; ADD 2 TO EXPONENT GIVES (FAC)*4
  4418 00:B704: B0 F2        	bcs	JOV		; OVERFLOW
  4419 00:B706: A2 00        	ldx	#0
  4420 00:B708: 86 AB        	stx	SGNCPR
  4421 00:B70A: 20 95 B4     	jsr	FADD2		; MAKES (FAC)*5
  4422 00:B70D: E6 9D        	inc	FAC		; *2, MAKES (FAC)*10
  4423 00:B70F: F0 E7        	beq	JOV		; OVERFLOW
  4424 00:B711: 60           MUL101:	rts
  4425                        
  4426                        ; ----------------------------------------------------------------------------
  4427 00:B712: 84 20 00 00  CONTEN:	db	$84,$20,$00,$00,$00
       00:B716: 00 
  4428                        
  4429                        
  4430                        ; ----------------------------------------------------------------------------
  4431                        ; DIVIDE FAC BY 10
  4432                        ; ----------------------------------------------------------------------------
  4433 00:B717: 20 25 B8     DIV10:	jsr	COPY_FAC_TO_ARG_ROUNDED
  4434 00:B71A: A9 12        	lda	#<CONTEN	; SET UP TO PUT
  4435 00:B71C: A0 B7        	ldy	#>CONTEN	; 10 IN FAC
  4436 00:B71E: A2 00        	ldx	#0
  4437                        
  4438                        
  4439                        ; ----------------------------------------------------------------------------
  4440                        ; FAC = ARG / (Y,A)
  4441                        ; ----------------------------------------------------------------------------
  4442 00:B720: 86 AB        DIV:	stx	SGNCPR
  4443 00:B722: 20 BB B7     	jsr	LOAD_FAC_FROM_YA
  4444 00:B725: 4C 2B B7     	jmp	FDIVT		; DIVIDE ARG BY FAC
  4445                        
  4446                        
  4447                        ; ----------------------------------------------------------------------------
  4448                        ; FAC = (Y,A) / FAC
  4449                        ; ----------------------------------------------------------------------------
  4450 00:B728: 20 A8 B6     FDIV:	jsr	LOAD_ARG_FROM_YA
  4451                        
  4452                        
  4453                        ; ----------------------------------------------------------------------------
  4454                        ; FAC = ARG / FAC
  4455                        ; ----------------------------------------------------------------------------
  4456 00:B72B: F0 76        FDIVT:	beq	FDIVT8		; FAC = 0, DIVIDE BY ZERO ERROR
  4457 00:B72D: 20 34 B8     	jsr	ROUND_FAC
  4458 00:B730: A9 00        	lda	#0		; NEGATE FAC EXPONENT, SO
  4459 00:B732: 38           	sec			; ADD.EXPONENTS FORMS DIFFERENCE
  4460 00:B733: E5 9D        	sbc	FAC
  4461 00:B735: 85 9D        	sta	FAC
  4462 00:B737: 20 D3 B6     	jsr	ADD_EXPONENTS
  4463 00:B73A: E6 9D        	inc	FAC
  4464 00:B73C: F0 BA        	beq	JOV		; OVERFLOW
  4465 00:B73E: A2 FC        	ldx	#$FC		; X = -4 : INDEX FOR RESULT
  4466 00:B740: A9 01        	lda	#1		; SENTINEL
  4467 00:B742: A4 A6        FDIVT1:	ldy	ARG+1		; SEE IF FAC CAN BE SUBTRACTED
  4468 00:B744: C4 9E        	cpy	FAC+1
  4469 00:B746: D0 10        	bne	FDIVT2
  4470 00:B748: A4 A7        	ldy	ARG+2
  4471 00:B74A: C4 9F        	cpy	FAC+2
  4472 00:B74C: D0 0A        	bne	FDIVT2
  4473 00:B74E: A4 A8        	ldy	ARG+3
  4474 00:B750: C4 A0        	cpy	FAC+3
  4475 00:B752: D0 04        	bne	FDIVT2
  4476 00:B754: A4 A9        	ldy	ARG+4
  4477 00:B756: C4 A1        	cpy	FAC+4
  4478 00:B758: 08           FDIVT2:	php			; SAVE THE ANSWER, AND ALSO ROLL THE
  4479 00:B759: 2A           	rol	a		; BIT INTO THE QUOTIENT, SENTINEL OUT
  4480 00:B75A: 90 09        	bcc	FDIVT3		; NO SENTINEL, STILL NOT 8 TRIPS
  4481 00:B75C: E8           	inx			; 8 TRIPS, STORE BYTE OF QUOTIENT
  4482 00:B75D: 95 65        	sta	RESULT+3,x
  4483 00:B75F: F0 32        	beq	FDIVT6		; 32-BITS COMPLETED
  4484 00:B761: 10 34        	bpl	FDIVT7		; FINAL EXIT WHEN X=1
  4485 00:B763: A9 01        	lda	#1		; RE-START SENTINEL
  4486 00:B765: 28           FDIVT3:	plp			; GET ANSWER, CAN FAC BE SUBTRACTED?
  4487 00:B766: B0 0E        	bcs	FDIVT5		; YES, DO IT
  4488 00:B768: 06 A9        FDIVT4:	asl	ARG+4		; NO, SHIFT ARG LEFT
  4489 00:B76A: 26 A8        	rol	ARG+3
  4490 00:B76C: 26 A7        	rol	ARG+2
  4491 00:B76E: 26 A6        	rol	ARG+1
  4492 00:B770: B0 E6        	bcs	FDIVT2		; ANOTHER TRIP
  4493 00:B772: 30 CE        	bmi	FDIVT1		; HAVE TO COMPARE FIRST
  4494 00:B774: 10 E2        	bpl	FDIVT2		; ...ALWAYS
  4495 00:B776: A8           FDIVT5:	tay			; SAVE QUOTIENT/SENTINEL BYTE
  4496 00:B777: A5 A9        	lda	ARG+4		; SUBTRACT FAC FROM ARG ONCE
  4497 00:B779: E5 A1        	sbc	FAC+4
  4498 00:B77B: 85 A9        	sta	ARG+4
  4499 00:B77D: A5 A8        	lda	ARG+3
  4500 00:B77F: E5 A0        	sbc	FAC+3
  4501 00:B781: 85 A8        	sta	ARG+3
  4502 00:B783: A5 A7        	lda	ARG+2
  4503 00:B785: E5 9F        	sbc	FAC+2
  4504 00:B787: 85 A7        	sta	ARG+2
  4505 00:B789: A5 A6        	lda	ARG+1
  4506 00:B78B: E5 9E        	sbc	FAC+1
  4507 00:B78D: 85 A6        	sta	ARG+1
  4508 00:B78F: 98           	tya			; RESTORE QUOTIENT/SENTINEL BYTE
  4509 00:B790: 4C 68 B7     	jmp	FDIVT4		; GO TO SHIFT ARG AND CONTINUE
  4510                        ; ----------------------------------------------------------------------------
  4511 00:B793: A9 40        FDIVT6:	lda	#$40		; DO A FEW EXTENSION BITS
  4512 00:B795: D0 CE        	bne	FDIVT3		; ...ALWAYS
  4513                        ; ----------------------------------------------------------------------------
  4514 00:B797: 0A           FDIVT7:	asl	a		; LEFT JUSTIFY THE EXTENSION BITS WE DID
  4515 00:B798: 0A           	asl	a
  4516 00:B799: 0A           	asl	a
  4517 00:B79A: 0A           	asl	a
  4518 00:B79B: 0A           	asl	a
  4519 00:B79C: 0A           	asl	a
  4520 00:B79D: 85 AC        	sta	FACEXTENSION
  4521 00:B79F: 28           	plp
  4522 00:B7A0: 4C A8 B7     	jmp	COPY_RESULT_INTO_FAC
  4523                        ; ----------------------------------------------------------------------------
  4524 00:B7A3: A2 53        FDIVT8:	ldx	#ERR_ZERODIV
  4525 00:B7A5: 4C DA A2     	jmp	ERROR
  4526                        
  4527                        
  4528                        ; ----------------------------------------------------------------------------
  4529                        ; COPY RESULT INTO FAC MANTISSA, AND NORMALIZE
  4530                        ; ----------------------------------------------------------------------------
  4531                        COPY_RESULT_INTO_FAC:
  4532 00:B7A8: A5 62        	lda	RESULT
  4533 00:B7AA: 85 9E        	sta	FAC+1
  4534 00:B7AC: A5 63        	lda	RESULT+1
  4535 00:B7AE: 85 9F        	sta	FAC+2
  4536 00:B7B0: A5 64        	lda	RESULT+2
  4537 00:B7B2: 85 A0        	sta	FAC+3
  4538 00:B7B4: A5 65        	lda	RESULT+3
  4539 00:B7B6: 85 A1        	sta	FAC+4
  4540 00:B7B8: 4C F5 B4     	jmp	NORMALIZE_FAC2
  4541                        
  4542                        
  4543                        ; ----------------------------------------------------------------------------
  4544                        ; UNPACK (Y,A) INTO FAC
  4545                        ; ----------------------------------------------------------------------------
  4546                        LOAD_FAC_FROM_YA:
  4547 00:B7BB: 85 5E        	sta	INDEX		; USE INDEX FOR PNTR
  4548 00:B7BD: 84 5F        	sty	INDEX+1
  4549 00:B7BF: A0 04        	ldy	#4		; PICK UP 5 BYTES
  4550 00:B7C1: B1 5E        	lda	(INDEX),y
  4551 00:B7C3: 85 A1        	sta	FAC+4
  4552 00:B7C5: 88           	dey
  4553 00:B7C6: B1 5E        	lda	(INDEX),y
  4554 00:B7C8: 85 A0        	sta	FAC+3
  4555 00:B7CA: 88           	dey
  4556 00:B7CB: B1 5E        	lda	(INDEX),y
  4557 00:B7CD: 85 9F        	sta	FAC+2
  4558 00:B7CF: 88           	dey
  4559 00:B7D0: B1 5E        	lda	(INDEX),y
  4560 00:B7D2: 85 A2        	sta	FACSIGN		; FIRST BIT IS SIGN
  4561 00:B7D4: 09 80        	ora	#$80		; SET NORMALIZED INVISIBLE BIT
  4562 00:B7D6: 85 9E        	sta	FAC+1
  4563 00:B7D8: 88           	dey
  4564 00:B7D9: B1 5E        	lda	(INDEX),y
  4565 00:B7DB: 85 9D        	sta	FAC		; EXPONENT
  4566 00:B7DD: 84 AC        	sty	FACEXTENSION	; Y=0
  4567 00:B7DF: 60           	rts
  4568                        
  4569                        
  4570                        ; ----------------------------------------------------------------------------
  4571                        ; ROUND FAC, STORE IN TEMP2
  4572                        ; ----------------------------------------------------------------------------
  4573                        STORE_FAC_IN_TEMP2_ROUNDED:
  4574 00:B7E0: A2 98        	ldx	#TEMP2		; PACK FAC INTO TEMP2
  4575 00:B7E2: 2C           	db	$2C		; TRICK TO BRANCH
  4576                        
  4577                        
  4578                        ; ----------------------------------------------------------------------------
  4579                        ; ROUND FAC, STORE IN TEMP1
  4580                        ; ----------------------------------------------------------------------------
  4581                        STORE_FAC_IN_TEMP1_ROUNDED:
  4582 00:B7E3: A2 93        	ldx	#<TEMP1		; PACK FAC INTO TEMP1
  4583 00:B7E5: A0 00        	ldy	#>TEMP1		; HI-BYTE OF TEMP1 SAME AS TEMP2
  4584 00:B7E7: F0 04        	beq	STORE_FAC_AT_YX_ROUNDED	; ...ALWAYS
  4585                        
  4586                        
  4587                        ; ----------------------------------------------------------------------------
  4588                        ; ROUND FAC, AND STORE WHERE FORPNT POINTS
  4589                        ; ----------------------------------------------------------------------------
  4590 00:B7E9: A6 85        SETFOR:	ldx	FORPNT
  4591 00:B7EB: A4 86        	ldy	FORPNT+1
  4592                        
  4593                        
  4594                        ; ----------------------------------------------------------------------------
  4595                        ; ROUND FAC, AND STORE AT (Y,X)
  4596                        ; ----------------------------------------------------------------------------
  4597                        STORE_FAC_AT_YX_ROUNDED:
  4598 00:B7ED: 20 34 B8     	jsr	ROUND_FAC	; ROUND VALUE IN FAC USING EXTENSION
  4599 00:B7F0: 86 5E        	stx	INDEX		; USE INDEX FOR PNTR
  4600 00:B7F2: 84 5F        	sty	INDEX+1
  4601 00:B7F4: A0 04        	ldy	#4		; STORING 5 PACKED BYTES
  4602 00:B7F6: A5 A1        	lda	FAC+4
  4603 00:B7F8: 91 5E        	sta	(INDEX),y
  4604 00:B7FA: 88           	dey
  4605 00:B7FB: A5 A0        	lda	FAC+3
  4606 00:B7FD: 91 5E        	sta	(INDEX),y
  4607 00:B7FF: 88           	dey
  4608 00:B800: A5 9F        	lda	FAC+2
  4609 00:B802: 91 5E        	sta	(INDEX),y
  4610 00:B804: 88           	dey
  4611 00:B805: A5 A2        	lda	FACSIGN		; PACK SIGN IN TOP BIT OF MANTISSA
  4612 00:B807: 09 7F        	ora	#$7F
  4613 00:B809: 25 9E        	and	FAC+1
  4614 00:B80B: 91 5E        	sta	(INDEX),y
  4615 00:B80D: 88           	dey
  4616 00:B80E: A5 9D        	lda	FAC		; EXPONENT
  4617 00:B810: 91 5E        	sta	(INDEX),y
  4618 00:B812: 84 AC        	sty	FACEXTENSION	; ZERO THE EXTENSION
  4619 00:B814: 60           	rts
  4620                        
  4621                        
  4622                        ; ----------------------------------------------------------------------------
  4623                        ; COPY ARG INTO FAC
  4624                        ; ----------------------------------------------------------------------------
  4625                        COPY_ARG_TO_FAC:
  4626 00:B815: A5 AA        	lda	ARGSIGN		; COPY SIGN
  4627 00:B817: 85 A2        MFA:	sta	FACSIGN
  4628 00:B819: A2 05        	ldx	#5		; MOVE 5 BYTES
  4629                        COPY_AR1:
  4630 00:B81B: B5 A4        	lda	ARG-1,x
  4631 00:B81D: 95 9C        	sta	FAC-1,x
  4632 00:B81F: CA           	dex
  4633 00:B820: D0 F9        	bne	COPY_AR1
  4634 00:B822: 86 AC        	stx	FACEXTENSION	; ZERO EXTENSION
  4635 00:B824: 60           	rts
  4636                        
  4637                        
  4638                        ; ----------------------------------------------------------------------------
  4639                        ; ROUND FAC AND COPY TO ARG
  4640                        ; ----------------------------------------------------------------------------
  4641                        COPY_FAC_TO_ARG_ROUNDED:
  4642 00:B825: 20 34 B8     	jsr	ROUND_FAC	; ROUND FAC USING EXTENSION
  4643 00:B828: A2 06        MAF:	ldx	#6		; COPY 6 BYTES, INCLUDES SIGN
  4644                        COPY_FA1:
  4645 00:B82A: B5 9C        	lda	FAC-1,x
  4646 00:B82C: 95 A4        	sta	ARG-1,x
  4647 00:B82E: CA           	dex
  4648 00:B82F: D0 F9        	bne	COPY_FA1
  4649 00:B831: 86 AC        	stx	FACEXTENSION	; ZERO FAC EXTENSION
  4650 00:B833: 60           RTS14:	rts
  4651                        
  4652                        
  4653                        ; ----------------------------------------------------------------------------
  4654                        ; ROUND FAC USING EXTENSION BYTE
  4655                        ; ----------------------------------------------------------------------------
  4656                        ROUND_FAC:
  4657 00:B834: A5 9D        	lda	FAC
  4658 00:B836: F0 FB        	beq	RTS14		; FAC = 0, RETURN
  4659 00:B838: 06 AC        	asl	FACEXTENSION	; IS FAC.EXTENSION >= 128?
  4660 00:B83A: 90 F7        	bcc	RTS14		; NO, FINISHED
  4661                        
  4662                        
  4663                        ; ----------------------------------------------------------------------------
  4664                        ; INCREMENT MANTISSA AND RE-NORMALIZE IF CARRY
  4665                        ; ----------------------------------------------------------------------------
  4666                        INCREMENT_MANTISSA:
  4667 00:B83C: 20 8D B5     	jsr	INCREMENT_FAC_MANTISSA	; YES, INCREMENT FAC
  4668 00:B83F: D0 F2        	bne	RTS14		; HIGH BYTE HAS BITS, FINISHED
  4669 00:B841: 4C 56 B5     	jmp	NORMALIZE_FAC6	; HI-BYTE=0, SO SHIFT LEFT
  4670                        
  4671                        
  4672                        ; ----------------------------------------------------------------------------
  4673                        ; TEST FAC FOR ZERO AND SIGN
  4674                        ;
  4675                        ; FAC > 0, RETURN +1
  4676                        ; FAC = 0, RETURN  0
  4677                        ; FAC < 0, RETURN -1
  4678                        ; ----------------------------------------------------------------------------
  4679 00:B844: A5 9D        SIGN:	lda	FAC		; CHECK SIGN OF FAC AND
  4680 00:B846: F0 09        	beq	RTS15		; RETURN -1,0,1 IN A-REG
  4681                        ; ----------------------------------------------------------------------------
  4682 00:B848: A5 A2        SIGN1:	lda	FACSIGN
  4683                        ; ----------------------------------------------------------------------------
  4684 00:B84A: 2A           SIGN2:	rol	a		; MSBIT TO CARRY
  4685 00:B84B: A9 FF        	lda	#$FF		; -1
  4686 00:B84D: B0 02        	bcs	RTS15		; MSBIT = 1
  4687 00:B84F: A9 01        	lda	#1		; +1
  4688 00:B851: 60           RTS15:	rts
  4689                        
  4690                        
  4691                        ; ----------------------------------------------------------------------------
  4692                        ; "SGN" FUNCTION
  4693                        ; ----------------------------------------------------------------------------
  4694 00:B852: 20 44 B8     SGN:	jsr	SIGN		; CONVERT FAC TO -1,0,1
  4695                        
  4696                        
  4697                        ; ----------------------------------------------------------------------------
  4698                        ; CONVERT (A) INTO FAC, AS SIGNED VALUE -128 TO +127
  4699                        ; ----------------------------------------------------------------------------
  4700 00:B855: 85 9E        FLOAT:	sta	FAC+1		; PUT IN HIGH BYTE OF MANTISSA
  4701 00:B857: A9 00        	lda	#0		; CLEAR 2ND BYTE OF MANTISSA
  4702 00:B859: 85 9F        	sta	FAC+2
  4703 00:B85B: A2 88        	ldx	#$88		; USE EXPONENT 2^9
  4704                        
  4705                        
  4706                        ; ----------------------------------------------------------------------------
  4707                        ; FLOAT UNSIGNED VALUE IN FAC+1,2
  4708                        ; (X) = EXPONENT
  4709                        ; ----------------------------------------------------------------------------
  4710 00:B85D: A5 9E        FLOAT1:	lda	FAC+1		; MSBIT=0, SET CARRY; =1, CLEAR CARRY
  4711 00:B85F: 49 FF        	eor	#$FF
  4712 00:B861: 2A           	rol	a
  4713                        
  4714                        
  4715                        ; ----------------------------------------------------------------------------
  4716                        ; FLOAT UNSIGNED VALUE IN FAC+1,2
  4717                        ; (X) = EXPONENT
  4718                        ; C=0 TO MAKE VALUE NEGATIVE
  4719                        ; C=1 TO MAKE VALUE POSITIVE
  4720                        ; ----------------------------------------------------------------------------
  4721 00:B862: A9 00        FLOAT2:	lda	#0		; CLEAR LOWER 16-BITS OF MANTISSA
  4722 00:B864: 85 A1        	sta	FAC+4
  4723 00:B866: 85 A0        	sta	FAC+3
  4724 00:B868: 86 9D        	stx	FAC		; STORE EXPONENT
  4725 00:B86A: 85 AC        	sta	FACEXTENSION	; CLEAR EXTENSION
  4726 00:B86C: 85 A2        	sta	FACSIGN		; MAKE SIGN POSITIVE
  4727 00:B86E: 4C F0 B4     	jmp	NORMALIZE_FAC1	; IF C=0, WILL NEGATE FAC
  4728                        
  4729                        
  4730                        ; ----------------------------------------------------------------------------
  4731                        ; "ABS" FUNCTION
  4732                        ; ----------------------------------------------------------------------------
  4733 00:B871: 46 A2        ABS:	lsr	FACSIGN		; CHANGE SIGN TO +
  4734 00:B873: 60           	rts
  4735                        
  4736                        
  4737                        ; ----------------------------------------------------------------------------
  4738                        ; COMPARE FAC WITH PACKED # AT (Y,A)
  4739                        ; RETURN A=1,0,-1 AS (Y,A) IS <,=,> FAC
  4740                        ; ----------------------------------------------------------------------------
  4741 00:B874: 85 60        FCOMP:	sta	DEST		; USE DEST FOR PNTR
  4742                        
  4743                        
  4744                        ; ----------------------------------------------------------------------------
  4745                        ; SPECIAL ENTRY FROM "NEXT" PROCESSOR
  4746                        ; "DEST" ALREADY SET UP
  4747                        ; ----------------------------------------------------------------------------
  4748 00:B876: 84 61        FCOMP2:	sty	DEST+1
  4749 00:B878: A0 00        	ldy	#0		; GET EXPONENT OF COMPARAND
  4750 00:B87A: B1 60        	lda	(DEST),y
  4751 00:B87C: C8           	iny			; POINT AT NEXT BYTE
  4752 00:B87D: AA           	tax			; EXPONENT TO X-REG
  4753 00:B87E: F0 C4        	beq	SIGN		; IF COMPARAND=0, "SIGN" COMPARES FAC
  4754 00:B880: B1 60        	lda	(DEST),y	; GET HI-BYTE OF MANTISSA
  4755 00:B882: 45 A2        	eor	FACSIGN		; COMPARE WITH FAC SIGN
  4756 00:B884: 30 C2        	bmi	SIGN1		; DIFFERENT SIGNS, "SIGN" GIVES ANSWER
  4757 00:B886: E4 9D        	cpx	FAC		; SAME SIGN, SO COMPARE EXPONENTS
  4758 00:B888: D0 21        	bne	FCOMP21		; DIFFERENT, SO SUFFICIENT TEST
  4759 00:B88A: B1 60        	lda	(DEST),y	; SAME EXPONENT, COMPARE MANTISSA
  4760 00:B88C: 09 80        	ora	#$80		; SET INVISIBLE NORMALIZED BIT
  4761 00:B88E: C5 9E        	cmp	FAC+1
  4762 00:B890: D0 19        	bne	FCOMP21		; NOT SAME, SO SUFFICIENT
  4763 00:B892: C8           	iny			; SAME, COMPARE MORE MANTISSA
  4764 00:B893: B1 60        	lda	(DEST),y
  4765 00:B895: C5 9F        	cmp	FAC+2
  4766 00:B897: D0 12        	bne	FCOMP21		; NOT SAME, SO SUFFICIENT
  4767 00:B899: C8           	iny			; SAME, COMPARE MORE MANTISSA
  4768 00:B89A: B1 60        	lda	(DEST),y
  4769 00:B89C: C5 A0        	cmp	FAC+3
  4770 00:B89E: D0 0B        	bne	FCOMP21		; NOT SAME, SO SUFFICIENT
  4771 00:B8A0: C8           	iny			; SAME, COMPARE REST OF MANTISSA
  4772 00:B8A1: A9 7F        	lda	#$7F		; ARTIFICIAL EXTENSION BYTE FOR COMPARAND
  4773 00:B8A3: C5 AC        	cmp	FACEXTENSION
  4774 00:B8A5: B1 60        	lda	(DEST),y
  4775 00:B8A7: E5 A1        	sbc	FAC+4
  4776 00:B8A9: F0 25        	beq	RTS16		; NUMBERS ARE EQUAL, RETURN (A)=0
  4777 00:B8AB: 6A           FCOMP21:	ror			; PUT CARRY INTO SIGN BIT
  4778 00:B8AC: 45 A2        	eor	FACSIGN		; TOGGLE WITH SIGN OF FAC
  4779                        ;FCOMP22:
  4780 00:B8AE: 4C 4A B8     	jmp	SIGN2		; CONVERT +1 OR -1
  4781                        
  4782                        
  4783                        ; ----------------------------------------------------------------------------
  4784                        ; QUICK INTEGER FUNCTION
  4785                        ;
  4786                        ; CONVERTS FP VALUE IN FAC TO INTEGER VALUE
  4787                        ; IN FAC+1...FAC+4, BY SHIFTING RIGHT WITH SIGN
  4788                        ; EXTENSION UNTIL FRACTIONAL BITS ARE OUT.
  4789                        ;
  4790                        ; THIS SUBROUTINE ASSUMES THE EXPONENT < 32.
  4791                        ; ----------------------------------------------------------------------------
  4792 00:B8B1: A5 9D        QINT:	lda	FAC		; LOOK AT FAC EXPONENT
  4793 00:B8B3: F0 4A        	beq	QINT3		; FAC=0, SO FINISHED
  4794 00:B8B5: 38           	sec			; GET -(NUMBER OF FRACTIONAL BITS)
  4795 00:B8B6: E9 A0        	sbc	#$A0		; IN A-REG FOR SHIFT COUNT
  4796 00:B8B8: 24 A2        	bit	FACSIGN		; CHECK SIGN OF FAC
  4797 00:B8BA: 10 09        	bpl	QINT1		; POSITIVE, CONTINUE
  4798 00:B8BC: AA           	tax			; NEGATIVE, SO COMPLEMENT MANTISSA
  4799 00:B8BD: A9 FF        	lda	#$FF		; AND SET SIGN EXTENSION FOR SHIFT
  4800 00:B8BF: 85 A4        	sta	SHIFTSIGNEXT
  4801 00:B8C1: 20 6B B5     	jsr	COMPLEMENT_FAC_MANTISSA
  4802 00:B8C4: 8A           	txa			; RESTORE BIT COUNT TO A-REG
  4803 00:B8C5: A2 9D        QINT1:	ldx	#FAC		; POINT SHIFT SUBROUTINE AT FAC
  4804 00:B8C7: C9 F9        	cmp	#$F9		; MORE THAN 7 BITS TO SHIFT?
  4805 00:B8C9: 10 06        	bpl	QINT2		; NO, SHORT SHIFT
  4806 00:B8CB: 20 B7 B5     	jsr	SHIFT_RIGHT	; YES, USE GENERAL ROUTINE
  4807 00:B8CE: 84 A4        	sty	SHIFTSIGNEXT	; Y=0, CLEAR SIGN EXTENSION
  4808 00:B8D0: 60           RTS16:	rts
  4809                        ; ----------------------------------------------------------------------------
  4810 00:B8D1: A8           QINT2:	tay			; SAVE SHIFT COUNT
  4811 00:B8D2: A5 A2        	lda	FACSIGN		; GET SIGN BIT
  4812 00:B8D4: 29 80        	and	#$80
  4813 00:B8D6: 46 9E        	lsr	FAC+1		; START RIGHT SHIFT
  4814 00:B8D8: 05 9E        	ora	FAC+1		; AND MERGE WITH SIGN
  4815 00:B8DA: 85 9E        	sta	FAC+1
  4816 00:B8DC: 20 CE B5     	jsr	SHIFT_RIGHT4	; JUMP INTO MIDDLE OF SHIFTER
  4817 00:B8DF: 84 A4        	sty	SHIFTSIGNEXT	; Y=0, CLEAR SIGN EXTENSION
  4818 00:B8E1: 60           	rts
  4819                        
  4820                        
  4821                        ; ----------------------------------------------------------------------------
  4822                        ; "INT" FUNCTION
  4823                        ;
  4824                        ; USES QINT TO CONVERT (FAC) TO INTEGER FORM,
  4825                        ; AND THEN REFLOATS THE INTEGER.
  4826                        ; ----------------------------------------------------------------------------
  4827 00:B8E2: A5 9D        INT:	lda	FAC		; CHECK IF EXPONENT < 32
  4828 00:B8E4: C9 A0        	cmp	#$A0		; BECAUSE IF > 31 THERE IS NO FRACTION
  4829 00:B8E6: B0 20        	bcs	RTS17		; NO FRACTION, WE ARE FINISHED
  4830 00:B8E8: 20 B1 B8     	jsr	QINT		; USE GENERAL INTEGER CONVERSION
  4831 00:B8EB: 84 AC        	sty	FACEXTENSION	; Y=0, CLEAR EXTENSION
  4832 00:B8ED: A5 A2        	lda	FACSIGN		; GET SIGN OF VALUE
  4833 00:B8EF: 84 A2        	sty	FACSIGN		; Y=0, CLEAR SIGN
  4834 00:B8F1: 49 80        	eor	#$80		; TOGGLE ACTUAL SIGN
  4835 00:B8F3: 2A           	rol	a		; AND SAVE IN CARRY
  4836 00:B8F4: A9 A0        	lda	#$A0		; SET EXPONENT TO 32
  4837 00:B8F6: 85 9D        	sta	FAC		; BECAUSE 4-BYTE INTEGER NOW
  4838 00:B8F8: A5 A1        	lda	FAC+4		; SAVE LOW 8-BITS OF INTEGER FORM
  4839 00:B8FA: 85 0D        	sta	CHARAC		; FOR EXP AND POWER
  4840 00:B8FC: 4C F0 B4     	jmp	NORMALIZE_FAC1	; NORMALIZE TO FINISH CONVERSION
  4841                        ; ----------------------------------------------------------------------------
  4842 00:B8FF: 85 9E        QINT3:	sta	FAC+1		; FAC=0, SO CLEAR ALL 4 BYTES FOR
  4843 00:B901: 85 9F        	sta	FAC+2		; INTEGER VERSION
  4844 00:B903: 85 A0        	sta	FAC+3
  4845 00:B905: 85 A1        	sta	FAC+4
  4846 00:B907: A8           	tay			; Y=0 TOO
  4847 00:B908: 60           RTS17:	rts
  4848                        
  4849                        
  4850                        ; ----------------------------------------------------------------------------
  4851                        ; CONVERT STRING TO FP VALUE IN FAC
  4852                        ;
  4853                        ; STRING POINTED TO BY TXTPTR
  4854                        ; FIRST CHAR ALREADY SCANNED BY CHRGET
  4855                        ; (A) = FIRST CHAR, C=0 IF DIGIT.
  4856                        ; ----------------------------------------------------------------------------
  4857 00:B909: A0 00        FIN:    ldy	#0		; CLEAR WORKING AREA ($99...$A3)
  4858 00:B90B: A2 0A        	ldx	#10		; TMPEXP, EXPON, DPFLG, EXPSGN, FAC, SERLEN
  4859 00:B90D: 94 99        FIN_1:	sty	TMPEXP,x
  4860 00:B90F: CA           	dex
  4861 00:B910: 10 FB        	bpl	FIN_1
  4862                        ; ----------------------------------------------------------------------------
  4863 00:B912: 90 0F        	bcc	FIN2		; FIRST CHAR IS A DIGIT
  4864 00:B914: C9 2D        	cmp	#'-'		; CHECK FOR LEADING SIGN
  4865 00:B916: D0 04        	bne	FIN_2		; NOT MINUS
  4866 00:B918: 86 A3        	stx	SERLEN		; MINUS, SET SERLEN = $FF FOR FLAG
  4867 00:B91A: F0 04        	beq	FIN1		; ...ALWAYS
  4868 00:B91C: C9 2B        FIN_2:	cmp	#'+'		; MIGHT BE PLUS
  4869 00:B91E: D0 05        	bne	FIN3		; NOT PLUS EITHER, CHECK DECIMAL POINT
  4870                        
  4871                        ; ----------------------------------------------------------------------------
  4872 00:B920: 20 B1 00     FIN1:	jsr	CHRGET		; GET NEXT CHAR OF STRING
  4873                        
  4874                        ; ----------------------------------------------------------------------------
  4875 00:B923: 90 5B        FIN2:	bcc	FIN9		; INSERT THIS DIGIT
  4876                        
  4877                        ; ----------------------------------------------------------------------------
  4878 00:B925: C9 2E        FIN3:	cmp	#'.'		; CHECK FOR DECIMAL POINT
  4879 00:B927: F0 2E        	beq	FIN10		; YES
  4880 00:B929: C9 45        	cmp	#'E'		; CHECK FOR EXPONENT PART
  4881 00:B92B: D0 30        	bne	FIN7		; NO, END OF NUMBER
  4882 00:B92D: 20 B1 00     	jsr	CHRGET		; YES, START CONVERTING EXPONENT
  4883 00:B930: 90 17        	bcc	FIN5		; EXPONENT DIGIT
  4884 00:B932: C9 A8        	cmp	#TOKEN_MINUS	; NEGATIVE EXPONENT?
  4885 00:B934: F0 0E        	beq	FIN31		; YES
  4886 00:B936: C9 2D        	cmp	#'-'		; MIGHT NOT BE TOKENIZED YET
  4887 00:B938: F0 0A        	beq	FIN31		; YES, IT IS NEGATIVE
  4888 00:B93A: C9 A7        	cmp	#TOKEN_PLUS	; OPTIONAL "+"
  4889 00:B93C: F0 08        	beq	FIN4		; YES
  4890 00:B93E: C9 2B        	cmp	#'+'		; MIGHT NOT BE TOKENIZED YET
  4891 00:B940: F0 04        	beq	FIN4		; YES, FOUND "+"
  4892 00:B942: D0 07        	bne	FIN6		; ...ALWAYS, NUMBER COMPLETED
  4893 00:B944: 66 9C        FIN31:	ror     EXPSGN		; C=1, SET FLAG NEGATIVE
  4894                        
  4895                        ; ----------------------------------------------------------------------------
  4896 00:B946: 20 B1 00     FIN4:	jsr	CHRGET		; GET NEXT DIGIT OF EXPONENT
  4897                        
  4898                        ; ----------------------------------------------------------------------------
  4899 00:B949: 90 5B        FIN5:	bcc	GETEXP		; CHAR IS A DIGIT OF EXPONENT
  4900                        
  4901                        ; ----------------------------------------------------------------------------
  4902 00:B94B: 24 9C        FIN6:	bit	EXPSGN		; END OF NUMBER, CHECK EXP SIGN
  4903 00:B94D: 10 0E        	bpl	FIN7		; POSITIVE EXPONENT
  4904 00:B94F: A9 00        	lda	#0		; NEGATIVE EXPONENT
  4905 00:B951: 38           	sec			; MAKE 2'S COMPLEMENT OF EXPONENT
  4906 00:B952: E5 9A        	sbc	EXPON
  4907 00:B954: 4C 5F B9     	jmp	FIN8
  4908                        ; ----------------------------------------------------------------------------
  4909                        ; FOUND A DECIMAL POINT
  4910                        ; ----------------------------------------------------------------------------
  4911 00:B957: 66 9B        FIN10:	ror	DPFLG		; C=1, SET DPFLG FOR DECIMAL POINT
  4912 00:B959: 24 9B        	bit	DPFLG		; CHECK IF PREVIOUS DEC. PT.
  4913 00:B95B: 50 C3        	bvc	FIN1		; NO PREVIOUS DECIMAL POINT
  4914                        ; A SECOND DECIMAL POINT IS TAKEN AS A TERMINATOR
  4915                        ; TO THE NUMERIC STRING.
  4916                        ; "A=11..22" WILL GIVE A SYNTAX ERROR, BECAUSE
  4917                        ; IT IS TWO NUMBERS WITH NO OPERATOR BETWEEN.
  4918                        ; "PRINT 11..22" GIVES NO ERROR, BECAUSE IT IS
  4919                        ; JUST THE CONCATENATION OF TWO NUMBERS.
  4920                        
  4921                        ; ----------------------------------------------------------------------------
  4922                        ; NUMBER TERMINATED, ADJUST EXPONENT NOW
  4923                        ; ----------------------------------------------------------------------------
  4924 00:B95D: A5 9A        FIN7:	lda	EXPON		; E-VALUE
  4925 00:B95F: 38           FIN8:	sec			; MODIFY WITH COUNT OF DIGITS
  4926 00:B960: E5 99        	sbc	TMPEXP		; AFTER THE DECIMAL POINT
  4927 00:B962: 85 9A        	sta	EXPON		; COMPLETE CURRENT EXPONENT
  4928 00:B964: F0 12        	beq	FIN815		; NO ADJUST NEEDED IF EXP=0
  4929 00:B966: 10 09        	bpl	FIN814		; EXP>0, MULTIPLY BY TEN
  4930 00:B968: 20 17 B7     FIN813:	jsr	DIV10		; EXP<0, DIVIDE BY TEN
  4931 00:B96B: E6 9A        	inc	EXPON		; UNTIL EXP=0
  4932 00:B96D: D0 F9        	bne	FIN813
  4933 00:B96F: F0 07        	beq	FIN815		; ...ALWAYS, WE ARE FINISHED
  4934 00:B971: 20 FB B6     FIN814:	jsr	MUL10		; EXP>0, MULTIPLY BKY TEN
  4935 00:B974: C6 9A        	dec	EXPON		; UNTIL EXP=0
  4936 00:B976: D0 F9        	bne	FIN814
  4937 00:B978: A5 A3        FIN815:	lda	SERLEN		; IS WHOLE NUMBER NEGATIVE?
  4938 00:B97A: 30 01        	bmi	FIN816		; YES
  4939 00:B97C: 60           	rts			; NO, RETURN, WHOLE JOB DONE!
  4940 00:B97D: 4C 8C BB     FIN816:	jmp	NEGOP		; NEGATIVE NUMBER, SO NEGATE FAC
  4941                        
  4942                        
  4943                        ; ----------------------------------------------------------------------------
  4944                        ; ACCUMULATE A DIGIT INTO FAC
  4945                        ; ----------------------------------------------------------------------------
  4946 00:B980: 48           FIN9:	pha			; SAVE DIGIT
  4947 00:B981: 24 9B        	bit	DPFLG		; SEEN A DECIMAL POINT YET?
  4948 00:B983: 10 02        	bpl	FIN91		; NO, STILL IN INTEGER PART
  4949 00:B985: E6 99        	inc	TMPEXP		; YES, COUNT THE FRACTIONAL DIGIT
  4950 00:B987: 20 FB B6     FIN91:	jsr	MUL10		; FAC = FAC * 10
  4951 00:B98A: 68           	pla			; CURRENT DIGIT
  4952 00:B98B: 29 0F        	and	#$0F
  4953 00:B98D: 20 93 B9     	jsr	ADDACC		; ADD THE DIGIT
  4954 00:B990: 4C 20 B9     	jmp	FIN1		; GO BACK FOR MORE
  4955                        
  4956                        
  4957                        ; ----------------------------------------------------------------------------
  4958                        ; ADD (A) TO FAC
  4959                        ; ----------------------------------------------------------------------------
  4960 00:B993: 48           ADDACC:	pha			; SAVE ADDEND
  4961 00:B994: 20 25 B8     	jsr	COPY_FAC_TO_ARG_ROUNDED
  4962 00:B997: 68           	pla			; GET ADDEND AGAIN
  4963 00:B998: 20 55 B8     	jsr	FLOAT		; CONVERT TO FP VALUE IN FAC
  4964 00:B99B: A5 AA        	lda	ARGSIGN
  4965 00:B99D: 45 A2        	eor	FACSIGN
  4966 00:B99F: 85 AB        	sta	SGNCPR
  4967 00:B9A1: A6 9D        	ldx	FAC		; TO SIGNAL IF FAC=0
  4968 00:B9A3: 4C 88 B4     	jmp	FADDT		; PERFORM THE ADDITION
  4969                        
  4970                        
  4971                        ; ----------------------------------------------------------------------------
  4972                        ; ACCUMULATE DIGIT OF EXPONENT
  4973                        ; ----------------------------------------------------------------------------
  4974 00:B9A6: A5 9A        GETEXP:	lda	EXPON		; CHECK CURRENT VALUE
  4975 00:B9A8: C9 0A        	cmp	#10		; FOR MORE THAN 2 DIGITS
  4976 00:B9AA: 90 09        	bcc	GETEXP1		; NO, THIS IS 1ST OR 2ND DIGIT
  4977 00:B9AC: A9 64        	lda	#100		; EXPONENT TOO BIG
  4978 00:B9AE: 24 9C        	bit	EXPSGN		; UNLESS IT IS NEGATIVE
  4979 00:B9B0: 30 10        	bmi	GETEXP2		; LARGE NEGATIVE EXPONENT MAKES FAC=0
  4980 00:B9B2: 4C 9C B5     	jmp	OVERFLOW	; LARGE POSITIVE EXPONENT IS ERROR
  4981                        GETEXP1:
  4982 00:B9B5: 0A           	asl	a		; EXPONENT TIMES 10
  4983 00:B9B6: 0A           	asl	a
  4984 00:B9B7: 18           	clc
  4985 00:B9B8: 65 9A        	adc	EXPON
  4986 00:B9BA: 0A           	asl	a
  4987 00:B9BB: A0 00        	ldy	#0		; ADD THE NEW DIGIT
  4988 00:B9BD: 71 B8        	adc	(TXTPTR),y	; BUT THIS IS IN ASCII,
  4989 00:B9BF: 38           	sec			; SO ADJUST BACK TO BINARY
  4990 00:B9C0: E9 30        	sbc	#'0'
  4991                        GETEXP2:
  4992 00:B9C2: 85 9A        	sta	EXPON		; NEW VALUE
  4993 00:B9C4: 4C 46 B9     	jmp	FIN4		; BACK FOR MORE
  4994                        
  4995                        ; ----------------------------------------------------------------------------
  4996                        CON_99999999_9:
  4997 00:B9C7: 9B 3E BC 1F  	db	$9B,$3E,$BC,$1F,$FD	; 99,999,999.9
       00:B9CB: FD 
  4998                        
  4999                        CON_999999999:
  5000 00:B9CC: 9E 6E 6B 27  	db	$9E,$6E,$6B,$27,$FD	; 999,999,999
       00:B9D0: FD 
  5001                        
  5002                        CON_BILLION:
  5003 00:B9D1: 9E 6E 6B 28  	db	$9E,$6E,$6B,$28,$00	; 1,000,000,000
       00:B9D5: 00 
  5004                        
  5005                        
  5006                        ; ----------------------------------------------------------------------------
  5007                        ; PRINT "IN <LINE #>"
  5008                        ; ----------------------------------------------------------------------------
  5009 00:B9D6: A9 21        INPRT:	lda	#<QT_IN		; PRINT " IN "
  5010 00:B9D8: A0 A2        	ldy	#>QT_IN
  5011 00:B9DA: 20 2B A9     	jsr	STROUT
  5012 00:B9DD: A5 76        	lda	CURLIN+1
  5013 00:B9DF: A6 75        	ldx	CURLIN
  5014                        
  5015                        
  5016                        ; ----------------------------------------------------------------------------
  5017                        ; PRINT A,X AS DECIMAL INTEGER
  5018                        ; ----------------------------------------------------------------------------
  5019 00:B9E1: 85 9E        LINPRT:	sta	FAC+1		; PRINT A,X IN DECIMAL
  5020 00:B9E3: 86 9F        	stx	FAC+2
  5021 00:B9E5: A2 90        	ldx	#$90		; EXPONENT = 2^16
  5022 00:B9E7: 38           	sec			; CONVERT UNSIGNED
  5023 00:B9E8: 20 62 B8     	jsr	FLOAT2		; CONVERT LINE # TO FP
  5024 00:B9EB: 20 F1 B9     	jsr	FOUT		; CONVERT (FAC) TO STRING AT STACK
  5025 00:B9EE: 4C 2B A9     	jmp	STROUT		; PRINT STRING AT A,Y
  5026                        
  5027                        
  5028                        ; ----------------------------------------------------------------------------
  5029                        ; CONVERT (FAC) TO STRING STARTING AT STACK
  5030                        ; RETURN WITH (Y,A) POINTING AT STRING
  5031                        ; ----------------------------------------------------------------------------
  5032 00:B9F1: A0 01        FOUT:	ldy	#1		; NORMAL ENTRY PUTS STRING AT STACK...
  5033                        
  5034                        
  5035                        ; ----------------------------------------------------------------------------
  5036                        ; "STR$" FUNCTION ENTERS HERE, WITH (Y)=0
  5037                        ; SO THAT RESULT STRING STARTS AT STACK-1
  5038                        ; (THIS IS USED AS A FLAG)
  5039                        ; ----------------------------------------------------------------------------
  5040 00:B9F3: A9 2D        FOUT1:	lda	#'-'		; IN CASE VALUE NEGATIVE
  5041 00:B9F5: 88           	dey			; BACK UP PNTR
  5042 00:B9F6: 24 A2        	bit	FACSIGN
  5043 00:B9F8: 10 04        	bpl	FOUT11		; VALUE IS +
  5044 00:B9FA: C8           	iny			; VALUE IS -
  5045 00:B9FB: 99 FF 00     	sta	STACK-1,y	; EMIT "-"
  5046 00:B9FE: 85 A2        FOUT11:	sta	FACSIGN		; MAKE FAC.SIGN POSITIVE ($2D)
  5047 00:BA00: 84 AD        	sty	STRNG2		; SAVE STRING PNTR
  5048 00:BA02: C8           	iny
  5049 00:BA03: A9 30        	lda	#'0'		; IN CASE (FAC)=0
  5050 00:BA05: A6 9D        	ldx	FAC		; NUMBER=0?
  5051 00:BA07: D0 03        	bne	FOUT12		; NO, (FAC) NOT ZERO
  5052 00:BA09: 4C 14 BB     	jmp	FOUT4		; YES, FINISHED
  5053                        ; ----------------------------------------------------------------------------
  5054 00:BA0C: A9 00        FOUT12:	lda	#0		; STARTING VALUE FOR TMPEXP
  5055 00:BA0E: E0 80        	cpx	#$80		; ANY INTEGER PART?
  5056 00:BA10: F0 02        	beq	FOUT13		; NO, BTWN .5 AND .999999999
  5057 00:BA12: B0 09        	bcs	FOUT14		; YES
  5058                        ; ----------------------------------------------------------------------------
  5059 00:BA14: A9 D1        FOUT13:	lda	#<CON_BILLION	; MULTIPLY BY 1E9
  5060 00:BA16: A0 B9        	ldy	#>CON_BILLION	; TO GIVE ADJUSTMENT A HEAD START
  5061 00:BA18: 20 46 B6     	jsr	FMULT
  5062 00:BA1B: A9 F7        	lda	#$F7		; A = -9 : EXPONENT ADJUSTMENT
  5063 00:BA1D: 85 99        FOUT14:	sta	TMPEXP		; 0 OR -9
  5064                        ; ----------------------------------------------------------------------------
  5065                        ; ADJUST UNTIL 1E8 <= (FAC) <1E9
  5066                        ; ----------------------------------------------------------------------------
  5067 00:BA1F: A9 CC        FOUT15:	lda	#<CON_999999999
  5068 00:BA21: A0 B9        	ldy	#>CON_999999999
  5069 00:BA23: 20 74 B8     	jsr	FCOMP		; COMPARE TO 1E9-1
  5070 00:BA26: F0 1E        	beq	FOUT110		; (FAC) = 1E9-1
  5071 00:BA28: 10 12        	bpl	FOUT18		; TOO LARGE, DIVIDE BY TEN
  5072 00:BA2A: A9 C7        FOUT16:	lda	#<CON_99999999_9	; COMPARE TO 1E8-.1
  5073 00:BA2C: A0 B9        	ldy	#>CON_99999999_9
  5074 00:BA2E: 20 74 B8     	jsr	FCOMP		; COMPARE TO 1E8-.1
  5075 00:BA31: F0 02        	beq	FOUT17		; (FAC) = 1E8-.1
  5076 00:BA33: 10 0E        	bpl	FOUT19		; IN RANGE, ADJUSTMENT FINISHED
  5077 00:BA35: 20 FB B6     FOUT17:	jsr	MUL10		; TOO SMALL, MULTIPLY BY TEN
  5078 00:BA38: C6 99        	dec	TMPEXP		; KEEP TRACK OF MULTIPLIES
  5079 00:BA3A: D0 EE        	bne	FOUT16		; ...ALWAYS
  5080 00:BA3C: 20 17 B7     FOUT18:	jsr	DIV10		; TOO LARGE, DIVIDE BY TEN
  5081 00:BA3F: E6 99        	inc	TMPEXP		; KEEP TRACK OF DIVISIONS
  5082 00:BA41: D0 DC        	bne	FOUT15		; ...ALWAYS
  5083                        ; ----------------------------------------------------------------------------
  5084 00:BA43: 20 67 B4     FOUT19:	jsr	FADDH_		; ROUND ADJUSTED RESULT
  5085                        FOUT110:
  5086 00:BA46: 20 B1 B8     	jsr	QINT		; CONVERT ADJUSTED VALUE TO 32-BIT INTEGER
  5087                        
  5088                        
  5089                        ; ----------------------------------------------------------------------------
  5090                        ; FAC+1...FAC+4 IS NOW IN INTEGER FORM
  5091                        ; WITH POWER OF TEN ADJUSTMENT IN TMPEXP
  5092                        ;
  5093                        ; IF -10 < TMPEXP > 1, PRINT IN DECIMAL FORM
  5094                        ; OTHERWISE, PRINT IN EXPONENTIAL FORM
  5095                        ; ----------------------------------------------------------------------------
  5096 00:BA49: A2 01        FOUT2:	ldx	#1		; ASSUME 1 DIGIT BEFORE "."
  5097 00:BA4B: A5 99        	lda	TMPEXP		; CHECK RANGE
  5098 00:BA4D: 18           	clc
  5099 00:BA4E: 69 0A        	adc	#10
  5100 00:BA50: 30 09        	bmi	FOUT21		; < .01, USE EXPONENTIAL FORM
  5101 00:BA52: C9 0B        	cmp	#11
  5102 00:BA54: B0 06        	bcs	FOUT22		; >= 1E10, USE EXPONENTIAL FORM
  5103 00:BA56: 69 FF        	adc	#$FF		; LESS 1 GIVES INDEX FOR "."
  5104 00:BA58: AA           	tax
  5105 00:BA59: A9 02        	lda	#2		; SET REMAINING EXPONENT = 0
  5106 00:BA5B: 38           FOUT21:	sec			; COMPUTE REMAINING EXPONENT
  5107 00:BA5C: E9 02        FOUT22:	sbc	#2
  5108 00:BA5E: 85 9A        	sta	EXPON		; VALUE FOR "E+XX" OR "E-XX"
  5109 00:BA60: 86 99        	stx	TMPEXP		; INDEX FOR DECIMAL POINT
  5110 00:BA62: 8A           	txa			; SEE IF "." COMES FIRST
  5111 00:BA63: F0 02        	beq	FOUT23		; YES
  5112 00:BA65: 10 13        	bpl	FOUT25		; NO, LATER
  5113 00:BA67: A4 AD        FOUT23:	ldy	STRNG2		; GET INDEX INTO STRING BEING BUILT
  5114 00:BA69: A9 2E        	lda	#'.'		; STORE A DECIMAL POINT
  5115 00:BA6B: C8           	iny
  5116 00:BA6C: 99 FF 00     	sta	STACK-1,y
  5117 00:BA6F: 8A           	txa			; SEE IF NEED ".0"
  5118 00:BA70: F0 06        	beq	FOUT24		; NO
  5119 00:BA72: A9 30        	lda	#'0'		; YES, STORE "0"
  5120 00:BA74: C8           	iny
  5121 00:BA75: 99 FF 00     	sta	STACK-1,y
  5122 00:BA78: 84 AD        FOUT24:	sty	STRNG2		; SAVE OUTPUT INDEX AGAIN
  5123                        ; ----------------------------------------------------------------------------
  5124                        ; NOW DIVIDE BY POWERS OF TEN TO GET SUCCESSIVE DIGITS
  5125                        ; ----------------------------------------------------------------------------
  5126 00:BA7A: A0 00        FOUT25:	ldy	#0		; INDEX TO TABLE OF POWERS OF TEN
  5127 00:BA7C: A2 80        	ldx	#$80		; STARTING VALUE FOR DIGIT WITH DIRECTION
  5128 00:BA7E: A5 A1        FOUT26:	lda	FAC+4		; START BY ADDING -100000000 UNTIL
  5129 00:BA80: 18           	clc			; OVERSHOOT.  THEN ADD +10000000,
  5130 00:BA81: 79 29 BB     	adc	DECTBL+3,y	; THEN ADD -1000000, THEN ADD
  5131 00:BA84: 85 A1        	sta	FAC+4		; +100000, AND SO ON.
  5132 00:BA86: A5 A0        	lda	FAC+3		; THE # OF TIMES EACH POWER IS ADDED
  5133 00:BA88: 79 28 BB     	adc	DECTBL+2,y	; IS 1 MORE THAN CORRESPONDING DIGIT
  5134 00:BA8B: 85 A0        	sta	FAC+3
  5135 00:BA8D: A5 9F        	lda	FAC+2
  5136 00:BA8F: 79 27 BB     	adc	DECTBL+1,y
  5137 00:BA92: 85 9F        	sta	FAC+2
  5138 00:BA94: A5 9E        	lda	FAC+1
  5139 00:BA96: 79 26 BB     	adc	DECTBL,y
  5140 00:BA99: 85 9E        	sta	FAC+1
  5141 00:BA9B: E8           	inx			; COUNT THE ADD
  5142 00:BA9C: B0 04        	bcs	FOUT27		; IF C=1 AND X NEGATIVE, KEEP ADDING
  5143 00:BA9E: 10 DE        	bpl	FOUT26		; IF C=0 AND X POSITIVE, KEEP ADDING
  5144 00:BAA0: 30 02        	bmi	FOUT28		; IF C=0 AND X NEGATIVE, WE OVERSHOT
  5145 00:BAA2: 30 DA        FOUT27:	bmi	FOUT26		; IF C=1 AND X POSITIVE, WE OVERSHOT
  5146 00:BAA4: 8A           FOUT28:	txa			; OVERSHOT, SO MAKE X INTO A DIGIT
  5147 00:BAA5: 90 04        	bcc	FOUT29		; HOW DEPENDS ON DIRECTION WE WERE GOING
  5148 00:BAA7: 49 FF        	eor	#$FF		; DIGIT = 9-X
  5149 00:BAA9: 69 0A        	adc	#10
  5150 00:BAAB: 69 2F        FOUT29:	adc	#'0'-1		; MAKE DIGIT INTO ASCII
  5151 00:BAAD: C8           	iny			; ADVANCE TO NEXT SMALLER POWER OF TEN
  5152 00:BAAE: C8           	iny
  5153 00:BAAF: C8           	iny
  5154 00:BAB0: C8           	iny
  5155 00:BAB1: 84 83        	sty	VARPNT		; SAVE PNTR TO POWERS
  5156 00:BAB3: A4 AD        	ldy	STRNG2		; GET OUTPUT PNTR
  5157 00:BAB5: C8           	iny			; STORE THE DIGIT
  5158 00:BAB6: AA           	tax			; SAVE DIGIT, HI-BIT IS DIRECTION
  5159 00:BAB7: 29 7F        	and	#$7F		; MAKE SURE $30...$39 FOR STRING
  5160 00:BAB9: 99 FF 00     	sta	STACK-1,y
  5161 00:BABC: C6 99        	dec	TMPEXP		; COUNT THE DIGIT
  5162 00:BABE: D0 06        	bne	FOUT210		; NOT TIME FOR "." YET
  5163 00:BAC0: A9 2E        	lda	#'.'		; TIME, SO STORE THE DECIMAL POINT
  5164 00:BAC2: C8           	iny
  5165 00:BAC3: 99 FF 00     	sta	STACK-1,y
  5166                        FOUT210:
  5167 00:BAC6: 84 AD        	sty	STRNG2		; SAVE OUTPUT PNTR AGAIN
  5168 00:BAC8: A4 83        	ldy	VARPNT		; GET PNTR TO POWERS
  5169 00:BACA: 8A           	txa			; GET DIGIT WITH HI-BIT = DIRECTION
  5170 00:BACB: 49 FF        	eor	#$FF		; CHANGE DIRECTION
  5171 00:BACD: 29 80        	and	#$80		; $00 IF ADDING, $80 IF SUBTRACTING
  5172 00:BACF: AA           	tax
  5173 00:BAD0: C0 24        	cpy	#DECTBL_END-DECTBL
  5174 00:BAD2: D0 AA        	bne	FOUT26		; NOT FINISHED YET
  5175                        
  5176                        
  5177                        ; ----------------------------------------------------------------------------
  5178                        ; NINE DIGITS HAVE BEEN STORED IN STRING.  NOW LOOK
  5179                        ; BACK AND LOP OFF TRAILING ZEROES AND A TRAILING
  5180                        ; DECIMAL POINT.
  5181                        ; ----------------------------------------------------------------------------
  5182 00:BAD4: A4 AD        FOUT3:	ldy	STRNG2		; POINTS AT LAST STORED CHAR
  5183 00:BAD6: B9 FF 00     FOUT31:	lda	STACK-1,y	; SEE IF LOPPABLE
  5184 00:BAD9: 88           	dey
  5185 00:BADA: C9 30        	cmp	#'0'		; SUPPRESS TRAILING ZEROES
  5186 00:BADC: F0 F8        	beq	FOUT31		; YES, KEEP LOOPING
  5187 00:BADE: C9 2E        	cmp	#'.'		; SUPPRESS TRAILING DECIMAL POINT
  5188 00:BAE0: F0 01        	beq	FOUT32		; ".", SO WRITE OVER IT
  5189 00:BAE2: C8           	iny			; NOT ".", SO INCLUDE IN STRING AGAIN
  5190 00:BAE3: A9 2B        FOUT32:	lda	#'+'		; PREPARE FOR POSITIVE EXPONENT "E+XX"
  5191 00:BAE5: A6 9A        	ldx	EXPON		; SEE IF ANY E-VALUE
  5192 00:BAE7: F0 2E        	beq	FOUT5		; NO, JUST MARK END OF STRING
  5193 00:BAE9: 10 08        	bpl	FOUT33		; YES, AND IT IS POSITIVE
  5194 00:BAEB: A9 00        	lda	#0		; YES, AND IT IS NEGATIVE
  5195 00:BAED: 38           	sec			; COMPLEMENT THE VALUE
  5196 00:BAEE: E5 9A        	sbc	EXPON
  5197 00:BAF0: AA           	tax			; GET MAGNITUDE IN X
  5198 00:BAF1: A9 2D        	lda	#'-'		; E SIGN
  5199 00:BAF3: 99 01 01     FOUT33:	sta	STACK+1,y	; STORE SIGN IN STRING
  5200 00:BAF6: A9 45        	lda	#'E'		; STORE "E" IN STRING BEFORE SIGN
  5201 00:BAF8: 99 00 01     	sta	STACK,y
  5202 00:BAFB: 8A           	txa			; EXPONENT MAGNITUDE IN A-REG
  5203 00:BAFC: A2 2F        	ldx	#'0'-1		; SEED FOR EXPONENT DIGIT
  5204 00:BAFE: 38           	sec			; CONVERT TO DECIMAL
  5205 00:BAFF: E8           FOUT34:	inx			; COUNT THE SUBTRACTION
  5206 00:BB00: E9 0A        	sbc	#10		; TEN'S DIGIT
  5207 00:BB02: B0 FB        	bcs	FOUT34		; MORE TENS TO SUBTRACT
  5208 00:BB04: 69 3A        	adc	#'0'+10		; CONVERT REMAINDER TO ONE'S DIGIT
  5209 00:BB06: 99 03 01     	sta	STACK+3,y	; STORE ONE'S DIGIT
  5210 00:BB09: 8A           	txa
  5211 00:BB0A: 99 02 01     	sta	STACK+2,y	; STORE TEN'S DIGIT
  5212 00:BB0D: A9 00        	lda	#0		; MARK END OF STRING WITH $00
  5213 00:BB0F: 99 04 01     	sta	STACK+4,y
  5214 00:BB12: F0 08        	beq	FOUT6		; ...ALWAYS
  5215 00:BB14: 99 FF 00     FOUT4:	sta	STACK-1,y	; STORE "0" IN ASCII
  5216 00:BB17: A9 00        FOUT5:	lda	#0		; STORE $00 ON END OF STRING
  5217 00:BB19: 99 00 01     	sta	STACK,y
  5218 00:BB1C: A9 00        FOUT6:	lda	#<STACK		; POINT Y,A AT BEGINNING OF STRING
  5219 00:BB1E: A0 01        	ldy	#>STACK		; (STR$ STARTED STRING AT STACK-1, BUT
  5220 00:BB20: 60           	rts			; STR$ DOESN'T USE Y,A ANYWAY.)
  5221                        
  5222                        
  5223                        ; ----------------------------------------------------------------------------
  5224                        CON_HALF:
  5225 00:BB21: 80 00 00 00  	db	$80,$00,$00,$00,$00	; FP CONSTANT 0.5
       00:BB25: 00 
  5226                        
  5227                        
  5228                        ; ----------------------------------------------------------------------------
  5229                        ; POWERS OF 10 FROM 1E8 DOWN TO 1,
  5230                        ; AS 32-BIT INTEGERS, WITH ALTERNATING SIGNS
  5231                        ; ----------------------------------------------------------------------------
  5232 00:BB26: FA 0A 1F 00  DECTBL: db	$FA,$0A,$1F,$00		; -100000000
  5233 00:BB2A: 00 98 96 80  	db	$00,$98,$96,$80		; 10000000
  5234 00:BB2E: FF F0 BD C0  	db	$FF,$F0,$BD,$C0		; -1000000
  5235 00:BB32: 00 01 86 A0  	db	$00,$01,$86,$A0		; 100000
  5236 00:BB36: FF FF D8 F0  	db	$FF,$FF,$D8,$F0		; -10000
  5237 00:BB3A: 00 00 03 E8  	db	$00,$00,$03,$E8		; 1000
  5238 00:BB3E: FF FF FF 9C  	db	$FF,$FF,$FF,$9C		; -100
  5239 00:BB42: 00 00 00 0A  	db	$00,$00,$00,$0A		; 10
  5240 00:BB46: FF FF FF FF  	db	$FF,$FF,$FF,$FF		; -1
  5241                        DECTBL_END:
  5242                        
  5243                        
  5244                        ; ----------------------------------------------------------------------------
  5245                        ; "SQR" FUNCTION
  5246                        ; ----------------------------------------------------------------------------
  5247 00:BB4A: 20 25 B8     SQR:	jsr	COPY_FAC_TO_ARG_ROUNDED
  5248 00:BB4D: A9 21        	lda	#<CON_HALF		; SET UP POWER OF 0.5
  5249 00:BB4F: A0 BB        	ldy	#>CON_HALF
  5250 00:BB51: 20 BB B7     	jsr	LOAD_FAC_FROM_YA
  5251                        
  5252                        
  5253                        ; ----------------------------------------------------------------------------
  5254                        ; EXPONENTIATION OPERATION
  5255                        ;
  5256                        ; ARG ^ FAC  =  EXP( LOG(ARG) * FAC )
  5257                        ; ----------------------------------------------------------------------------
  5258 00:BB54: F0 6F        FPWRT:	beq	EXP		; IF FAC=0, ARG^FAC=EXP(0)
  5259 00:BB56: A5 A5        	lda	ARG		; IF ARG=0, ARG^FAC=0
  5260 00:BB58: D0 03        	bne	FPWRT1		; NEITHER IS ZERO
  5261 00:BB5A: 4C 17 B5     	jmp	STA_IN_FAC_SIGN_AND_EXP		; SET FAC = 0
  5262 00:BB5D: A2 8A        FPWRT1:	ldx	#TEMP3		; SAVE FAC IN TEMP3
  5263 00:BB5F: A0 00        	ldy	#0
  5264 00:BB61: 20 ED B7     	jsr	STORE_FAC_AT_YX_ROUNDED
  5265 00:BB64: A5 AA        	lda	ARGSIGN		; NORMALLY, ARG MUST BE POSITIVE
  5266 00:BB66: 10 0F        	bpl	FPWRT2		; IT IS POSITIVE, SO ALL IS WELL
  5267 00:BB68: 20 E2 B8     	jsr	INT		; NEGATIVE, BUT OK IF INTEGRAL POWER
  5268 00:BB6B: A9 8A        	lda	#TEMP3		; SEE IF INT(FAC)=FAC
  5269 00:BB6D: A0 00        	ldy	#0
  5270 00:BB6F: 20 74 B8     	jsr	FCOMP		; IS IT AN INTEGER POWER?
  5271 00:BB72: D0 03        	bne	FPWRT2		; NOT INTEGRAL,  WILL CAUSE ERROR LATER
  5272 00:BB74: 98           	tya			; MAKE ARG SIGN + AS IT IS MOVED TO FAC
  5273 00:BB75: A4 0D        	ldy	CHARAC		; INTEGRAL, SO ALLOW NEGATIVE ARG
  5274 00:BB77: 20 17 B8     FPWRT2:	jsr	MFA		; MOVE ARGUMENT TO FAC
  5275 00:BB7A: 98           	tya			; SAVE FLAG FOR NEGATIVE ARG (0=+) 
  5276 00:BB7B: 48           	pha
  5277 00:BB7C: 20 08 B6     	jsr	LOG		; GET LOG(ARG)
  5278 00:BB7F: A9 8A        	lda	#TEMP3		; MULTIPLY BY POWER
  5279 00:BB81: A0 00        	ldy	#0
  5280 00:BB83: 20 46 B6     	jsr	FMULT
  5281 00:BB86: 20 C5 BB     	jsr	EXP		; E ^ LOG(FAC)
  5282 00:BB89: 68           	pla			; GET FLAG FOR NEGATIVE ARG
  5283 00:BB8A: 10 0A        	bpl	RTS18		; NOT NEGATIVE, FINISHED
  5284                        
  5285                        
  5286                        ; ----------------------------------------------------------------------------
  5287                        ; NEGATE VALUE IN FAC
  5288                        ; ----------------------------------------------------------------------------
  5289 00:BB8C: A5 9D        NEGOP:	lda	FAC		; IF FAC=0, NO NEED TO COMPLEMENT
  5290 00:BB8E: F0 06        	beq	RTS18		; YES, FAC=0
  5291 00:BB90: A5 A2        	lda	FACSIGN		; NO, SO TOGGLE SIGN
  5292 00:BB92: 49 FF        	eor	#$FF
  5293 00:BB94: 85 A2        	sta	FACSIGN
  5294 00:BB96: 60           RTS18:	rts
  5295                        
  5296                        
  5297                        ; ----------------------------------------------------------------------------
  5298                        CON_LOG_E:
  5299 00:BB97: 81 38 AA 3B  	db	$81,$38,$AA,$3B,$29	; LOG(E) TO BASE 2
       00:BB9B: 29 
  5300                        ; ----------------------------------------------------------------------------
  5301                        POLY_EXP:
  5302 00:BB9C: 07           	db	$07			; ( # OF TERMS IN POLYNOMIAL) - 1
  5303 00:BB9D: 71 34 58 3E  	db	$71,$34,$58,$3E,$56	; (LOG(2)^7)/8!
       00:BBA1: 56 
  5304 00:BBA2: 74 16 7E B3  	db	$74,$16,$7E,$B3,$1B	; (LOG(2)^6)/7!
       00:BBA6: 1B 
  5305 00:BBA7: 77 2F EE E3  	db	$77,$2F,$EE,$E3,$85	; (LOG(2)^5)/6!
       00:BBAB: 85 
  5306 00:BBAC: 7A 1D 84 1C  	db	$7A,$1D,$84,$1C,$2A	; (LOG(2)^4)/5!
       00:BBB0: 2A 
  5307 00:BBB1: 7C 63 59 58  	db	$7C,$63,$59,$58,$0A	; (LOG(2)^3)/4!
       00:BBB5: 0A 
  5308 00:BBB6: 7E 75 FD E7  	db	$7E,$75,$FD,$E7,$C6	; (LOG(2)^2)/3!
       00:BBBA: C6 
  5309 00:BBBB: 80 31 72 18  	db	$80,$31,$72,$18,$10	; LOG(2)/2!
       00:BBBF: 10 
  5310 00:BBC0: 81 00 00 00  	db	$81,$00,$00,$00,$00	; 1
       00:BBC4: 00 
  5311                        
  5312                        
  5313                        ; ----------------------------------------------------------------------------
  5314                        ; "EXP" FUNCTION
  5315                        ;
  5316                        ; FAC = E ^ FAC
  5317                        ; ----------------------------------------------------------------------------
  5318 00:BBC5: A9 97        EXP:	lda	#<CON_LOG_E	; CONVERT TO POWER OF TWO PROBLEM
  5319 00:BBC7: A0 BB        	ldy	#>CON_LOG_E	; E^X = 2^(LOG2(E)*X)
  5320 00:BBC9: 20 46 B6     	jsr	FMULT
  5321 00:BBCC: A5 AC        	lda	FACEXTENSION	; NON-STANDARD ROUNDING HERE
  5322 00:BBCE: 69 50        	adc	#$50		; ROUND UP IF EXTENSION > $AF
  5323 00:BBD0: 90 03        	bcc	EXP1		; NO, DON'T ROUND UP
  5324 00:BBD2: 20 3C B8     	jsr	INCREMENT_MANTISSA
  5325 00:BBD5: 85 92        EXP1:	sta	ARGEXTENSION	; STRANGE VALUE
  5326 00:BBD7: 20 28 B8     	jsr	MAF		; COPY FAC INTO ARG
  5327 00:BBDA: A5 9D        	lda	FAC		; MAXIMUM EXPONENT IS < 128
  5328 00:BBDC: C9 88        	cmp	#$88		; WITHIN RANGE?
  5329 00:BBDE: 90 03        	bcc	EXP3		; YES
  5330 00:BBE0: 20 ED B6     EXP2:	jsr	OUTOFRNG	; OVERFLOW IF +, RETURN 0.0 IF -
  5331 00:BBE3: 20 E2 B8     EXP3:	jsr	INT		; GET INT(FAC)
  5332 00:BBE6: A5 0D        	lda	CHARAC		; THIS IS THE INETGRAL PART OF THE POWER
  5333 00:BBE8: 18           	clc			; ADD TO EXPONENT BIAS + 1
  5334 00:BBE9: 69 81        	adc	#$81
  5335 00:BBEB: F0 F3        	beq	EXP2		; OVERFLOW
  5336 00:BBED: 38           	sec			; BACK OFF TO NORMAL BIAS
  5337 00:BBEE: E9 01        	sbc	#1
  5338 00:BBF0: 48           	pha			; SAVE EXPONENT
  5339                        ; ----------------------------------------------------------------------------
  5340 00:BBF1: A2 05        	ldx	#5		; SWAP ARG AND FAC
  5341 00:BBF3: B5 A5        EXP4:	lda	ARG,x
  5342 00:BBF5: B4 9D        	ldy	FAC,x
  5343 00:BBF7: 95 9D        	sta	FAC,x
  5344 00:BBF9: 94 A5        	sty	ARG,x
  5345 00:BBFB: CA           	dex
  5346 00:BBFC: 10 F5        	bpl	EXP4
  5347 00:BBFE: A5 92        	lda	ARGEXTENSION
  5348 00:BC00: 85 AC        	sta	FACEXTENSION
  5349 00:BC02: 20 71 B4     	jsr	FSUBT		; POWER-INT(POWER) --> FRACTIONAL PART
  5350 00:BC05: 20 8C BB     	jsr	NEGOP
  5351 00:BC08: A9 9C        	lda	#<POLY_EXP
  5352 00:BC0A: A0 BB        	ldy	#>POLY_EXP
  5353 00:BC0C: 20 2D BC     	jsr	POLYNOMIAL	; COMPUTE F(X) ON FRACTIONAL PART
  5354 00:BC0F: A9 00        	lda	#0
  5355 00:BC11: 85 AB        	sta	SGNCPR
  5356 00:BC13: 68           	pla			; GET EXPONENT
  5357 00:BC14: 4C D5 B6     	jmp	ADD_EXPONENTS1
  5358                        
  5359                        
  5360                        ; ----------------------------------------------------------------------------
  5361                        ; ODD POLYNOMIAL SUBROUTINE
  5362                        ;
  5363                        ; F(X) = X * P(X^2)
  5364                        ;
  5365                        ; WHERE:  X IS VALUE IN FAC
  5366                        ;	Y,A POINTS AT COEFFICIENT TABLE
  5367                        ;	FIRST BYTE OF COEFF. TABLE IS N
  5368                        ;	COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
  5369                        ;
  5370                        ; P(X^2) COMPUTED USING NORMAL POLYNOMIAL SUBROUTINE
  5371                        ; ----------------------------------------------------------------------------
  5372                        POLYNOMIAL_ODD:
  5373 00:BC17: 85 AD        	sta	SERPNT		; SAVE ADDRESS OF COEFFICIENT TABLE
  5374 00:BC19: 84 AE        	sty	SERPNT+1
  5375 00:BC1B: 20 E3 B7     	jsr	STORE_FAC_IN_TEMP1_ROUNDED
  5376 00:BC1E: A9 93        	lda	#TEMP1		; Y=0 ALREADY, SO Y,A POINTS AT TEMP1
  5377 00:BC20: 20 46 B6     	jsr	FMULT		; FORM X^2
  5378 00:BC23: 20 31 BC     	jsr	SERMAIN		; DO SERIES IN X^2
  5379 00:BC26: A9 93        	lda	#<TEMP1		; GET X AGAIN
  5380 00:BC28: A0 00        	ldy	#>TEMP1
  5381 00:BC2A: 4C 46 B6     	jmp	FMULT		; MULTIPLY X BY P(X^2) AND EXIT
  5382                        
  5383                        
  5384                        ; ----------------------------------------------------------------------------
  5385                        ; NORMAL POLYNOMIAL SUBROUTINE
  5386                        ;
  5387                        ; P(X) = C(0)*X^N + C(1)*X^(N-1) + ... + C(N)
  5388                        ;
  5389                        ; WHERE:  X IS VALUE IN FAC
  5390                        ;	Y,A POINTS AT COEFFICIENT TABLE
  5391                        ;	FIRST BYTE OF COEFF. TABLE IS N
  5392                        ;	COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
  5393                        ; ----------------------------------------------------------------------------
  5394                        POLYNOMIAL:
  5395 00:BC2D: 85 AD        	sta	SERPNT		; POINTER TO COEFFICIENT TABLE
  5396 00:BC2F: 84 AE        	sty	SERPNT+1
  5397                        ; ----------------------------------------------------------------------------
  5398                        SERMAIN:
  5399 00:BC31: 20 E0 B7     	jsr	STORE_FAC_IN_TEMP2_ROUNDED
  5400 00:BC34: B1 AD        	lda	(SERPNT),y	; GET N
  5401 00:BC36: 85 A3        	sta	SERLEN		; SAVE N
  5402 00:BC38: A4 AD        	ldy	SERPNT		; BUMP PNTR TO HIGHEST COEFFICIENT
  5403 00:BC3A: C8           	iny			; AND GET PNTR INTO Y,A
  5404 00:BC3B: 98           	tya
  5405 00:BC3C: D0 02        	bne	SERMAIN1
  5406 00:BC3E: E6 AE        	inc	SERPNT+1
  5407                        SERMAIN1:
  5408 00:BC40: 85 AD        	sta	SERPNT
  5409 00:BC42: A4 AE        	ldy	SERPNT+1
  5410                        SERMAIN2:
  5411 00:BC44: 20 46 B6     	jsr	FMULT		; ACCUMULATE SERIES TERMS
  5412 00:BC47: A5 AD        	lda	SERPNT		; BUMP PNTR TO NEXT COEFFICIENT
  5413 00:BC49: A4 AE        	ldy	SERPNT+1
  5414 00:BC4B: 18           	clc
  5415 00:BC4C: 69 05        	adc	#5
  5416 00:BC4E: 90 01        	bcc	SERMAIN3
  5417 00:BC50: C8           	iny
  5418                        SERMAIN3:
  5419 00:BC51: 85 AD        	sta	SERPNT
  5420 00:BC53: 84 AE        	sty	SERPNT+1
  5421 00:BC55: 20 85 B4     	jsr	FADD		; ADD NEXT COEFFICIENT
  5422 00:BC58: A9 98        	lda	#TEMP2		; POINT AT X AGAIN
  5423 00:BC5A: A0 00        	ldy	#0
  5424 00:BC5C: C6 A3        	dec	SERLEN		; IF SERIES NOT FINISHED,
  5425 00:BC5E: D0 E4        	bne	SERMAIN2		; THEN ADD ANOTHER TERM
  5426 00:BC60: 60           RTS19:  rts			; FINISHED
  5427                        
  5428                        ; ----------------------------------------------------------------------------
  5429                        CONRND1:
  5430 00:BC61: 98 35 44 7A  	db	$98,$35,$44,$7A		; THESE ARE MISSING ONE BYTE FOR FP VALUES
  5431                        
  5432                        CONRND2:
  5433 00:BC65: 68 28 B1 46  	db	$68,$28,$B1,$46
  5434                        
  5435                        
  5436                        ; ----------------------------------------------------------------------------
  5437                        ; "RND" FUNCTION
  5438                        ; ----------------------------------------------------------------------------
  5439 00:BC69: 20 44 B8     RND:	jsr	SIGN		; REDUCE ARGUMENT TO -1, 0, OR +1
  5440 00:BC6C: AA           	tax			; SAVE ARGUMENT
  5441 00:BC6D: 30 18        	bmi	RND1		; = -1, USE CURRENT ARGUMENT FOR SEED
  5442 00:BC6F: A9 C9        	lda	#<RNDSEED	; USE CURRENT SEED
  5443 00:BC71: A0 00        	ldy	#>RNDSEED
  5444 00:BC73: 20 BB B7     	jsr	LOAD_FAC_FROM_YA
  5445 00:BC76: 8A           	txa			; RECALL SIGN OF ARGUMENT
  5446 00:BC77: F0 E7        	beq	RTS19		; =0, RETURN SEED UNCHANGED
  5447 00:BC79: A9 61        	lda	#<CONRND1	; VERY POOR RND ALGORITHM
  5448 00:BC7B: A0 BC        	ldy	#>CONRND1
  5449 00:BC7D: 20 46 B6     	jsr	FMULT
  5450 00:BC80: A9 65        	lda	#<CONRND2	; ALSO, CONSTANTS ARE TRUNCATED
  5451 00:BC82: A0 BC        	ldy	#>CONRND2
  5452 00:BC84: 20 85 B4     	jsr	FADD
  5453 00:BC87: A6 A1        RND1:	ldx	FAC+4		; SHUFFLE HI AND LO BYTES
  5454 00:BC89: A5 9E        	lda	FAC+1		; TO SUPPOSEDLY MAKE IT MORE RANDOM
  5455 00:BC8B: 85 A1        	sta	FAC+4
  5456 00:BC8D: 86 9E        	stx	FAC+1
  5457 00:BC8F: A9 00        	lda	#0		; MAKE IT POSITIVE
  5458 00:BC91: 85 A2        	sta	FACSIGN
  5459 00:BC93: A5 9D        	lda	FAC		; A SOMEWHAT RANDOM EXTENSION
  5460 00:BC95: 85 AC        	sta	FACEXTENSION
  5461 00:BC97: A9 80        	lda	#$80		; EXPONENT TO MAKE VALUE < 1.0
  5462 00:BC99: 85 9D        	sta	FAC
  5463 00:BC9B: 20 F5 B4     	jsr	NORMALIZE_FAC2
  5464 00:BC9E: A2 C9        	ldx	#<RNDSEED	; MOVE FAC TO RND SEED
  5465 00:BCA0: A0 00        	ldy	#>RNDSEED
  5466 00:BCA2: 4C ED B7     	jmp	STORE_FAC_AT_YX_ROUNDED
  5467                        
  5468                        
  5469                        ; ----------------------------------------------------------------------------
  5470                        ; GENERIC COPY OF CHRGET SUBROUTINE, WHICH
  5471                        ; IS COPIED INTO $00B1...$00C8 DURING INITIALIZATION
  5472                        ;
  5473                        ; CORNELIS BONGERS DESCRIBED SEVERAL IMPROVEMENTS 
  5474                        ; TO CHRGET IN MICRO MAGAZINE OR CALL A.P.P.L.E.
  5475                        ; (I DON'T REMEMBER WHICH OR EXACTLY WHEN)
  5476                        ; ----------------------------------------------------------------------------
  5477                        GENERIC_CHRGET:
  5478 00:BCA5: E6 B8        	inc	TXTPTR
  5479 00:BCA7: D0 02        	bne	GENERIC1
  5480 00:BCA9: E6 B9        	inc	TXTPTR+1
  5481                        GENERIC1:
  5482 00:BCAB: AD 60 EA     	lda	$EA60		; ACTUAL ADDRESS FILLED IN LATER
  5483 00:BCAE: C9 3A        	cmp	#':'		; EOS, ALSO TOP OF NUMERIC RANGE
  5484 00:BCB0: B0 0A        	bcs	GENERIC2		; NOT NUMBER, MIGHT BE EOS
  5485 00:BCB2: C9 20        	cmp	#' '		; IGNORE BLANKS
  5486 00:BCB4: F0 EF        	beq	GENERIC_CHRGET
  5487 00:BCB6: 38           	sec			; TEST FOR NUMERIC RANGE IN WAY THAT
  5488 00:BCB7: E9 30        	sbc	#'0'		; CLEARS CARRY IF CHAR IS DIGIT
  5489 00:BCB9: 38           	sec			; AND LEAVES CHAR IN A-REG
  5490 00:BCBA: E9 D0        	sbc	#$D0		; -'0'
  5491                        GENERIC2:
  5492 00:BCBC: 60           	rts
  5493                        
  5494                        
  5495                        ; ----------------------------------------------------------------------------
  5496                        ; INITIAL VALUE FOR RANDOM NUMBER, ALSO COPIED
  5497                        ; IN ALONG WITH CHRGET, BUT ERRONEOUSLY:
  5498                        ; THE LAST BYTE IS NOT COPIED
  5499                        ; ----------------------------------------------------------------------------
  5500 00:BCBD: 80 4F C7 52  	db	$80,$4F,$C7,$52,$58	; APPROX. = .811635157
       00:BCC1: 58 
  5501                        GENERIC_END:
  5502                        
  5503                        
  5504                        ; ----------------------------------------------------------------------------
  5505                        COLDSTART:
  5506 00:BCC2: A2 FF        	ldx	#$FF		; SET DIRECT MODE FLAG
  5507 00:BCC4: 86 76        	stx	CURLIN+1
  5508 00:BCC6: A2 FB        	ldx	#$FB		; SET STACK POINTER, LEAVING ROOM FOR
  5509 00:BCC8: 9A           	txs			; LINE BUFFER DURING PARSING
  5510 00:BCC9: A9 C2        	lda	#<COLDSTART	; SET RESTART TO COLD.START
  5511 00:BCCB: A0 BC        	ldy	#>COLDSTART	; UNTIL COLDSTART IS COMPLETED
  5512 00:BCCD: 85 01        	sta	GOWARM+1
  5513 00:BCCF: 84 02        	sty	GOWARM+2
  5514 00:BCD1: 85 04        	sta	GOSTROUTZ+1	; ALSO SECOND USER VECTOR...
  5515 00:BCD3: 84 05        	sty	GOSTROUTZ+2	; ..WE SIMPLY MUST FINISH COLD.START!
  5516 00:BCD5: A9 4C        	lda	#$4C		; "JMP" OPCODE FOR 4 VECTORS
  5517 00:BCD7: 85 00        	sta	GOWARM		; WARM START
  5518 00:BCD9: 85 03        	sta	GOSTROUTZ	; ANYONE EVER USE THIS ONE?
  5519 00:BCDB: 85 90        	sta	JMPADRS		; USED BY FUNCTIONS (JSR JMPADRS)
  5520                        
  5521                        ; ----------------------------------------------------------------------------
  5522                        ; MOVE GENERIC CHRGET AND RANDOM SEED INTO PLACE
  5523                        ;
  5524                        ; NOTE THAT LOOP VALUE IS WRONG! 
  5525                        ; THE LAST BYTE OF THE RANDOM SEED IS NOT
  5526                        ; COPIED INTO PAGE ZERO!
  5527                        ; ----------------------------------------------------------------------------
  5528                        ;	ldx	#GENERIC_END-GENERIC_CHRGET-1
  5529 00:BCDD: A2 1D        	ldx	#GENERIC_END-GENERIC_CHRGET
  5530                        COLDSTART1:
  5531 00:BCDF: BD A4 BC     	lda	GENERIC_CHRGET-1,x
  5532 00:BCE2: 95 B0        	sta	CHRGET-1,x
  5533 00:BCE4: CA           	dex
  5534 00:BCE5: D0 F8        	bne	COLDSTART1
  5535                        ; ----------------------------------------------------------------------------
  5536 00:BCE7: 8A           	txa			; A=0
  5537 00:BCE8: 85 A4        	sta	SHIFTSIGNEXT
  5538 00:BCEA: 85 54        	sta	LASTPT+1
  5539 00:BCEC: 48           	pha			; PUT $00 ON STACK (WHAT FOR?)
  5540 00:BCED: A9 03        	lda	#3		; SET LENGTH OF TEMP. STRING DESCRIPTORS
  5541 00:BCEF: 85 8F        	sta	DSCLEN		; FOR GARBAGE COLLECTION SUBROUTINE
  5542 00:BCF1: 20 46 BE     	jsr	CRDO		; PRINT <RETURN>
  5543 00:BCF4: A9 01        	lda	#1		; SET UP FAKE FORWARD LINK
  5544 00:BCF6: 8D FD 01     	sta	INPUTBUFFER-3
  5545 00:BCF9: 8D FC 01     	sta	INPUTBUFFER-4
  5546 00:BCFC: A2 55        	ldx	#TEMPST		; INIT INDEX TO TEMP STRING DESCRIPTORS
  5547 00:BCFE: 86 52        	stx	TEMPPT
  5548                        ; ----------------------------------------------------------------------------
  5549                        ; FIND HIGH END OF RAM
  5550                        ; ----------------------------------------------------------------------------
  5551 00:BD00: A9 00        	lda	#<$0800		; SET UP POINTER TO LOW END OF RAM (Low)
  5552 00:BD02: A0 08        	ldy	#>$0800		; High
  5553 00:BD04: 85 50        	sta	LINNUM
  5554 00:BD06: 84 51        	sty	LINNUM+1
  5555                        
  5556                        	.if 0
  5557                        	ldy	#0
  5558                        COLDSTART2:
  5559                        	inc	LINNUM+1	; TEST FIRST BYTE OF EACH PAGE
  5560                        	lda	(LINNUM),y	; BY COMPLEMENTING IT AND WATCHING
  5561                        	eor	#$FF		; IT CHANGE THE SAME WAY
  5562                        	sta	(LINNUM),y
  5563                        	cmp	(LINNUM),y	; ROM OR EMPTY SOCKETS WON'T TRACK
  5564                        	bne	COLDSTART3		; NOT RAM HERE
  5565                        	eor	#$FF		; RESTORE ORIGINAL VALUE
  5566                        	sta	(LINNUM),y
  5567                        	cmp	(LINNUM),y	; DID IT TRACK AGAIN?
  5568                        	beq	COLDSTART2		; YES, STILL IN RAM
  5569                        COLDSTART3:
  5570                        	ldy	LINNUM		; NO, END OF RAM
  5571                        	lda	LINNUM+1
  5572                        	and	#$F0		; FORCE A MULTIPLE OF 4096 BYTES
  5573                        	.endif
  5574                        	
  5575 00:BD08: A0 00        	ldy	#<memsize		; SET PROGRAM POINTER TO $0800
  5576 00:BD0A: A9 80        	lda	#>memsize
  5577                        
  5578 00:BD0C: 84 50        	sty	LINNUM
  5579 00:BD0E: 85 51        	sta	LINNUM+1
  5580 00:BD10: 84 73        	sty	MEMSIZ		; (BAD RAM MAY HAVE YIELDED NON-MULTIPLE)
  5581 00:BD12: 85 74        	sta	MEMSIZ+1
  5582 00:BD14: 84 6F        	sty	FRETOP		; SET HIMEM AND BOTTOM OF STRINGS
  5583 00:BD16: 85 70        	sta	FRETOP+1
  5584 00:BD18: A2 00        	ldx	#<$0800		; SET PROGRAM POINTER TO $0800
  5585 00:BD1A: A0 08        	ldy	#>$0800
  5586 00:BD1C: 86 67        	stx	TXTTAB
  5587 00:BD1E: 84 68        	sty	TXTTAB+1
  5588 00:BD20: A0 00        	ldy	#0		; TURN OFF SEMI-SECRET LOCK FLAG
  5589 00:BD22: 84 D6        	sty	LOCK
  5590 00:BD24: 98           	tya			; A=0 TOO
  5591 00:BD25: 91 67        	sta	(TXTTAB),y	; FIRST BYTE IN PROGRAM SPACE = 0
  5592 00:BD27: E6 67        	inc	TXTTAB		; ADVANCE PAST THE $00
  5593 00:BD29: D0 02        	bne	COLDSTART4
  5594 00:BD2B: E6 68        	inc	TXTTAB+1
  5595                        COLDSTART4:
  5596 00:BD2D: A5 67        	lda	TXTTAB
  5597 00:BD2F: A4 68        	ldy	TXTTAB+1
  5598 00:BD31: 20 AB A2     	jsr	REASON		; SET REST OF POINTERS UP
  5599 00:BD34: 20 EC A4     	jsr	SCRTCH		; MORE POINTERS
  5600 00:BD37: A9 2B        	lda	#<STROUT	; PUT CORRECT ADDRESSES IN TWO
  5601 00:BD39: A0 A9        	ldy	#>STROUT	; USER VECTORS
  5602 00:BD3B: 85 04        	sta	GOSTROUTZ+1
  5603 00:BD3D: 84 05        	sty	GOSTROUTZ+2
  5604 00:BD3F: A9 04        	lda	#<RESTART
  5605 00:BD41: A0 A3        	ldy	#>RESTART
  5606 00:BD43: 85 01        	sta	GOWARM+1
  5607 00:BD45: 84 02        	sty	GOWARM+2
  5608                        
  5609             00000000   IN_GOWARM	equ	GOWARM
  5610                        
  5611 00:BD47: 6C 01 00     	jmp	(IN_GOWARM+1)	; SILLY, WHY NOT JUST "JMP RESTART"
  5612                        
  5613                        
  5614                        ; ----------------------------------------------------------------------------
  5615                        ; "CALL" STATEMENT
  5616                        ;
  5617                        ; EFFECTIVELY PERFORMS A "JSR" TO THE SPECIFIED
  5618                        ; ADDRESS, WITH THE FOLLOWING REGISTER CONTENTS:
  5619                        ; 	(A,Y) = CALL ADDRESS
  5620                        ;	(X)   = $9D
  5621                        ;
  5622                        ; THE CALLED ROUTINE CAN RETURN WITH "RTS",
  5623                        ; AND APPLESOFT WILL CONTINUE WITH THE NEXT
  5624                        ; STATEMENT.
  5625                        ; ----------------------------------------------------------------------------
  5626 00:BD4A: 20 34 AB     CALL:	jsr	FRMNUM		; EVALUATE EXPRESSION FOR CALL ADDRESS
  5627 00:BD4D: 20 35 B4     	jsr	GETADR		; CONVERT EXPRESSION TO 16-BIT INTEGER
  5628                        
  5629             00000050   IN_LINNUM	equ	LINNUM
  5630                        
  5631 00:BD50: 6C 50 00     	jmp	(IN_LINNUM)	; IN LINNUM, AND JUMP THERE.
  5632                        
  5633                        
  5634                        ; ----------------------------------------------------------------------------
  5635                        ; "HIMEM:" STATEMENT
  5636                        ; ----------------------------------------------------------------------------
  5637 00:BD53: 20 34 AB     HIMEM:	jsr	FRMNUM		; GET VALUE SPECIFIED FOR HIMEM
  5638 00:BD56: 20 35 B4     	jsr	GETADR		; AS 16-BIT INTEGER
  5639 00:BD59: A5 50        	lda	LINNUM		; MUST BE ABOVE VARIABLES AND ARRAYS
  5640 00:BD5B: C5 6D        	cmp	STREND
  5641 00:BD5D: A5 51        	lda	LINNUM+1
  5642 00:BD5F: E5 6E        	sbc	STREND+1
  5643 00:BD61: B0 03        	bcs	SETHI		; IT IS ABOVE THEM
  5644 00:BD63: 4C D8 A2     JMM:	jmp	MEMERR		; NOT ENOUGH MEMORY
  5645 00:BD66: A5 50        SETHI:	lda	LINNUM		; STORE NEW HIMEM: VALUE
  5646 00:BD68: 85 73        	sta	MEMSIZ
  5647 00:BD6A: 85 6F        	sta	FRETOP		; NOTE THAT "HIMEM:" DOES NOT
  5648 00:BD6C: A5 51        	lda	LINNUM+1	; CLEAR STRING VARIABLES.
  5649 00:BD6E: 85 74        	sta	MEMSIZ+1	; THIS COULD BE DISASTROUS.
  5650 00:BD70: 85 70        	sta	FRETOP+1
  5651 00:BD72: 60           	rts
  5652                        
  5653                        
  5654                        ; ----------------------------------------------------------------------------
  5655                        ; "LOMEM:" STATEMENT
  5656                        ; ----------------------------------------------------------------------------
  5657 00:BD73: 20 34 AB     LOMEM:	jsr	FRMNUM		; GET VALUE SPECIFIED FOR LOMEM
  5658 00:BD76: 20 35 B4     	jsr	GETADR		; AS 16-BIT INTEGER IN LINNUM
  5659 00:BD79: A5 50        	lda	LINNUM		; MUST BE BELOW HIMEM
  5660 00:BD7B: C5 73        	cmp	MEMSIZ
  5661 00:BD7D: A5 51        	lda	LINNUM+1
  5662 00:BD7F: E5 74        	sbc	MEMSIZ+1
  5663 00:BD81: B0 E0        	bcs	JMM		; ABOVE HIMEM, MEMORY ERROR
  5664 00:BD83: A5 50        	lda	LINNUM		; MUST BE ABOVE PROGRAM
  5665 00:BD85: C5 69        	cmp	VARTAB
  5666 00:BD87: A5 51        	lda	LINNUM+1
  5667 00:BD89: E5 6A        	sbc	VARTAB+1
  5668 00:BD8B: 90 D6        	bcc	JMM		; NOT ABOVE PROGRAM, ERROR
  5669 00:BD8D: A5 50        	lda	LINNUM		; STORE NEW LOMEM VALUE
  5670 00:BD8F: 85 69        	sta	VARTAB
  5671 00:BD91: A5 51        	lda	LINNUM+1
  5672 00:BD93: 85 6A        	sta	VARTAB+1
  5673 00:BD95: 4C 0D A5     	jmp	CLEARC		; LOMEM CLEARS VARIABLES AND ARRAYS
  5674                        
  5675                        
  5676                        ; ----------------------------------------------------------------------------
  5677                        ; "ON ERR GO TO" STATEMENT
  5678                        ; ----------------------------------------------------------------------------
  5679 00:BD98: A9 8E        ONERR:	lda	#TOKEN_GOTO	; MUST BE "GOTO" NEXT
  5680 00:BD9A: 20 86 AC     	jsr	SYNCHR
  5681 00:BD9D: A5 B8        	lda	TXTPTR		; SAVE TXTPTR FOR HANDLERR
  5682 00:BD9F: 85 F4        	sta	TXTPSV
  5683 00:BDA1: A5 B9        	lda	TXTPTR+1
  5684 00:BDA3: 85 F5        	sta	TXTPSV+1
  5685 00:BDA5: 38           	sec			; SET SIGN BIT OF ERRFLG
  5686 00:BDA6: 66 D8        	ror	ERRFLG
  5687 00:BDA8: A5 75        	lda	CURLIN		; SAVE LINE # OF CURRENT LINE
  5688 00:BDAA: 85 F6        	sta	CURLSV
  5689 00:BDAC: A5 76        	lda	CURLIN+1
  5690 00:BDAE: 85 F7        	sta	CURLSV+1
  5691 00:BDB0: 20 BF A7     	jsr	REMN		; IGNORE REST OF LINE <<<WHY?>>>
  5692 00:BDB3: 4C B1 A7     	jmp	ADDON		; CONTINUE PROGRAM
  5693                        
  5694                        
  5695                        ; ----------------------------------------------------------------------------
  5696                        ; ROUTINE TO HANDLE ERRORS IF ONERR GOTO ACTIVE
  5697                        ; ----------------------------------------------------------------------------
  5698                        HANDLERR:
  5699 00:BDB6: 86 DE        	stx	ERRNUM		; SAVE ERROR CODE NUMBER
  5700 00:BDB8: A6 F8        	ldx	REMSTK		; GET STACK PNTR SAVED AT NEWSTT
  5701 00:BDBA: 86 DF        	stx	ERRSTK		; REMEMBER IT
  5702 00:BDBC: A5 75        	lda	CURLIN		; GET LINE # OF OFFENDING STATEMENT
  5703 00:BDBE: 85 DA        	sta	ERRLIN		; SO USER CAN SEE IT IF DESIRED
  5704 00:BDC0: A5 76        	lda	CURLIN+1
  5705 00:BDC2: 85 DB        	sta	ERRLIN+1
  5706 00:BDC4: A5 79        	lda	OLDTEXT		; ALSO THE POSITION IN THE LINE
  5707 00:BDC6: 85 DC        	sta	ERRPOS		; IN CASE USER WANTS TO "RESUME"
  5708 00:BDC8: A5 7A        	lda	OLDTEXT+1
  5709 00:BDCA: 85 DD        	sta	ERRPOS+1
  5710 00:BDCC: A5 F4        	lda	TXTPSV		; SET UP TXTPTR TO READ TARGET LINE #
  5711 00:BDCE: 85 B8        	sta	TXTPTR		; IN "ON ERR GO TO XXXX"
  5712 00:BDD0: A5 F5        	lda	TXTPSV+1
  5713 00:BDD2: 85 B9        	sta	TXTPTR+1
  5714 00:BDD4: A5 F6        	lda	CURLSV
  5715 00:BDD6: 85 75        	sta	CURLIN		; LINE # OF "ON ERR" STATEMENT
  5716 00:BDD8: A5 F7        	lda	CURLSV+1
  5717 00:BDDA: 85 76        	sta	CURLIN+1
  5718 00:BDDC: 20 B7 00     	jsr	CHRGOT		; START CONVERSION
  5719 00:BDDF: 20 57 A7     	jsr	GOTO		; GOTO SPECIFIED ONERR LINE
  5720 00:BDE2: 4C 62 A6     	jmp	NEWSTT
  5721                        
  5722                        
  5723                        ; ----------------------------------------------------------------------------
  5724                        ; "RESUME" STATEMENT
  5725                        ; ----------------------------------------------------------------------------
  5726 00:BDE5: A5 DA        RESUME:	lda	ERRLIN		; RESTORE LINE # AND TXTPTR
  5727 00:BDE7: 85 75        	sta	CURLIN		; TO RE-TRY OFFENDING LINE
  5728 00:BDE9: A5 DB        	lda	ERRLIN+1
  5729 00:BDEB: 85 76        	sta	CURLIN+1
  5730 00:BDED: A5 DC        	lda	ERRPOS
  5731 00:BDEF: 85 B8        	sta	TXTPTR
  5732 00:BDF1: A5 DD        	lda	ERRPOS+1
  5733 00:BDF3: 85 B9        	sta	TXTPTR+1
  5734 00:BDF5: A6 DF        	ldx	ERRSTK		; RETRIEVE STACK PNTR AS IT WAS
  5735 00:BDF7: 9A           	txs			; BEFORE STATEMENT SCANNED
  5736 00:BDF8: 4C 62 A6     	jmp	NEWSTT		; DO STATEMENT AGAIN
  5737                        
  5738                        ;###############################################################################
  5739                        
  5740                        ; MEZW65C_RAM I/O routines for Applesoft Lite
  5741                        ; Last modified 2024.11.21
  5742                        
  5743                        ;;;
  5744                        ;;;	Console Driver
  5745                        ;;;
  5746                        
  5747                        ;
  5748                        ; request CONIN, CONST CONOUT to PIC18F47QXX
  5749                        ;
  5750                        ;;; Constants
  5751             0000000D   CR	EQU	$0D
  5752             0000000A   LF	EQU	$0A
  5753             00000008   BS	EQU	$08
  5754             00000009   TAB	EQU	$09
  5755             0000007F   DEL	EQU	$7F
  5756             00000000   NULL	EQU	$00
  5757                        
  5758             00000001   B_CONIN		EQU	$01
  5759             00000002   B_CONOUT	EQU	$02
  5760             00000003   B_CONST		EQU	$03
  5761             000000FF   B_END_P		equ	$ff
  5762                        
  5763                        ; ----------------------------------------------------------------------------
  5764                        ; Get keystroke from keyboard (RDKEY)
  5765                        ; ----------------------------------------------------------------------------
  5766                        ;CONIN
  5767                        RDKEY:
  5768 00:BDFB: 00 01        	brk	B_CONIN
  5769 00:BDFD: 60           	rts
  5770                        
  5771                        CONST
  5772 00:BDFE: 00 03        	brk	B_CONST
  5773 00:BE00: 29 01        	and	#$01
  5774 00:BE02: 60           	rts
  5775                        
  5776                        CONOUT
  5777 00:BE03: 48           	pha
  5778 00:BE04: 00 02        	brk	B_CONOUT
  5779 00:BE06: 68           	pla
  5780 00:BE07: 60           	rts
  5781                        
  5782                        NMI_SIG
  5783 00:BE08: 00 FF        	brk	B_END_P
  5784 00:BE0A: DB           	stp
  5785                        
  5786                        ; ----------------------------------------------------------------------------
  5787                        ; Get keystroke from keyboard (RDKEY)
  5788                        ; ----------------------------------------------------------------------------
  5789                        ;RDKEY:
  5790                        ;	lda	KEYBOARDCR	; Key ready?
  5791                        ;	bpl	RDKEY		; Loop until ready
  5792                        ;	lda	KEYBOARD	; Load character
  5793                        ;	and	#$7F		; Clear hi bit
  5794                        ;	rts
  5795                        
  5796                        ; ----------------------------------------------------------------------------
  5797                        ; Get line of input (GETLN)
  5798                        ; adapted from Apple II monitor
  5799                        ; ----------------------------------------------------------------------------
  5800                        NOTCR:
  5801 00:BE0B: C9 18        	cmp	#$18		; CTRL-X?
  5802 00:BE0D: F0 0A        	beq	CANCEL		; Cancel line if so
  5803 00:BE0F: 20 03 BE     	jsr	CONOUT		; Output using monitor ECHO routine
  5804 00:BE12: C9 08        	cmp	#BS		; backspace?
  5805 00:BE14: F0 0E        	beq	BCKSPC		; Yes, do backspace...
  5806 00:BE16: E8           NOTCR1:	inx
  5807 00:BE17: D0 0F        	bne	NXTCHAR		; Wasn't backspace or CTRL+X, get next key
  5808 00:BE19: 20 36 BE     CANCEL:	jsr	OUTSLASH	; Output a "\" to indicate cancelled line
  5809 00:BE1C: 20 46 BE     GETLNZ:	jsr	CRDO		; new line
  5810                        
  5811 00:BE1F: 20 3A BE     GETLN:	jsr	OUTPROMPT	; Display the prompt
  5812 00:BE22: A2 01        	ldx	#$01		; Set cursor at 1, it gets decremented later
  5813 00:BE24: 8A           BCKSPC:	txa
  5814 00:BE25: F0 F5        	beq	GETLNZ		; Backspace with nothing on the line? start new line
  5815 00:BE27: CA           	dex			; Move "cursor" back one space
  5816                        NXTCHAR:
  5817 00:BE28: 20 FB BD     	jsr	RDKEY		; Read key from keyboard
  5818 00:BE2B: 9D 00 02     ADDINP:	sta	INPUTBUFFER,x	; Put it in the input buffer
  5819 00:BE2E: C9 0D        	cmp	#$0D		; CR?
  5820 00:BE30: D0 D9        	bne	NOTCR		; No, keep looping
  5821 00:BE32: 20 46 BE     	jsr	CRDO		; Output CR
  5822 00:BE35: 60           	rts	
  5823                        
  5824                        
  5825                        ; ----------------------------------------------------------------------------
  5826                        ; These moved here from the main Applesoft code to save a few bytes
  5827                        ; ----------------------------------------------------------------------------
  5828                        OUTSLASH:
  5829 00:BE36: A9 5C        	lda	#'\'	;'
  5830 00:BE38: 80 13        	bra	OUTDO
  5831                        
  5832                        OUTPROMPT:
  5833 00:BE3A: A5 33        	lda	PROMPT
  5834 00:BE3C: 80 0F        	bra	OUTDO
  5835                        
  5836 00:BE3E: A9 20        OUTSP:	lda	#' '
  5837 00:BE40: 80 0B        	bra	OUTDO
  5838                        
  5839                        OUTQUES:
  5840 00:BE42: A9 3F        	lda	#'?'
  5841 00:BE44: 80 07        	bra	OUTDO
  5842                        
  5843 00:BE46: A9 0D        CRDO:	lda	#CR
  5844 00:BE48: 20 03 BE     	jsr	CONOUT	; Send character to monitor ECHO
  5845 00:BE4B: A9 0A        	lda	#LF
  5846                        
  5847 00:BE4D: 29 7F        OUTDO:	and	#$7F
  5848 00:BE4F: 20 03 BE     	jsr	CONOUT	; Send character to monitor ECHO
  5849 00:BE52: 60           	rts
  5850                        
  5851                        
  5852                        ; ----------------------------------------------------------------------------
  5853                        ; Corny method of clearing the screen by sending a bunch of CR's.
  5854                        ; ----------------------------------------------------------------------------
  5855                        CLS:
  5856 00:BE53: A0 18        	ldy	#24	; loop 24 times
  5857 00:BE55: 20 46 BE     CLS1:	jsr	CRDO	; ouput CR
  5858 00:BE58: 88           	dey
  5859 00:BE59: 10 FA        	bpl	CLS1	; ... do it again
  5860 00:BE5B: 60           	rts
  5861                        
  5862                        ;###############################################################################
  5863                        ; CFFA1 I/O routines for Applesoft Lite
  5864                        ; NO SUPPORT
  5865                        ;.export CFFALoad, CFFASave, CFFAMenu
  5866                        
  5867                        CFFALoad:
  5868                        CFFASave:
  5869                        CFFAMenu:
  5870 00:BE5C: 18           	clc
  5871 00:BE5D: 60           	ret
  5872                        
  5873                        ; --------------------------------------------------------
  5874 00:BE5E: D8           RESET:	cld			; Clear decimal arithmetic mode
  5875                        ;	sei
  5876 00:BE5F: A2 FB        	ldx	#$FB		; SET STACK POINTER, LEAVING ROOM FOR
  5877 00:BE61: 9A           	txs			; LINE BUFFER DURING PARSING
  5878 00:BE62: 4C C2 BC     	jmp	COLDSTART
  5879                        
  5880                        	end


      Lines assembled: 5880
      Errors: 0
