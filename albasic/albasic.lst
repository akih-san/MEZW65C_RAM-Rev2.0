     1                        	; Applesoft Lite
     2                        ;
     3                        ; Disassembled from the Apple II+ ROMs with da65 V2.12.0
     4                        ;
     5                        ; Most comments and label names from the S-C DocuMentor
     6                        ; by Bob Sander-Cederlof
     7                        ;
     8                        ; Adapted for the Replica-1 by Tom Greene
     9                        ; 7-May-2008
    10                        ;
    11                        ; Modified by Akihito Honda for MEZW65C_RAM Firmware Rev2.0
    12                        ; https://github.com/akih-san/MEZW65C_RAM-Rev2.0
    13                        ; 2024.12.5
    14                        
    15                        ; Thanks all
    16                        ;
    17                        
    18                        	pl	0
    19                        	pw      132
    20                        	chip    65C02
    21                        
    22                        
    23                        ; Zero Page locatinos used by Applesoft Lite
    24                        
    25                        	.page0
    26                        
    27             00000000   GOWARM		equ $0000	; Gets "jmp RESTART"
    28             00000003   GOSTROUTZ		equ $0003	; Gets "jmp STROUT"
    29             0000000D   CHARAC		equ $000D	; Alternate string terminator
    30             0000000E   ENDCHR		equ $000E	; String terminator
    31             0000000F   TKNCNTR		equ $000F	; Used in PARSE
    32             0000000F   EOLPNTR		equ $000F	; Used in NXLIN
    33             0000000F   NUMDIM		equ $000F	; Used in array routines
    34             00000010   DIMFLG		equ $0010	
    35             00000011   VALTYP		equ $0011	; $: VALTYP=$FF; %: VALTYP+1=$80
    36             00000013   DATAFLG		equ $0013	; Used in PARSE
    37             00000013   GARFLG		equ $0013	; Used in GARBAG
    38             00000014   SUBFLG		equ $0014
    39             00000015   INPUTFLG		equ $0015	; = $40 for GET, $98 for READ
    40             00000016   CPRMASK		equ $0016	; Receives CPRTYP in FRMEVL
    41                        
    42             00000033   PROMPT		equ $0033
    43             00000050   LINNUM		equ $0050	; Converted line #
    44             00000052   TEMPPT		equ $0052	; Last used temp string desc
    45             00000053   LASTPT		equ $0053	; Last used temp string pntr
    46             00000055   TEMPST		equ $0055	; Holds up to 3 descriptors
    47             0000005E   INDEX		equ $005E
    48             00000060   DEST		equ $0060
    49             00000062   RESULT		equ $0062	; Result of last * or /
    50             00000067   TXTTAB		equ $0067	; Start of program text
    51             00000069   VARTAB		equ $0069	; Start of variable storage
    52             0000006B   ARYTAB		equ $006B	; Start of array storage
    53             0000006D   STREND		equ $006D	; End of array storage
    54             0000006F   FRETOP		equ $006F	; Start of string storage
    55             00000071   FRESPC		equ $0071	; Temp pntr, string routines
    56             00000073   MEMSIZ		equ $0073	; End of string space (HIMEM)
    57             00000075   CURLIN		equ $0075	; Current line number
    58             00000077   OLDLIN		equ $0077	; Addr. of last line executed
    59             00000079   OLDTEXT		equ $0079
    60             0000007B   DATLIN		equ $007B	; Line # of current data stt.
    61             0000007D   DATPTR		equ $007D	; Addr of current data stt.
    62             0000007F   INPTR		equ $007F
    63             00000081   VARNAM		equ $0081	; Name of variable
    64             00000083   VARPNT		equ $0083	; Addr of variable
    65             00000085   FORPNT		equ $0085
    66             00000087   TXPSV		equ $0087	; Used in INPUT
    67             00000087   LASTOP		equ $0087	; Scratch flag used in FRMEVL
    68             00000089   CPRTYP		equ $0089	; >,=,< flag in FRMEVL
    69             0000008A   TEMP3		equ $008A
    70             0000008A   FNCNAM		equ $008A
    71             0000008C   DSCPTR		equ $008C
    72             0000008F   DSCLEN		equ $008F	; used in GARBAG
    73             00000090   JMPADRS		equ $0090	; gets "jmp ...."
    74             00000091   LENGTH		equ $0091	; used in GARBAG
    75             00000092   ARGEXTENSION	equ $0092	; FP extra precision
    76             00000093   TEMP1		equ $0093	; save areas for FAC
    77             00000094   ARYPNT		equ $0094	; used in GARBAG
    78             00000094   HIGHDS		equ $0094	; pntr for BLTU
    79             00000096   HIGHTR		equ $0096	; pntr for BLTU
    80             00000098   TEMP2		equ $0098
    81             00000099   TMPEXP		equ $0099	; used in FIN (EVAL)
    82             00000099   INDX		equ $0099	; used by array rtns
    83             0000009A   EXPON		equ $009A	;   "
    84             0000009B   DPFLG		equ $009B	; flags dec pnt in FIN
    85             0000009B   LOWTR		equ $009B
    86             0000009C   EXPSGN		equ $009C
    87             0000009D   FAC		equ $009D	; main floating point accumulator
    88             000000A0   VPNT		equ $00A0	; temp var ptr
    89             000000A2   FACSIGN		equ $00A2	; holds unpacked sign
    90             000000A3   SERLEN		equ $00A3	; holds length of series - 1
    91             000000A4   SHIFTSIGNEXT	equ $00A4	; sign extension, right shifts
    92             000000A5   ARG		equ $00A5	; secondary FP accumulator
    93             000000AA   ARGSIGN		equ $00AA
    94             000000AB   SGNCPR		equ $00AB	; flags opp sign in FP routines
    95             000000AC   FACEXTENSION	equ $00AC	; FAC extension byte
    96             000000AD   SERPNT		equ $00AD	; pntr to series data in FP
    97             000000AB   STRNG1		equ $00AB
    98             000000AD   STRNG2		equ $00AD
    99             000000AF   PRGEND		equ $00AF
   100             000000B1   CHRGET		equ $00B1
   101             000000B7   CHRGOT		equ $00B7
   102             000000B8   TXTPTR		equ $00B8
   103             000000C9   RNDSEED		equ $00C9
   104             000000D6   LOCK		equ $00D6	; no user access if > 127
   105             000000D8   ERRFLG		equ $00D8	; $80 if ON ERR active
   106             000000DA   ERRLIN		equ $00DA	; line # where error occurred
   107             000000DC   ERRPOS		equ $00DC	; TXTPTR save for HANDLERR
   108             000000DE   ERRNUM		equ $00DE	; which error occurrred
   109             000000DF   ERRSTK		equ $00DF	; stack pntr before error
   110             000000F2   TRCFLG		equ $00F2
   111             000000F4   TXTPSV		equ $00F4
   112             000000F6   CURLSV		equ $00F6	
   113             000000F8   REMSTK		equ $00F8	; stack pntr before each stt.
   114                        
   115                        
   116                        
   117             0000A000   PRG_B	equ	$A000
   118             00008000   memsize	equ	$8000
   119                        
   120                        	code
   121                        	org	PRG_B
   122                        
   123                        ; ----------------------------------------------------------------------------
   124             00000100   STACK		equ $0100
   125             00000200   INPUTBUFFER	equ $0200
   126                        
   127                        ; ----------------------------------------------------------------------------
   128                        ; Applesoft Tokens
   129                        ; ----------------------------------------------------------------------------
   130             00000081   TOKEN_FOR	equ $81
   131             00000083   TOKEN_DATA	equ $83
   132             00000088   TOKEN_POP	equ $88
   133             0000008E   TOKEN_GOTO	equ $8E
   134             00000092   TOKEN_GOSUB	equ $92
   135             00000094   TOKEN_REM	equ $94
   136             00000098   TOKEN_PRINT	equ $98
   137             000000A2   TOKEN_TO	equ $A2
   138             000000A3   TOKEN_SPC	equ $A3
   139             000000A4   TOKEN_THEN	equ $A4
   140             000000A5   TOKEN_NOT	equ $A5
   141             000000A6   TOKEN_STEP	equ $A6
   142             000000A7   TOKEN_PLUS	equ $A7
   143             000000A8   TOKEN_MINUS	equ $A8
   144             000000AE   TOKEN_GREATER	equ $AE
   145             000000AF   TOKEN_EQUAL	equ $AF
   146             000000B1   TOKEN_SGN	equ $B1
   147             000000BF   TOKEN_LEFTSTR	equ $BF
   148                        
   149                        ; ----------------------------------------------------------------------------
   150                        ; Cold and warm entry points at $E000 and E003
   151                        ; ----------------------------------------------------------------------------
   152                        ;--------- MEZW65C_RAM file header --------------------------
   153 00:A000: 4C 5E BE     	jmp	RESET
   154 00:A003: 4C 04 A3     	jmp	RESTART
   155                        
   156                        	; uinimon config data
   157                        	;
   158 00:A006: 00 00        	db	0,0
   159                        	; Unique ID
   160 00:A008: 4D 45 5A 57  mezID:	db	"MEZW65C",0
       00:A00C: 36 35 43 00 
   161                        	;start program address & load address
   162 00:A010: 00 A0        start_p:	dw	PRG_B		; load address (Low)
   163 00:A012: 00 00        	dw	0		; (high)
   164                        
   165                        	; define Common memory address
   166 00:A014: 00 00        PIC_IF:	dw	0	; reserve
   167 00:A016: 00 00        	dw	0		; (high)
   168                        
   169 00:A018: 00           SW_816:	db	0	; 0 : W65C02
   170                        			; 1 : W65C816 native mode 
   171 00:A019: 00           irq_sw	db	0	; reserve : standalone
   172 00:A01A: 00 00        reg_tp	dw	0	; reserve : standalone
   173 00:A01C: 00 00        reg_ts	dw	0	; reserve : standalone
   174 00:A01E: 00           nmi_sw	db	0	; reserve : standalone
   175 00:A01F: 01           bios_sw	db	1	; 0 : standalone program
   176                        			; 1 : program call bios command
   177                        			; 2 : monitor program (.SYS)
   178                        ;--------- MEZW65C_RAM file header --------------------------
   179                        ; ----------------------------------------------------------------------------
   180                        ; Branch Table for Tokens
   181                        ; ----------------------------------------------------------------------------
   182                        TOKEN_ADDRESS_TABLE:
   183 00:A020: EA A6        	dw	END-1	; $80... 128... END
   184 00:A022: F5 A5        	dw	FOR-1	; $81... 129... FOR
   185 00:A024: C5 AA        	dw	NEXT-1	; $82... 130... NEXT
   186 00:A026: AD A7        	dw	DATA-1	; $83... 131... DATA
   187 00:A028: 80 A9        	dw	INPUT-1	; $84... 132... INPUT
   188 00:A02A: 7E AD        	dw	DIM-1	; $85... 133... DIM
   189 00:A02C: B0 A9        	dw	READ-1	; $86... 134... READ
   190 00:A02E: 49 BD        	dw	CALL-1	; $87... 135... CALL
   191 00:A030: 83 A7        	dw	POP-1	; $88... 136... POP
   192 00:A032: 52 BD        	dw	HIMEM-1	; $89... 136... HIMEM:
   193 00:A034: 72 BD        	dw	LOMEM-1	; $8A... 137... LOMEM:
   194 00:A036: 97 BD        	dw	ONERR-1	; $8B... 138... ONERR
   195 00:A038: E4 BD        	dw	RESUME-1	; $8C... 139... RESUME
   196 00:A03A: 5E A8        	dw	LET-1	; $8D... 140... LET
   197 00:A03C: 56 A7        	dw	GOTO-1	; $8E... 141... GOTO
   198 00:A03E: 2A A7        	dw	RUN-1	; $8F... 142... RUN
   199 00:A040: E1 A7        	dw	IF-1	; $90... 143... IF
   200 00:A042: C0 A6        	dw	RESTORE-1	; $91... 144... RESTORE
   201 00:A044: 39 A7        	dw	GOSUB-1	; $92... 145... GOSUB
   202 00:A046: 83 A7        	dw	POP-1	; $93... 146... RETURN
   203 00:A048: F4 A7        	dw	REM-1	; $94... 147... REM
   204 00:A04A: E8 A6        	dw	STOP-1	; $95... 148... STOP
   205 00:A04C: 04 A8        	dw	ONGOTO-1	; $96... 149... ON
   206 00:A04E: 5D B4        	dw	POKE-1	; $97... 150... POKE
   207 00:A050: ED A8        	dw	PRINT-1	; $98... 151... PRINT
   208 00:A052: 10 A7        	dw	CONT-1	; $99... 152... CONT
   209 00:A054: 45 A5        	dw	LIST-1	; $9A... 153... LIST
   210 00:A056: 0A A5        	dw	CLEAR-1	; $9B... 154... CLEAR
   211 00:A058: 6F A9        	dw	GET-1	; $9C... 155... GET
   212 00:A05A: E9 A4        	dw	NEW-1	; $9D... 156... NEW
   213 00:A05C: 5B BE        	dw	CFFAMenu-1	; $9E... 157... MENU
   214 00:A05E: 5B BE        	dw	CFFASave-1	; $9F... 158... SAVE
   215 00:A060: 5B BE        	dw	CFFALoad-1	; $A0... 160... LOAD
   216 00:A062: 52 BE        	dw	CLS-1	; $A1... 161... CLS
   217                        ; ----------------------------------------------------------------------------
   218 00:A064: 52 B8        UNFNC:  dw	SGN		; $B1... 177... SGN
   219 00:A066: E2 B8        	dw	INT		; $B2... 178... INT
   220 00:A068: 71 B8        	dw	ABS		; $B3... 179... ABS
   221 00:A06A: 79 B0        	dw	FRE		; $B4... 180... FRE
   222 00:A06C: 4A BB        	dw	SQR		; $B5... 181... SQR
   223 00:A06E: 69 BC        	dw	RND		; $B6... 182... RND
   224 00:A070: 08 B6        	dw	LOG		; $B7... 183... LOG
   225 00:A072: C5 BB        	dw	EXP		; $B8... 184... EXP
   226 00:A074: 47 B4        	dw	PEEK		; $B9... 185... PEEK
   227 00:A076: B9 B3        	dw	LEN		; $BA... 186... LEN
   228 00:A078: A8 B0        	dw	STR		; $BB... 187... STR$
   229 00:A07A: EA B3        	dw	VAL		; $BC... 188... VAL
   230 00:A07C: C8 B3        	dw	ASC		; $BD... 189... ASC
   231 00:A07E: 29 B3        	dw	CHRSTR		; $BE... 190... CHR$
   232 00:A080: 3D B3        	dw	LEFTSTR		; $BF... 191... LEFT$
   233 00:A082: 69 B3        	dw	RIGHTSTR	; $C0... 192... RIGHT$
   234 00:A084: 74 B3        	dw	MIDSTR		; $C1... 193... MID$
   235                        
   236                        
   237                        ; ----------------------------------------------------------------------------
   238                        ; Math Operator Branch Table
   239                        ;
   240                        ; one-byte precedence code
   241                        ; two-byte address
   242                        ; ----------------------------------------------------------------------------
   243             00000046   POR		equ $46	; "OR" is lowest precedence
   244             00000050   PAND		equ $50
   245             00000064   PREL		equ $64	; Relational operators
   246             00000079   PADD		equ $79	; binary + and -
   247             0000007B   PMUL		equ $7B	; * and /
   248             0000007D   PPWR		equ $7D	; exponentiation
   249             0000007F   PNEQ		equ $7F	; unary - and comparison =
   250                        ; ----------------------------------------------------------------------------
   251                        MATHTBL:
   252 00:A086: 79           	db   PADD
   253 00:A087: 87 B4        	dw	FADDT-1	; $A7... 167... +
   254 00:A089: 79           	db	PADD
   255 00:A08A: 70 B4        	dw	FSUBT-1	; $A8... 168... -
   256 00:A08C: 7B           	db	PMUL
   257 00:A08D: 48 B6        	dw	FMULTT-1	; $A9... 169... *
   258 00:A08F: 7B           	db	PMUL
   259 00:A090: 2A B7        	dw	FDIVT-1	; $AA... 170... /
   260 00:A092: 7D           	db	PPWR
   261 00:A093: 53 BB        	dw	FPWRT-1	; $AB... 171... ^
   262 00:A095: 50           	db	PAND
   263 00:A096: 03 AD        	dw	TAND-1	; $AC... 172... AND
   264 00:A098: 46           	db	POR
   265 00:A099: FD AC        	dw	OR-1		; $AD... 173... OR
   266 00:A09B: 7F           M_NEG:	db	PNEQ
   267 00:A09C: 8B BB        	dw	NEGOP-1	; $AE... 174... >
   268 00:A09E: 7F           M_EQU:	db	PNEQ
   269 00:A09F: 64 AC        	dw	EQUOP-1	; $AF... 175... =
   270 00:A0A1: 64           M_REL:	db	PREL
   271 00:A0A2: 13 AD        	dw	RELOPS-1	; $B0... 176... <
   272                        
   273                        
   274                        ; ----------------------------------------------------------------------------
   275                        ; Token Name Table
   276                        ; ----------------------------------------------------------------------------
   277                        TOKEN_NAME_TABLE:
   278 00:A0A4: 45 4E C4     	db	"EN",#'D'+$80		; $80... 128
   279 00:A0A7: 46 4F D2     	db	"FO",#'R'+$80		; $81... 129
   280 00:A0AA: 4E 45 58 D4  	db	"NEX",#'T'+$80		; $82... 130
   281 00:A0AE: 44 41 54 C1  	db	"DAT",#'A'+$80		; $83... 131
   282 00:A0B2: 49 4E 50 55  	db	"INPU",#'T'+$80		; $84... 132
       00:A0B6: D4 
   283 00:A0B7: 44 49 CD     	db	"DI",#'M'+$80		; $85... 133
   284 00:A0BA: 52 45 41 C4  	db	"REA",#'D'+$80		; $86... 134
   285 00:A0BE: 43 41 4C CC  	db	"CAL",#'L'+$80		; $87... 135
   286 00:A0C2: 50 4F D0     	db	"PO",#'P'+$80		; $88... 136
   287 00:A0C5: 48 49 4D 45  	db	"HIMEM",#':'+$80		; $89... 137
       00:A0C9: 4D BA 
   288 00:A0CB: 4C 4F 4D 45  	db	"LOMEM",#':'+$80		; $8A... 138
       00:A0CF: 4D BA 
   289 00:A0D1: 4F 4E 45 52  	db	"ONER",#'R'+$80		; $8B... 139
       00:A0D5: D2 
   290 00:A0D6: 52 45 53 55  	db	"RESUM",#'E'+$80		; $8C... 140
       00:A0DA: 4D C5 
   291 00:A0DC: 4C 45 D4     	db	"LE",#'T'+$80		; $8D... 141
   292 00:A0DF: 47 4F 54 CF  	db	"GOT",#'O'+$80		; $8E... 142
   293 00:A0E3: 52 55 CE     	db	"RU",#'N'+$80		; $8F... 143
   294 00:A0E6: 49 C6        	db	'I',#'F'+$80		; $90... 144
   295 00:A0E8: 52 45 53 54  	db	"RESTOR",#'E'+$80	; $91... 145
       00:A0EC: 4F 52 C5 
   296 00:A0EF: 47 4F 53 55  	db	"GOSU",#'B'+$80		; $92... 146
       00:A0F3: C2 
   297 00:A0F4: 52 45 54 55  	db	"RETUR",#'N'+$80		; $93... 147
       00:A0F8: 52 CE 
   298 00:A0FA: 52 45 CD     	db	"RE",#'M'+$80		; $94... 148
   299 00:A0FD: 53 54 4F D0  	db	"STO",#'P'+$80		; $95... 149
   300 00:A101: 4F CE        	db	'O',#'N'+$80		; $96... 150
   301 00:A103: 50 4F 4B C5  	db	"POK",#'E'+$80		; $97... 151
   302 00:A107: 50 52 49 4E  	db	"PRIN",#'T'+$80		; $98... 152
       00:A10B: D4 
   303 00:A10C: 43 4F 4E D4  	db	"CON",#'T'+$80		; $99... 153
   304 00:A110: 4C 49 53 D4  	db	"LIS",#'T'+$80		; $9A... 154
   305 00:A114: 43 4C 45 41  	db	"CLEA",#'R'+$80		; $9B... 155
       00:A118: D2 
   306 00:A119: 47 45 D4     	db	"GE",#'T'+$80		; $9C... 156
   307 00:A11C: 4E 45 D7     	db	"NE",#'W'+$80		; $9D... 157
   308 00:A11F: 4D 45 4E D5  	db	"MEN",#'U'+$80		; $9E... 158   New tokens 
   309 00:A123: 53 41 56 C5  	db	"SAV",#'E'+$80		; $9F... 159   for
   310 00:A127: 4C 4F 41 C4  	db	"LOA",#'D'+$80		; $A0... 160   CFFA I/O
   311 00:A12B: 43 4C D3     	db	"CL",#'S'+$80		; $A1... 161   New token to clear screen
   312 00:A12E: 54 CF        	db	'T',#'O'+$80		; $A2... 162
   313 00:A130: 53 50 43 A8  	db	"SPC",#'('+$80		; $A3... 163
   314 00:A134: 54 48 45 CE  	db	"THE",#'N'+$80		; $A4... 164
   315 00:A138: 4E 4F D4     	db	"NO",#'T'+$80		; $A5... 165
   316 00:A13B: 53 54 45 D0  	db	"STE",#'P'+$80		; $A6... 166
   317 00:A13F: AB           	db	#'+'+$80		; $A7... 167
   318 00:A140: AD           	db	#'-'+$80		; $A8... 168
   319 00:A141: AA           	db	#'*'+$80		; $A9... 169
   320 00:A142: AF           	db	#'/'+$80		; $AA... 170
   321 00:A143: DE           	db	#'^'+$80		; $AB... 171
   322 00:A144: 41 4E C4     	db	"AN",#'D'+$80		; $AC... 172
   323 00:A147: 4F D2        	db	'O',#'R'+$80		; $AD... 173
   324 00:A149: BE           	db	#'>'+$80		; $AE... 174
   325 00:A14A: BD           	db	#'='+$80		; $AF... 175
   326 00:A14B: BC           	db	#'<'+$80		; $B0... 176
   327 00:A14C: 53 47 CE     	db	"SG",#'N'+$80		; $B1... 177
   328 00:A14F: 49 4E D4     	db	"IN",#'T'+$80		; $B2... 178
   329 00:A152: 41 42 D3     	db	"AB",#'S'+$80		; $B3... 179
   330 00:A155: 46 52 C5     	db	"FR",#'E'+$80		; $B4... 180
   331 00:A158: 53 51 D2     	db	"SQ",#'R'+$80		; $B5... 181
   332 00:A15B: 52 4E C4     	db	"RN",#'D'+$80		; $B6... 182
   333 00:A15E: 4C 4F C7     	db	"LO",#'G'+$80		; $B7... 183
   334 00:A161: 45 58 D0     	db	"EX",#'P'+$80		; $B8... 184
   335 00:A164: 50 45 45 CB  	db	"PEE",#'K'+$80		; $B9... 185
   336 00:A168: 4C 45 CE     	db	"LE",#'N'+$80		; $BA... 186
   337 00:A16B: 53 54 52 A4  	db	"STR",#'$'+$80		; $BB... 187
   338 00:A16F: 56 41 CC     	db	"VA",#'L'+$80		; $BC... 188
   339 00:A172: 41 53 C3     	db	"AS",#'C'+$80		; $BD... 189
   340 00:A175: 43 48 52 A4  	db	"CHR",#'$'+$80		; $BE... 190
   341 00:A179: 4C 45 46 54  	db	"LEFT",#'$'+$80		; $BF... 191
       00:A17D: A4 
   342 00:A17E: 52 49 47 48  	db	"RIGHT",#'$'+$80		; $C0... 192
       00:A182: 54 A4 
   343 00:A184: 4D 49 44 A4  	db	"MID",#'$'+$80		; $C1... 193
   344 00:A188: 00           	db	$00			; END OF TOKEN NAME TABLE
   345                        
   346                        
   347                        ; ----------------------------------------------------------------------------
   348                        ; Error Messages
   349                        ; ----------------------------------------------------------------------------
   350                        ERROR_MESSAGES:
   351                        
   352             00000000   ERR_NOFOR	equ $FF&(*-ERROR_MESSAGES)
   353 00:A189: 4E 4F 20 46  	db	"NO FO",#'R'+$80
       00:A18D: 4F D2 
   354                        
   355             00000006   ERR_SYNTAX	equ $FF&(*-ERROR_MESSAGES)
   356 00:A18F: 53 59 4E 54  	db	"SYNTA",#'X'+$80
       00:A193: 41 D8 
   357                        
   358             0000000C   ERR_NOGOSUB	equ $FF&(*-ERROR_MESSAGES)
   359 00:A195: 4E 4F 20 47  	db	"NO GOSU",#'B'+$80
       00:A199: 4F 53 55 C2 
   360                        
   361             00000014   ERR_NODATA	equ $FF&(*-ERROR_MESSAGES)
   362 00:A19D: 4F 55 54 20  	db	"OUT OF DAT",#'A'+$80
       00:A1A1: 4F 46 20 44 
       00:A1A5: 41 54 C1 
   363                        
   364             0000001F   ERR_ILLQTY	equ $FF&(*-ERROR_MESSAGES)
   365 00:A1A8: 49 4C 4C 45  	db	"ILLEG QT",#'Y'+$80
       00:A1AC: 47 20 51 54 
       00:A1B0: D9 
   366                        
   367             00000028   ERR_OVERFLOW	equ $FF&(*-ERROR_MESSAGES)
   368 00:A1B1: 4F 56 45 52  	db	"OVERFLO",#'W'+$80
       00:A1B5: 46 4C 4F D7 
   369                        
   370             00000030   ERR_MEMFULL	equ $FF&(*-ERROR_MESSAGES)
   371 00:A1B9: 4F 55 54 20  	db	"OUT OF ME",#'M'+$80
       00:A1BD: 4F 46 20 4D 
       00:A1C1: 45 CD 
   372                        
   373             0000003A   ERR_UNDEFSTAT	equ $FF&(*-ERROR_MESSAGES)
   374 00:A1C3: 55 4E 44 45  	db	"UNDEF LIN",#'E'+$80
       00:A1C7: 46 20 4C 49 
       00:A1CB: 4E C5 
   375                        
   376             00000044   ERR_BADSUBS	equ $FF&(*-ERROR_MESSAGES)
   377 00:A1CD: 42 41 44 20  	db	"BAD SUBSC",#'R'+$80
       00:A1D1: 53 55 42 53 
       00:A1D5: 43 D2 
   378                        
   379             0000004E   ERR_REDIMD	equ $FF&(*-ERROR_MESSAGES)
   380 00:A1D7: 52 45 44 49  	db	"REDI",#'M'+$80
       00:A1DB: CD 
   381                        
   382             00000053   ERR_ZERODIV	equ $FF&(*-ERROR_MESSAGES)
   383 00:A1DC: 44 49 56 20  	db	"DIV BY ",#'0'+$80
       00:A1E0: 42 59 20 B0 
   384                        
   385             0000005B   ERR_ILLDIR	equ $FF&(*-ERROR_MESSAGES)
   386 00:A1E4: 4E 4F 54 20  	db	"NOT DIREC",#'T'+$80
       00:A1E8: 44 49 52 45 
       00:A1EC: 43 D4 
   387                        
   388             00000065   ERR_BADTYPE	equ $FF&(*-ERROR_MESSAGES)
   389 00:A1EE: 57 52 4F 4E  	db	"WRONG TY",#'P'+$80
       00:A1F2: 47 20 54 59 
       00:A1F6: D0 
   390                        
   391             0000006E   ERR_STRLONG	equ $FF&(*-ERROR_MESSAGES)
   392 00:A1F7: 4C 4F 4E 47  	db	"LONG ST",#'R'+$80
       00:A1FB: 20 53 54 D2 
   393                        
   394             00000076   ERR_FRMCPX	equ $FF&(*-ERROR_MESSAGES)
   395 00:A1FF: 4C 4F 4E 47  	db	"LONG FORMUL",#'A'+$80
       00:A203: 20 46 4F 52 
       00:A207: 4D 55 4C C1 
   396                        
   397             00000082   ERR_CANTCONT	equ $FF&(*-ERROR_MESSAGES)
   398 00:A20B: 43 41 4E 27  	db	"CAN'T CON",#'T'+$80
       00:A20F: 54 20 43 4F 
       00:A213: 4E D4 
   399                        
   400             0000008C   ERR_NOCFFA	equ $FF&(*-ERROR_MESSAGES)	; New error message for CFFA1 I/O
   401 00:A215: 4E 4F 20 43  	db	"NO CFF",#'A'+$80
       00:A219: 46 46 C1 
   402                        ; ----------------------------------------------------------------------------
   403                        QT_ERROR:
   404 00:A21C: 20 45 52 52  	db	" ERR"
   405 00:A220: 00           	db	$00
   406 00:A221: 20 49 4E 20  QT_IN:	db	" IN "
   407 00:A225: 00           	db	$00
   408                        QT_BREAK:
   409 00:A226: 0D           	db	$0D
   410 00:A227: 42 52 45 41  	db	"BREAK"
       00:A22B: 4B 
   411 00:A22C: 00           	db	$00
   412                        
   413                        ; ----------------------------------------------------------------------------
   414                        ; CALLED BY "NEXT" AND "FOR" TO SCAN THROUGH
   415                        ; THE STACK FOR A FRAME WITH THE SAME VARIABLE.
   416                        ;
   417                        ; (FORPNT) = ADDRESS OF VARIABLE IF "FOR" OR "NEXT"
   418                        ; 	= $XXFF IF CALLED FROM "RETURN"
   419                        ; 	<<< BUG: SHOULD BE $FFXX >>>
   420                        ;
   421                        ;	RETURNS .NE. IF VARIABLE NOT FOUND,
   422                        ;	(X) = STACK PNTR AFTER SKIPPING ALL FRAMES
   423                        ;
   424                        ;	.EQ. IF FOUND
   425                        ;	(X) = STACK PNTR OF FRAME FOUND
   426                        ; ----------------------------------------------------------------------------
   427                        GTFORPNT:
   428 00:A22D: BA           	tsx
   429 00:A22E: E8           	inx
   430 00:A22F: E8           	inx
   431 00:A230: E8           	inx
   432 00:A231: E8           	inx
   433 00:A232: BD 01 01     GTF1:	lda	STACK+1,x	; "FOR" FRAME HERE?
   434 00:A235: C9 81        	cmp	#TOKEN_FOR
   435 00:A237: D0 21        	bne	GTF4		; NO
   436 00:A239: A5 86        	lda	FORPNT+1	; YES -- "NEXT" WITH NO VARIABLE?
   437 00:A23B: D0 0A        	bne	GTF2		; NO, VARIABLE SPECIFIED
   438 00:A23D: BD 02 01     	lda	STACK+2,x	; YES, SO USE THIS FRAME
   439 00:A240: 85 85        	sta	FORPNT
   440 00:A242: BD 03 01     	lda	STACK+3,x
   441 00:A245: 85 86        	sta	FORPNT+1
   442 00:A247: DD 03 01     GTF2:	cmp	STACK+3,x	; IS VARIABLE IN THIS FRAME?
   443 00:A24A: D0 07        	bne	GTF3		; NO
   444 00:A24C: A5 85        	lda	FORPNT		; LOOK AT 2ND BYTE TOO
   445 00:A24E: DD 02 01     	cmp	STACK+2,x	; SAME VARIABLE?
   446 00:A251: F0 07        	beq	GTF4		; YES
   447 00:A253: 8A           GTF3:	txa			; NO, SO TRY NEXT FRAME (IF ANY)
   448 00:A254: 18           	clc			; 18 BYTES PER FRAME
   449 00:A255: 69 12        	adc     #18
   450 00:A257: AA           	tax
   451 00:A258: D0 D8        	bne	GTF1		; ...ALWAYS?
   452 00:A25A: 60           GTF4:	rts
   453                        
   454                        
   455                        ; ----------------------------------------------------------------------------
   456                        ; MOVE BLOCK OF MEMORY UP
   457                        ;
   458                        ; ON ENTRY:
   459                        ;	(Y,A) = (HIGHDS) = DESTINATION END+1
   460                        ;	(LOWTR) = LOWEST ADDRESS OF SOURCE
   461                        ;	(HIGHTR) = HIGHEST SOURCE ADDRESS+1
   462                        ; ----------------------------------------------------------------------------
   463 00:A25B: 20 AB A2     BLTU:	jsr	REASON		; BE SURE (Y,A) < FRETOP
   464 00:A25E: 85 6D        	sta	STREND		; NEW TOP OF ARRAY STORAGE
   465 00:A260: 84 6E        	sty	STREND+1
   466 00:A262: 38           BLTU2:	sec
   467 00:A263: A5 96        	lda	HIGHTR		; COMPUTE # OF BYTES TO BE MOVED
   468 00:A265: E5 9B        	sbc	LOWTR		; 	(FROM LOWTR THRU HIGHTR-1)
   469 00:A267: 85 5E        	sta	INDEX		; PARTIAL PAGE AMOUNT
   470 00:A269: A8           	tay
   471 00:A26A: A5 97        	lda	HIGHTR+1
   472 00:A26C: E5 9C        	sbc	LOWTR+1
   473 00:A26E: AA           	tax			; # OF WHOLE PAGES IN X-REG
   474 00:A26F: E8           	inx
   475 00:A270: 98           	tya			; # BYTES IN PARTIAL PAGE
   476 00:A271: F0 23        	beq	BLT4		; NO PARTIAL PAGE
   477 00:A273: A5 96        	lda	HIGHTR		; BACK UP HIGHTR # BYTES IN PARTIAL PAGE
   478 00:A275: 38           	sec
   479 00:A276: E5 5E        	sbc	INDEX
   480 00:A278: 85 96        	sta	HIGHTR
   481 00:A27A: B0 03        	bcs	BLT1
   482 00:A27C: C6 97        	dec	HIGHTR+1
   483 00:A27E: 38           	sec
   484 00:A27F: A5 94        BLT1:	lda	HIGHDS		; BACK UP HIGHDS # BYTES IN PARTIAL PAGE
   485 00:A281: E5 5E        	sbc	INDEX
   486 00:A283: 85 94        	sta	HIGHDS
   487 00:A285: B0 08        	bcs	BLT3
   488 00:A287: C6 95        	dec	HIGHDS+1
   489 00:A289: 90 04        	bcc	BLT3		; ...ALWAYS
   490 00:A28B: B1 96        BLT2:	lda	(HIGHTR),y	; MOVE THE BYTES
   491 00:A28D: 91 94        	sta	(HIGHDS),y
   492 00:A28F: 88           BLT3:	dey
   493 00:A290: D0 F9        	bne	BLT2		; LOOP TO END OF THIS 256 BYTES
   494 00:A292: B1 96        	lda	(HIGHTR),y	; MOVE ONE MORE BYTE
   495 00:A294: 91 94        	sta	(HIGHDS),y
   496 00:A296: C6 97        BLT4:	dec	HIGHTR+1	; DOWN TO NEXT BLOCK OF 256
   497 00:A298: C6 95        	dec	HIGHDS+1
   498 00:A29A: CA           	dex			; ANOTHER BLOCK OF 256 TO MOVE?
   499 00:A29B: D0 F2        	bne	BLT3		; YES
   500 00:A29D: 60           	rts			; NO, FINISHED
   501                        
   502                        
   503                        ; ----------------------------------------------------------------------------
   504                        ; CHECK IF ENOUGH ROOM LEFT ON STACK
   505                        ; FOR "FOR", "GOSUB", OR EXPRESSION EVALUATION
   506                        ; ----------------------------------------------------------------------------
   507 00:A29E: 0A           CHKMEM:	asl	a
   508 00:A29F: 69 36        	adc	#54
   509 00:A2A1: B0 35        	bcs	MEMERR		; ...MEM FULL ERR
   510 00:A2A3: 85 5E        	sta	INDEX
   511 00:A2A5: BA           	tsx
   512 00:A2A6: E4 5E        	cpx	INDEX
   513 00:A2A8: 90 2E        	bcc	MEMERR		; ...MEM FULL ERR
   514 00:A2AA: 60           	rts
   515                        
   516                        
   517                        ; ----------------------------------------------------------------------------
   518                        ; CHECK IF ENOUGH ROOM BETWEEN ARRAYS AND STRINGS
   519                        ; (Y,A) = ADDR ARRAYS NEED TO GROW TO
   520                        ; ----------------------------------------------------------------------------
   521 00:A2AB: C4 70        REASON:	cpy	FRETOP+1	; HIGH BYTE
   522 00:A2AD: 90 28        	bcc	REA4		; PLENTY OF ROOM
   523 00:A2AF: D0 04        	bne	REA1		; NOT ENOUGH, TRY GARBAGE COLLECTION
   524 00:A2B1: C5 6F        	cmp	FRETOP		; LOW BYTE
   525 00:A2B3: 90 22        	bcc	REA4		; ENOUGH ROOM
   526 00:A2B5: 48           REA1:	pha			; SAVE (Y,A), TEMP1, AND TEMP2
   527 00:A2B6: A2 09        	ldx	#FAC-TEMP1-1
   528 00:A2B8: 98           	tya
   529 00:A2B9: 48           REA2:	pha
   530 00:A2BA: B5 93        	lda	TEMP1,x
   531 00:A2BC: CA           	dex
   532 00:A2BD: 10 FA        	bpl	REA2
   533 00:A2BF: 20 67 B1     	jsr	GARBAG		; MAKE AS MUCH ROOM AS POSSIBLE
   534 00:A2C2: A2 F7        	ldx	#$FF&(TEMP1-FAC+1)	; RESTORE TEMP1 AND TEMP2
   535 00:A2C4: 68           REA3:	pla			; AND (Y,A)
   536 00:A2C5: 95 9D        	sta	FAC,x
   537 00:A2C7: E8           	inx
   538 00:A2C8: 30 FA        	bmi	REA3
   539 00:A2CA: 68           	pla
   540 00:A2CB: A8           	tay
   541 00:A2CC: 68           	pla			; DID WE FIND ENOUGH ROOM?
   542 00:A2CD: C4 70        	cpy	FRETOP+1	; HIGH BYTE
   543 00:A2CF: 90 06        	bcc	REA4		; YES, AT LEAST A PAGE
   544 00:A2D1: D0 05        	bne	MEMERR		; NO, MEM FULL ERR
   545 00:A2D3: C5 6F        	cmp	FRETOP		; LOW BYTE
   546 00:A2D5: B0 01        	bcs	MEMERR		; NO, MEM FULL ERR
   547 00:A2D7: 60           REA4:	rts			; YES, RETURN
   548                        
   549                        ; ----------------------------------------------------------------------------
   550 00:A2D8: A2 30        MEMERR:	ldx	#ERR_MEMFULL
   551                        
   552                        
   553                        ; ----------------------------------------------------------------------------
   554                        ; HANDLE AN ERROR
   555                        ;
   556                        ; (X)=OFFSET IN ERROR MESSAGE TABLE
   557                        ; (ERRFLG) > 128 IF "ON ERR" TURNED ON
   558                        ; (CURLIN+1) = $FF IF IN DIRECT MODE
   559                        ; ----------------------------------------------------------------------------
   560 00:A2DA: 24 D8        ERROR:	bit	ERRFLG		; "ON ERR" TURNED ON?
   561 00:A2DC: 10 03        	bpl	ERRO1		; NO
   562 00:A2DE: 4C B6 BD     	jmp	HANDLERR	; YES
   563 00:A2E1: 20 46 BE     ERRO1:	jsr	CRDO		; PRINT <RETURN>
   564 00:A2E4: 20 42 BE     	jsr	OUTQUES		; PRINT "?"
   565 00:A2E7: BD 89 A1     ERRO2:	lda	ERROR_MESSAGES,x
   566 00:A2EA: 48           	pha			; PRINT MESSAGE
   567 00:A2EB: 20 4D BE     	jsr	OUTDO
   568 00:A2EE: E8           	inx
   569 00:A2EF: 68           	pla
   570 00:A2F0: 10 F5        	bpl	ERRO2
   571 00:A2F2: 20 24 A5     	jsr	STKINI		; FIX STACK, ET AL
   572 00:A2F5: A9 1C        	lda	#<QT_ERROR	; PRINT " ERROR" AND BELL
   573 00:A2F7: A0 A2        	ldy	#>QT_ERROR
   574                        
   575                        
   576                        ; ----------------------------------------------------------------------------
   577                        ; PRINT STRING AT (Y,A)
   578                        ; PRINT CURRENT LINE # UNLESS IN DIRECT MODE
   579                        ; FALL INTO WARM RESTART
   580                        ; ----------------------------------------------------------------------------
   581                        PRINT_ERROR_LINNUM:
   582 00:A2F9: 20 2B A9     	jsr	STROUT		; PRINT STRING AT (Y,A)
   583 00:A2FC: A4 76        	ldy	CURLIN+1	; RUNNING, OR DIRECT?
   584 00:A2FE: C8           	iny
   585 00:A2FF: F0 03        	beq	RESTART		; WAS $FF, SO DIRECT MODE
   586 00:A301: 20 D6 B9     	jsr	INPRT		; RUNNING, SO PRINT LINE NUMBER
   587                        
   588                        
   589                        ; ----------------------------------------------------------------------------
   590                        ; WARM RESTART ENTRY
   591                        ;
   592                        ; COME HERE FROM MONITOR BY CTL-C, 0G, 3D0G, OR E003G
   593                        ; ----------------------------------------------------------------------------
   594                        RESTART:
   595 00:A304: 20 46 BE     	jsr	CRDO		; PRINT <RETURN>
   596 00:A307: A2 DD        	ldx	#']'+$80	; PROMPT CHARACTER
   597 00:A309: 20 F6 A3     	jsr	INLIN2		; READ A LINE
   598 00:A30C: 86 B8        	stx	TXTPTR		; SET UP CHRGET TO SCAN THE LINE
   599 00:A30E: 84 B9        	sty	TXTPTR+1
   600 00:A310: 46 D8        	lsr	ERRFLG		; CLEAR FLAG
   601 00:A312: 20 B1 00     	jsr	CHRGET
   602 00:A315: AA           	tax
   603 00:A316: F0 EC        	beq	RESTART		; EMPTY LINE
   604 00:A318: A2 FF        	ldx	#$FF		; $FF IN HI-BYTE OF CURLIN MEANS
   605 00:A31A: 86 76        	stx	CURLIN+1	; WE ARE IN DIRECT MODE
   606 00:A31C: 90 06        	bcc	NUMBERED_LINE	; CHRGET SAW DIGIT, NUMBERED LINE
   607 00:A31E: 20 0B A4     	jsr	PARSE_INPUT_LINE	; NO NUMBER, SO PARSE IT
   608 00:A321: 4C 95 A6     	jmp	NEWSTT2		; AND TRY EXECUTING IT
   609                        
   610                        
   611                        ; ----------------------------------------------------------------------------
   612                        ; HANDLE NUMBERED LINE
   613                        ; ----------------------------------------------------------------------------
   614                        NUMBERED_LINE:
   615 00:A324: A6 AF        	ldx	PRGEND		; SQUASH VARIABLE TABLE
   616 00:A326: 86 69        	stx	VARTAB
   617 00:A328: A6 B0        	ldx	PRGEND+1
   618 00:A32A: 86 6A        	stx	VARTAB+1
   619 00:A32C: 20 25 A8     	jsr	LINGET		; GET LINE #
   620 00:A32F: 20 0B A4     	jsr	PARSE_INPUT_LINE	; AND PARSE THE INPUT LINE
   621 00:A332: 84 0F        	sty	EOLPNTR		; SAVE INDEX TO INPUT BUFFER
   622 00:A334: 20 BB A4     	jsr	FNDLIN		; IS THIS LINE # ALREADY IN PROGRAM?
   623 00:A337: 90 44        	bcc	PUT_NEW_LINE	; NO
   624 00:A339: A0 01        	ldy	#1		; YES, SO DELETE IT
   625 00:A33B: B1 9B        	lda	(LOWTR),y	; LOWTR POINTS AT LINE
   626 00:A33D: 85 5F        	sta	INDEX+1		; GET HIGH BYTE OF FORWARD PNTR
   627 00:A33F: A5 69        	lda	VARTAB
   628 00:A341: 85 5E        	sta	INDEX
   629 00:A343: A5 9C        	lda	LOWTR+1
   630 00:A345: 85 61        	sta	DEST+1
   631 00:A347: A5 9B        	lda	LOWTR
   632 00:A349: 88           	dey
   633 00:A34A: F1 9B        	sbc	(LOWTR),y
   634 00:A34C: 18           	clc
   635 00:A34D: 65 69        	adc	VARTAB
   636 00:A34F: 85 69        	sta	VARTAB
   637 00:A351: 85 60        	sta	DEST
   638 00:A353: A5 6A        	lda	VARTAB+1
   639 00:A355: 69 FF        	adc	#$FF
   640 00:A357: 85 6A        	sta	VARTAB+1
   641 00:A359: E5 9C        	sbc	LOWTR+1
   642 00:A35B: AA           	tax
   643 00:A35C: 38           	sec
   644 00:A35D: A5 9B        	lda	LOWTR
   645 00:A35F: E5 69        	sbc	VARTAB
   646 00:A361: A8           	tay
   647 00:A362: B0 03        	bcs	NUMB1
   648 00:A364: E8           	inx
   649 00:A365: C6 61        	dec	DEST+1
   650 00:A367: 18           NUMB1:	clc
   651 00:A368: 65 5E        	adc	INDEX
   652 00:A36A: 90 03        	bcc	NUMB2
   653 00:A36C: C6 5F        	dec	INDEX+1
   654 00:A36E: 18           	clc
   655                        ; ----------------------------------------------------------------------------
   656 00:A36F: B1 5E        NUMB2:	lda	(INDEX),y	; MOVE HIGHER LINES OF PROGRAM
   657 00:A371: 91 60        	sta	(DEST),y	; DOWN OVER THE DELETED LINE.
   658 00:A373: C8           	iny
   659 00:A374: D0 F9        	bne	NUMB2
   660 00:A376: E6 5F        	inc	INDEX+1
   661 00:A378: E6 61        	inc	DEST+1
   662 00:A37A: CA           	dex
   663 00:A37B: D0 F2        	bne	NUMB2
   664                        
   665                        
   666                        ; ----------------------------------------------------------------------------
   667                        PUT_NEW_LINE:
   668 00:A37D: AD 00 02     	lda	INPUTBUFFER	; ANY CHARACTERS AFTER LINE #?
   669 00:A380: F0 38        	beq	FIX_LINKS	; NO, SO NOTHING TO INSERT.
   670 00:A382: A5 73        	lda	MEMSIZ		; YES, SO MAKE ROOM AND INSERT LINE
   671 00:A384: A4 74        	ldy	MEMSIZ+1	; WIPE STRING AREA CLEAN
   672 00:A386: 85 6F        	sta	FRETOP
   673 00:A388: 84 70        	sty	FRETOP+1
   674 00:A38A: A5 69        	lda	VARTAB		; SET UP BLTU SUBROUTINE
   675 00:A38C: 85 96        	sta	HIGHTR		; INSERT NEW LINE.
   676 00:A38E: 65 0F        	adc	EOLPNTR
   677 00:A390: 85 94        	sta	HIGHDS
   678 00:A392: A4 6A        	ldy	VARTAB+1
   679 00:A394: 84 97        	sty	HIGHTR+1
   680 00:A396: 90 01        	bcc	PUT_1
   681 00:A398: C8           	iny
   682 00:A399: 84 95        PUT_1:	sty	HIGHDS+1
   683 00:A39B: 20 5B A2     	jsr	BLTU		; MAKE ROOM FOR THE LINE
   684 00:A39E: A5 50        	lda	LINNUM		; PUT LINE NUMBER IN LINE IMAGE
   685 00:A3A0: A4 51        	ldy	LINNUM+1
   686 00:A3A2: 8D FE 01     	sta	INPUTBUFFER-2
   687 00:A3A5: 8C FF 01     	sty	INPUTBUFFER-1
   688 00:A3A8: A5 6D        	lda	STREND
   689 00:A3AA: A4 6E        	ldy	STREND+1
   690 00:A3AC: 85 69        	sta	VARTAB
   691 00:A3AE: 84 6A        	sty	VARTAB+1
   692 00:A3B0: A4 0F        	ldy	EOLPNTR
   693                        ; ---COPY LINE INTO PROGRAM-------
   694 00:A3B2: B9 FB 01     PUT_2:	lda	INPUTBUFFER-5,y
   695 00:A3B5: 88           	dey
   696 00:A3B6: 91 9B        	sta	(LOWTR),y
   697 00:A3B8: D0 F8        	bne	PUT_2
   698                        
   699                        
   700                        ; ----------------------------------------------------------------------------
   701                        ; CLEAR ALL VARIABLES
   702                        ; RE-ESTABLISH ALL FORWARD LINKS
   703                        ; ----------------------------------------------------------------------------
   704                        FIX_LINKS:
   705 00:A3BA: 20 06 A5     	jsr	SETPTRS		; CLEAR ALL VARIABLES
   706 00:A3BD: A5 67        	lda	TXTTAB		; POINT INDEX AT START OF PROGRAM
   707 00:A3BF: A4 68        	ldy	TXTTAB+1
   708 00:A3C1: 85 5E        	sta	INDEX
   709 00:A3C3: 84 5F        	sty	INDEX+1
   710 00:A3C5: 18           	clc
   711 00:A3C6: A0 01        FIX_1:	ldy	#1		; HI-BYTE OF NEXT FORWARD PNTR
   712 00:A3C8: B1 5E        	lda	(INDEX),y	; END OF PROGRAM YET?
   713 00:A3CA: D0 0B        	bne	FIX_2		; NO, KEEP GOING
   714 00:A3CC: A5 69        	lda	VARTAB		; YES
   715 00:A3CE: 85 AF        	sta	PRGEND
   716 00:A3D0: A5 6A        	lda	VARTAB+1
   717 00:A3D2: 85 B0        	sta	PRGEND+1
   718 00:A3D4: 4C 04 A3     	jmp	RESTART
   719 00:A3D7: A0 04        FIX_2:	ldy	#4		; FIND END OF THIS LINE
   720 00:A3D9: C8           FIX_3:	iny			; (NOTE MAXIMUM LENGTH < 256)
   721 00:A3DA: B1 5E        	lda	(INDEX),y
   722 00:A3DC: D0 FB        	bne	FIX_3
   723 00:A3DE: C8           	iny			; COMPUTE ADDRESS OF NEXT LINE
   724 00:A3DF: 98           	tya
   725 00:A3E0: 65 5E        	adc	INDEX
   726 00:A3E2: AA           	tax
   727 00:A3E3: A0 00        	ldy	#0		; STORE FORWARD PNTR IN THIS LINE
   728 00:A3E5: 91 5E        	sta	(INDEX),y
   729 00:A3E7: A5 5F        	lda	INDEX+1
   730 00:A3E9: 69 00        	adc	#0		; (NOTE: THIS CLEARS CARRY)
   731 00:A3EB: C8           	iny
   732 00:A3EC: 91 5E        	sta	(INDEX),y
   733 00:A3EE: 86 5E        	stx	INDEX
   734 00:A3F0: 85 5F        	sta	INDEX+1
   735 00:A3F2: 90 D2        	bcc	FIX_1		; ...ALWAYS
   736                        
   737                        
   738                        ; ----------------------------------------------------------------------------
   739                        ; READ A LINE, AND STRIP OFF SIGN BITS
   740                        ; ----------------------------------------------------------------------------
   741 00:A3F4: A2 80        INLIN:	ldx	#$80		; NULL PROMPT
   742 00:A3F6: 86 33        INLIN2:	stx	PROMPT
   743 00:A3F8: 20 1F BE     	jsr	GETLN
   744 00:A3FB: E0 EF        	cpx	#239		; MAXIMUM LINE LENGTH
   745 00:A3FD: 90 02        	bcc	INLI1
   746 00:A3FF: A2 EF        	ldx	#239		; TRUNCATE AT 239 CHARS
   747 00:A401: A9 00        INLI1:	lda	#0		; MARK END OF LINE WITH $00 BYTE
   748 00:A403: 9D 00 02     	sta	INPUTBUFFER,x
   749                        ;	txa
   750                        ;	beq	INLI3		; NULL INPUT LINE
   751                        ;INLI2:	lda	INPUTBUFFER-1,x	; DROP SIGN BITS
   752                        ;	and	#$7F		;	already cleared by GETLN
   753                        ;	sta	INPUTBUFFER-1,x
   754                        ;	dex
   755                        ;	bne	INLI2
   756                        ;INLI3:	lda	#0		; (Y,X) POINTS AT BUFFER-1
   757 00:A406: A2 FF        	ldx	#<(INPUTBUFFER-1)
   758 00:A408: A0 01        	ldy	#>(INPUTBUFFER-1)
   759 00:A40A: 60           	rts
   760                        
   761                        ; ----------------------------------------------------------------------------
   762                        ; TOKENIZE THE INPUT LINE
   763                        ; ----------------------------------------------------------------------------
   764                        PARSE_INPUT_LINE:
   765 00:A40B: A6 B8        	ldx	TXTPTR		; INDEX INTO UNPARSED LINE
   766 00:A40D: CA           	dex			; PREPARE FOR INX AT "PARSE"
   767 00:A40E: A0 04        	ldy	#4		; INDEX TO PARSED OUTPUT LINE
   768 00:A410: 84 13        	sty	DATAFLG		; CLEAR SIGN-BIT OF DATAFLG
   769 00:A412: 24 D6        	bit	LOCK		; IS THIS PROGRAM LOCKED?
   770 00:A414: 10 08        	bpl	PARSE		; NO, GO AHEAD AND PARSE THE LINE
   771 00:A416: 68           	pla			; YES, IGNORE INPUT AND "RUN"
   772 00:A417: 68           	pla			;    THE PROGRAM
   773 00:A418: 20 06 A5     	jsr	SETPTRS		; CLEAR ALL VARIABLES
   774 00:A41B: 4C 62 A6     	jmp	NEWSTT		; START RUNNING
   775                        ; ----------------------------------------------------------------------------
   776 00:A41E: E8           PARSE:	inx			; NEXT INPUT CHARACTER
   777 00:A41F: BD 00 02     PARS1:	lda	INPUTBUFFER,x
   778 00:A422: 24 13        	bit	DATAFLG		; IN A "DATA" STATEMENT?
   779 00:A424: 70 04        	bvs	PARS2		; YES (DATAFLG = $49)
   780 00:A426: C9 20        	cmp	#' '		; IGNORE BLANKS
   781 00:A428: F0 F4        	beq	PARSE
   782 00:A42A: 85 0E        PARS2:	sta	ENDCHR
   783 00:A42C: C9 22        	cmp	#'"'		; START OF QUOTATION?
   784 00:A42E: F0 63        	beq	PARS13
   785 00:A430: 70 3C        	bvs	PARS9		; BRANCH IF IN "DATA" STATEMENT
   786 00:A432: C9 3F        	cmp	#'?'		; SHORTHAND FOR "PRINT"?
   787 00:A434: D0 04        	bne	PARS3		; NO
   788 00:A436: A9 98        	lda	#TOKEN_PRINT	; YES, REPLACE WITH "PRINT" TOKEN
   789 00:A438: D0 34        	bne	PARS9		; ...ALWAYS
   790 00:A43A: C9 30        PARS3:	cmp	#'0'		; IS IT A DIGIT, COLON, OR SEMI-COLON?
   791 00:A43C: 90 04        	bcc	PARS4		; NO, PUNCTUATION !"#$%&'()*+,-./
   792 00:A43E: C9 3C        	cmp	#';'+1
   793 00:A440: 90 2C        	bcc	PARS9		; YES, NOT A TOKEN
   794                        ; ----------------------------------------------------------------------------
   795                        ; SEARCH TOKEN NAME TABLE FOR MATCH STARTING
   796                        ; WITH CURRENT CHAR FROM INPUT LINE
   797                        ; ----------------------------------------------------------------------------
   798 00:A442: 84 AD        PARS4:	sty	STRNG2		; SAVE INDEX TO OUTPUT LINE
   799 00:A444: A9 A4        	lda	#<(TOKEN_NAME_TABLE-$100)
   800 00:A446: 85 9D        	sta	FAC		; MAKE PNTR FOR SEARCH
   801 00:A448: A9 9F        	lda	#>(TOKEN_NAME_TABLE-$100)
   802 00:A44A: 85 9E        	sta	FAC+1
   803 00:A44C: A0 00        	ldy	#0		; USE Y-REG WITH (FAC) TO ADDRESS TABLE
   804 00:A44E: 84 0F        	sty	TKNCNTR		; HOLDS CURRENT TOKEN-$80
   805 00:A450: 88           	dey			; PREPARE FOR "INY" A FEW LINES DOWN
   806 00:A451: 86 B8        	stx	TXTPTR		; SAVE POSITION IN INPUT LINE
   807 00:A453: CA           	dex			; PREPARE FOR "INX" A FEW LINES DOWN
   808 00:A454: C8           PARS5:	iny			; ADVANCE POINTER TO TOKEN TABLE
   809 00:A455: D0 02        	bne	PARS6		; Y=Y+1 IS ENOUGH
   810 00:A457: E6 9E        	inc	FAC+1		; ALSO NEED TO BUMP THE PAGE
   811 00:A459: E8           PARS6:	inx			; ADVANCE POINTER TO INPUT LINE
   812 00:A45A: BD 00 02     PARS7:	lda	INPUTBUFFER,x	; NEXT CHAR FROM INPUT LINE
   813 00:A45D: C9 20        	cmp	#' '		; THIS CHAR A BLANK?
   814 00:A45F: F0 F8        	beq	PARS6		; YES, IGNORE ALL BLANKS
   815 00:A461: 38           	sec			; NO, COMPARE TO CHAR IN TABLE
   816 00:A462: F1 9D        	sbc	(FAC),y		; SAME AS NEXT CHAR OF TOKEN NAME?
   817 00:A464: F0 EE        	beq	PARS5		; YES, CONTINUE MATCHING
   818 00:A466: C9 80        	cmp	#$80		; MAYBE; WAS IT SAME EXCEPT FOR BIT 7?
   819 00:A468: D0 30        	bne	PARS14		; NO, SKIP TO NEXT TOKEN
   820 00:A46A: 05 0F        	ora	TKNCNTR		; YES, END OF TOKEN; GET TOKEN #
   821                        ; ----------------------------------------------------------------------------
   822                        ; STORE CHARACTER OR TOKEN IN OUTPUT LINE
   823                        ; ----------------------------------------------------------------------------
   824 00:A46C: A4 AD        PARS8:	ldy	STRNG2		; GET INDEX TO OUTPUT LINE IN Y-REG
   825 00:A46E: E8           PARS9:	inx			; ADVANCE INPUT INDEX
   826 00:A46F: C8           	iny			; ADVANCE OUTPUT INDEX
   827 00:A470: 99 FB 01     	sta	INPUTBUFFER-5,y	; STORE CHAR OR TOKEN
   828 00:A473: B9 FB 01     	lda	INPUTBUFFER-5,y	; TEST FOR EOL OR EOS
   829 00:A476: F0 39        	beq	PARS17		; END OF LINE
   830 00:A478: 38           	sec
   831 00:A479: E9 3A        	sbc	#':'		; END OF STATEMENT?
   832 00:A47B: F0 04        	beq	PARS10		; YES, CLEAR DATAFLG
   833 00:A47D: C9 49        	cmp	#TOKEN_DATA-':'	; "DATA" TOKEN?
   834 00:A47F: D0 02        	bne	PARS11		; NO, LEAVE DATAFLG ALONE
   835 00:A481: 85 13        PARS10:	sta	DATAFLG		; DATAFLG = 0 OR $83-$3A = $49
   836 00:A483: 38           PARS11:	sec			; IS IT A "REM" TOKEN?
   837 00:A484: E9 5A        	sbc	#TOKEN_REM-':'
   838 00:A486: D0 97        	bne	PARS1		; NO, CONTINUE PARSING LINE
   839 00:A488: 85 0E        	sta	ENDCHR		; YES, CLEAR LITERAL FLAG
   840                        ; ----------------------------------------------------------------------------
   841                        ; HANDLE LITERAL (BETWEEN QUOTES) OR REMARK,
   842                        ; BY COPYING CHARS UP TO ENDCHR.
   843                        ; ----------------------------------------------------------------------------
   844 00:A48A: BD 00 02     PARS12:	lda	INPUTBUFFER,x
   845 00:A48D: F0 DF        	beq	PARS9		; END OF LINE
   846 00:A48F: C5 0E        	cmp	ENDCHR
   847 00:A491: F0 DB        	beq	PARS9		; FOUND ENDCHR
   848 00:A493: C8           PARS13:	iny			; NEXT OUTPUT CHAR
   849 00:A494: 99 FB 01     	sta	INPUTBUFFER-5,y
   850 00:A497: E8           	inx			; NEXT INPUT CHAR
   851 00:A498: D0 F0        	bne	PARS12		; ...ALWAYS
   852                        ; ----------------------------------------------------------------------------
   853                        ; ADVANCE POINTER TO NEXT TOKEN NAME
   854                        ; ----------------------------------------------------------------------------
   855 00:A49A: A6 B8        PARS14:	ldx	TXTPTR		; GET POINTER TO INPUT LINE IN X-REG
   856 00:A49C: E6 0F        	inc	TKNCNTR		;    BUMP (TOKEN # - $80)
   857 00:A49E: B1 9D        PARS15:	lda	(FAC),y		; SCAN THROUGH TABLE FOR BIT7 = 1
   858 00:A4A0: C8           	iny			; NEXT TOKEN ONE BEYOND THAT
   859 00:A4A1: D0 02        	bne	PARS16		; ...USUALLY ENOUGH TO BUMP Y-REG
   860 00:A4A3: E6 9E        	inc	FAC+1		; NEXT SET OF 256 TOKEN CHARS
   861 00:A4A5: 0A           PARS16:	asl	a		; SEE IF SIGN BIT SET ON CHAR
   862 00:A4A6: 90 F6        	bcc	PARS15		; NO, MORE IN THIS NAME
   863 00:A4A8: B1 9D        	lda	(FAC),y		; YES, AT NEXT NAME.  END OF TABLE?
   864 00:A4AA: D0 AE        	bne	PARS7		; NO, NOT END OF TABLE
   865 00:A4AC: BD 00 02     	lda	INPUTBUFFER,x	; YES, SO NOT A KEYWORD
   866 00:A4AF: 10 BB        	bpl	PARS8		; ...ALWAYS, COPY CHAR AS IS
   867                        ; ---END OF LINE------------------
   868 00:A4B1: 99 FD 01     PARS17:	sta	INPUTBUFFER-3,y	; STORE ANOTHER 00 ON END
   869 00:A4B4: C6 B9        	dec	TXTPTR+1	; SET TXTPTR = INPUTBUFFER-1
   870 00:A4B6: A9 FF        	lda	#<(INPUTBUFFER-1)
   871 00:A4B8: 85 B8        	sta	TXTPTR
   872 00:A4BA: 60           	rts
   873                        
   874                        
   875                        ; ----------------------------------------------------------------------------
   876                        ; SEARCH FOR LINE
   877                        ;
   878                        ; (LINNUM) = LINE # TO FIND
   879                        ; IF NOT FOUND:  CARRY = 0
   880                        ;	LOWTR POINTS AT NEXT LINE
   881                        ; IF FOUND:      CARRY = 1
   882                        ;	LOWTR POINTS AT LINE
   883                        ; ----------------------------------------------------------------------------
   884 00:A4BB: A5 67        FNDLIN:	lda	TXTTAB		; SEARCH FROM BEGINNING OF PROGRAM
   885 00:A4BD: A6 68        	ldx	TXTTAB+1
   886 00:A4BF: A0 01        FL1:	ldy	#1		; SEARCH FROM (X,A)
   887 00:A4C1: 85 9B        	sta	LOWTR
   888 00:A4C3: 86 9C        	stx	LOWTR+1
   889 00:A4C5: B1 9B        	lda	(LOWTR),y
   890 00:A4C7: F0 1F        	beq	FNDL3		; END OF PROGRAM, AND NOT FOUND
   891 00:A4C9: C8           	iny
   892 00:A4CA: C8           	iny
   893 00:A4CB: A5 51        	lda	LINNUM+1
   894 00:A4CD: D1 9B        	cmp	(LOWTR),y
   895 00:A4CF: 90 18        	bcc	RTS1		; IF NOT FOUND
   896 00:A4D1: F0 03        	beq	FNDL1
   897 00:A4D3: 88           	dey
   898 00:A4D4: D0 09        	bne	FNDL2
   899 00:A4D6: A5 50        FNDL1:	lda	LINNUM
   900 00:A4D8: 88           	dey
   901 00:A4D9: D1 9B        	cmp	(LOWTR),y
   902 00:A4DB: 90 0C        	bcc	RTS1		; PAST LINE, NOT FOUND
   903 00:A4DD: F0 0A        	beq	RTS1		; IF FOUND
   904 00:A4DF: 88           FNDL2:	dey
   905 00:A4E0: B1 9B        	lda	(LOWTR),y
   906 00:A4E2: AA           	tax
   907 00:A4E3: 88           	dey
   908 00:A4E4: B1 9B        	lda	(LOWTR),y
   909 00:A4E6: B0 D7        	bcs	FL1		; ALWAYS
   910 00:A4E8: 18           FNDL3:	clc			; RETURN CARRY = 0
   911 00:A4E9: 60           RTS1:	rts
   912                        
   913                        
   914                        ; ----------------------------------------------------------------------------
   915                        ; "NEW" STATEMENT
   916                        ; ----------------------------------------------------------------------------
   917 00:A4EA: D0 FD        NEW:	bne	RTS1		; IGNORE IF MORE TO THE STATEMENT
   918 00:A4EC: A9 00        SCRTCH:	lda	#0
   919 00:A4EE: 85 D6        	sta	LOCK
   920 00:A4F0: A8           	tay
   921 00:A4F1: 91 67        	sta	(TXTTAB),y
   922 00:A4F3: C8           	iny
   923 00:A4F4: 91 67        	sta	(TXTTAB),y
   924 00:A4F6: A5 67        	lda	TXTTAB
   925 00:A4F8: 69 02        	adc	#2		; (CARRY WASN'T CLEARED, SO "NEW" USUALLY
   926 00:A4FA: 85 69        	sta	VARTAB		; ADDS 3, WHEREAS "FP" ADDS 2.)
   927 00:A4FC: 85 AF        	sta	PRGEND
   928 00:A4FE: A5 68        	lda	TXTTAB+1
   929 00:A500: 69 00        	adc	#0
   930 00:A502: 85 6A        	sta	VARTAB+1
   931 00:A504: 85 B0        	sta	PRGEND+1
   932                        ; ----------------------------------------------------------------------------
   933                        SETPTRS:
   934 00:A506: 20 38 A5     	jsr	STXTPT		; SET TXTPTR TO TXTTAB - 1
   935 00:A509: A9 00        	lda	#0		; (THIS COULD HAVE BEEN ".byte $2C")
   936                        
   937                        
   938                        ; ----------------------------------------------------------------------------
   939                        ; "CLEAR" STATEMENT
   940                        ; ----------------------------------------------------------------------------
   941 00:A50B: D0 2A        CLEAR:	bne	RTS2		; IGNORE IF NOT AT END OF STATEMENT
   942 00:A50D: A5 73        CLEARC:	lda	MEMSIZ		; CLEAR STRING AREA
   943 00:A50F: A4 74        	ldy	MEMSIZ+1
   944 00:A511: 85 6F        	sta	FRETOP
   945 00:A513: 84 70        	sty	FRETOP+1
   946 00:A515: A5 69        	lda	VARTAB		; CLEAR ARRAY AREA
   947 00:A517: A4 6A        	ldy	VARTAB+1
   948 00:A519: 85 6B        	sta	ARYTAB
   949 00:A51B: 84 6C        	sty	ARYTAB+1
   950 00:A51D: 85 6D        	sta	STREND		; LOW END OF FREE SPACE
   951 00:A51F: 84 6E        	sty	STREND+1
   952 00:A521: 20 C1 A6     	jsr	RESTORE		; SET "DATA" POINTER TO BEGINNING
   953                        ; ----------------------------------------------------------------------------
   954 00:A524: A2 55        STKINI:	ldx	#TEMPST
   955 00:A526: 86 52        	stx	TEMPPT
   956 00:A528: 68           	pla			; SAVE RETURN ADDRESS
   957 00:A529: A8           	tay
   958 00:A52A: 68           	pla
   959 00:A52B: A2 F8        	ldx	#$F8		; START STACK AT $F8,
   960 00:A52D: 9A           	txs			;   LEAVING ROOM FOR PARSING LINES
   961 00:A52E: 48           	pha			; RESTORE RETURN ADDRESS
   962 00:A52F: 98           	tya
   963 00:A530: 48           	pha
   964 00:A531: A9 00        	lda	#0
   965 00:A533: 85 7A        	sta	OLDTEXT+1
   966 00:A535: 85 14        	sta	SUBFLG
   967 00:A537: 60           RTS2:	rts
   968                        
   969                        ; ----------------------------------------------------------------------------
   970                        ; SET TXTPTR TO BEGINNING OF PROGRAM
   971                        ; ----------------------------------------------------------------------------
   972 00:A538: 18           STXTPT:	clc			; TXTPTR = TXTTAB - 1
   973 00:A539: A5 67        	lda     TXTTAB
   974 00:A53B: 69 FF        	adc     #$FF
   975 00:A53D: 85 B8        	sta     TXTPTR
   976 00:A53F: A5 68        	lda     TXTTAB+1
   977 00:A541: 69 FF        	adc     #$FF
   978 00:A543: 85 B9        	sta     TXTPTR+1
   979 00:A545: 60           	rts
   980                        
   981                        ; ----------------------------------------------------------------------------
   982                        ; "LIST" STATEMENT
   983                        ; ----------------------------------------------------------------------------
   984 00:A546: 90 0A        LIST:	bcc	LIST_1		; NO  LINE # SPECIFIED
   985 00:A548: F0 08        	beq	LIST_1		; ---DITTO---
   986 00:A54A: C9 A8        	cmp	#TOKEN_MINUS	; IF DASH OR COMMA, START AT LINE 0
   987 00:A54C: F0 04        	beq	LIST_1		; IT IS A DASH
   988 00:A54E: C9 2C        	cmp	#','		; COMMA?
   989 00:A550: D0 E5        	bne	RTS2		; NO, ERROR
   990 00:A552: 20 25 A8     LIST_1:	jsr	LINGET		; CONVERT LINE NUMBER IF ANY
   991 00:A555: 20 BB A4     	jsr	FNDLIN		; POINT LOWTR TO 1ST LINE
   992 00:A558: 20 B7 00     	jsr	CHRGOT		; RANGE SPECIFIED?
   993 00:A55B: F0 10        	beq	LIST_3		; NO
   994 00:A55D: C9 A8        	cmp	#TOKEN_MINUS
   995 00:A55F: F0 04        	beq	LIST_2
   996 00:A561: C9 2C        	cmp	#','
   997 00:A563: D0 84        	bne	RTS1
   998 00:A565: 20 B1 00     LIST_2:	jsr	CHRGET		; GET NEXT CHAR
   999 00:A568: 20 25 A8     	jsr	LINGET		; CONVERT SECOND LINE #
  1000 00:A56B: D0 CA        	bne	RTS2		; BRANCH IF SYNTAX ERR
  1001 00:A56D: 68           LIST_3:	pla			; POP RETURN ADRESS
  1002 00:A56E: 68           	pla			; (GET BACK BY "JMP NEWSTT")
  1003 00:A56F: A5 50        	lda	LINNUM		; IF NO SECOND NUMBER, USE $FFFF
  1004 00:A571: 05 51        	ora	LINNUM+1
  1005 00:A573: D0 06        	bne	LIST0		; THERE WAS A SECOND NUMBER
  1006 00:A575: A9 FF        	lda	#$FF		; MAX END RANGE
  1007 00:A577: 85 50        	sta	LINNUM
  1008 00:A579: 85 51        	sta	LINNUM+1
  1009 00:A57B: A0 01        LIST0:	ldy	#1
  1010 00:A57D: B1 9B        	lda	(LOWTR),y	; HIGH BYTE OF LINK
  1011 00:A57F: F0 37        	beq	LIST3		; END OF PROGRAM
  1012 00:A581: 20 D0 A6     	jsr	ISCNTC		; CHECK IF CONTROL-C HAS BEEN TYPED
  1013 00:A584: 20 46 BE     	jsr	CRDO		; NO, PRINT <RETURN>
  1014 00:A587: C8           	iny
  1015 00:A588: B1 9B        	lda	(LOWTR),y	; GET LINE #, COMPARE WITH END RANGE
  1016 00:A58A: AA           	tax
  1017 00:A58B: C8           	iny
  1018 00:A58C: B1 9B        	lda	(LOWTR),y
  1019 00:A58E: C5 51        	cmp	LINNUM+1
  1020 00:A590: D0 04        	bne	LIST_5
  1021 00:A592: E4 50        	cpx	LINNUM
  1022 00:A594: F0 02        	beq	LIST_6		; ON LAST LINE OF RANGE
  1023 00:A596: B0 20        LIST_5:	bcs	LIST3		; FINISHED THE RANGE
  1024                        ; ---LIST ONE LINE----------------
  1025 00:A598: 84 85        LIST_6:	sty	FORPNT
  1026 00:A59A: 20 E1 B9     	jsr	LINPRT		; PRINT LINE # FROM X,A
  1027 00:A59D: A9 20        	lda	#' '		; PRINT SPACE AFTER LINE #
  1028 00:A59F: A4 85        LIST1:	ldy	FORPNT
  1029 00:A5A1: 29 7F        	and	#$7F
  1030 00:A5A3: 20 4D BE     LIST2:	jsr	OUTDO
  1031 00:A5A6: C8           LIST21:	iny
  1032 00:A5A7: B1 9B        	lda	(LOWTR),y
  1033 00:A5A9: D0 1B        	bne	LIST4		; NOT END OF LINE YET
  1034 00:A5AB: A8           	tay			; END OF LINE
  1035 00:A5AC: B1 9B        	lda	(LOWTR),y	; GET LINK TO NEXT LINE
  1036 00:A5AE: AA           	tax
  1037 00:A5AF: C8           	iny
  1038 00:A5B0: B1 9B        	lda	(LOWTR),y
  1039 00:A5B2: 86 9B        	stx	LOWTR		; POINT TO NEXT LINE
  1040 00:A5B4: 85 9C        	sta	LOWTR+1
  1041 00:A5B6: D0 C3        	bne	LIST0		; BRANCH IF NOT END OF PROGRAM
  1042 00:A5B8: 20 46 BE     LIST3:	jsr	CRDO		; PRINT <RETURN>
  1043 00:A5BB: 4C 62 A6     	jmp	NEWSTT		; TO NEXT STATEMENT
  1044                        ; ----------------------------------------------------------------------------
  1045 00:A5BE: C8           GETCHR:	iny			;  PICK UP CHAR FROM TABLE
  1046 00:A5BF: D0 02        	bne	GETCHR21
  1047 00:A5C1: E6 9E        	inc	FAC+1
  1048                        GETCHR21:
  1049 00:A5C3: B1 9D        	lda	(FAC),y
  1050 00:A5C5: 60           	rts
  1051                        ; ----------------------------------------------------------------------------
  1052 00:A5C6: 10 DB        LIST4:	bpl	LIST2		; BRANCH IF NOT A TOKEN
  1053 00:A5C8: 38           	sec
  1054 00:A5C9: E9 7F        	sbc	#$7F		; CONVERT TOKEN TO INDEX
  1055 00:A5CB: AA           	tax
  1056 00:A5CC: 84 85        	sty	FORPNT		; SAVE LINE POINTER
  1057 00:A5CE: A0 A4        	ldy	#<(TOKEN_NAME_TABLE-$100)
  1058 00:A5D0: 84 9D        	sty	FAC		; POINT FAC TO TABLE
  1059 00:A5D2: A0 9F        	ldy	#>(TOKEN_NAME_TABLE-$100)
  1060 00:A5D4: 84 9E        	sty	FAC+1
  1061 00:A5D6: A0 FF        	ldy	#$FF		; Y= -1
  1062 00:A5D8: CA           LIST41:	dex			; SKIP KEYWORDS UNTIL REACH THIS ONE
  1063 00:A5D9: F0 07        	beq	LIST43
  1064 00:A5DB: 20 BE A5     LIST42:	jsr	GETCHR		; BUMP Y, GET CHAR FROM TABLE
  1065 00:A5DE: 10 FB        	bpl	LIST42		; NOT AT END OF KEYWORD YET
  1066 00:A5E0: 30 F6        	bmi	LIST41		; END OF KEYWORD, ALWAYS BRANCHES
  1067 00:A5E2: 20 3E BE     LIST43:	jsr	OUTSP		; FOUND THE RIGHT KEYWORD, PRINT LEADING SPACE
  1068 00:A5E5: 20 BE A5     LIST44:	jsr	GETCHR		; PRINT THE KEYWORD
  1069 00:A5E8: 30 05        	bmi	LIST45		; LAST CHAR OF KEYWORD
  1070 00:A5EA: 20 4D BE     	jsr	OUTDO
  1071 00:A5ED: D0 F6        	bne	LIST44		; ...ALWAYS
  1072 00:A5EF: 20 4D BE     LIST45:	jsr	OUTDO		; PRINT LAST CHAR OF KEYWORD
  1073 00:A5F2: A9 20        	lda	#' '		; PRINT TRAILING SPACE
  1074 00:A5F4: D0 A9        	bne	LIST1		; ...ALWAYS, BACK TO ACTUAL LINE
  1075                        
  1076                        
  1077                        ; ----------------------------------------------------------------------------
  1078                        ; "FOR" STATEMENT
  1079                        ;
  1080                        ; FOR PUSHES 18 BYTES ON THE STACK:
  1081                        ; 2 -- TXTPTR
  1082                        ; 2 -- LINE NUMBER
  1083                        ; 5 -- INITIAL (CURRENT)  FOR VARIABLE VALUE
  1084                        ; 1 -- STEP SIGN
  1085                        ; 5 -- STEP VALUE
  1086                        ; 2 -- ADDRESS OF FOR VARIABLE IN VARTAB
  1087                        ; 1 -- FOR TOKEN ($81)
  1088                        ; ----------------------------------------------------------------------------
  1089 00:A5F6: A9 80        FOR:	lda	#$80
  1090 00:A5F8: 85 14        	sta	SUBFLG		; SUBSCRIPTS NOT ALLOWED
  1091 00:A5FA: 20 5F A8     	jsr	LET		; DO <VAR> = <EXP>, STORE ADDR IN FORPNT
  1092 00:A5FD: 20 2D A2     	jsr	GTFORPNT	; IS THIS FOR VARIABLE ACTIVE?
  1093 00:A600: D0 05        	bne	FOR_1		; NO
  1094 00:A602: 8A           	txa			; YES, CANCEL IT AND ENCLOSED LOOPS
  1095 00:A603: 69 0F        	adc	#15		; CARRY=1, THIS ADDS 16
  1096 00:A605: AA           	tax			; X WAS ALREADY S+2
  1097 00:A606: 9A           	txs
  1098 00:A607: 68           FOR_1:	pla			; POP RETURN ADDRESS TOO
  1099 00:A608: 68           	pla
  1100 00:A609: A9 09        	lda	#9		; BE CERTAIN ENOUGH ROOM IN STACK
  1101 00:A60B: 20 9E A2     	jsr	CHKMEM
  1102 00:A60E: 20 BC A7     	jsr	DATAN		; SCAN AHEAD TO NEXT STATEMENT
  1103 00:A611: 18           	clc			; PUSH STATEMENT ADDRESS ON STACK
  1104 00:A612: 98           	tya
  1105 00:A613: 65 B8        	adc	TXTPTR
  1106 00:A615: 48           	pha
  1107 00:A616: A5 B9        	lda	TXTPTR+1
  1108 00:A618: 69 00        	adc	#0
  1109 00:A61A: 48           	pha
  1110 00:A61B: A5 76        	lda	CURLIN+1	; PUSH LINE NUMBER ON STACK
  1111 00:A61D: 48           	pha
  1112 00:A61E: A5 75        	lda	CURLIN
  1113 00:A620: 48           	pha
  1114 00:A621: A9 A2        	lda	#TOKEN_TO
  1115 00:A623: 20 86 AC     	jsr	SYNCHR		; REQUIRE "TO"
  1116 00:A626: 20 37 AB     	jsr	CHKNUM		; <VAR> = <EXP> MUST BE NUMERIC
  1117 00:A629: 20 34 AB     	jsr	FRMNUM		; GET FINAL VALUE, MUST BE NUMERIC
  1118 00:A62C: A5 A2        	lda	FACSIGN		; PUT SIGN INTO VALUE IN FAC
  1119 00:A62E: 09 7F        	ora	#$7F
  1120 00:A630: 25 9E        	and	FAC+1
  1121 00:A632: 85 9E        	sta	FAC+1
  1122 00:A634: A9 3F        	lda	#<STEP		; SET UP FOR RETURN
  1123 00:A636: A0 A6        	ldy	#>STEP		; TO STEP
  1124 00:A638: 85 5E        	sta	INDEX
  1125 00:A63A: 84 5F        	sty	INDEX+1
  1126 00:A63C: 4C ED AB     	jmp	FRM_STACK3	; RETURNS BY "JMP (INDEX)"
  1127                        
  1128                        
  1129                        ; ----------------------------------------------------------------------------
  1130                        ; "STEP" PHRASE OF "FOR" STATEMENT
  1131                        ; ----------------------------------------------------------------------------
  1132 00:A63F: A9 DA        STEP:	lda	#<CON_ONE	; STEP DEFAULT=1
  1133 00:A641: A0 B5        	ldy	#>CON_ONE
  1134 00:A643: 20 BB B7     	jsr	LOAD_FAC_FROM_YA
  1135 00:A646: 20 B7 00     	jsr	CHRGOT
  1136 00:A649: C9 A6        	cmp	#TOKEN_STEP
  1137 00:A64B: D0 06        	bne	STEP_1		; USE DEFAULT VALUE OF 1.0
  1138 00:A64D: 20 B1 00     	jsr	CHRGET		; STEP SPECIFIED, GET IT
  1139 00:A650: 20 34 AB     	jsr	FRMNUM
  1140 00:A653: 20 44 B8     STEP_1:	jsr	SIGN
  1141 00:A656: 20 E2 AB     	jsr	FRM_STACK2
  1142 00:A659: A5 86        	lda	FORPNT+1
  1143 00:A65B: 48           	pha
  1144 00:A65C: A5 85        	lda	FORPNT
  1145 00:A65E: 48           	pha
  1146 00:A65F: A9 81        	lda	#TOKEN_FOR
  1147 00:A661: 48           	pha
  1148                        
  1149                        
  1150                        ; ----------------------------------------------------------------------------
  1151                        ; PERFORM NEXT STATEMENT
  1152                        ; ----------------------------------------------------------------------------
  1153 00:A662: BA           NEWSTT:	tsx			; REMEMBER THE STACK POSITION
  1154 00:A663: 86 F8        	stx	REMSTK
  1155 00:A665: 20 D0 A6     	jsr	ISCNTC		; SEE IF CONTROL-C HAS BEEN TYPED
  1156 00:A668: A5 B8        	lda	TXTPTR		; NO, KEEP EXECUTING
  1157 00:A66A: A4 B9        	ldy	TXTPTR+1
  1158 00:A66C: A6 76        	ldx	CURLIN+1	; =$FF IF IN DIRECT MODE
  1159 00:A66E: E8           	inx			; $FF TURNS INTO $00
  1160 00:A66F: F0 04        	beq	NEWSTT_1		; IN DIRECT MODE
  1161 00:A671: 85 79        	sta	OLDTEXT		; IN RUNNING MODE
  1162 00:A673: 84 7A        	sty	OLDTEXT+1
  1163                        NEWSTT_1:
  1164 00:A675: A0 00        	ldy	#0
  1165 00:A677: B1 B8        	lda	(TXTPTR),y	; END OF LINE YET?
  1166 00:A679: D0 3F        	bne	COLON		; NO
  1167 00:A67B: A0 02        	ldy	#2		; YES, SEE IF END OF PROGRAM
  1168 00:A67D: B1 B8        	lda	(TXTPTR),y
  1169 00:A67F: 18           	clc
  1170 00:A680: F0 1C        	beq	GOEND		; YES, END OF PROGRAM
  1171 00:A682: C8           	iny
  1172 00:A683: B1 B8        	lda	(TXTPTR),y	; GET LINE # OF NEXT LINE
  1173 00:A685: 85 75        	sta	CURLIN
  1174 00:A687: C8           	iny
  1175 00:A688: B1 B8        	lda	(TXTPTR),y
  1176 00:A68A: 85 76        	sta	CURLIN+1
  1177 00:A68C: 98           	tya			; ADJUST TXTPTR TO START
  1178 00:A68D: 65 B8        	adc	TXTPTR		; OF NEW LINE
  1179 00:A68F: 85 B8        	sta	TXTPTR
  1180 00:A691: 90 02        	bcc	NEWSTT_2
  1181 00:A693: E6 B9        	inc	TXTPTR+1
  1182                        NEWSTT_2:
  1183                        NEWSTT2:
  1184 00:A695: 20 B1 00     	jsr	CHRGET		; GET FIRST CHR OF STATEMENT
  1185 00:A698: 20 A0 A6     	jsr	EXECUTE_STATEMENT	; AND START PROCESSING
  1186 00:A69B: 4C 62 A6     	jmp	NEWSTT		; BACK FOR MORE
  1187                        ; ----------------------------------------------------------------------------
  1188 00:A69E: F0 65        GOEND:	beq	END4
  1189                        
  1190                        
  1191                        ; ----------------------------------------------------------------------------
  1192                        ; EXECUTE A STATEMENT
  1193                        ;
  1194                        ; (A) IS FIRST CHAR OF STATEMENT
  1195                        ; CARRY IS SET
  1196                        ; ----------------------------------------------------------------------------
  1197                        EXECUTE_STATEMENT:
  1198 00:A6A0: F0 2D        	beq	RTS3		; END OF LINE, NULL STATEMENT
  1199                        EXECUTE_STATEMENT1:
  1200 00:A6A2: E9 80        	sbc	#$80		; FIRST CHAR A TOKEN?
  1201 00:A6A4: 90 11        	bcc	EXECUTE_S1		; NOT TOKEN, MUST BE "LET"
  1202 00:A6A6: C9 40        	cmp	#$40		; STATEMENT-TYPE TOKEN?
  1203 00:A6A8: B0 14        	bcs	SYNERR1		; NO, SYNTAX ERROR
  1204 00:A6AA: 0A           	asl	a		; DOUBLE TO GET INDEX
  1205 00:A6AB: A8           	tay			; INTO ADDRESS TABLE
  1206 00:A6AC: B9 21 A0     	lda	TOKEN_ADDRESS_TABLE+1,y
  1207 00:A6AF: 48           	pha			; PUT ADDRESS ON STACK
  1208 00:A6B0: B9 20 A0     	lda	TOKEN_ADDRESS_TABLE,y
  1209 00:A6B3: 48           	pha
  1210 00:A6B4: 4C B1 00     	jmp	CHRGET		; GET NEXT CHR & RTS TO ROUTINE
  1211                        ; ----------------------------------------------------------------------------
  1212                        EXECUTE_S1:
  1213 00:A6B7: 4C 5F A8     	jmp	LET		; MUST BE <VAR> = <EXP>
  1214                        ; ----------------------------------------------------------------------------
  1215 00:A6BA: C9 3A        COLON:	cmp	#':'
  1216 00:A6BC: F0 D7        	beq	NEWSTT2
  1217                        SYNERR1:
  1218 00:A6BE: 4C 8F AC     	jmp	SYNERR
  1219                        
  1220                        
  1221                        ; ----------------------------------------------------------------------------
  1222                        ; "RESTORE" STATEMENT
  1223                        ; ----------------------------------------------------------------------------
  1224                        RESTORE:
  1225 00:A6C1: 38           	sec			; SET DATPTR TO BEGINNING OF PROGRAM
  1226 00:A6C2: A5 67        	lda	TXTTAB
  1227 00:A6C4: E9 01        	sbc	#1
  1228 00:A6C6: A4 68        	ldy	TXTTAB+1
  1229 00:A6C8: B0 01        	bcs	SETDA
  1230 00:A6CA: 88           	dey
  1231                        ; ---SET DATPTR TO Y,A------------
  1232 00:A6CB: 85 7D        SETDA:  sta	DATPTR
  1233 00:A6CD: 84 7E        	sty	DATPTR+1
  1234 00:A6CF: 60           RTS3:   rts
  1235                        
  1236                        
  1237                        ; ----------------------------------------------------------------------------
  1238                        ; SEE IF CONTROL-C TYPED
  1239                        ; ----------------------------------------------------------------------------
  1240                        ISCNTC:
  1241 00:A6D0: 20 FE BD     	jsr	CONST
  1242 00:A6D3: D0 01        	bne	ISC_0
  1243 00:A6D5: 60           	rts
  1244                        ISC_0:
  1245 00:A6D6: 20 FB BD     	jsr	RDKEY
  1246 00:A6D9: C9 03        	cmp	#$03
  1247 00:A6DB: F0 01        	beq	ISC_1
  1248 00:A6DD: 60           	rts
  1249                        
  1250                        ISC_1:
  1251                        CONTROL_C_TYPED:
  1252 00:A6DE: A2 FF        	ldx	#$FF		; CONTROL C ATTEMPTED
  1253 00:A6E0: 24 D8        	bit	ERRFLG		; "ON ERR" ENABLED?
  1254 00:A6E2: 10 03        	bpl	ISC_2		; NO
  1255 00:A6E4: 4C B6 BD     	jmp	HANDLERR	; YES, RETURN ERR CODE = 255
  1256 00:A6E7: C9 03        ISC_2:	cmp	#3		; SINCE IT IS CTRL-C, SET Z AND C BITS
  1257                        
  1258                        
  1259                        ; ----------------------------------------------------------------------------
  1260                        ; "STOP" STATEMENT
  1261                        ; ----------------------------------------------------------------------------
  1262 00:A6E9: B0 01        STOP:	bcs	END2		; CARRY=1 TO FORCE PRINTING "BREAK AT.."
  1263                        
  1264                        
  1265                        ; ----------------------------------------------------------------------------
  1266                        ; "END" STATEMENT
  1267                        ; ----------------------------------------------------------------------------
  1268 00:A6EB: 18           END:	clc			; CARRY=0 TO AVOID PRINTING MESSAGE
  1269 00:A6EC: D0 3C        END2:	bne     RTS4		; IF NOT END OF STATEMENT, DO NOTHING
  1270 00:A6EE: A5 B8        	lda     TXTPTR
  1271 00:A6F0: A4 B9        	ldy     TXTPTR+1
  1272 00:A6F2: A6 76        	ldx     CURLIN+1
  1273 00:A6F4: E8           	inx			; RUNNING?
  1274 00:A6F5: F0 0C        	beq     END21		; NO, DIRECT MODE
  1275 00:A6F7: 85 79        	sta     OLDTEXT
  1276 00:A6F9: 84 7A        	sty     OLDTEXT+1
  1277 00:A6FB: A5 75        	lda     CURLIN
  1278 00:A6FD: A4 76        	ldy     CURLIN+1
  1279 00:A6FF: 85 77        	sta     OLDLIN
  1280 00:A701: 84 78        	sty     OLDLIN+1
  1281 00:A703: 68           END21:	pla
  1282 00:A704: 68           	pla
  1283 00:A705: A9 26        END4:   lda     #<QT_BREAK	; " BREAK"
  1284 00:A707: A0 A2        	ldy     #>QT_BREAK
  1285 00:A709: 90 03        	bcc     END41
  1286 00:A70B: 4C F9 A2     	jmp     PRINT_ERROR_LINNUM
  1287 00:A70E: 4C 04 A3     END41:	jmp	RESTART
  1288                        
  1289                        
  1290                        ; ----------------------------------------------------------------------------
  1291                        ; "CONT" COMMAND
  1292                        ; ----------------------------------------------------------------------------
  1293 00:A711: D0 17        CONT:	bne	RTS4		; IF NOT END OF STATEMENT, DO NOTHING
  1294 00:A713: A2 82        	ldx	#ERR_CANTCONT
  1295 00:A715: A4 7A        	ldy	OLDTEXT+1	; MEANINGFUL RE-ENTRY?
  1296 00:A717: D0 03        	bne	CONT1		; YES
  1297 00:A719: 4C DA A2     	jmp	ERROR		; NO
  1298 00:A71C: A5 79        CONT1:	lda	OLDTEXT		; RESTORE TXTPTR
  1299 00:A71E: 85 B8        	sta	TXTPTR
  1300 00:A720: 84 B9        	sty	TXTPTR+1
  1301 00:A722: A5 77        	lda	OLDLIN		; RESTORE LINE NUMBER
  1302 00:A724: A4 78        	ldy	OLDLIN+1
  1303 00:A726: 85 75        	sta	CURLIN
  1304 00:A728: 84 76        	sty	CURLIN+1
  1305 00:A72A: 60           RTS4:	rts
  1306                        
  1307                        
  1308                        ; ----------------------------------------------------------------------------
  1309                        ; "RUN" COMMAND
  1310                        ; ----------------------------------------------------------------------------
  1311 00:A72B: 08           RUN:	php			; SAVE STATUS WHILE SUBTRACTING
  1312 00:A72C: C6 76        	dec	CURLIN+1	; IF WAS $FF (MEANING DIRECT MODE) MAKE IT "RUNNING MODE"
  1313 00:A72E: 28           	plp			; GET STATUS AGAIN (FROM CHRGET)
  1314 00:A72F: D0 03        	bne	RUN1		; PROBABLY A LINE NUMBER
  1315 00:A731: 4C 06 A5     	jmp	SETPTRS		; START AT BEGINNING OF PROGRAM
  1316 00:A734: 20 0D A5     RUN1:	jsr	CLEARC		; CLEAR VARIABLES
  1317 00:A737: 4C 4E A7     	jmp	GO_TO_LINE	; JOIN GOSUB STATEMENT
  1318                        
  1319                        
  1320                        ; ----------------------------------------------------------------------------
  1321                        ; "GOSUB" STATEMENT
  1322                        ;
  1323                        ; LEAVES 7 BYTES ON STACK:
  1324                        ; 2 -- RETURN ADDRESS (NEWSTT)
  1325                        ; 2 -- TXTPTR
  1326                        ; 2 -- LINE #
  1327                        ; 1 -- GOSUB TOKEN
  1328                        ; ----------------------------------------------------------------------------
  1329 00:A73A: A9 03        GOSUB:	lda	#3		; BE SURE ENOUGH ROOM ON STACK
  1330 00:A73C: 20 9E A2     	jsr	CHKMEM
  1331 00:A73F: A5 B9        	lda	TXTPTR+1
  1332 00:A741: 48           	pha
  1333 00:A742: A5 B8        	lda	TXTPTR
  1334 00:A744: 48           	pha
  1335 00:A745: A5 76        	lda	CURLIN+1
  1336 00:A747: 48           	pha
  1337 00:A748: A5 75        	lda	CURLIN
  1338 00:A74A: 48           	pha
  1339 00:A74B: A9 92        	lda	#TOKEN_GOSUB
  1340 00:A74D: 48           	pha
  1341                        GO_TO_LINE:
  1342 00:A74E: 20 B7 00     	jsr	CHRGOT
  1343 00:A751: 20 57 A7     	jsr	GOTO
  1344 00:A754: 4C 62 A6     	jmp	NEWSTT
  1345                        
  1346                        
  1347                        ; ----------------------------------------------------------------------------
  1348                        ; "GOTO" STATEMENT
  1349                        ; ALSO USED BY "RUN" AND "GOSUB"
  1350                        ; ----------------------------------------------------------------------------
  1351 00:A757: 20 25 A8     GOTO:	jsr	LINGET		; GET GOTO LINE
  1352 00:A75A: 20 BF A7     	jsr	REMN		; POINT Y TO EOL
  1353 00:A75D: A5 76        	lda	CURLIN+1	; IS CURRENT PAGE < GOTO PAGE?
  1354 00:A75F: C5 51        	cmp	LINNUM+1
  1355 00:A761: B0 0B        	bcs	GOTO1		; SEARCH FROM PROG START IF NOT
  1356 00:A763: 98           	tya			; OTHERWISE SEARCH FROM NEXT LINE
  1357 00:A764: 38           	sec
  1358 00:A765: 65 B8        	adc	TXTPTR
  1359 00:A767: A6 B9        	ldx	TXTPTR+1
  1360 00:A769: 90 07        	bcc	GOTO2
  1361 00:A76B: E8           	inx
  1362 00:A76C: B0 04        	bcs	GOTO2
  1363 00:A76E: A5 67        GOTO1:	lda	TXTTAB		; GET PROGRAM BEGINNING
  1364 00:A770: A6 68        	ldx	TXTTAB+1
  1365 00:A772: 20 BF A4     GOTO2:	jsr	FL1		; SEARCH FOR GOTO LINE
  1366 00:A775: 90 1E        	bcc	UNDERR		; ERROR IF NOT THERE
  1367 00:A777: A5 9B        	lda	LOWTR		; TXTPTR = START OF THE DESTINATION LINE
  1368 00:A779: E9 01        	sbc	#1
  1369 00:A77B: 85 B8        	sta	TXTPTR
  1370 00:A77D: A5 9C        	lda	LOWTR+1
  1371 00:A77F: E9 00        	sbc	#0
  1372 00:A781: 85 B9        	sta	TXTPTR+1
  1373 00:A783: 60           RTS5:	rts			; RETURN TO NEWSTT OR GOSUB
  1374                        
  1375                        
  1376                        ; ----------------------------------------------------------------------------
  1377                        ; "POP" AND "RETURN" STATEMENTS
  1378                        ; ----------------------------------------------------------------------------
  1379 00:A784: D0 FD        POP:	bne	RTS5
  1380 00:A786: A9 FF        	lda	#$FF
  1381 00:A788: 85 85        	sta	FORPNT		; <<< BUG: SHOULD BE FORPNT+1  SEE "ALL ABOUT APPLESOFT", PAGES 100,101>>>
  1382 00:A78A: 20 2D A2     	jsr	GTFORPNT	; TO CANCEL FOR/NEXT IN SUB
  1383 00:A78D: 9A           	txs
  1384 00:A78E: C9 92        	cmp	#TOKEN_GOSUB	; LAST GOSUB FOUND?
  1385 00:A790: F0 0B        	beq	RETURN
  1386 00:A792: A2 0C        	ldx	#ERR_NOGOSUB
  1387 00:A794: 2C           	db	$2C		; FAKE
  1388 00:A795: A2 3A        UNDERR:	ldx	#ERR_UNDEFSTAT
  1389 00:A797: 4C DA A2     	jmp	ERROR
  1390                        ; ----------------------------------------------------------------------------
  1391                        SYNERR2:
  1392 00:A79A: 4C 8F AC     	jmp	SYNERR
  1393                        ; ----------------------------------------------------------------------------
  1394 00:A79D: 68           RETURN:	pla			; DISCARD GOSUB TOKEN
  1395 00:A79E: 68           	pla
  1396 00:A79F: C0 10        	cpy	#<(TOKEN_POP*2)	; BRANCH IF A POP
  1397 00:A7A1: F0 3B        	beq	PULL3		; PULL LINE #
  1398 00:A7A3: 85 75        	sta	CURLIN
  1399 00:A7A5: 68           	pla
  1400 00:A7A6: 85 76        	sta	CURLIN+1
  1401 00:A7A8: 68           	pla
  1402 00:A7A9: 85 B8        	sta	TXTPTR		; PULL TXTPTR
  1403 00:A7AB: 68           	pla
  1404 00:A7AC: 85 B9        	sta	TXTPTR+1
  1405                        
  1406                        
  1407                        ; ----------------------------------------------------------------------------
  1408                        ; "DATA" STATEMENT
  1409                        ; EXECUTED BY SKIPPING TO NEXT COLON OR EOL
  1410                        ; ----------------------------------------------------------------------------
  1411 00:A7AE: 20 BC A7     DATA:	jsr	DATAN		; MOVE TO NEXT STATEMENT
  1412                        
  1413                        
  1414                        ; ----------------------------------------------------------------------------
  1415                        ; ADD (Y) TO TXTPTR
  1416                        ; ----------------------------------------------------------------------------
  1417 00:A7B1: 98           ADDON:	tya
  1418 00:A7B2: 18           	clc
  1419 00:A7B3: 65 B8        	adc	TXTPTR
  1420 00:A7B5: 85 B8        	sta	TXTPTR
  1421 00:A7B7: 90 02        	bcc	ADDON1
  1422 00:A7B9: E6 B9        	inc	TXTPTR+1
  1423                        ADDON1:
  1424 00:A7BB: 60           RTS6:	rts
  1425                        
  1426                        
  1427                        ; ----------------------------------------------------------------------------
  1428                        ; SCAN AHEAD TO NEXT ":" OR EOL
  1429                        ; ----------------------------------------------------------------------------
  1430 00:A7BC: A2 3A        DATAN:	ldx	#':'		; GET OFFSET IN Y TO EOL OR ":"
  1431 00:A7BE: 2C           	db	$2C		; FAKE
  1432                        ; ----------------------------------------------------------------------------
  1433 00:A7BF: A2 00        REMN:	ldx	#0		; TO EOL ONLY
  1434 00:A7C1: 86 0D        	stx	CHARAC
  1435 00:A7C3: A0 00        	ldy	#0
  1436 00:A7C5: 84 0E        	sty	ENDCHR
  1437 00:A7C7: A5 0E        REMN1:	lda	ENDCHR		; TRICK TO COUNT QUOTE PARITY
  1438 00:A7C9: A6 0D        	ldx	CHARAC
  1439 00:A7CB: 85 0D        	sta	CHARAC
  1440 00:A7CD: 86 0E        	stx	ENDCHR
  1441 00:A7CF: B1 B8        REMN2:	lda	(TXTPTR),y
  1442 00:A7D1: F0 E8        	beq	RTS6		; END OF LINE
  1443 00:A7D3: C5 0E        	cmp 	ENDCHR
  1444 00:A7D5: F0 E4        	beq	RTS6		; COLON IF LOOKING FOR COLONS
  1445 00:A7D7: C8           	iny
  1446 00:A7D8: C9 22        	cmp	#'"'
  1447 00:A7DA: D0 F3        	bne	REMN2
  1448 00:A7DC: F0 E9        	beq	REMN1		; ...ALWAYS
  1449                        ; ----------------------------------------------------------------------------
  1450 00:A7DE: 68           PULL3:	pla
  1451 00:A7DF: 68           	pla
  1452 00:A7E0: 68           	pla
  1453 00:A7E1: 60           	rts
  1454                        
  1455                        
  1456                        ; ----------------------------------------------------------------------------
  1457                        ; "IF" STATEMENT
  1458                        ; ----------------------------------------------------------------------------
  1459 00:A7E2: 20 48 AB     IF:	jsr	FRMEVL
  1460 00:A7E5: 20 B7 00     	jsr	CHRGOT
  1461 00:A7E8: C9 8E        	cmp	#TOKEN_GOTO
  1462 00:A7EA: F0 05        	beq	IF_1
  1463 00:A7EC: A9 A4        	lda	#TOKEN_THEN
  1464 00:A7EE: 20 86 AC     	jsr	SYNCHR
  1465 00:A7F1: A5 9D        IF_1:	lda	FAC		; CONDITION TRUE OR FALSE?
  1466 00:A7F3: D0 05        	bne	IF_TRUE		; BRANCH IF TRUE
  1467                        
  1468                        
  1469                        ; ----------------------------------------------------------------------------
  1470                        ; "REM" STATEMENT, OR FALSE "IF" STATEMENT
  1471                        ; ----------------------------------------------------------------------------
  1472 00:A7F5: 20 BF A7     REM:	jsr	REMN		; SKIP REST OF LINE
  1473 00:A7F8: F0 B7        	beq	ADDON		; ...ALWAYS
  1474                        ; ----------------------------------------------------------------------------
  1475                        IF_TRUE:
  1476 00:A7FA: 20 B7 00     	jsr	CHRGOT		; COMMAND OR NUMBER?
  1477 00:A7FD: B0 03        	bcs	IF_T1		; COMMAND
  1478 00:A7FF: 4C 57 A7     	jmp	GOTO		; NUMBER
  1479 00:A802: 4C A0 A6     IF_T1:	jmp	EXECUTE_STATEMENT
  1480                        
  1481                        
  1482                        ; ----------------------------------------------------------------------------
  1483                        ; "ON" STATEMENT
  1484                        ;
  1485                        ; ON <EXP> GOTO <LIST>
  1486                        ; ON <EXP> GOSUB <LIST>
  1487                        ; ----------------------------------------------------------------------------
  1488 00:A805: 20 DB B3     ONGOTO:	jsr	GETBYT		; EVALUATE <EXP>, AS BYTE IN FAC+4
  1489 00:A808: 48           	pha			; SAVE NEXT CHAR ON STACK
  1490 00:A809: C9 92        	cmp	#TOKEN_GOSUB
  1491 00:A80B: F0 04        	beq	ON2
  1492 00:A80D: C9 8E        ON1:	cmp	#TOKEN_GOTO
  1493 00:A80F: D0 89        	bne	SYNERR2
  1494 00:A811: C6 A1        ON2:	dec	FAC+4		; COUNTED TO RIGHT ONE YET?
  1495 00:A813: D0 04        	bne	ONG3		; NO, KEEP LOOKING
  1496 00:A815: 68           	pla			; YES, RETRIEVE CMD
  1497 00:A816: 4C A2 A6     	jmp	EXECUTE_STATEMENT1	; AND GO.
  1498 00:A819: 20 B1 00     ONG3:	jsr	CHRGET		; PRIME CONVERT SUBROUTINE
  1499 00:A81C: 20 25 A8     	jsr	LINGET		; CONVERT LINE #
  1500 00:A81F: C9 2C        	cmp	#','		; TERMINATE WITH COMMA?
  1501 00:A821: F0 EE        	beq	ON2		; YES
  1502 00:A823: 68           	pla			; NO, END OF LIST, SO IGNORE
  1503 00:A824: 60           RTS7:	rts
  1504                        
  1505                        
  1506                        ; ----------------------------------------------------------------------------
  1507                        ; CONVERT LINE NUMBER
  1508                        ; ----------------------------------------------------------------------------
  1509 00:A825: A2 00        LINGET:	ldx	#0		; ASC # TO HEX ADDRESS
  1510 00:A827: 86 50        	stx	LINNUM		; IN LINNUM.
  1511 00:A829: 86 51        	stx	LINNUM+1
  1512 00:A82B: B0 F7        LING1:	bcs	RTS7		; NOT A DIGIT
  1513 00:A82D: E9 2F        	sbc	#'0'-1		; CONVERT DIGIT TO BINARY
  1514 00:A82F: 85 0D        	sta	CHARAC		; SAVE THE DIGIT
  1515 00:A831: A5 51        	lda	LINNUM+1	; CHECK RANGE
  1516 00:A833: 85 5E        	sta	INDEX
  1517 00:A835: C9 19        	cmp	#>6400		; LINE # TOO LARGE?
  1518 00:A837: B0 D4        	bcs	ON1		; YES, > 63999, GO INDIRECTLY TO "SYNTAX ERROR".
  1519 00:A839: A5 50        	lda	LINNUM		; MULTIPLY BY TEN
  1520 00:A83B: 0A           	asl	a
  1521 00:A83C: 26 5E        	rol	INDEX
  1522 00:A83E: 0A           	asl	a
  1523 00:A83F: 26 5E        	rol	INDEX
  1524 00:A841: 65 50        	adc	LINNUM
  1525 00:A843: 85 50        	sta	LINNUM
  1526 00:A845: A5 5E        	lda	INDEX
  1527 00:A847: 65 51        	adc	LINNUM+1
  1528 00:A849: 85 51        	sta	LINNUM+1
  1529 00:A84B: 06 50        	asl	LINNUM
  1530 00:A84D: 26 51        	rol	LINNUM+1
  1531 00:A84F: A5 50        	lda	LINNUM
  1532 00:A851: 65 0D        	adc	CHARAC		; ADD DIGIT
  1533 00:A853: 85 50        	sta	LINNUM
  1534 00:A855: 90 02        	bcc	LING2
  1535 00:A857: E6 51        	inc	LINNUM+1
  1536 00:A859: 20 B1 00     LING2:	jsr	CHRGET		; GET NEXT CHAR
  1537 00:A85C: 4C 2B A8     	jmp	LING1		; MORE CONVERTING
  1538                        
  1539                        
  1540                        ; ----------------------------------------------------------------------------
  1541                        ; "LET" STATEMENT
  1542                        ;
  1543                        ; LET <VAR> = <EXP>
  1544                        ; <VAR> = <EXP>
  1545                        ; ----------------------------------------------------------------------------
  1546 00:A85F: 20 89 AD     LET:	jsr	PTRGET		; GET <VAR>
  1547 00:A862: 85 85        	sta	FORPNT
  1548 00:A864: 84 86        	sty	FORPNT+1
  1549 00:A866: A9 AF        	lda	#TOKEN_EQUAL
  1550 00:A868: 20 86 AC     	jsr	SYNCHR
  1551 00:A86B: A5 12        	lda	VALTYP+1	; SAVE VARIABLE TYPE
  1552 00:A86D: 48           	pha
  1553 00:A86E: A5 11        	lda	VALTYP
  1554 00:A870: 48           	pha
  1555 00:A871: 20 48 AB     	jsr	FRMEVL		; EVALUATE <EXP>
  1556 00:A874: 68           	pla
  1557 00:A875: 2A           	rol	a
  1558 00:A876: 20 3A AB     	jsr	CHKVAL
  1559 00:A879: D0 18        	bne	LETSTRING
  1560 00:A87B: 68           	pla
  1561                        ; ----------------------------------------------------------------------------
  1562 00:A87C: 10 12        LET2:	bpl	LET21		; REAL VARIABLE
  1563 00:A87E: 20 34 B8     	jsr	ROUND_FAC	; INTEGER VAR: ROUND TO 32 BITS
  1564 00:A881: 20 A8 AE     	jsr	AYINT		; TRUNCATE TO 16-BITS
  1565 00:A884: A0 00        	ldy	#0
  1566 00:A886: A5 A0        	lda	FAC+3
  1567 00:A888: 91 85        	sta	(FORPNT),y
  1568 00:A88A: C8           	iny
  1569 00:A88B: A5 A1        	lda	FAC+4
  1570 00:A88D: 91 85        	sta	(FORPNT),y
  1571 00:A88F: 60           	rts
  1572                        
  1573                        
  1574                        ; ----------------------------------------------------------------------------
  1575                        ; REAL VARIABLE = EXPRESSION
  1576                        ; ----------------------------------------------------------------------------
  1577 00:A890: 4C E9 B7     LET21:	jmp	SETFOR
  1578                        ; ----------------------------------------------------------------------------
  1579                        LETSTRING:
  1580 00:A893: 68           	pla
  1581                        
  1582                        
  1583                        ; ----------------------------------------------------------------------------
  1584                        ; INSTALL STRING, DESCRIPTOR ADDRESS IS AT FAC+3,4
  1585                        ; ----------------------------------------------------------------------------
  1586 00:A894: A0 02        PUTSTR:	ldy	#2		; STRING DATA ALREADY IN STRING AREA?
  1587 00:A896: B1 A0        	lda	(FAC+3),y	; (STRING AREA IS BTWN FRETOP
  1588 00:A898: C5 70        	cmp	FRETOP+1	; 	HIMEM)
  1589 00:A89A: 90 17        	bcc	PUTST2		; YES, DATA ALREADY UP THERE
  1590 00:A89C: D0 07        	bne	PUTST1		; NO
  1591 00:A89E: 88           	dey			; MAYBE, TEST LOW BYTE OF POINTER
  1592 00:A89F: B1 A0        	lda	(FAC+3),y
  1593 00:A8A1: C5 6F        	cmp	FRETOP
  1594 00:A8A3: 90 0E        	bcc	PUTST2		; YES, ALREADY THERE
  1595 00:A8A5: A4 A1        PUTST1:	ldy	FAC+4		; NO. DESCRIPTOR ALREADY AMONG VARIABLES?
  1596 00:A8A7: C4 6A        	cpy	VARTAB+1
  1597 00:A8A9: 90 08        	bcc	PUTST2		; NO
  1598 00:A8AB: D0 0D        	bne	PUTST3		; YES
  1599 00:A8AD: A5 A0        	lda	FAC+3		; MAYBE, COMPARE LO-BYTE
  1600 00:A8AF: C5 69        	cmp	VARTAB
  1601 00:A8B1: B0 07        	bcs	PUTST3		; YES, DESCRIPTOR IS AMONG VARIABLES
  1602 00:A8B3: A5 A0        PUTST2:	lda	FAC+3		; EITHER STRING ALREADY ON TOP, OR
  1603 00:A8B5: A4 A1        	ldy	FAC+4		; DESCRIPTOR IS NOT A VARIABLE
  1604 00:A8B7: 4C D0 A8     	jmp	PUTST4		; SO JUST STORE THE DESCRIPTOR
  1605                        ; ----------------------------------------------------------------------------
  1606                        ; STRING NOT YET IN STRING AREA,
  1607                        ; AND DESCRIPTOR IS A VARIABLE
  1608                        ; ----------------------------------------------------------------------------
  1609 00:A8BA: A0 00        PUTST3:	ldy	#0		; POINT AT LENGTH IN DESCRIPTOR
  1610 00:A8BC: B1 A0        	lda	(FAC+3),y	; GET LENGTH
  1611 00:A8BE: 20 B8 B0     	jsr	STRINI		; MAKE A STRING THAT LONG UP ABOVE
  1612 00:A8C1: A5 8C        	lda	DSCPTR		; SET UP SOURCE PNTR FOR MONINS
  1613 00:A8C3: A4 8D        	ldy	DSCPTR+1
  1614 00:A8C5: 85 AB        	sta	STRNG1
  1615 00:A8C7: 84 AC        	sty	STRNG1+1
  1616 00:A8C9: 20 B7 B2     	jsr	MOVINS		; MOVE STRING DATA TO NEW AREA
  1617 00:A8CC: A9 9D        	lda	#<FAC		; ADDRESS OF DESCRIPTOR IS IN FAC
  1618 00:A8CE: A0 00        	ldy	#>FAC
  1619 00:A8D0: 85 8C        PUTST4:	sta	DSCPTR
  1620 00:A8D2: 84 8D        	sty	DSCPTR+1
  1621 00:A8D4: 20 18 B3     	jsr	FRETMS		; DISCARD DESCRIPTOR IF 'TWAS TEMPORARY
  1622 00:A8D7: A0 00        	ldy	#0		; COPY STRING DESCRIPTOR
  1623 00:A8D9: B1 8C        	lda	(DSCPTR),y
  1624 00:A8DB: 91 85        	sta	(FORPNT),y
  1625 00:A8DD: C8           	iny
  1626 00:A8DE: B1 8C        	lda	(DSCPTR),y
  1627 00:A8E0: 91 85        	sta	(FORPNT),y
  1628 00:A8E2: C8           	iny
  1629 00:A8E3: B1 8C        	lda	(DSCPTR),y
  1630 00:A8E5: 91 85        	sta	(FORPNT),y
  1631 00:A8E7: 60           RTS8:	rts
  1632                        
  1633                        
  1634                        ; ----------------------------------------------------------------------------
  1635                        PRSTRING:
  1636 00:A8E8: 20 2E A9     	jsr	STRPRT
  1637 00:A8EB: 20 B7 00     	jsr	CHRGOT
  1638                        
  1639                        
  1640                        ; ----------------------------------------------------------------------------
  1641                        ; "PRINT" STATEMENT
  1642                        ; ----------------------------------------------------------------------------
  1643 00:A8EE: F0 1F        PRINT:	beq	GOCR		; NO MORE LIST, PRINT <RETURN>
  1644                        ; ----------------------------------------------------------------------------
  1645 00:A8F0: F0 F5        PRINT2: beq	RTS8		; NO MORE LIST, DON'T PRINT <RETURN>
  1646 00:A8F2: C9 A3        	cmp	#TOKEN_SPC
  1647 00:A8F4: 18           	clc
  1648 00:A8F5: F0 1B        	beq	PR_TAB_OR_SPC	; C=0 FOR SPC(
  1649 00:A8F7: C9 2C        	cmp	#','
  1650 00:A8F9: F0 25        	beq	PR_NEXT_CHAR
  1651 00:A8FB: C9 3B        	cmp	#';'
  1652 00:A8FD: F0 21        	beq	PR_NEXT_CHAR
  1653 00:A8FF: 20 48 AB     	jsr	FRMEVL		; EVALUATE EXPRESSION
  1654 00:A902: 24 11        	bit	VALTYP		; STRING OR FP VALUE?
  1655 00:A904: 30 E2        	bmi	PRSTRING	; STRING
  1656 00:A906: 20 F1 B9     	jsr	FOUT		; FP: CONVERT INTO BUFFER
  1657 00:A909: 20 CA B0     	jsr	STRLIT		; 	MAKE BUFFER INTO STRING
  1658 00:A90C: 4C E8 A8     	jmp	PRSTRING	; 	PRINT THE STRING
  1659                        ; ----------------------------------------------------------------------------
  1660 00:A90F: 4C 46 BE     GOCR:	jmp	CRDO
  1661                        
  1662                        ; ----------------------------------------------------------------------------
  1663                        PR_TAB_OR_SPC:
  1664 00:A912: 20 D8 B3     	jsr	GTBYTC		; GET VALUE
  1665 00:A915: C9 29        	cmp	#')'		; TRAILING PARENTHESIS
  1666 00:A917: F0 03        	beq	PR_TAB_2		; GOOD
  1667 00:A919: 4C 8F AC     	jmp	SYNERR		; NO, SYNTAX ERROR
  1668                        PR_TAB_2:
  1669 00:A91C: E8           	inx
  1670 00:A91D: CA           NXSPC:  dex
  1671 00:A91E: D0 06        	bne	DOSPC		; MORE SPACES TO PRINT
  1672                        ; ----------------------------------------------------------------------------
  1673                        PR_NEXT_CHAR:
  1674 00:A920: 20 B1 00     	jsr	CHRGET
  1675 00:A923: 4C F0 A8     	jmp	PRINT2		; CONTINUE PARSING PRINT LIST
  1676                        ; ----------------------------------------------------------------------------
  1677 00:A926: 20 3E BE     DOSPC:	jsr	OUTSP
  1678 00:A929: D0 F2        	bne	NXSPC		; ...ALWAYS
  1679                        
  1680                        
  1681                        ; ----------------------------------------------------------------------------
  1682                        ; PRINT STRING AT (Y,A)
  1683                        ; ----------------------------------------------------------------------------
  1684 00:A92B: 20 CA B0     STROUT:	jsr	STRLIT		; MAKE (Y,A) PRINTABLE
  1685                        
  1686                        
  1687                        ; ----------------------------------------------------------------------------
  1688                        ; PRINT STRING AT (FACMO,FACLO)
  1689                        ; ----------------------------------------------------------------------------
  1690 00:A92E: 20 E3 B2     STRPRT:	jsr	FREFAC		; GET ADDRESS INTO INDEX, (A)=LENGTH
  1691 00:A931: AA           	tax			; USE X-REG FOR COUNTER
  1692 00:A932: A0 00        	ldy	#0		; USE Y-REG FOR SCANNER
  1693 00:A934: E8           	inx
  1694 00:A935: CA           STRP1:	dex
  1695 00:A936: F0 AF        	beq	RTS8		; FINISHED
  1696 00:A938: B1 5E        	lda	(INDEX),y	; NEXT CHAR FROM STRING
  1697 00:A93A: 20 4D BE     	jsr	OUTDO		; PRINT THE CHAR
  1698 00:A93D: C8           	iny
  1699 00:A93E: 4C 35 A9     	jmp	STRP1
  1700                        
  1701                        
  1702                        ; ----------------------------------------------------------------------------
  1703                        ; INPUT CONVERSION ERROR:  ILLEGAL CHARACTER
  1704                        ; IN NUMERIC FIELD.  MUST DISTINGUISH
  1705                        ; BETWEEN INPUT, READ, AND GET
  1706                        ; ----------------------------------------------------------------------------
  1707                        INPUTERR:
  1708 00:A941: A5 15        	lda	INPUTFLG
  1709 00:A943: F0 12        	beq	RESPERR		; TAKEN IF INPUT
  1710 00:A945: 30 04        	bmi	READERR		; TAKEN IF READ
  1711 00:A947: A0 FF        	ldy	#$FF		; FROM A GET
  1712 00:A949: D0 04        	bne	ERLIN		;  ...ALWAYS
  1713                        ; ----------------------------------------------------------------------------
  1714                        READERR:
  1715 00:A94B: A5 7B        	lda	DATLIN		; TELL WHERE THE "DATA" IS, RATHER
  1716 00:A94D: A4 7C        	ldy	DATLIN+1	; THAN THE "READ"
  1717                        ; ----------------------------------------------------------------------------
  1718 00:A94F: 85 75        ERLIN:	sta	CURLIN
  1719 00:A951: 84 76        	sty	CURLIN+1
  1720 00:A953: 4C 8F AC     	jmp	SYNERR
  1721                        ; ----------------------------------------------------------------------------
  1722 00:A956: 68           INPERR:	pla
  1723                        ; ----------------------------------------------------------------------------
  1724                        RESPERR:
  1725 00:A957: 24 D8        	bit	ERRFLG		; "ON ERR" TURNED ON?
  1726 00:A959: 10 05        	bpl	RESPE1		; NO, GIVE REENTRY A TRY
  1727 00:A95B: A2 FE        	ldx	#254		; ERROR CODE = 254
  1728 00:A95D: 4C B6 BD     	jmp	HANDLERR
  1729 00:A960: A9 BC        RESPE1:	lda	#<ERRREENTRY	; "?REENTER"
  1730 00:A962: A0 AA        	ldy	#>ERRREENTRY
  1731 00:A964: 20 2B A9     	jsr	STROUT
  1732 00:A967: A5 79        	lda	OLDTEXT		; RE-EXECUTE THE WHOLE INPUT STATEMENT
  1733 00:A969: A4 7A        	ldy	OLDTEXT+1
  1734 00:A96B: 85 B8        	sta	TXTPTR
  1735 00:A96D: 84 B9        	sty	TXTPTR+1
  1736 00:A96F: 60           	rts
  1737                        
  1738                        
  1739                        ; ----------------------------------------------------------------------------
  1740                        ; "GET" STATEMENT
  1741                        ; ----------------------------------------------------------------------------
  1742 00:A970: 20 9E B0     GET:	jsr	ERRDIR		; ILLEGAL IF IN DIRECT MODE
  1743 00:A973: A2 01        	ldx	#<(INPUTBUFFER+1)	; SIMULATE INPUT
  1744 00:A975: A0 02        	ldy	#>(INPUTBUFFER+1)
  1745 00:A977: A9 00        	lda	#0
  1746 00:A979: 8D 01 02     	sta	INPUTBUFFER+1
  1747 00:A97C: A9 40        	lda	#$40		; SET UP INPUTFLG
  1748 00:A97E: 4C BA A9     	jmp	PROCESS_INPUT_LIST
  1749                        
  1750                        
  1751                        ; ----------------------------------------------------------------------------
  1752                        ; "INPUT" STATEMENT
  1753                        ; ----------------------------------------------------------------------------
  1754 00:A981: C9 22        INPUT:	cmp	#'"'		; CHECK FOR OPTIONAL PROMPT STRING
  1755 00:A983: D0 0E        	bne	INPU_1		; NO, PRINT "?" PROMPT
  1756 00:A985: 20 4E AC     	jsr	STRTXT		; MAKE A PRINTABLE STRING OUT OF IT
  1757 00:A988: A9 3B        	lda	#';'		; MUST HAVE ; NOW
  1758 00:A98A: 20 86 AC     	jsr	SYNCHR
  1759 00:A98D: 20 2E A9     	jsr	STRPRT		; PRINT THE STRING
  1760 00:A990: 4C 96 A9     	jmp	INPU_2
  1761 00:A993: 20 42 BE     INPU_1:	jsr	OUTQUES		; NO STRING, PRINT "?"
  1762 00:A996: 20 9E B0     INPU_2:	jsr	ERRDIR		; ILLEGAL IF IN DIRECT MODE
  1763 00:A999: A9 2C        	lda	#','		; PRIME THE BUFFER
  1764 00:A99B: 8D FF 01     	sta	INPUTBUFFER-1
  1765 00:A99E: 20 F4 A3     	jsr	INLIN
  1766 00:A9A1: AD 00 02     	lda	INPUTBUFFER
  1767 00:A9A4: C9 03        	cmp	#$03		; CONTROL C?
  1768 00:A9A6: D0 10        	bne	INPUTFLAGZERO	; NO
  1769 00:A9A8: 4C DE A6     	jmp	CONTROL_C_TYPED
  1770                        ; ----------------------------------------------------------------------------
  1771 00:A9AB: 20 42 BE     NXIN:	jsr	OUTQUES		; PRINT "?"
  1772 00:A9AE: 4C F4 A3     	jmp	INLIN
  1773                        
  1774                        
  1775                        ; ----------------------------------------------------------------------------
  1776                        ; "READ" STATEMENT
  1777                        ; ----------------------------------------------------------------------------
  1778 00:A9B1: A6 7D        READ:	ldx	DATPTR		; Y,X POINTS AT NEXT DATA STATEMENT
  1779 00:A9B3: A4 7E        	ldy	DATPTR+1
  1780 00:A9B5: A9 98        	lda	#$98		; SET INPUTFLG = $98
  1781 00:A9B7: 2C           	db	$2C		; TRICK TO PROCESS_INPUT_LIST
  1782                        ; ----------------------------------------------------------------------------
  1783                        INPUTFLAGZERO:
  1784 00:A9B8: A9 00        	lda	#0		; SET INPUTFLG = $00
  1785                        
  1786                        
  1787                        ; ----------------------------------------------------------------------------
  1788                        ; PROCESS INPUT LIST
  1789                        ;
  1790                        ; (Y,X) IS ADDRESS OF INPUT DATA STRING
  1791                        ; (A) = VALUE FOR INPUTFLG:  $00 FOR INPUT
  1792                        ; 				$40 FOR GET
  1793                        ;				$98 FOR READ
  1794                        ; ----------------------------------------------------------------------------
  1795                        PROCESS_INPUT_LIST:
  1796 00:A9BA: 85 15        	sta	INPUTFLG
  1797 00:A9BC: 86 7F        	stx	INPTR		; ADDRESS OF INPUT STRING
  1798 00:A9BE: 84 80        	sty	INPTR+1
  1799                        
  1800                        ; ----------------------------------------------------------------------------
  1801                        PROCESS_INPUT_ITEM:
  1802 00:A9C0: 20 89 AD     	jsr	PTRGET		; GET ADDRESS OF VARIABLE
  1803 00:A9C3: 85 85        	sta	FORPNT
  1804 00:A9C5: 84 86        	sty	FORPNT+1
  1805 00:A9C7: A5 B8        	lda	TXTPTR		; SAVE CURRENT TXTPTR,
  1806 00:A9C9: A4 B9        	ldy	TXTPTR+1	; WHICH POINTS INTO PROGRAM
  1807 00:A9CB: 85 87        	sta	TXPSV
  1808 00:A9CD: 84 88        	sty	TXPSV+1
  1809 00:A9CF: A6 7F        	ldx	INPTR		; SET TXTPTR TO POINT AT INPUT BUFFER
  1810 00:A9D1: A4 80        	ldy	INPTR+1		; OR "DATA" LINE
  1811 00:A9D3: 86 B8        	stx	TXTPTR
  1812 00:A9D5: 84 B9        	sty	TXTPTR+1
  1813 00:A9D7: 20 B7 00     	jsr	CHRGOT		; GET CHAR AT PNTR
  1814 00:A9DA: D0 1C        	bne	INSTART		; NOT END OF LINE OR COLON
  1815 00:A9DC: 24 15        	bit	INPUTFLG	; DOING A "GET"?
  1816 00:A9DE: 50 0C        	bvc	PROCE1		; NO
  1817 00:A9E0: 20 FB BD     	jsr	RDKEY		; YES, GET CHAR
  1818 00:A9E3: 8D 00 02     	sta	INPUTBUFFER
  1819 00:A9E6: A2 FF        	ldx	#<(INPUTBUFFER-1)
  1820 00:A9E8: A0 01        	ldy	#>(INPUTBUFFER-1)
  1821 00:A9EA: D0 08        	bne	PROCE2		; ...ALWAYS
  1822                        ; ----------------------------------------------------------------------------
  1823 00:A9EC: 30 7F        PROCE1:	bmi	FINDATA		; DOING A "READ"
  1824 00:A9EE: 20 42 BE     	jsr	OUTQUES		; DOING AN "INPUT", PRINT "?"
  1825 00:A9F1: 20 AB A9     	jsr	NXIN		; PRINT ANOTHER "?", AND INPUT A LINE
  1826 00:A9F4: 86 B8        PROCE2:	stx	TXTPTR
  1827 00:A9F6: 84 B9        	sty	TXTPTR+1
  1828                        
  1829                        ; ----------------------------------------------------------------------------
  1830                        INSTART:
  1831 00:A9F8: 20 B1 00     	jsr	CHRGET		; GET NEXT INPUT CHAR
  1832 00:A9FB: 24 11        	bit	VALTYP		; STRING OR NUMERIC?
  1833 00:A9FD: 10 31        	bpl	INSTA5		; NUMERIC
  1834 00:A9FF: 24 15        	bit	INPUTFLG	; STRING -- NOW WHAT INPUT TYPE?
  1835 00:AA01: 50 09        	bvc	INSTA1		; NOT A "GET"
  1836 00:AA03: E8           	inx			; "GET"
  1837 00:AA04: 86 B8        	stx	TXTPTR
  1838 00:AA06: A9 00        	lda	#0
  1839 00:AA08: 85 0D        	sta	CHARAC		; NO OTHER TERMINATORS THAN $00
  1840 00:AA0A: F0 0C        	beq	INSTA2		; ...ALWAYS
  1841                        ; ----------------------------------------------------------------------------
  1842 00:AA0C: 85 0D        INSTA1:	sta	CHARAC
  1843 00:AA0E: C9 22        	cmp	#'"'		; TERMINATE ON $00 OR QUOTE
  1844 00:AA10: F0 07        	beq	INSTA3
  1845 00:AA12: A9 3A        	lda	#':'		; TERMINATE ON $00, COLON, OR COMMA
  1846 00:AA14: 85 0D        	sta	CHARAC
  1847 00:AA16: A9 2C        	lda	#','
  1848 00:AA18: 18           INSTA2:	clc
  1849 00:AA19: 85 0E        INSTA3:	sta	ENDCHR
  1850 00:AA1B: A5 B8        	lda	TXTPTR
  1851 00:AA1D: A4 B9        	ldy	TXTPTR+1
  1852 00:AA1F: 69 00        	adc	#0		; SKIP OVER QUOTATION MARK, IF
  1853 00:AA21: 90 01        	bcc	INSTA4		;    THERE WAS ONE
  1854 00:AA23: C8           	iny
  1855 00:AA24: 20 D0 B0     INSTA4:	jsr	STRLT2		; BUILD STRING STARTING AT (Y,A) TERMINATED BY $00, (CHARAC), OR (EN
                    DCHR)
  1856 00:AA27: 20 20 B4     	jsr	POINT		; SET TXTPTR TO POINT AT STRING
  1857 00:AA2A: 20 94 A8     	jsr	PUTSTR		; STORE STRING IN VARIABLE
  1858 00:AA2D: 4C 3F AA     	jmp	INPUT_MORE
  1859                        ; ----------------------------------------------------------------------------
  1860 00:AA30: 48           INSTA5:	pha
  1861 00:AA31: AD 00 02     	lda	INPUTBUFFER	; ANYTHING IN BUFFER?
  1862 00:AA34: F0 30        	beq	INPFIN		; NO, SEE IF READ OR INPUT
  1863                        
  1864                        ; ----------------------------------------------------------------------------
  1865                        INPUT_DATA:
  1866 00:AA36: 68           	pla			; "READ"
  1867 00:AA37: 20 09 B9     	jsr	FIN		; GET FP NUMBER AT TXTPTR
  1868 00:AA3A: A5 12        	lda	VALTYP+1
  1869 00:AA3C: 20 7C A8     	jsr	LET2		; STORE RESULT IN VARIABLE
  1870                        
  1871                        ; ----------------------------------------------------------------------------
  1872                        INPUT_MORE:
  1873 00:AA3F: 20 B7 00     	jsr	CHRGOT
  1874 00:AA42: F0 07        	beq	INPUT_M1		; END OF LINE OR COLON
  1875 00:AA44: C9 2C        	cmp	#','		; COMMA IN INPUT?
  1876 00:AA46: F0 03        	beq	INPUT_M1		; YES
  1877 00:AA48: 4C 41 A9     	jmp	INPUTERR	; NOTHING ELSE WILL DO
  1878                        INPUT_M1:
  1879 00:AA4B: A5 B8        	lda	TXTPTR		; SAVE POSITION IN INPUT BUFFER
  1880 00:AA4D: A4 B9        	ldy	TXTPTR+1
  1881 00:AA4F: 85 7F        	sta	INPTR
  1882 00:AA51: 84 80        	sty	INPTR+1
  1883 00:AA53: A5 87        	lda	TXPSV		; RESTORE PROGRAM POINTER
  1884 00:AA55: A4 88        	ldy	TXPSV+1
  1885 00:AA57: 85 B8        	sta	TXTPTR
  1886 00:AA59: 84 B9        	sty	TXTPTR+1
  1887 00:AA5B: 20 B7 00     	jsr	CHRGOT		; NEXT CHAR FROM PROGRAM
  1888 00:AA5E: F0 33        	beq	INPDONE		; END OF STATEMENT
  1889 00:AA60: 20 84 AC     	jsr	CHKCOM		; BETTER BE A COMMA THEN
  1890 00:AA63: 4C C0 A9     	jmp	PROCESS_INPUT_ITEM
  1891                        
  1892                        ; ----------------------------------------------------------------------------
  1893 00:AA66: A5 15        INPFIN:	lda	INPUTFLG	; "INPUT" OR "READ"
  1894 00:AA68: D0 CC        	bne	INPUT_DATA	; "READ"
  1895 00:AA6A: 4C 56 A9     	jmp	INPERR
  1896                        
  1897                        ; ----------------------------------------------------------------------------
  1898                        FINDATA:
  1899 00:AA6D: 20 BC A7     	jsr	DATAN		; GET OFFSET TO NEXT COLON OR EOL
  1900 00:AA70: C8           	iny			; TO FIRST CHAR OF NEXT LINE
  1901 00:AA71: AA           	tax			; WHICH:  EOL OR COLON?
  1902 00:AA72: D0 12        	bne	FINDA1		; COLON
  1903 00:AA74: A2 14        	ldx	#ERR_NODATA	; EOL: MIGHT BE OUT OF DATA
  1904 00:AA76: C8           	iny			; CHECK HI-BYTE OF FORWARD PNTR
  1905 00:AA77: B1 B8        	lda	(TXTPTR),y	; END OF PROGRAM?
  1906 00:AA79: F0 5F        	beq	GERR		; YES, WE ARE OUT OF DATA
  1907 00:AA7B: C8           	iny			; PICK UP THE LINE #
  1908 00:AA7C: B1 B8        	lda	(TXTPTR),y
  1909 00:AA7E: 85 7B        	sta	DATLIN
  1910 00:AA80: C8           	iny
  1911 00:AA81: B1 B8        	lda	(TXTPTR),y
  1912 00:AA83: C8           	iny			; POINT AT FIRST TEXT CHAR IN LINE
  1913 00:AA84: 85 7C        	sta	DATLIN+1
  1914 00:AA86: B1 B8        FINDA1:	lda	(TXTPTR),y	; GET 1ST TOKEN OF STATEMENT
  1915 00:AA88: AA           	tax			; SAVE TOKEN IN X-REG
  1916 00:AA89: 20 B1 A7     	jsr	ADDON		; ADD (Y) TO TXTPTR
  1917 00:AA8C: E0 83        	cpx	#TOKEN_DATA	; DID WE FIND A "DATA" STATEMENT?
  1918 00:AA8E: D0 DD        	bne	FINDATA		; NOT YET
  1919 00:AA90: 4C F8 A9     	jmp	INSTART		; YES, READ IT
  1920                        ; ---NO MORE INPUT REQUESTED------
  1921                        INPDONE:
  1922 00:AA93: A5 7F        	lda	INPTR		; GET POINTER IN CASE IT WAS "READ"
  1923 00:AA95: A4 80        	ldy	INPTR+1
  1924 00:AA97: A6 15        	ldx	INPUTFLG	; "READ" OR "INPUT"?
  1925 00:AA99: 10 03        	bpl	INPD1		; "INPUT"
  1926 00:AA9B: 4C CB A6     	jmp	SETDA		; "DATA", SO STORE (Y,X) AT DATPTR
  1927 00:AA9E: A0 00        INPD1:	ldy	#0		; "INPUT":  ANY MORE CHARS ON LINE?
  1928 00:AAA0: B1 7F        	lda	(INPTR),y
  1929 00:AAA2: F0 07        	beq	INPD2		; NO, ALL IS WELL
  1930 00:AAA4: A9 AC        	lda	#<ERREXTRA	; YES, ERROR
  1931 00:AAA6: A0 AA        	ldy	#>ERREXTRA	; "EXTRA IGNORED"
  1932 00:AAA8: 4C 2B A9     	jmp	STROUT
  1933 00:AAAB: 60           INPD2:	rts
  1934                        
  1935                        ; ----------------------------------------------------------------------------
  1936                        ERREXTRA:
  1937 00:AAAC: 3F 45 58 54  	db	"?EXTRA IGNORED",$0D,$00
       00:AAB0: 52 41 20 49 
       00:AAB4: 47 4E 4F 52 
       00:AAB8: 45 44 0D 00 
  1938                        ERRREENTRY:
  1939 00:AABC: 3F 52 45 45  	db	"?REENTER",$0D,$00
       00:AAC0: 4E 54 45 52 
       00:AAC4: 0D 00 
  1940                        
  1941                        
  1942                        ; ----------------------------------------------------------------------------
  1943                        ; "NEXT" STATEMENT
  1944                        ; ----------------------------------------------------------------------------
  1945 00:AAC6: D0 04        NEXT:	bne	NEXT1		; VARIABLE AFTER "NEXT"
  1946 00:AAC8: A0 00        	ldy	#0		; FLAG BY SETTING FORPNT+1 = 0
  1947 00:AACA: F0 03        	beq	NEXT2		; ...ALWAYS
  1948                        ; ----------------------------------------------------------------------------
  1949 00:AACC: 20 89 AD     NEXT1:	jsr	PTRGET		; GET PNTR TO VARIABLE IN (Y,A)
  1950 00:AACF: 85 85        NEXT2:	sta	FORPNT
  1951 00:AAD1: 84 86        	sty	FORPNT+1
  1952 00:AAD3: 20 2D A2     	jsr	GTFORPNT	; FIND FOR-FRAME FOR THIS VARIABLE
  1953 00:AAD6: F0 04        	beq	NEXT3		; FOUND IT
  1954 00:AAD8: A2 00        	ldx	#ERR_NOFOR	; NOT THERE, ABORT
  1955 00:AADA: F0 69        GERR:	beq	JERROR		; ...ALWAYS
  1956 00:AADC: 9A           NEXT3:	txs			; SET STACK PTR TO POINT TO THIS FRAME,
  1957 00:AADD: E8           	inx			;    WHICH TRIMS OFF ANY INNER LOOPS
  1958 00:AADE: E8           	inx
  1959 00:AADF: E8           	inx
  1960 00:AAE0: E8           	inx
  1961 00:AAE1: 8A           	txa			; LOW BYTE OF ADRS OF STEP VALUE
  1962 00:AAE2: E8           	inx
  1963 00:AAE3: E8           	inx
  1964 00:AAE4: E8           	inx
  1965 00:AAE5: E8           	inx
  1966 00:AAE6: E8           	inx
  1967 00:AAE7: E8           	inx
  1968 00:AAE8: 86 60        	stx	DEST		; LOW BYTE ADRS OF FOR VAR VALUE
  1969 00:AAEA: A0 01        	ldy	#>STACK		; (Y,A) IS ADDRESS OF STEP VALUE
  1970 00:AAEC: 20 BB B7     	jsr	LOAD_FAC_FROM_YA	; STEP TO FAC
  1971 00:AAEF: BA           	tsx
  1972 00:AAF0: BD 09 01     	lda	STACK+9,x
  1973 00:AAF3: 85 A2        	sta	FACSIGN
  1974 00:AAF5: A5 85        	lda	FORPNT
  1975 00:AAF7: A4 86        	ldy	FORPNT+1
  1976 00:AAF9: 20 85 B4     	jsr	FADD		; ADD TO FOR VALUE
  1977 00:AAFC: 20 E9 B7     	jsr	SETFOR		; PUT NEW VALUE BACK
  1978 00:AAFF: A0 01        	ldy	#>STACK		; (Y,A) IS ADDRESS OF END VALUE
  1979 00:AB01: 20 76 B8     	jsr	FCOMP2		; COMPARE TO END VALUE
  1980 00:AB04: BA           	tsx
  1981 00:AB05: 38           	sec
  1982 00:AB06: FD 09 01     	sbc	STACK+9,x	; SIGN OF STEP
  1983 00:AB09: F0 17        	beq	NEXT32		; BRANCH IF FOR COMPLETE
  1984 00:AB0B: BD 0F 01     	lda	STACK+15,x	; OTHERWISE SET UP
  1985 00:AB0E: 85 75        	sta	CURLIN		; FOR LINE #
  1986 00:AB10: BD 10 01     	lda	STACK+16,x
  1987 00:AB13: 85 76        	sta	CURLIN+1
  1988 00:AB15: BD 12 01     	lda	STACK+18,x	; AND SET TXTPTR TO JUST
  1989 00:AB18: 85 B8        	sta	TXTPTR		; AFTER FOR STATEMENT
  1990 00:AB1A: BD 11 01     	lda	STACK+17,x
  1991 00:AB1D: 85 B9        	sta	TXTPTR+1
  1992 00:AB1F: 4C 62 A6     NEXT31:	jmp	NEWSTT
  1993 00:AB22: 8A           NEXT32:	txa			; POP OFF FOR-FRAME, LOOP IS DONE
  1994 00:AB23: 69 11        	adc	#17		; CARRY IS SET, SO ADDS 18
  1995 00:AB25: AA           	tax
  1996 00:AB26: 9A           	txs
  1997 00:AB27: 20 B7 00     	jsr	CHRGOT		; CHAR AFTER VARIABLE
  1998 00:AB2A: C9 2C        	cmp	#','		; ANOTHER VARIABLE IN NEXT?
  1999 00:AB2C: D0 F1        	bne	NEXT31		; NO, GO TO NEXT STATEMENT
  2000 00:AB2E: 20 B1 00     	jsr	CHRGET		; YES, PRIME FOR NEXT VARIABLE
  2001 00:AB31: 20 CC AA     	jsr	NEXT1		; (DOES NOT RETURN)
  2002                        
  2003                        
  2004                        ; ----------------------------------------------------------------------------
  2005                        ; EVALUATE EXPRESSION, MAKE SURE IT IS NUMERIC
  2006                        ; ----------------------------------------------------------------------------
  2007 00:AB34: 20 48 AB     FRMNUM:	jsr	FRMEVL
  2008                        
  2009                        
  2010                        ; ----------------------------------------------------------------------------
  2011                        ; MAKE SURE (FAC) IS NUMERIC
  2012                        ; ----------------------------------------------------------------------------
  2013 00:AB37: 18           CHKNUM:	clc
  2014 00:AB38: 24           	db	$24		; DUMMY FOR SKIP
  2015                        
  2016                        
  2017                        ; ----------------------------------------------------------------------------
  2018                        ; MAKE SURE (FAC) IS STRING
  2019                        ; ----------------------------------------------------------------------------
  2020 00:AB39: 38           CHKSTR:	sec
  2021                        
  2022                        
  2023                        ; ----------------------------------------------------------------------------
  2024                        ; MAKE SURE (FAC) IS CORRECT TYPE
  2025                        ; IF C=0, TYPE MUST BE NUMERIC
  2026                        ; IF C=1, TYPE MUST BE STRING
  2027                        ; ----------------------------------------------------------------------------
  2028 00:AB3A: 24 11        CHKVAL:	bit     VALTYP		; $00 IF NUMERIC, $FF IF STRING
  2029 00:AB3C: 30 03        	bmi     CHKVAL2		; TYPE IS STRING
  2030 00:AB3E: B0 03        	bcs     CHKVAL3		; NOT STRING, BUT WE NEED STRING
  2031                        CHKVAL1:
  2032 00:AB40: 60           	rts			; TYPE IS CORRECT
  2033                        CHKVAL2:
  2034 00:AB41: B0 FD        	bcs     CHKVAL1		; IS STRING AND WE WANTED STRING
  2035                        CHKVAL3:
  2036 00:AB43: A2 65        	ldx     #ERR_BADTYPE	; TYPE MISMATCH
  2037 00:AB45: 4C DA A2     JERROR: jmp     ERROR
  2038                        
  2039                        
  2040                        ; ----------------------------------------------------------------------------
  2041                        ; EVALUATE THE EXPRESSION AT TXTPTR, LEAVING THE
  2042                        ; RESULT IN FAC.  WORKS FOR BOTH STRING AND NUMERIC
  2043                        ; EXPRESSIONS.
  2044                        ; ----------------------------------------------------------------------------
  2045 00:AB48: A6 B8        FRMEVL:	ldx	TXTPTR		; DECREMENT TXTPTR
  2046 00:AB4A: D0 02        	bne	FRMEVL11
  2047 00:AB4C: C6 B9        	dec	TXTPTR+1
  2048                        FRMEVL11:
  2049 00:AB4E: C6 B8        	dec	TXTPTR
  2050 00:AB50: A2 00        	ldx	#0		; START WITH PRECEDENCE = 0
  2051 00:AB52: 24           	db	$24		; TRICK TO SKIP FOLLOWING "PHA"
  2052                        ; ----------------------------------------------------------------------------
  2053                        FRMEVL1:
  2054 00:AB53: 48           	pha			; PUSH RELOPS FLAGS
  2055 00:AB54: 8A           	txa
  2056 00:AB55: 48           	pha			; SAVE LAST PRECEDENCE
  2057 00:AB56: A9 01        	lda	#1
  2058 00:AB58: 20 9E A2     	jsr	CHKMEM		; CHECK IF ENOUGH ROOM ON STACK
  2059 00:AB5B: 20 2D AC     	jsr	FRM_ELEMENT	; GET AN ELEMENT
  2060 00:AB5E: A9 00        	lda	#0
  2061 00:AB60: 85 89        	sta	CPRTYP		; CLEAR COMPARISON OPERATOR FLAGS
  2062                        ; ----------------------------------------------------------------------------
  2063                        FRMEVL2:
  2064 00:AB62: 20 B7 00     	jsr	CHRGOT		; CHECK FOR RELATIONAL OPERATORS
  2065                        FRMEVL21:
  2066 00:AB65: 38           	sec			; > IS $AE, = IS $AF, < IS $B0
  2067 00:AB66: E9 AE        	sbc	#TOKEN_GREATER	; > IS 0, = IS 1, < IS 2
  2068 00:AB68: 90 17        	bcc	FRMEVL22		; NOT RELATIONAL OPERATOR
  2069 00:AB6A: C9 03        	cmp	#3
  2070 00:AB6C: B0 13        	bcs	FRMEVL22		; NOT RELATIONAL OPERATOR
  2071 00:AB6E: C9 01        	cmp	#1		; SET CARRY IF "=" OR "<"
  2072 00:AB70: 2A           	rol	a		; NOW > IS 0, = IS 3, < IS 5
  2073 00:AB71: 49 01        	eor	#1		; NOW > IS 1, = IS 2, < IS 4
  2074 00:AB73: 45 89        	eor	CPRTYP		; SET BITS OF CPRTYP:  00000<=>
  2075 00:AB75: C5 89        	cmp	CPRTYP		; CHECK FOR ILLEGAL COMBINATIONS
  2076 00:AB77: 90 61        	bcc	SNTXERR		; IF LESS THAN, A RELOP WAS REPEATED
  2077 00:AB79: 85 89        	sta	CPRTYP
  2078 00:AB7B: 20 B1 00     	jsr	CHRGET		; ANOTHER OPERATOR?
  2079 00:AB7E: 4C 65 AB     	jmp	FRMEVL21		; CHECK FOR <,=,> AGAIN
  2080                        ; ----------------------------------------------------------------------------
  2081                        FRMEVL22:
  2082 00:AB81: A6 89        	ldx	CPRTYP		; DID WE FIND A RELATIONAL OPERATOR?
  2083 00:AB83: D0 2C        	bne	FRM_RELATIONAL	; YES
  2084 00:AB85: B0 7B        	bcs	NOTMATH		; NO, AND NEXT TOKEN IS > $D1
  2085 00:AB87: 69 07        	adc	#TOKEN_GREATER-TOKEN_PLUS	; NO, AND NEXT TOKEN < $CF
  2086 00:AB89: 90 77        	bcc	NOTMATH		; IF NEXT TOKEN < "+"
  2087 00:AB8B: 65 11        	adc	VALTYP		; + AND LAST RESULT A STRING?
  2088 00:AB8D: D0 03        	bne	FRMEVL23		; BRANCH IF NOT
  2089 00:AB8F: 4C 7A B2     	jmp	CAT		; CONCATENATE IF SO.
  2090                        ; ----------------------------------------------------------------------------
  2091                        FRMEVL23:
  2092 00:AB92: 69 FF        	adc	#$FF		; +-*/ IS 0123
  2093 00:AB94: 85 5E        	sta	INDEX
  2094 00:AB96: 0A           	asl	a		; MULTIPLY BY 3
  2095 00:AB97: 65 5E        	adc	INDEX		; +-*/ IS 0,3,6,9
  2096 00:AB99: A8           	tay
  2097                        
  2098                        ; ----------------------------------------------------------------------------
  2099                        FRM_PRECEDENCE_TEST:
  2100 00:AB9A: 68           	pla			; GET LAST PRECEDENCE
  2101 00:AB9B: D9 86 A0     	cmp	MATHTBL,y
  2102 00:AB9E: B0 67        	bcs	FRM_PERFORM1	; DO NOW IF HIGHER PRECEDENCE
  2103 00:ABA0: 20 37 AB     	jsr	CHKNUM		; WAS LAST RESULT A #?
  2104 00:ABA3: 48           NXOP:	pha			; YES, SAVE PRECEDENCE ON STACK
  2105 00:ABA4: 20 CA AB     SAVOP:	jsr	FRM_RECURSE	; SAVE REST, CALL FRMEVL RECURSIVELY
  2106 00:ABA7: 68           	pla
  2107 00:ABA8: A4 87        	ldy	LASTOP
  2108 00:ABAA: 10 17        	bpl	PREFNC
  2109 00:ABAC: AA           	tax
  2110 00:ABAD: F0 56        	beq	GOEX		; EXIT IF NO MATH IN EXPRESSION
  2111 00:ABAF: D0 5F        	bne	FRM_PERFORM2	; ...ALWAYS
  2112                        
  2113                        
  2114                        ; ----------------------------------------------------------------------------
  2115                        ; FOUND ONE OR MORE RELATIONAL OPERATORS <,=,>
  2116                        ; ----------------------------------------------------------------------------
  2117                        FRM_RELATIONAL:
  2118 00:ABB1: 46 11        	lsr	VALTYP		; (VALTYP) = 0 (NUMERIC), = $FF (STRING)
  2119 00:ABB3: 8A           	txa			; SET CPRTYP TO 0000<=>C
  2120 00:ABB4: 2A           	rol	a		; WHERE C=0 IF #, C=1 IF STRING
  2121 00:ABB5: A6 B8        	ldx	TXTPTR		; BACK UP TXTPTR
  2122 00:ABB7: D0 02        	bne	FRM_R1
  2123 00:ABB9: C6 B9        	dec	TXTPTR+1
  2124 00:ABBB: C6 B8        FRM_R1:	dec	TXTPTR
  2125 00:ABBD: A0 1B        	ldy	#M_REL-MATHTBL	; POINT AT RELOPS ENTRY
  2126 00:ABBF: 85 89        	sta	CPRTYP
  2127 00:ABC1: D0 D7        	bne	FRM_PRECEDENCE_TEST	; ...ALWAYS
  2128                        ; ----------------------------------------------------------------------------
  2129 00:ABC3: D9 86 A0     PREFNC:	cmp	MATHTBL,y
  2130 00:ABC6: B0 48        	bcs	FRM_PERFORM2	; DO NOW IF HIGHER PRECEDENCE
  2131 00:ABC8: 90 D9        	bcc	NXOP		; ...ALWAYS
  2132                        
  2133                        
  2134                        ; ----------------------------------------------------------------------------
  2135                        ; STACK THIS OPERATION AND CALL FRMEVL FOR
  2136                        ; ANOTHER ONE
  2137                        ; ----------------------------------------------------------------------------
  2138                        FRM_RECURSE:
  2139 00:ABCA: B9 88 A0     	lda	MATHTBL+2,y
  2140 00:ABCD: 48           	pha			; PUSH ADDRESS OF OPERATION PERFORMER
  2141 00:ABCE: B9 87 A0     	lda	MATHTBL+1,y
  2142 00:ABD1: 48           	pha
  2143 00:ABD2: 20 DD AB     	jsr	FRM_STACK1	; STACK FAC.SIGN AND FAC
  2144 00:ABD5: A5 89        	lda	CPRTYP		; A=RELOP FLAGS, X=PRECEDENCE BYTE
  2145 00:ABD7: 4C 53 AB     	jmp	FRMEVL1		; RECURSIVELY CALL FRMEVL
  2146                        ; ----------------------------------------------------------------------------
  2147                        SNTXERR:
  2148 00:ABDA: 4C 8F AC     	jmp	SYNERR
  2149                        
  2150                        
  2151                        ; ----------------------------------------------------------------------------
  2152                        ; STACK (FAC)
  2153                        ; THREE ENTRY POINTS:
  2154                        ; 	1, FROM FRMEVL
  2155                        ;	2, FROM "STEP"
  2156                        ;	3, FROM "FOR"
  2157                        ; ----------------------------------------------------------------------------
  2158                        FRM_STACK1:
  2159 00:ABDD: A5 A2        	lda	FACSIGN		; GET FAC.SIGN TO PUSH IT
  2160 00:ABDF: BE 86 A0     	ldx	MATHTBL,y	; PRECEDENCE BYTE FROM MATHTBL
  2161                        
  2162                        
  2163                        ; ----------------------------------------------------------------------------
  2164                        ; ENTER HERE FROM "STEP", TO PUSH STEP SIGN AND VALUE
  2165                        ; ----------------------------------------------------------------------------
  2166                        FRM_STACK2:
  2167 00:ABE2: A8           	tay			; FAC.SIGN OR SGN(STEP VALUE)
  2168 00:ABE3: 68           	pla			; PULL RETURN ADDRESS AND ADD 1
  2169 00:ABE4: 85 5E        	sta	INDEX		; <<< ASSUMES NOT ON PAGE BOUNDARY! >>>
  2170 00:ABE6: E6 5E        	inc	INDEX		; PLACE BUMPED RETURN ADDRESS IN
  2171 00:ABE8: 68           	pla			; 	INDEX,INDEX+1
  2172 00:ABE9: 85 5F        	sta	INDEX+1
  2173 00:ABEB: 98           	tya			; FAC.SIGN OR SGN(STEP VALUE)
  2174 00:ABEC: 48           	pha			; PUSH FAC.SIGN OR SGN(STEP VALUE)
  2175                        
  2176                        
  2177                        ; ----------------------------------------------------------------------------
  2178                        ; ENTER HERE FROM "FOR", WITH (INDEX) = STEP,
  2179                        ; TO PUSH INITIAL VALUE OF "FOR" VARIABLE
  2180                        ; ----------------------------------------------------------------------------
  2181             0000005E   IN_INDEX	equ	INDEX
  2182                        
  2183                        FRM_STACK3:
  2184 00:ABED: 20 34 B8     	jsr	ROUND_FAC	; ROUND TO 32 BITS
  2185 00:ABF0: A5 A1        	lda	FAC+4		; PUSH (FAC)
  2186 00:ABF2: 48           	pha
  2187 00:ABF3: A5 A0        	lda	FAC+3
  2188 00:ABF5: 48           	pha
  2189 00:ABF6: A5 9F        	lda	FAC+2
  2190 00:ABF8: 48           	pha
  2191 00:ABF9: A5 9E        	lda	FAC+1
  2192 00:ABFB: 48           	pha
  2193 00:ABFC: A5 9D        	lda	FAC
  2194 00:ABFE: 48           	pha
  2195 00:ABFF: 6C 5E 00     	jmp	(IN_INDEX)		; DO RTS FUNNY WAY
  2196                        
  2197                        
  2198                        ; ----------------------------------------------------------------------------
  2199                        NOTMATH:
  2200 00:AC02: A0 FF        	ldy	#$FF		; SET UP TO EXIT ROUTINE
  2201 00:AC04: 68           	pla
  2202 00:AC05: F0 23        GOEX:	beq	EXIT		; EXIT IF NO MATH TO DO
  2203                        
  2204                        
  2205                        ; ----------------------------------------------------------------------------
  2206                        ; PERFORM STACKED OPERATION
  2207                        ;
  2208                        ; (A) = PRECEDENCE BYTE
  2209                        ; STACK:  1 -- CPRMASK
  2210                        ;	5 -- (ARG)
  2211                        ;	2 -- ADDR OF PERFORMER
  2212                        ; ----------------------------------------------------------------------------
  2213                        FRM_PERFORM1:
  2214 00:AC07: C9 64        	cmp	#PREL		; WAS IT RELATIONAL OPERATOR?
  2215 00:AC09: F0 03        	beq	FRM_P1		; YES, ALLOW STRING COMPARE
  2216 00:AC0B: 20 37 AB     	jsr	CHKNUM		; MUST BE NUMERIC VALUE
  2217 00:AC0E: 84 87        FRM_P1:	sty	LASTOP
  2218                        FRM_PERFORM2:
  2219 00:AC10: 68           	pla			; GET 0000<=>C FROM STACK
  2220 00:AC11: 4A           	lsr	a		; SHIFT TO 00000<=> FORM
  2221 00:AC12: 85 16        	sta	CPRMASK		; 00000<=>
  2222 00:AC14: 68           	pla
  2223 00:AC15: 85 A5        	sta	ARG		; GET FLOATING POINT VALUE OFF STACK,
  2224 00:AC17: 68           	pla			; AND PUT IT IN ARG
  2225 00:AC18: 85 A6        	sta	ARG+1
  2226 00:AC1A: 68           	pla
  2227 00:AC1B: 85 A7        	sta	ARG+2
  2228 00:AC1D: 68           	pla
  2229 00:AC1E: 85 A8        	sta	ARG+3
  2230 00:AC20: 68           	pla
  2231 00:AC21: 85 A9        	sta	ARG+4
  2232 00:AC23: 68           	pla
  2233 00:AC24: 85 AA        	sta	ARG+5
  2234 00:AC26: 45 A2        	eor	FACSIGN		; SAVE EOR OF SIGNS OF THE OPERANDS,
  2235 00:AC28: 85 AB        	sta	SGNCPR		; IN CASE OF MULTIPLY OR DIVIDE
  2236 00:AC2A: A5 9D        EXIT:	lda	FAC		; FAC EXPONENT IN A-REG / STATUS .EQ. IF (FAC)=0
  2237 00:AC2C: 60           	rts			; RTS GOES TO PERFORM OPERATION
  2238                        
  2239                        
  2240                        ; ----------------------------------------------------------------------------
  2241                        ; GET ELEMENT IN EXPRESSION
  2242                        ;
  2243                        ; GET VALUE OF VARIABLE OR NUMBER AT TXTPNT, OR POINT
  2244                        ; TO STRING DESCRIPTOR IF A STRING, AND PUT IN FAC.
  2245                        ; ----------------------------------------------------------------------------
  2246                        FRM_ELEMENT:
  2247 00:AC2D: A9 00        	lda	#0		; ASSUME NUMERIC
  2248 00:AC2F: 85 11        	sta	VALTYP
  2249 00:AC31: 20 B1 00     FRM_E1:	jsr	CHRGET
  2250 00:AC34: B0 03        	bcs	FRM_E3		; NOT A DIGIT
  2251 00:AC36: 4C 09 B9     FRM_E2:	jmp	FIN		; NUMERIC CONSTANT
  2252 00:AC39: 20 19 AE     FRM_E3:	jsr	ISLETC		; VARIABLE NAME?
  2253 00:AC3C: B0 5D        	bcs	FRM_VARIABLE	; YES
  2254 00:AC3E: C9 2E        	cmp	#'.'		; DECIMAL POINT
  2255 00:AC40: F0 F4        	beq	FRM_E2		; YES, NUMERIC CONSTANT
  2256 00:AC42: C9 A8        	cmp	#TOKEN_MINUS	; UNARY MINUS?
  2257 00:AC44: F0 4E        	beq	MIN		; YES
  2258 00:AC46: C9 A7        	cmp	#TOKEN_PLUS	; UNARY PLUS
  2259 00:AC48: F0 E7        	beq	FRM_E1		; YES
  2260 00:AC4A: C9 22        	cmp	#'"'		; STRING CONSTANT?
  2261 00:AC4C: D0 0F        	bne	NOT_		; NO
  2262                        
  2263                        
  2264                        ; ----------------------------------------------------------------------------
  2265                        ; STRING CONSTANT ELEMENT
  2266                        ;
  2267                        ; SET Y,A = (TXTPTR)+CARRY
  2268                        ; ----------------------------------------------------------------------------
  2269 00:AC4E: A5 B8        STRTXT:	lda	TXTPTR		; ADD (CARRY) TO GET ADDRESS OF 1ST CHAR
  2270 00:AC50: A4 B9        	ldy	TXTPTR+1	;    OF STRING IN Y,A
  2271 00:AC52: 69 00        	adc	#0
  2272 00:AC54: 90 01        	bcc	STRTXT1
  2273 00:AC56: C8           	iny
  2274                        STRTXT1:
  2275 00:AC57: 20 CA B0     	jsr	STRLIT		; BUILD DESCRIPTOR TO STRING / GET ADDRESS OF DESCRIPTOR IN FAC
  2276 00:AC5A: 4C 20 B4     	jmp	POINT		; POINT TXTPTR AFTER TRAILING QUOTE
  2277                        
  2278                        
  2279                        ; ----------------------------------------------------------------------------
  2280                        ; "NOT" FUNCTION
  2281                        ; IF FAC=0, RETURN FAC=1
  2282                        ; IF FAC<>0, RETURN FAC=0
  2283                        ; ----------------------------------------------------------------------------
  2284 00:AC5D: C9 A5        NOT_:	cmp	#TOKEN_NOT
  2285 00:AC5F: D0 10        	bne	SGN_		; NOT "NOT", TRY "SGN"
  2286 00:AC61: A0 18        	ldy	#M_EQU-MATHTBL	; POINT AT = COMPARISON
  2287 00:AC63: D0 31        	bne	EQUL		; ...ALWAYS
  2288                        
  2289                        
  2290                        ; ----------------------------------------------------------------------------
  2291                        ; COMPARISON FOR EQUALITY (= OPERATOR)
  2292                        ; ALSO USED TO EVALUATE "NOT" FUNCTION
  2293                        ; ----------------------------------------------------------------------------
  2294 00:AC65: A5 9D        EQUOP:	lda	FAC		; SET "TRUE" IF (FAC) = ZERO
  2295 00:AC67: D0 03        	bne	EQUOP1		; FALSE
  2296 00:AC69: A0 01        	ldy	#1		; TRUE
  2297 00:AC6B: 2C           	db	$2C		; TRICK TO SKIP NEXT 2 BYTES
  2298 00:AC6C: A0 00        EQUOP1:	ldy	#0		; FALSE
  2299 00:AC6E: 4C 9A B0     	jmp	SNGFLT
  2300                        ; ----------------------------------------------------------------------------
  2301 00:AC71: C9 B1        SGN_:	cmp	#TOKEN_SGN
  2302 00:AC73: 90 03        	bcc	PARCHK
  2303 00:AC75: 4C BF AC     	jmp	UNARY
  2304                        
  2305                        
  2306                        ; ----------------------------------------------------------------------------
  2307                        ; EVALUATE "(EXPRESSION)"
  2308                        ; ----------------------------------------------------------------------------
  2309 00:AC78: 20 81 AC     PARCHK:	jsr	CHKOPN		; IS THERE A '(' AT TXTPTR?
  2310 00:AC7B: 20 48 AB     	jsr	FRMEVL		; YES, EVALUATE EXPRESSION
  2311                        ; ----------------------------------------------------------------------------
  2312 00:AC7E: A9 29        CHKCLS:	lda	#')'		; CHECK FOR ')'
  2313 00:AC80: 2C           	db	$2C		; TRICK
  2314                        ; ----------------------------------------------------------------------------
  2315 00:AC81: A9 28        CHKOPN:	lda	#'('
  2316 00:AC83: 2C           	db   $2C		; TRICK
  2317                        ; ----------------------------------------------------------------------------
  2318 00:AC84: A9 2C        CHKCOM:	lda	#','		; COMMA AT TXTPTR?
  2319                        
  2320                        
  2321                        ; ----------------------------------------------------------------------------
  2322                        ; UNLESS CHAR AT TXTPTR = (A), SYNTAX ERROR
  2323                        ; ----------------------------------------------------------------------------
  2324 00:AC86: A0 00        SYNCHR:	ldy	#0
  2325 00:AC88: D1 B8        	cmp	(TXTPTR),y
  2326 00:AC8A: D0 03        	bne	SYNERR
  2327 00:AC8C: 4C B1 00     	jmp	CHRGET		; MATCH, GET NEXT CHAR & RETURN
  2328                        ; ----------------------------------------------------------------------------
  2329 00:AC8F: A2 06        SYNERR:	ldx	#ERR_SYNTAX
  2330 00:AC91: 4C DA A2     	jmp	ERROR
  2331                        ; ----------------------------------------------------------------------------
  2332 00:AC94: A0 15        MIN:	ldy     #M_NEG-MATHTBL	; POINT AT UNARY MINUS
  2333 00:AC96: 68           EQUL:	pla
  2334 00:AC97: 68           	pla
  2335 00:AC98: 4C A4 AB     	jmp	SAVOP
  2336                        ; ----------------------------------------------------------------------------
  2337                        FRM_VARIABLE:
  2338 00:AC9B: 20 89 AD     	jsr	PTRGET
  2339                        
  2340             0000AC9D   FRM_VARIABLE_CALL	equ *-1	; SO PTRGET CAN TELL WE CALLED
  2341                        
  2342 00:AC9E: 85 A0        	sta	VPNT		; ADDRESS OF VARIABLE
  2343 00:ACA0: 84 A1        	sty	VPNT+1
  2344 00:ACA2: A6 11        	ldx	VALTYP		; NUMERIC OR STRING?
  2345 00:ACA4: F0 05        	beq	FRM_V1		; NUMERIC
  2346 00:ACA6: A2 00        	ldx	#0		; STRING
  2347 00:ACA8: 86 AC        	stx	STRNG1+1
  2348 00:ACAA: 60           	rts
  2349 00:ACAB: A6 12        FRM_V1:	ldx	VALTYP+1	; NUMERIC, WHICH TYPE?
  2350 00:ACAD: 10 0D        	bpl	FRM_V2		; FLOATING POINT
  2351 00:ACAF: A0 00        	ldy	#0		; INTEGER
  2352 00:ACB1: B1 A0        	lda	(VPNT),y
  2353 00:ACB3: AA           	tax			; GET VALUE IN A,Y
  2354 00:ACB4: C8           	iny
  2355 00:ACB5: B1 A0        	lda	(VPNT),y
  2356 00:ACB7: A8           	tay
  2357 00:ACB8: 8A           	txa
  2358 00:ACB9: 4C 8D B0     	jmp	GIVAYF		; CONVERT A,Y TO FLOATING POINT
  2359 00:ACBC: 4C BB B7     FRM_V2:	jmp	LOAD_FAC_FROM_YA
  2360                        
  2361                        
  2362                        ; ----------------------------------------------------------------------------
  2363 00:ACBF: 0A           UNARY:	asl	a		; DOUBLE TOKEN TO GET INDEX
  2364 00:ACC0: 48           	pha
  2365 00:ACC1: AA           	tax
  2366 00:ACC2: 20 B1 00     	jsr	CHRGET
  2367 00:ACC5: E0 7D        	cpx	#<(TOKEN_LEFTSTR*2-1)	; LEFT$, RIGHT$, AND MID$
  2368 00:ACC7: 90 20        	bcc	UNARY1		; NOT ONE OF THE STRING FUNCTIONS
  2369 00:ACC9: 20 81 AC     	jsr	CHKOPN		; STRING FUNCTION, NEED "("
  2370 00:ACCC: 20 48 AB     	jsr	FRMEVL		; EVALUATE EXPRESSION FOR STRING
  2371 00:ACCF: 20 84 AC     	jsr	CHKCOM		; REQUIRE A COMMA
  2372 00:ACD2: 20 39 AB     	jsr	CHKSTR		; MAKE SURE EXPRESSION IS A STRING
  2373 00:ACD5: 68           	pla
  2374 00:ACD6: AA           	tax			; RETRIEVE ROUTINE POINTER
  2375 00:ACD7: A5 A1        	lda	VPNT+1		; STACK ADDRESS OF STRING
  2376 00:ACD9: 48           	pha
  2377 00:ACDA: A5 A0        	lda	VPNT
  2378 00:ACDC: 48           	pha
  2379 00:ACDD: 8A           	txa
  2380 00:ACDE: 48           	pha			; STACK DOUBLED TOKEN
  2381 00:ACDF: 20 DB B3     	jsr	GETBYT		; CONVERT NEXT EXPRESSION TO BYTE IN X-REG
  2382 00:ACE2: 68           	pla			; GET DOUBLED TOKEN OFF STACK
  2383 00:ACE3: A8           	tay			; USE AS INDEX TO BRANCH
  2384 00:ACE4: 8A           	txa			; VALUE OF SECOND PARAMETER
  2385 00:ACE5: 48           	pha			; PUSH 2ND PARAM
  2386 00:ACE6: 4C EE AC     	jmp	UNARY2		; JOIN UNARY FUNCTIONS
  2387 00:ACE9: 20 78 AC     UNARY1:	jsr	PARCHK		; REQUIRE "(EXPRESSION)"
  2388 00:ACEC: 68           	pla
  2389 00:ACED: A8           	tay			; INDEX INTO FUNCTION ADDRESS TABLE
  2390 00:ACEE: B9 02 A0     UNARY2:	lda	UNFNC-TOKEN_SGN-TOKEN_SGN+$100,y
  2391 00:ACF1: 85 91        	sta	JMPADRS+1	; PREPARE TO JSR TO ADDRESS
  2392 00:ACF3: B9 03 A0     	lda	UNFNC-TOKEN_SGN-TOKEN_SGN+$101,y
  2393 00:ACF6: 85 92        	sta	JMPADRS+2
  2394 00:ACF8: 20 90 00     	jsr	JMPADRS		; DOES NOT RETURN FOR CHR$, LEFT$, RIGHT$, OR MID$
  2395 00:ACFB: 4C 37 AB     	jmp	CHKNUM		; REQUIRE NUMERIC RESULT
  2396                        ; ----------------------------------------------------------------------------
  2397 00:ACFE: A5 A5        OR:	lda	ARG		; "OR" OPERATOR
  2398 00:AD00: 05 9D        	ora	FAC		; IF RESULT NONZERO, IT IS TRUE
  2399 00:AD02: D0 0B        	bne	TRUE
  2400                        ; ----------------------------------------------------------------------------
  2401 00:AD04: A5 A5        TAND:	lda	ARG		; "AND" OPERATOR
  2402 00:AD06: F0 04        	beq	FALSE		; IF EITHER IS ZERO, RESULT IS FALSE
  2403 00:AD08: A5 9D        	lda	FAC
  2404 00:AD0A: D0 03        	bne	TRUE
  2405                        ; ----------------------------------------------------------------------------
  2406 00:AD0C: A0 00        FALSE:	ldy	#0		; RETURN FAC=0
  2407 00:AD0E: 2C           	db	$2C		; TRICK
  2408                        ; ----------------------------------------------------------------------------
  2409 00:AD0F: A0 01        TRUE:	ldy	#1		; RETURN FAC=1
  2410 00:AD11: 4C 9A B0     	jmp	SNGFLT
  2411                        
  2412                        
  2413                        ; ----------------------------------------------------------------------------
  2414                        ; PERFORM RELATIONAL OPERATIONS
  2415                        ; ----------------------------------------------------------------------------
  2416 00:AD14: 20 3A AB     RELOPS:	jsr	CHKVAL		; MAKE SURE FAC IS CORRECT TYPE
  2417 00:AD17: B0 13        	bcs	STRCMP		; TYPE MATCHES, BRANCH IF STRINGS
  2418 00:AD19: A5 AA        	lda	ARGSIGN		; NUMERIC COMPARISON
  2419 00:AD1B: 09 7F        	ora	#$7F		; RE-PACK VALUE IN ARG FOR FCOMP
  2420 00:AD1D: 25 A6        	and	ARG+1
  2421 00:AD1F: 85 A6        	sta	ARG+1
  2422 00:AD21: A9 A5        	lda	#<ARG
  2423 00:AD23: A0 00        	ldy	#>ARG
  2424 00:AD25: 20 74 B8     	jsr	FCOMP		; RETURN A-REG = -1,0,1
  2425 00:AD28: AA           	tax			; AS ARG <,=,> FAC
  2426 00:AD29: 4C 5F AD     	jmp	NUMCMP
  2427                        
  2428                        
  2429                        ; ----------------------------------------------------------------------------
  2430                        ; STRING COMPARISON
  2431                        ; ----------------------------------------------------------------------------
  2432 00:AD2C: A9 00        STRCMP:	lda	#0		; SET RESULT TYPE TO NUMERIC
  2433 00:AD2E: 85 11        	sta	VALTYP
  2434 00:AD30: C6 89        	dec	CPRTYP		; MAKE CPRTYP 0000<=>0
  2435 00:AD32: 20 E3 B2     	jsr	FREFAC
  2436 00:AD35: 85 9D        	sta	FAC		; STRING LENGTH
  2437 00:AD37: 86 9E        	stx	FAC+1
  2438 00:AD39: 84 9F        	sty	FAC+2
  2439 00:AD3B: A5 A8        	lda	ARG+3
  2440 00:AD3D: A4 A9        	ldy	ARG+4
  2441 00:AD3F: 20 E7 B2     	jsr	FRETMP
  2442 00:AD42: 86 A8        	stx	ARG+3
  2443 00:AD44: 84 A9        	sty	ARG+4
  2444 00:AD46: AA           	tax			; LEN (ARG) STRING
  2445 00:AD47: 38           	sec
  2446 00:AD48: E5 9D        	sbc	FAC		; SET X TO SMALLER LEN
  2447 00:AD4A: F0 08        	beq	STRCMP11
  2448 00:AD4C: A9 01        	lda	#1
  2449 00:AD4E: 90 04        	bcc	STRCMP11
  2450 00:AD50: A6 9D        	ldx	FAC
  2451 00:AD52: A9 FF        	lda	#$FF
  2452                        STRCMP11:
  2453 00:AD54: 85 A2        	sta	FACSIGN		; FLAG WHICH SHORTER
  2454 00:AD56: A0 FF        	ldy	#$FF
  2455 00:AD58: E8           	inx
  2456                        STRCMP1:
  2457 00:AD59: C8           	iny
  2458 00:AD5A: CA           	dex
  2459 00:AD5B: D0 07        	bne	STRCMP2		; MORE CHARS IN BOTH STRINGS
  2460 00:AD5D: A6 A2        	ldx	FACSIGN		; IF = SO FAR, DECIDE BY LENGTH
  2461                        ; ----------------------------------------------------------------------------
  2462 00:AD5F: 30 0F        NUMCMP:	bmi	CMPDONE
  2463 00:AD61: 18           	clc
  2464 00:AD62: 90 0C        	bcc	CMPDONE		; ...ALWAYS
  2465                        ; ----------------------------------------------------------------------------
  2466                        STRCMP2:
  2467 00:AD64: B1 A8        	lda	(ARG+3),y
  2468 00:AD66: D1 9E        	cmp	(FAC+1),y
  2469 00:AD68: F0 EF        	beq	STRCMP1		; SAME, KEEP COMPARING
  2470 00:AD6A: A2 FF        	ldx	#$FF		; IN CASE ARG GREATER
  2471 00:AD6C: B0 02        	bcs	CMPDONE		; IT IS
  2472 00:AD6E: A2 01        	ldx	#1		; FAC GREATER
  2473                        ; ----------------------------------------------------------------------------
  2474                        CMPDONE:
  2475 00:AD70: E8           	inx			; CONVERT FF,0,1 TO 0,1,2
  2476 00:AD71: 8A           	txa
  2477 00:AD72: 2A           	rol	a		; AND TO 0,2,4 IF C=0, ELSE 1,2,5
  2478 00:AD73: 25 16        	and	CPRMASK		; 00000<=>
  2479 00:AD75: F0 02        	beq	CMPDONE1		; IF NO MATCH: FALSE
  2480 00:AD77: A9 01        	lda	#1		; AT LEAST ONE MATCH: TRUE
  2481                        CMPDONE1:
  2482 00:AD79: 4C 55 B8     	jmp	FLOAT
  2483                        
  2484                        
  2485                        ; ----------------------------------------------------------------------------
  2486                        ; "DIM" STATEMENT
  2487                        ; ----------------------------------------------------------------------------
  2488 00:AD7C: 20 84 AC     NXDIM:	jsr	CHKCOM		; SEPARATED BY COMMAS
  2489 00:AD7F: AA           DIM:	tax			; NON-ZERO, FLAGS PTRGET DIM CALLED
  2490 00:AD80: 20 8E AD     	jsr	PTRGET2		; ALLOCATE THE ARRAY
  2491 00:AD83: 20 B7 00     	jsr	CHRGOT		; NEXT CHAR
  2492 00:AD86: D0 F4        	bne	NXDIM		; NOT END OF STATEMENT
  2493 00:AD88: 60           	rts
  2494                        
  2495                        
  2496                        ; ----------------------------------------------------------------------------
  2497                        ; PTRGET -- GENERAL VARIABLE SCAN
  2498                        ;
  2499                        ; SCANS VARIABLE NAME AT TXTPTR, AND SEARCHES THE
  2500                        ; VARTAB AND ARYTAB FOR THE NAME.
  2501                        ; IF NOT FOUND, CREATE VARIABLE OF APPROPRIATE TYPE.
  2502                        ; RETURN WITH ADDRESS IN VARPNT AND Y,A
  2503                        ;
  2504                        ; ACTUAL ACTIVITY CONTROLLED SOMEWHAT BY TWO FLAGS:
  2505                        ;	DIMFLG -- NONZERO IF CALLED FROM "DIM"
  2506                        ;		ELSE = 0
  2507                        ;
  2508                        ;	SUBFLG -- = $00
  2509                        ;		= $40 IF CALLED FROM "GETARYPT"
  2510                        ; ----------------------------------------------------------------------------
  2511 00:AD89: A2 00        PTRGET:	ldx	#0
  2512 00:AD8B: 20 B7 00     	jsr	CHRGOT		; GET FIRST CHAR OF VARIABLE NAME
  2513                        ; ----------------------------------------------------------------------------
  2514                        PTRGET2:
  2515 00:AD8E: 86 10        	stx	DIMFLG		; X IS NONZERO IF FROM DIM
  2516                        ; ----------------------------------------------------------------------------
  2517                        PTRGET3:
  2518 00:AD90: 85 81        	sta	VARNAM
  2519 00:AD92: 20 B7 00     	jsr	CHRGOT
  2520 00:AD95: 20 19 AE     	jsr	ISLETC		; IS IT A LETTER?
  2521 00:AD98: B0 03        	bcs	NAMOK		; YES, OKAY SO FAR
  2522 00:AD9A: 4C 8F AC     BADNAM:	jmp	SYNERR		; NO, SYNTAX ERROR
  2523 00:AD9D: A2 00        NAMOK:	ldx	#0
  2524 00:AD9F: 86 11        	stx	VALTYP
  2525 00:ADA1: 86 12        	stx	VALTYP+1
  2526                        ; ----------------------------------------------------------------------------
  2527                        PTRGET4:
  2528 00:ADA3: 20 B1 00     	jsr	CHRGET		; SECOND CHAR OF VARIABLE NAME
  2529 00:ADA6: 90 05        	bcc	PTRGET41		; NUMERIC
  2530 00:ADA8: 20 19 AE     	jsr	ISLETC		; LETTER?
  2531 00:ADAB: 90 0B        	bcc	PTRGET43		; NO, END OF NAME
  2532                        PTRGET41:
  2533 00:ADAD: AA           	tax			; SAVE SECOND CHAR OF NAME IN X
  2534                        PTRGET42:
  2535 00:ADAE: 20 B1 00     	jsr	CHRGET		; SCAN TO END OF VARIABLE NAME
  2536 00:ADB1: 90 FB        	bcc	PTRGET42		; NUMERIC
  2537 00:ADB3: 20 19 AE     	jsr	ISLETC
  2538 00:ADB6: B0 F6        	bcs	PTRGET42		; ALPHA
  2539                        PTRGET43:
  2540 00:ADB8: C9 24        	cmp	#'$'		; STRING?
  2541 00:ADBA: D0 06        	bne	PTRGET44		; NO
  2542 00:ADBC: A9 FF        	lda	#$FF
  2543 00:ADBE: 85 11        	sta	VALTYP
  2544 00:ADC0: D0 10        	bne	PTRGET45		; ...ALWAYS
  2545                        PTRGET44:
  2546 00:ADC2: C9 25        	cmp	#'%'		; INTEGER?
  2547 00:ADC4: D0 13        	bne	PTRGET46		; NO
  2548 00:ADC6: A5 14        	lda	SUBFLG		; YES; INTEGER VARIABLE ALLOWED?
  2549 00:ADC8: 30 D0        	bmi	BADNAM		; NO, SYNTAX ERROR
  2550 00:ADCA: A9 80        	lda	#$80		; YES
  2551 00:ADCC: 85 12        	sta	VALTYP+1	; FLAG INTEGER MODE
  2552 00:ADCE: 05 81        	ora	VARNAM
  2553 00:ADD0: 85 81        	sta	VARNAM		; SET SIGN BIT ON VARNAME
  2554                        PTRGET45:
  2555 00:ADD2: 8A           	txa			; SECOND CHAR OF NAME
  2556 00:ADD3: 09 80        	ora	#$80		; SET SIGN
  2557 00:ADD5: AA           	tax
  2558 00:ADD6: 20 B1 00     	jsr	CHRGET		; GET TERMINATING CHAR
  2559                        PTRGET46:
  2560 00:ADD9: 86 82        	stx	VARNAM+1	; STORE SECOND CHAR OF NAME
  2561 00:ADDB: 38           	sec
  2562 00:ADDC: 05 14        	ora	SUBFLG		; $00 OR $40 IF SUBSCRIPTS OK, ELSE $80
  2563 00:ADDE: E9 28        	sbc	#'('		; IF SUBFLG=$00 AND CHAR="("...
  2564 00:ADE0: D0 03        	bne	PTRGET48		; NOPE
  2565                        PTRGET47:
  2566 00:ADE2: 4C BA AE     	jmp	ARRAY		; YES
  2567                        PTRGET48:
  2568 00:ADE5: 24 14        	bit	SUBFLG		; CHECK TOP TWO BITS OF SUBFLG
  2569 00:ADE7: 30 02        	bmi	PTRGET49		; $80
  2570 00:ADE9: 70 F7        	bvs	PTRGET47		; $40, CALLED FROM GETARYPT
  2571                        PTRGET49:
  2572 00:ADEB: A9 00        	lda	#0		; CLEAR SUBFLG
  2573 00:ADED: 85 14        	sta	SUBFLG
  2574 00:ADEF: A5 69        	lda	VARTAB		; START LOWTR AT SIMPLE VARIABLE TABLE
  2575 00:ADF1: A6 6A        	ldx	VARTAB+1
  2576 00:ADF3: A0 00        	ldy	#0
  2577                        PTRGET410:
  2578 00:ADF5: 86 9C        	stx	LOWTR+1
  2579                        PTRGET411:
  2580 00:ADF7: 85 9B        	sta	LOWTR
  2581 00:ADF9: E4 6C        	cpx	ARYTAB+1	; END OF SIMPLE VARIABLES?
  2582 00:ADFB: D0 04        	bne	PTRGET412		; NO, GO ON
  2583 00:ADFD: C5 6B        	cmp	ARYTAB		; YES; END OF ARRAYS?
  2584 00:ADFF: F0 21        	beq	NAMENOTFOUND	; YES, MAKE ONE
  2585                        PTRGET412:
  2586 00:AE01: A5 81        	lda	VARNAM		; SAME FIRST LETTER?
  2587 00:AE03: D1 9B        	cmp	(LOWTR),y
  2588 00:AE05: D0 08        	bne	PTRGET413		; NOT SAME FIRST LETTER
  2589 00:AE07: A5 82        	lda	VARNAM+1	; SAME SECOND LETTER?
  2590 00:AE09: C8           	iny
  2591 00:AE0A: D1 9B        	cmp	(LOWTR),y
  2592 00:AE0C: F0 6B        	beq	SET_VARPNT_AND_YA	; YES, SAME VARIABLE NAME
  2593 00:AE0E: 88           	dey			; NO, BUMP TO NEXT NAME
  2594                        PTRGET413:
  2595 00:AE0F: 18           	clc
  2596 00:AE10: A5 9B        	lda	LOWTR
  2597 00:AE12: 69 07        	adc	#7
  2598 00:AE14: 90 E1        	bcc	PTRGET411
  2599 00:AE16: E8           	inx
  2600 00:AE17: D0 DC        	bne	PTRGET410		; ...ALWAYS
  2601                        
  2602                        
  2603                        ; ----------------------------------------------------------------------------
  2604                        ; CHECK IF (A) IS ASCII LETTER A-Z
  2605                        ;
  2606                        ; RETURN CARRY = 1 IF A-Z
  2607                        ;	= 0 IF NOT
  2608                        ; ----------------------------------------------------------------------------
  2609 00:AE19: C9 5B        ISLETC:	cmp	#'Z'+1		; COMPARE HI END
  2610 00:AE1B: B0 03        	bcs	ISLETC1		; ABOVE A-Z
  2611 00:AE1D: C9 41        	cmp	#'A'		; COMPARE LO END
  2612 00:AE1F: 60           	rts			; C=0 IF LO, C=1 IF A-Z
  2613                        ISLETC1:
  2614 00:AE20: 18           	clc			; C=0 IF HI
  2615 00:AE21: 60           	rts
  2616                        
  2617                        
  2618                        ; ----------------------------------------------------------------------------
  2619                        ; VARIABLE NOT FOUND, SO MAKE ONE
  2620                        ; ----------------------------------------------------------------------------
  2621                        NAMENOTFOUND:
  2622 00:AE22: 68           	pla			; LOOK AT RETURN ADDRESS ON STACK TO
  2623 00:AE23: 48           	pha			; SEE IF CALLED FROM FRM.VARIABLE
  2624 00:AE24: C9 9D        	cmp	#<FRM_VARIABLE_CALL
  2625 00:AE26: D0 0F        	bne	MAKENEWVARIABLE	; NO
  2626 00:AE28: BA           	tsx
  2627 00:AE29: BD 02 01     	lda	STACK+2,x
  2628 00:AE2C: C9 AC        	cmp	#>FRM_VARIABLE_CALL
  2629 00:AE2E: D0 07        	bne	MAKENEWVARIABLE	; NO
  2630 00:AE30: A9 35        	lda	#<C_ZERO	; YES, CALLED FROM FRM.VARIABLE
  2631 00:AE32: A0 AE        	ldy	#>C_ZERO	; POINT TO A CONSTANT ZERO
  2632 00:AE34: 60           	rts			; NEW VARIABLE USED IN EXPRESSION = 0
  2633                        
  2634                        ; ----------------------------------------------------------------------------
  2635 00:AE35: 00 00        C_ZERO:	dw	$0000		; INTEGER OR REAL ZERO, OR NULL STRING
  2636                        
  2637                        
  2638                        ; ----------------------------------------------------------------------------
  2639                        ; MAKE A NEW SIMPLE VARIABLE
  2640                        ;
  2641                        ; MOVE ARRAYS UP 7 BYTES TO MAKE ROOM FOR NEW VARIABLE
  2642                        ; ENTER 7-BYTE VARIABLE DATA IN THE HOLE
  2643                        ; ----------------------------------------------------------------------------
  2644                        MAKENEWVARIABLE:
  2645 00:AE37: A5 6B        	lda	ARYTAB		; SET UP CALL TO BLTU TO
  2646 00:AE39: A4 6C        	ldy	ARYTAB+1	; TO MOVE FROM ARYTAB THRU STREND-1
  2647 00:AE3B: 85 9B        	sta	LOWTR		; 7 BYTES HIGHER
  2648 00:AE3D: 84 9C        	sty	LOWTR+1
  2649 00:AE3F: A5 6D        	lda	STREND
  2650 00:AE41: A4 6E        	ldy	STREND+1
  2651 00:AE43: 85 96        	sta	HIGHTR
  2652 00:AE45: 84 97        	sty	HIGHTR+1
  2653 00:AE47: 18           	clc
  2654 00:AE48: 69 07        	adc	#7
  2655 00:AE4A: 90 01        	bcc	MAKENE1
  2656 00:AE4C: C8           	iny
  2657                        MAKENE1:
  2658 00:AE4D: 85 94        	sta	ARYPNT
  2659 00:AE4F: 84 95        	sty	ARYPNT+1
  2660 00:AE51: 20 5B A2     	jsr	BLTU		; MOVE ARRAY BLOCK UP
  2661 00:AE54: A5 94        	lda	ARYPNT		; STORE NEW START OF ARRAYS
  2662 00:AE56: A4 95        	ldy	ARYPNT+1
  2663 00:AE58: C8           	iny
  2664 00:AE59: 85 6B        	sta	ARYTAB
  2665 00:AE5B: 84 6C        	sty	ARYTAB+1
  2666 00:AE5D: A0 00        	ldy	#0
  2667 00:AE5F: A5 81        	lda	VARNAM		; FIRST CHAR OF NAME
  2668 00:AE61: 91 9B        	sta	(LOWTR),y
  2669 00:AE63: C8           	iny
  2670 00:AE64: A5 82        	lda	VARNAM+1	; SECOND CHAR OF NAME
  2671 00:AE66: 91 9B        	sta	(LOWTR),y
  2672 00:AE68: A9 00        	lda	#0		; SET FIVE-BYTE VALUE TO 0
  2673 00:AE6A: C8           	iny
  2674 00:AE6B: 91 9B        	sta	(LOWTR),y
  2675 00:AE6D: C8           	iny
  2676 00:AE6E: 91 9B        	sta	(LOWTR),y
  2677 00:AE70: C8           	iny
  2678 00:AE71: 91 9B        	sta	(LOWTR),y
  2679 00:AE73: C8           	iny
  2680 00:AE74: 91 9B        	sta	(LOWTR),y
  2681 00:AE76: C8           	iny
  2682 00:AE77: 91 9B        	sta	(LOWTR),y
  2683                        
  2684                        
  2685                        ; ----------------------------------------------------------------------------
  2686                        ; PUT ADDRESS OF VALUE OF VARIABLE IN VARPNT AND Y,A
  2687                        ; ----------------------------------------------------------------------------
  2688                        SET_VARPNT_AND_YA:
  2689 00:AE79: A5 9B        	lda	LOWTR		; LOWTR POINTS AT NAME OF VARIABLE,
  2690 00:AE7B: 18           	clc			; SO ADD 2 TO GET TO VALUE
  2691 00:AE7C: 69 02        	adc	#2
  2692 00:AE7E: A4 9C        	ldy	LOWTR+1
  2693 00:AE80: 90 01        	bcc	SET_VA1
  2694 00:AE82: C8           	iny
  2695                        SET_VA1:
  2696 00:AE83: 85 83        	sta	VARPNT		; ADDRESS IN VARPNT AND Y,A
  2697 00:AE85: 84 84        	sty	VARPNT+1
  2698 00:AE87: 60           	rts
  2699                        
  2700                        
  2701                        ; ----------------------------------------------------------------------------
  2702                        ; COMPUTE ADDRESS OF FIRST VALUE IN ARRAY
  2703                        ; ARYPNT = (LOWTR) + #DIMS*2 + 5
  2704                        ; ----------------------------------------------------------------------------
  2705 00:AE88: A5 0F        GETARY:	lda	NUMDIM		; GET # OF DIMENSIONS
  2706 00:AE8A: 0A           	asl	a		; #DIMS*2 (SIZE OF EACH DIM IN 2 BYTES)
  2707 00:AE8B: 69 05        	adc	#5		; + 5 (2 FOR NAME, 2 FOR OFFSET TO NEXT ARRAY, AND 1 FOR #DIMS
  2708 00:AE8D: 65 9B        	adc	LOWTR		; ADDRESS OF TH IS ARRAY IN ARYTAB
  2709 00:AE8F: A4 9C        	ldy	LOWTR+1
  2710 00:AE91: 90 01        	bcc	GETARY1
  2711 00:AE93: C8           	iny
  2712                        GETARY1:
  2713 00:AE94: 85 94        	sta	ARYPNT		; ADDRESS OF FIRST VALUE IN ARRAY
  2714 00:AE96: 84 95        	sty	ARYPNT+1
  2715 00:AE98: 60           	rts
  2716                        
  2717                        
  2718                        ; ----------------------------------------------------------------------------
  2719                        NEG32768:
  2720 00:AE99: 90 80 00 00  	db   $90,$80,$00,$00,$00	; -32768 IN FLOATING POINT
       00:AE9D: 00 
  2721                        ; ----------------------------------------------------------------------------
  2722                        
  2723                        
  2724                        ; ----------------------------------------------------------------------------
  2725                        ; EVALUATE NUMERIC FORMULA AT TXTPTR
  2726                        ; CONVERTING RESULT TO INTEGER 0 <= X <= 32767
  2727                        ; IN FAC+3,4
  2728                        ; ----------------------------------------------------------------------------
  2729 00:AE9E: 20 B1 00     MAKINT:	jsr	CHRGET
  2730 00:AEA1: 20 34 AB     	jsr	FRMNUM
  2731                        
  2732                        
  2733                        ; ----------------------------------------------------------------------------
  2734                        ; CONVERT FAC TO INTEGER
  2735                        ; MUST BE POSITIVE AND LESS THAN 32768
  2736                        ; ----------------------------------------------------------------------------
  2737 00:AEA4: A5 A2        MKINT:	lda	FACSIGN		; ERROR IF -
  2738 00:AEA6: 30 0D        	bmi	MI1
  2739                        
  2740                        
  2741                        ; ----------------------------------------------------------------------------
  2742                        ; CONVERT FAC TO INTEGER
  2743                        ; MUST BE -32767 <= FAC <= 32767
  2744                        ; ----------------------------------------------------------------------------
  2745 00:AEA8: A5 9D        AYINT:	lda	FAC		; EXPONENT OF VALUE IN FAC
  2746 00:AEAA: C9 90        	cmp	#$90		; ABS(VALUE) < 32768?
  2747 00:AEAC: 90 09        	bcc	MI2		; YES, OK FOR INTEGER
  2748 00:AEAE: A9 99        	lda	#<NEG32768	; NO
  2749 00:AEB0: A0 AE        	ldy	#>NEG32768
  2750 00:AEB2: 20 74 B8     	jsr	FCOMP
  2751                        ; ----------------------------------------------------------------------------
  2752 00:AEB5: D0 7E        MI1:	bne	IQERR		; ILLEGAL QUANTITY
  2753 00:AEB7: 4C B1 B8     MI2:	jmp	QINT		; CONVERT TO INTEGER
  2754                        
  2755                        
  2756                        ; ----------------------------------------------------------------------------
  2757                        ; LOCATE ARRAY ELEMENT OR CREATE AN ARRAY
  2758                        ; ----------------------------------------------------------------------------
  2759 00:AEBA: A5 14        ARRAY:  lda	SUBFLG		; SUBSCRIPTS GIVEN?
  2760 00:AEBC: D0 47        	bne	ARRAY2		; NO
  2761                        ; ----------------------------------------------------------------------------
  2762                        ; PARSE THE SUBSCRIPT LIST
  2763                        ; ----------------------------------------------------------------------------
  2764 00:AEBE: A5 10        	lda	DIMFLG		; YES
  2765 00:AEC0: 05 12        	ora	VALTYP+1	; SET HIGH BIT IF %
  2766 00:AEC2: 48           	pha			; SAVE VALTYP AND DIMFLG ON STACK
  2767 00:AEC3: A5 11        	lda	VALTYP
  2768 00:AEC5: 48           	pha
  2769 00:AEC6: A0 00        	ldy	#0		; COUNT # DIMENSIONS IN Y-REG
  2770 00:AEC8: 98           ARRAY1:	tya			; SAVE #DIMS ON STACK
  2771 00:AEC9: 48           	pha
  2772 00:AECA: A5 82        	lda	VARNAM+1	; SAVE VARIABLE NAME ON STACK
  2773 00:AECC: 48           	pha
  2774 00:AECD: A5 81        	lda	VARNAM
  2775 00:AECF: 48           	pha
  2776 00:AED0: 20 9E AE     	jsr	MAKINT		; EVALUATE SUBSCRIPT AS INTEGER
  2777 00:AED3: 68           	pla			; RESTORE VARIABLE NAME
  2778 00:AED4: 85 81        	sta	VARNAM
  2779 00:AED6: 68           	pla
  2780 00:AED7: 85 82        	sta	VARNAM+1
  2781 00:AED9: 68           	pla			; RESTORE # DIMS TO Y-REG
  2782 00:AEDA: A8           	tay
  2783 00:AEDB: BA           	tsx			; COPY VALTYP AND DIMFLG ON STACK
  2784 00:AEDC: BD 02 01     	lda	STACK+2,x	; TO LEAVE ROOM FOR THE SUBSCRIPT
  2785 00:AEDF: 48           	pha
  2786 00:AEE0: BD 01 01     	lda	STACK+1,x
  2787 00:AEE3: 48           	pha
  2788 00:AEE4: A5 A0        	lda	FAC+3		; GET SUBSCRIPT VALUE AND PLACE IN THE
  2789 00:AEE6: 9D 02 01     	sta	STACK+2,x	; STACK WHERE VALTYP & DIMFLG WERE
  2790 00:AEE9: A5 A1        	lda	FAC+4
  2791 00:AEEB: 9D 01 01     	sta	STACK+1,x
  2792 00:AEEE: C8           	iny			; COUNT THE SUBSCRIPT
  2793 00:AEEF: 20 B7 00     	jsr	CHRGOT		; NEXT CHAR
  2794 00:AEF2: C9 2C        	cmp	#','
  2795 00:AEF4: F0 D2        	beq	ARRAY1		; COMMA, PARSE ANOTHER SUBSCRIPT
  2796 00:AEF6: 84 0F        	sty	NUMDIM		; NO MORE SUBSCRIPTS, SAVE #
  2797 00:AEF8: 20 7E AC     	jsr	CHKCLS		; NOW NEED ")"
  2798 00:AEFB: 68           	pla			; RESTORE VALTYPE AND DIMFLG
  2799 00:AEFC: 85 11        	sta	VALTYP
  2800 00:AEFE: 68           	pla
  2801 00:AEFF: 85 12        	sta	VALTYP+1
  2802 00:AF01: 29 7F        	and	#$7F		; ISOLATE DIMFLG
  2803 00:AF03: 85 10        	sta	DIMFLG
  2804                        ; ----------------------------------------------------------------------------
  2805                        ; SEARCH ARRAY TABLE FOR THIS ARRAY NAME
  2806                        ; ----------------------------------------------------------------------------
  2807 00:AF05: A6 6B        ARRAY2:	ldx	ARYTAB		; (A,X) = START OF ARRAY TABLE
  2808 00:AF07: A5 6C        	lda	ARYTAB+1
  2809 00:AF09: 86 9B        ARRAY3:	stx	LOWTR		; USE LOWTR FOR RUNNING POINTER
  2810 00:AF0B: 85 9C        	sta	LOWTR+1
  2811 00:AF0D: C5 6E        	cmp	STREND+1	; DID WE REACH THE END OF ARRAYS YET?
  2812 00:AF0F: D0 04        	bne	ARRAY4		; NO, KEEP SEARCHING
  2813 00:AF11: E4 6D        	cpx	STREND
  2814 00:AF13: F0 3F        	beq	MAKE_NEW_ARRAY	; YES, THIS IS A NEW ARRAY NAME
  2815 00:AF15: A0 00        ARRAY4:	ldy	#0		; POINT AT 1ST CHAR OF ARRAY NAME
  2816 00:AF17: B1 9B        	lda	(LOWTR),y	; GET 1ST CHAR OF NAME
  2817 00:AF19: C8           	iny			; POINT AT 2ND CHAR
  2818 00:AF1A: C5 81        	cmp	VARNAM		; 1ST CHAR SAME?
  2819 00:AF1C: D0 06        	bne	ARRAY5		; NO, MOVE TO NEXT ARRAY
  2820 00:AF1E: A5 82        	lda	VARNAM+1	; YES, TRY 2ND CHAR
  2821 00:AF20: D1 9B        	cmp	(LOWTR),y	; SAME?
  2822 00:AF22: F0 16        	beq	USE_OLD_ARRAY	; YES, ARRAY FOUND
  2823 00:AF24: C8           ARRAY5:	iny			; POINT AT OFFSET TO NEXT ARRAY
  2824 00:AF25: B1 9B        	lda	(LOWTR),y	; ADD OFFSET TO RUNNING POINTER
  2825 00:AF27: 18           	clc
  2826 00:AF28: 65 9B        	adc	LOWTR
  2827 00:AF2A: AA           	tax
  2828 00:AF2B: C8           	iny
  2829 00:AF2C: B1 9B        	lda	(LOWTR),y
  2830 00:AF2E: 65 9C        	adc	LOWTR+1
  2831 00:AF30: 90 D7        	bcc	ARRAY3		; ...ALWAYS
  2832                        
  2833                        
  2834                        ; ----------------------------------------------------------------------------
  2835                        ; ERROR:  BAD SUBSCRIPTS
  2836                        ; ----------------------------------------------------------------------------
  2837 00:AF32: A2 44        SUBERR:	ldx	#ERR_BADSUBS
  2838 00:AF34: 2C           	db	$2C		; TRICK TO SKIP NEXT LINE
  2839                        
  2840                        
  2841                        ; ----------------------------------------------------------------------------
  2842                        ; ERROR:  ILLEGAL QUANTITY
  2843                        ; ----------------------------------------------------------------------------
  2844 00:AF35: A2 1F        IQERR:	ldx	#ERR_ILLQTY
  2845 00:AF37: 4C DA A2     JER:	jmp	ERROR
  2846                        
  2847                        
  2848                        ; ----------------------------------------------------------------------------
  2849                        ; FOUND THE ARRAY
  2850                        ; ----------------------------------------------------------------------------
  2851                        USE_OLD_ARRAY:
  2852 00:AF3A: A2 4E        	ldx	#ERR_REDIMD	; SET UP FOR REDIM'D ARRAY ERROR
  2853 00:AF3C: A5 10        	lda	DIMFLG		; CALLED FROM "DIM" STATEMENT?
  2854 00:AF3E: D0 F7        	bne	JER		; YES, ERROR
  2855 00:AF40: A5 14        	lda	SUBFLG		; NO, CHECK IF ANY SUBSCRIPTS
  2856 00:AF42: F0 02        	beq	USE_O1		; YES, NEED TO CHECK THE NUMBER
  2857 00:AF44: 38           	sec			; NO, SIGNAL ARRAY FOUND
  2858 00:AF45: 60           	rts
  2859                        ; ----------------------------------------------------------------------------
  2860 00:AF46: 20 88 AE     USE_O1:	jsr	GETARY		; SET (ARYPNT) = ADDR OF FIRST ELEMENT
  2861 00:AF49: A5 0F        	lda	TKNCNTR		; COMPARE NUMBER OF DIMENSIONS
  2862 00:AF4B: A0 04        	ldy	#4
  2863 00:AF4D: D1 9B        	cmp	(LOWTR),y
  2864 00:AF4F: D0 E1        	bne	SUBERR		; NOT SAME, SUBSCRIPT ERROR
  2865 00:AF51: 4C E6 AF     	jmp	FIND_ARRAY_ELEMENT
  2866                        
  2867                        
  2868                        ; ----------------------------------------------------------------------------
  2869                        ; CREATE A NEW ARRAY, UNLESS CALLED FROM GETARYPT
  2870                        ; ----------------------------------------------------------------------------
  2871                        MAKE_NEW_ARRAY:
  2872 00:AF54: A5 14        	lda	SUBFLG		; CALLED FROM GETARYPT?
  2873 00:AF56: F0 05        	beq	MAKE_NE1		; NO
  2874 00:AF58: A2 14        	ldx	#ERR_NODATA	; YES, GIVE "OUT OF DATA" ERROR
  2875 00:AF5A: 4C DA A2     	jmp	ERROR
  2876                        MAKE_NE1:
  2877 00:AF5D: 20 88 AE     	jsr	GETARY		; PUT ADDR OF 1ST ELEMENT IN ARYPNT
  2878 00:AF60: 20 AB A2     	jsr	REASON		; MAKE SURE ENOUGH MEMORY LEFT
  2879 00:AF63: A0 00        	ldy	#0		; POINT Y-REG AT VARIABLE NAME SLOT
  2880 00:AF65: 84 AE        	sty	STRNG2+1	; START SIZE COMPUTATION
  2881 00:AF67: A2 05        	ldx	#5		; ASSUME 5-BYTES PER ELEMENT
  2882 00:AF69: A5 81        	lda	VARNAM		; STUFF VARIABLE NAME IN ARRAY
  2883 00:AF6B: 91 9B        	sta	(LOWTR),y
  2884 00:AF6D: 10 01        	bpl	MAKE_NE2		; NOT INTEGER ARRAY
  2885 00:AF6F: CA           	dex			; INTEGER ARRAY, DECR. SIZE TO 4-BYTES
  2886                        MAKE_NE2:
  2887 00:AF70: C8           	iny			; POINT Y-REG AT NEXT CHAR OF NAME
  2888 00:AF71: A5 82        	lda	VARNAM+1	; REST OF ARRAY NAME
  2889 00:AF73: 91 9B        	sta	(LOWTR),y
  2890 00:AF75: 10 02        	bpl	MAKE_NE3		; REAL ARRAY, STICK WITH SIZE = 5 BYTES
  2891 00:AF77: CA           	dex			; INTEGER OR STRING ARRAY, ADJUST SIZE
  2892 00:AF78: CA           	dex			; TO INTEGER=3, STRING=2 BYTES
  2893                        MAKE_NE3:
  2894 00:AF79: 86 AD        	stx	STRNG2		; STORE LOW-BYTE OF ARRAY ELEMENT SIZE
  2895 00:AF7B: A5 0F        	lda	NUMDIM		; STORE NUMBER OF DIMENSIONS
  2896 00:AF7D: C8           	iny			; IN 5TH BYTE OF ARRAY
  2897 00:AF7E: C8           	iny
  2898 00:AF7F: C8           	iny
  2899 00:AF80: 91 9B        	sta	(LOWTR),y
  2900                        MAKE_NE4:
  2901 00:AF82: A2 0B        	ldx	#11		; DEFAULT DIMENSION = 11 ELEMENTS
  2902 00:AF84: A9 00        	lda	#0		; FOR HI-BYTE OF DIMENSION IF DEFAULT
  2903 00:AF86: 24 10        	bit	DIMFLG		; DIMENSIONED ARRAY?
  2904 00:AF88: 50 08        	bvc	MAKE_NE5		; NO, USE DEFAULT VALUE
  2905 00:AF8A: 68           	pla			; GET SPECIFIED DIM IN A,X
  2906 00:AF8B: 18           	clc			; # ELEMENTS IS 1 LARGER THAN
  2907 00:AF8C: 69 01        	adc	#1		; DIMENSION VALUE
  2908 00:AF8E: AA           	tax
  2909 00:AF8F: 68           	pla
  2910 00:AF90: 69 00        	adc	#0
  2911                        MAKE_NE5:
  2912 00:AF92: C8           	iny			; ADD THIS DIMENSION TO ARRAY DESCRIPTOR
  2913 00:AF93: 91 9B        	sta	(LOWTR),y
  2914 00:AF95: C8           	iny
  2915 00:AF96: 8A           	txa
  2916 00:AF97: 91 9B        	sta	(LOWTR),y
  2917 00:AF99: 20 48 B0     	jsr	MULTIPLY_SUBSCRIPT	; MULTIPLY THIS DIMENSION BY RUNNING SIZE ((LOWTR)) * (STRNG2) --> A
                    ,X
  2918 00:AF9C: 86 AD        	stx	STRNG2		; STORE RUNNING SIZE IN STRNG2
  2919 00:AF9E: 85 AE        	sta	STRNG2+1
  2920 00:AFA0: A4 5E        	ldy	INDEX		; RETRIEVE Y SAVED BY MULTIPLY.SUBSCRIPT
  2921 00:AFA2: C6 0F        	dec	NUMDIM		; COUNT DOWN # DIMS
  2922 00:AFA4: D0 DC        	bne	MAKE_NE4		; LOOP TILL DONE
  2923                        ; ----------------------------------------------------------------------------
  2924                        ; NOW A,X HAS TOTAL # BYTES OF ARRAY ELEMENTS
  2925                        ; ----------------------------------------------------------------------------
  2926 00:AFA6: 65 95        	adc	ARYPNT+1	; COMPUTE ADDRESS OF END OF THIS ARRAY
  2927 00:AFA8: B0 5D        	bcs	GME		; ...TOO LARGE, ERROR
  2928 00:AFAA: 85 95        	sta	ARYPNT+1
  2929 00:AFAC: A8           	tay
  2930 00:AFAD: 8A           	txa
  2931 00:AFAE: 65 94        	adc	ARYPNT
  2932 00:AFB0: 90 03        	bcc	MAKE_NE6
  2933 00:AFB2: C8           	iny
  2934 00:AFB3: F0 52        	beq	GME		; ...TOO LARGE, ERROR
  2935                        MAKE_NE6:
  2936 00:AFB5: 20 AB A2     	jsr	REASON		; MAKE SURE THERE IS ROOM UP TO Y,A
  2937 00:AFB8: 85 6D        	sta	STREND		; THERE IS ROOM SO SAVE NEW END OF TABLE
  2938 00:AFBA: 84 6E        	sty	STREND+1	;     AND ZERO THE ARRAY
  2939 00:AFBC: A9 00        	lda	#0
  2940 00:AFBE: E6 AE        	inc	STRNG2+1	; PREPARE FOR FAST ZEROING LOOP
  2941 00:AFC0: A4 AD        	ldy	STRNG2		; # BYTES MOD 256
  2942 00:AFC2: F0 05        	beq	MAKE_NE8		; FULL PAGE
  2943                        MAKE_NE7:
  2944 00:AFC4: 88           	dey			; CLEAR PAGE FULL
  2945 00:AFC5: 91 94        	sta	(ARYPNT),y
  2946 00:AFC7: D0 FB        	bne	MAKE_NE7
  2947                        MAKE_NE8:
  2948 00:AFC9: C6 95        	dec	ARYPNT+1	; POINT TO NEXT PAGE
  2949 00:AFCB: C6 AE        	dec	STRNG2+1	; COUNT THE PAGES
  2950 00:AFCD: D0 F5        	bne	MAKE_NE7		; STILL MORE TO CLEAR
  2951 00:AFCF: E6 95        	inc	ARYPNT+1	; RECOVER LAST DEC, POINT AT 1ST ELEMENT
  2952 00:AFD1: 38           	sec
  2953 00:AFD2: A5 6D        	lda	STREND		; COMPUTE OFFSET TO END OF ARRAYS
  2954 00:AFD4: E5 9B        	sbc	LOWTR		; AND STORE IN ARRAY DESCRIPTOR
  2955 00:AFD6: A0 02        	ldy	#2
  2956 00:AFD8: 91 9B        	sta	(LOWTR),y
  2957 00:AFDA: A5 6E        	lda	STREND+1
  2958 00:AFDC: C8           	iny
  2959 00:AFDD: E5 9C        	sbc	LOWTR+1
  2960 00:AFDF: 91 9B        	sta	(LOWTR),y
  2961 00:AFE1: A5 10        	lda	DIMFLG		; WAS THIS CALLED FROM "DIM" STATEMENT?
  2962 00:AFE3: D0 62        	bne	RTS9		; YES, WE ARE FINISHED
  2963 00:AFE5: C8           	iny			; NO, NOW NEED TO FIND THE ELEMENT
  2964                        
  2965                        
  2966                        ; ----------------------------------------------------------------------------
  2967                        ; FIND SPECIFIED ARRAY ELEMENT
  2968                        ;
  2969                        ; (LOWTR),Y POINTS AT # OF DIMS IN ARRAY DESCRIPTOR
  2970                        ; THE SUBSCRIPTS ARE ALL ON THE STACK AS INTEGERS
  2971                        ; ----------------------------------------------------------------------------
  2972                        FIND_ARRAY_ELEMENT:
  2973 00:AFE6: B1 9B        	lda	(LOWTR),y	; GET # OF DIMENSIONS
  2974 00:AFE8: 85 0F        	sta	NUMDIM
  2975 00:AFEA: A9 00        	lda	#0		; ZERO SUBSCRIPT ACCUMULATOR
  2976 00:AFEC: 85 AD        	sta	STRNG2
  2977 00:AFEE: 85 AE        FAE1:	sta	STRNG2+1
  2978 00:AFF0: C8           	iny
  2979 00:AFF1: 68           	pla			; PULL NEXT SUBSCRIPT FROM STACK
  2980 00:AFF2: AA           	tax			; SAVE IN FAC+3,4
  2981 00:AFF3: 85 A0        	sta	FAC+3		; AND COMPARE WITH DIMENSIONED SIZE
  2982 00:AFF5: 68           	pla
  2983 00:AFF6: 85 A1        	sta	FAC+4
  2984 00:AFF8: D1 9B        	cmp	(LOWTR),y
  2985 00:AFFA: 90 0E        	bcc	FAE2		; SUBSCRIPT NOT TOO LARGE
  2986 00:AFFC: D0 06        	bne	GSE		; SUBSCRIPT IS TOO LARGE
  2987 00:AFFE: C8           	iny			; CHECK LOW-BYTE OF SUBSCRIPT
  2988 00:AFFF: 8A           	txa
  2989 00:B000: D1 9B        	cmp	(LOWTR),y
  2990 00:B002: 90 07        	bcc	FAE3		; NOT TOO LARGE
  2991                        ; ----------------------------------------------------------------------------
  2992 00:B004: 4C 32 AF     GSE:	jmp	SUBERR		; BAD SUBSCRIPTS ERROR
  2993 00:B007: 4C D8 A2     GME:	jmp	MEMERR		; MEM FULL ERROR
  2994                        ; ----------------------------------------------------------------------------
  2995 00:B00A: C8           FAE2:	iny			; BUMP POINTER INTO DESCRIPTOR
  2996 00:B00B: A5 AE        FAE3:	lda	STRNG2+1	; BYPASS MULTIPLICATION IF VALUE SO
  2997 00:B00D: 05 AD        	ora	STRNG2		; FAR = 0
  2998 00:B00F: 18           	clc
  2999 00:B010: F0 0A        	beq	FIND_A1		; IT IS ZERO SO FAR
  3000 00:B012: 20 48 B0     	jsr	MULTIPLY_SUBSCRIPT	; NOT ZERO, SO MULTIPLY
  3001 00:B015: 8A           	txa			; ADD CURRENT SUBSCRIPT
  3002 00:B016: 65 A0        	adc	FAC+3
  3003 00:B018: AA           	tax
  3004 00:B019: 98           	tya
  3005 00:B01A: A4 5E        	ldy	INDEX		; RETRIEVE Y SAVED BY MULTIPLY.SUBSCRIPT
  3006                        FIND_A1:
  3007 00:B01C: 65 A1        	adc	FAC+4		; FINISH ADDING CURRENT SUBSCRIPT
  3008 00:B01E: 86 AD        	stx	STRNG2		; STORE ACCUMULATED OFFSET
  3009 00:B020: C6 0F        	dec	NUMDIM		; LAST SUBSCRIPT YET?
  3010 00:B022: D0 CA        	bne	FAE1		; NO, LOOP TILL DONE
  3011 00:B024: 85 AE        	sta	STRNG2+1	; YES, NOW MULTIPLY BE ELEMENT SIZE
  3012 00:B026: A2 05        	ldx	#5		; START WITH SIZE = 5
  3013 00:B028: A5 81        	lda	VARNAM		; DETERMINE VARIABLE TYPE
  3014 00:B02A: 10 01        	bpl	FIND_A2		; NOT INTEGER
  3015 00:B02C: CA           	dex			; INTEGER, BACK DOWN SIZE TO 4 BYTES
  3016                        FIND_A2:
  3017 00:B02D: A5 82        	lda	VARNAM+1	; DISCRIMINATE BETWEEN REAL AND STR
  3018 00:B02F: 10 02        	bpl	FIND_A3		; IT IS REAL
  3019 00:B031: CA           	dex			; SIZE = 3 IF STRING, =2 IF INTEGER
  3020 00:B032: CA           	dex
  3021                        FIND_A3:
  3022 00:B033: 86 64        	stx	RESULT+2	; SET UP MULTIPLIER
  3023 00:B035: A9 00        	lda	#0		; HI-BYTE OF MULTIPLIER
  3024 00:B037: 20 51 B0     	jsr	MULTIPLY_SUBS1	; (STRNG2) BY ELEMENT SIZE
  3025 00:B03A: 8A           	txa			; ADD ACCUMULATED OFFSET
  3026 00:B03B: 65 94        	adc	ARYPNT		; TO ADDRESS OF 1ST ELEMENT
  3027 00:B03D: 85 83        	sta	VARPNT		; TO GET ADDRESS OF SPECIFIED ELEMENT
  3028 00:B03F: 98           	tya
  3029 00:B040: 65 95        	adc	ARYPNT+1
  3030 00:B042: 85 84        	sta	VARPNT+1
  3031 00:B044: A8           	tay			; RETURN WITH ADDR IN VARPNT
  3032 00:B045: A5 83        	lda	VARPNT		; AND IN Y,A
  3033 00:B047: 60           RTS9:	rts
  3034                        
  3035                        
  3036                        ; ----------------------------------------------------------------------------
  3037                        ; MULTIPLY (STRNG2) BY ((LOWTR),Y)
  3038                        ; LEAVING PRODUCT IN A,X.  (HI-BYTE ALSO IN Y.)
  3039                        ; USED ONLY BY ARRAY SUBSCRIPT ROUTINES
  3040                        ; ----------------------------------------------------------------------------
  3041                        MULTIPLY_SUBSCRIPT:
  3042 00:B048: 84 5E        	sty	INDEX		; SAVE Y-REG
  3043 00:B04A: B1 9B        	lda	(LOWTR),y	; GET MULTIPLIER
  3044 00:B04C: 85 64        	sta	RESULT+2	; SAVE IN RESULT+2,3
  3045 00:B04E: 88           	dey
  3046 00:B04F: B1 9B        	lda	(LOWTR),y
  3047                        ; ----------------------------------------------------------------------------
  3048                        MULTIPLY_SUBS1:
  3049 00:B051: 85 65        	sta	RESULT+3	; LOW BYTE OF MULTIPLIER
  3050 00:B053: A9 10        	lda	#16		; MULTIPLY 16 BITS
  3051 00:B055: 85 99        	sta	INDX
  3052 00:B057: A2 00        	ldx	#0		; PRODUCT = 0 INITIALLY
  3053 00:B059: A0 00        	ldy	#0
  3054                        MULTIP1:
  3055 00:B05B: 8A           	txa			; DOUBLE PRODUCT
  3056 00:B05C: 0A           	asl	a		; LOW BYTE
  3057 00:B05D: AA           	tax
  3058 00:B05E: 98           	tya			; HIGH BYTE
  3059 00:B05F: 2A           	rol	a		; IF TOO LARGE, SET CARRY
  3060 00:B060: A8           	tay
  3061 00:B061: B0 A4        	bcs	GME		; TOO LARGE, "MEM FULL ERROR"
  3062 00:B063: 06 AD        	asl	STRNG2		; NEXT BIT OF MUTLPLICAND
  3063 00:B065: 26 AE        	rol	STRNG2+1	;	INTO CARRY
  3064 00:B067: 90 0B        	bcc	MULTIP2		; BIT=0, DON'T NEED TO ADD
  3065 00:B069: 18           	clc			; BIT=1, ADD INTO PARTIAL PRODUCT
  3066 00:B06A: 8A           	txa
  3067 00:B06B: 65 64        	adc	RESULT+2
  3068 00:B06D: AA           	tax
  3069 00:B06E: 98           	tya
  3070 00:B06F: 65 65        	adc	RESULT+3
  3071 00:B071: A8           	tay
  3072 00:B072: B0 93        	bcs	GME		; TOO LARGE, "MEM FULL ERROR"
  3073                        MULTIP2:
  3074 00:B074: C6 99        	dec	INDX		; 16-BITS YET?
  3075 00:B076: D0 E3        	bne	MULTIP1		; NO, KEEP SHUFFLING
  3076 00:B078: 60           	rts			; YES, PRODUCT IN Y,X AND A,X
  3077                        
  3078                        
  3079                        ; ----------------------------------------------------------------------------
  3080                        ; "FRE" FUNCTION
  3081                        ;
  3082                        ; COLLECTS GARBAGE AND RETURNS # BYTES OF MEMORY LEFT
  3083                        ; ----------------------------------------------------------------------------
  3084 00:B079: A5 11        FRE:	lda	VALTYP		; LOOK AT VALUE OF ARGUMENT
  3085 00:B07B: F0 03        	beq	FRE_1		; =0 MEANS REAL, =$FF MEANS STRING
  3086 00:B07D: 20 E3 B2     	jsr	FREFAC		; STRING, SO SET IT FREE IS TEMP
  3087 00:B080: 20 67 B1     FRE_1:	jsr	GARBAG		; COLLECT ALL THE GARBAGE IN SIGHT
  3088 00:B083: 38           	sec			; COMPUTE SPACE BETWEEN ARRAYS AND
  3089 00:B084: A5 6F        	lda	FRETOP		; STRING TEMP AREA
  3090 00:B086: E5 6D        	sbc	STREND
  3091 00:B088: A8           	tay
  3092 00:B089: A5 70        	lda	FRETOP+1
  3093 00:B08B: E5 6E        	sbc	STREND+1	; FREE SPACE IN Y,A
  3094                        ; FALL INTO GIVAYF TO FLOAT THE VALUE
  3095                        ; NOTE THAT VALUES OVER 32767 WILL RETURN AS NEGATIVE
  3096                        
  3097                        
  3098                        ; ----------------------------------------------------------------------------
  3099                        ; FLOAT THE SIGNED INTEGER IN A,Y
  3100                        ; ----------------------------------------------------------------------------
  3101 00:B08D: A2 00        GIVAYF:	ldx	#0		; MARK FAC VALUE TYPE REAL
  3102 00:B08F: 86 11        	stx	VALTYP
  3103 00:B091: 85 9E        	sta	FAC+1		; SAVE VALUE FROM A,Y IN MANTISSA
  3104 00:B093: 84 9F        	sty	FAC+2
  3105 00:B095: A2 90        	ldx	#$90		; SET EXPONENT TO 2^16
  3106 00:B097: 4C 5D B8     	jmp	FLOAT1		; CONVERT TO SIGNED FP
  3107                        
  3108                        
  3109                        ; ----------------------------------------------------------------------------
  3110                        ; FLOAT (Y) INTO FAC, GIVING VALUE 0-255
  3111                        ; ----------------------------------------------------------------------------
  3112 00:B09A: A9 00        SNGFLT:	lda	#0		; MSB = 0
  3113 00:B09C: F0 EF        	beq	GIVAYF		; ...ALWAYS
  3114                        
  3115                        
  3116                        ; ----------------------------------------------------------------------------
  3117                        ; CHECK FOR DIRECT OR RUNNING MODE
  3118                        ; GIVING ERROR IF DIRECT MODE
  3119                        ; ----------------------------------------------------------------------------
  3120 00:B09E: A6 76        ERRDIR:	ldx	CURLIN+1	; =$FF IF DIRECT MODE
  3121 00:B0A0: E8           	inx			; MAKES $FF INTO ZERO
  3122 00:B0A1: D0 A4        	bne	RTS9		; RETURN IF RUNNING MODE
  3123 00:B0A3: A2 5B        	ldx	#ERR_ILLDIR	; DIRECT MODE, GIVE ERROR
  3124 00:B0A5: 4C DA A2     	jmp	ERROR
  3125                        
  3126                        
  3127                        ; ----------------------------------------------------------------------------
  3128                        ; "STR$" FUNCTION
  3129                        ; ----------------------------------------------------------------------------
  3130 00:B0A8: 20 37 AB     STR:	jsr	CHKNUM		; EXPRESSION MUST BE NUMERIC
  3131 00:B0AB: A0 00        	ldy	#0		; START STRING AT STACK-1 ($00FF) SO STRLIT CAN DIFFRENTIATE STR$ CALLS
  3132 00:B0AD: 20 F3 B9     	jsr	FOUT1		; CONVERT FAC TO STRING
  3133 00:B0B0: 68           	pla			; POP RETURN OFF STACK
  3134 00:B0B1: 68           	pla
  3135 00:B0B2: A9 FF        	lda	#<(STACK-1)	; POINT TO STACK-1
  3136 00:B0B4: A0 00        	ldy	#>(STACK-1)	; (WHICH=0)
  3137 00:B0B6: F0 12        	beq	STRLIT		; ...ALWAYS, CREATE DESC & MOVE STRING
  3138                        
  3139                        
  3140                        ; ----------------------------------------------------------------------------
  3141                        ; GET SPACE AND MAKE DESCRIPTOR FOR STRING WHOSE
  3142                        ; ADDRESS IS IN FAC+3,4 AND WHOSE LENGTH IS IN A-REG
  3143                        ; ----------------------------------------------------------------------------
  3144 00:B0B8: A6 A0        STRINI:	ldx	FAC+3		; Y,X = STRING ADDRESS
  3145 00:B0BA: A4 A1        	ldy	FAC+4
  3146 00:B0BC: 86 8C        	stx	DSCPTR
  3147 00:B0BE: 84 8D        	sty	DSCPTR+1
  3148                        
  3149                        
  3150                        ; ----------------------------------------------------------------------------
  3151                        ; GET SPACE AND MAKE DESCRIPTOR FOR STRING WHOSE
  3152                        ; ADDRESS IS IN Y,X AND WHOSE LENGTH IS IN A-REG
  3153                        ; ----------------------------------------------------------------------------
  3154 00:B0C0: 20 35 B1     STRSPA:	jsr	GETSPA		; A HOLDS LENGTH
  3155 00:B0C3: 86 9E        	stx	FAC+1		; SAVE DESCRIPTOR IN FAC
  3156 00:B0C5: 84 9F        	sty	FAC+2		; ---FAC--- --FAC+1-- --FAC+2--
  3157 00:B0C7: 85 9D        	sta	FAC		; <LENGTH>  <ADDR-LO> <ADDR-HI>
  3158 00:B0C9: 60           	rts
  3159                        
  3160                        
  3161                        ; ----------------------------------------------------------------------------
  3162                        ; BUILD A DESCRIPTOR FOR STRING STARTING AT Y,A
  3163                        ; AND TERMINATED BY $00 OR QUOTATION MARK
  3164                        ; RETURN WITH DESCRIPTOR IN A TEMPORARY
  3165                        ; AND ADDRESS OF DESCRIPTOR IN FAC+3,4
  3166                        ; ----------------------------------------------------------------------------
  3167 00:B0CA: A2 22        STRLIT:	ldx	#'"'		; SET UP LITERAL SCAN TO STOP ON
  3168 00:B0CC: 86 0D        	stx	CHARAC		; QUOTATION MARK OR $00
  3169 00:B0CE: 86 0E        	stx	ENDCHR
  3170                        
  3171                        
  3172                        ; ----------------------------------------------------------------------------
  3173                        ; BUILD A DESCRIPTOR FOR STRING STARTING AT Y,A
  3174                        ; AND TERMINATED BY $00, (CHARAC), OR (ENDCHR)
  3175                        ;
  3176                        ; RETURN WITH DESCRIPTOR IN A TEMPORARY
  3177                        ; AND ADDRESS OF DESCRIPTOR IN FAC+3,4
  3178                        ; ----------------------------------------------------------------------------
  3179 00:B0D0: 85 AB        STRLT2:	sta	STRNG1		; SAVE ADDRESS OF STRING
  3180 00:B0D2: 84 AC        	sty	STRNG1+1
  3181 00:B0D4: 85 9E        	sta	FAC+1		; ...AGAIN
  3182 00:B0D6: 84 9F        	sty	FAC+2
  3183 00:B0D8: A0 FF        	ldy	#$FF
  3184                        STRLT21:
  3185 00:B0DA: C8           	iny			; FIND END OF STRING
  3186 00:B0DB: B1 AB        	lda	(STRNG1),y	; NEXT STRING CHAR
  3187 00:B0DD: F0 0C        	beq	STRLT23		; END OF STRING
  3188 00:B0DF: C5 0D        	cmp	CHARAC		; ALTERNATE TERMINATOR # 1?
  3189 00:B0E1: F0 04        	beq	STRLT22		; YES
  3190 00:B0E3: C5 0E        	cmp	ENDCHR		; ALTERNATE TERMINATOR # 2?
  3191 00:B0E5: D0 F3        	bne	STRLT21		; NO, KEEP SCANNING
  3192                        STRLT22:
  3193 00:B0E7: C9 22        	cmp	#'"'		; IS STRING ENDED WITH QUOTE MARK?
  3194 00:B0E9: F0 01        	beq	STRLT24		; YES, C=1 TO INCLUDE " IN STRING
  3195                        STRLT23:
  3196 00:B0EB: 18           	clc
  3197                        STRLT24:
  3198 00:B0EC: 84 9D        	sty	FAC		; SAVE LENGTH
  3199 00:B0EE: 98           	tya
  3200 00:B0EF: 65 AB        	adc	STRNG1		; COMPUTE ADDRESS OF END OF STRING
  3201 00:B0F1: 85 AD        	sta	STRNG2		;	(OF 00 BYTE, OR JUST AFTER ")
  3202 00:B0F3: A6 AC        	ldx	STRNG1+1
  3203 00:B0F5: 90 01        	bcc	STRLT25
  3204 00:B0F7: E8           	inx
  3205                        STRLT25:
  3206 00:B0F8: 86 AE        	stx	STRNG2+1
  3207 00:B0FA: A5 AC        	lda	STRNG1+1	; WHERE DOES THE STRING START?
  3208 00:B0FC: F0 04        	beq	STRLT26		; PAGE 0, MUST BE FROM STR$ FUNCTION
  3209 00:B0FE: C9 02        	cmp	#2		; PAGE 2?
  3210 00:B100: D0 0B        	bne	PUTNEW		; NO, NOT PAGE 0 OR 2
  3211                        STRLT26:
  3212 00:B102: 98           	tya			; LENGTH OF STRING
  3213 00:B103: 20 B8 B0     	jsr	STRINI		; MAKE SPACE FOR STRING
  3214 00:B106: A6 AB        	ldx	STRNG1
  3215 00:B108: A4 AC        	ldy	STRNG1+1
  3216 00:B10A: 20 C5 B2     	jsr	MOVSTR		; MOVE IT IN
  3217                        
  3218                        
  3219                        ; ----------------------------------------------------------------------------
  3220                        ; STORE DESCRIPTOR IN TEMPORARY DESCRIPTOR STACK
  3221                        ;
  3222                        ; THE DESCRIPTOR IS NOW IN FAC, FAC+1, FAC+2
  3223                        ; PUT ADDRESS OF TEMP DESCRIPTOR IN FAC+3,4
  3224                        ; ----------------------------------------------------------------------------
  3225 00:B10D: A6 52        PUTNEW:	ldx	TEMPPT		; POINTER TO NEXT TEMP STRING SLOT
  3226 00:B10F: E0 5E        	cpx	#TEMPST+9	; MAX OF 3 TEMP STRINGS
  3227 00:B111: D0 05        	bne	PUTEMP		; ROOM FOR ANOTHER ONE
  3228 00:B113: A2 76        	ldx	#ERR_FRMCPX	; TOO MANY, FORMULA TOO COMPLEX
  3229 00:B115: 4C DA A2     JERR:	jmp	ERROR
  3230                        ; ----------------------------------------------------------------------------
  3231 00:B118: A5 9D        PUTEMP:	lda	FAC		; COPY TEMP DESCRIPTOR INTO TEMP STACK
  3232 00:B11A: 95 00        	sta	<0,x
  3233 00:B11C: A5 9E        	lda	FAC+1
  3234 00:B11E: 95 01        	sta	<1,x
  3235 00:B120: A5 9F        	lda	FAC+2
  3236 00:B122: 95 02        	sta	<2,x
  3237 00:B124: A0 00        	ldy	#0
  3238 00:B126: 86 A0        	stx	FAC+3		; ADDRESS OF TEMP DESCRIPTOR
  3239 00:B128: 84 A1        	sty	FAC+4		; IN Y,X AND FAC+3,4
  3240 00:B12A: 88           	dey			; Y=$FF
  3241 00:B12B: 84 11        	sty	VALTYP		; FLAG (FAC ) AS STRING
  3242 00:B12D: 86 53        	stx	LASTPT		; INDEX OF LAST POINTER
  3243 00:B12F: E8           	inx			; UPDATE FOR NEXT TEMP ENTRY
  3244 00:B130: E8           	inx
  3245 00:B131: E8           	inx
  3246 00:B132: 86 52        	stx	TEMPPT
  3247 00:B134: 60           	rts
  3248                        
  3249                        
  3250                        ; ----------------------------------------------------------------------------
  3251                        ; MAKE SPACE FOR STRING AT BOTTOM OF STRING SPACE
  3252                        ; (A)=# BYTES SPACE TO MAKE
  3253                        ;
  3254                        ; RETURN WITH (A) SAME,
  3255                        ;	AND Y,X = ADDRESS OF SPACE ALLOCATED
  3256                        ; ----------------------------------------------------------------------------
  3257 00:B135: 46 13        GETSPA:	lsr	GARFLG		; CLEAR SIGNBIT OF FLAG
  3258                        GETSPA1:
  3259 00:B137: 48           	pha			; A HOLDS LENGTH
  3260 00:B138: 49 FF        	eor	#$FF		; GET -LENGTH
  3261 00:B13A: 38           	sec
  3262 00:B13B: 65 6F        	adc	FRETOP		; COMPUTE STARTING ADDRESS OF SPACE
  3263 00:B13D: A4 70        	ldy	FRETOP+1	; FOR THE STRING
  3264 00:B13F: B0 01        	bcs	GETSPA2
  3265 00:B141: 88           	dey
  3266                        GETSPA2:
  3267 00:B142: C4 6E        	cpy	STREND+1	; SEE IF FITS IN REMAINING MEMORY
  3268 00:B144: 90 11        	bcc	GETSPA4		; NO, TRY GARBAGE
  3269 00:B146: D0 04        	bne	GETSPA3		; YES, IT FITS
  3270 00:B148: C5 6D        	cmp	STREND		; HAVE TO CHECK LOWER BYTES
  3271 00:B14A: 90 0B        	bcc	GETSPA4		; NOT ENUF ROOM YET
  3272                        GETSPA3:
  3273 00:B14C: 85 6F        	sta	FRETOP		; THERE IS ROOM SO SAVE NEW FRETOP
  3274 00:B14E: 84 70        	sty	FRETOP+1
  3275 00:B150: 85 71        	sta	FRESPC
  3276 00:B152: 84 72        	sty	FRESPC+1
  3277 00:B154: AA           	tax			; ADDR IN Y,X
  3278 00:B155: 68           	pla			; LENGTH IN A
  3279 00:B156: 60           	rts
  3280                        GETSPA4:
  3281 00:B157: A2 30        	ldx	#ERR_MEMFULL
  3282 00:B159: A5 13        	lda	GARFLG		; GARBAGE DONE YET?
  3283 00:B15B: 30 B8        	bmi	JERR		; YES, MEMORY IS REALLY FULL
  3284 00:B15D: 20 67 B1     	jsr	GARBAG		; NO, TRY COLLECTING NOW
  3285 00:B160: A9 80        	lda	#$80		; FLAG THAT COLLECTED GARBAGE ALREADY
  3286 00:B162: 85 13        	sta	GARFLG
  3287 00:B164: 68           	pla			; GET STRING LENGTH AGAIN
  3288 00:B165: D0 D0        	bne	GETSPA1		; ...ALWAYS
  3289                        
  3290                        
  3291                        ; ----------------------------------------------------------------------------
  3292                        ; SHOVE ALL REFERENCED STRINGS AS HIGH AS POSSIBLE
  3293                        ; IN MEMORY (AGAINST HIMEM), FREEING UP SPACE
  3294                        ; BELOW STRING AREA DOWN TO STREND.
  3295                        ; ----------------------------------------------------------------------------
  3296 00:B167: A6 73        GARBAG:	ldx	MEMSIZ		; COLLECT FROM TOP DOWN
  3297 00:B169: A5 74        	lda	MEMSIZ+1
  3298                        FINDHIGHESTSTRING:
  3299 00:B16B: 86 6F        	stx	FRETOP		; ONE PASS THROUGH ALL VARS
  3300 00:B16D: 85 70        	sta	FRETOP+1	; FOR EACH ACTIVE STRING!
  3301 00:B16F: A0 00        	ldy	#0
  3302 00:B171: 84 8B        	sty	FNCNAM+1	; FLAG IN CASE NO STRINGS TO COLLECT
  3303 00:B173: A5 6D        	lda	STREND
  3304 00:B175: A6 6E        	ldx	STREND+1
  3305 00:B177: 85 9B        	sta	LOWTR
  3306 00:B179: 86 9C        	stx	LOWTR+1
  3307                        ; ----------------------------------------------------------------------------
  3308                        ; START BY COLLECTING TEMPORARIES
  3309                        ; ----------------------------------------------------------------------------
  3310 00:B17B: A9 55        	lda	#<TEMPST
  3311 00:B17D: A2 00        	ldx	#>TEMPST
  3312 00:B17F: 85 5E        	sta	INDEX
  3313 00:B181: 86 5F        	stx	INDEX+1
  3314                        GARBAG1:
  3315 00:B183: C5 52        	cmp	TEMPPT		; FINISHED WITH TEMPS YET?
  3316 00:B185: F0 05        	beq	GARBAG2		; YES, NOW DO SIMPLE VARIABLES
  3317 00:B187: 20 06 B2     	jsr	CHECK_VARIABLE	; DO A TEMP
  3318 00:B18A: F0 F7        	beq	GARBAG1		; ...ALWAYS
  3319                        ; ----------------------------------------------------------------------------
  3320                        ; NOW COLLECT SIMPLE VARIABLES
  3321                        ; ----------------------------------------------------------------------------
  3322                        GARBAG2:
  3323 00:B18C: A9 07        	lda	#7		; LENGTH OF EACH VARIABLE IS 7 BYTES
  3324 00:B18E: 85 8F        	sta	DSCLEN
  3325 00:B190: A5 69        	lda	VARTAB		; START AT BEGINNING OF VARTAB
  3326 00:B192: A6 6A        	ldx	VARTAB+1
  3327 00:B194: 85 5E        	sta	INDEX
  3328 00:B196: 86 5F        	stx	INDEX+1
  3329                        GARBAG3:
  3330 00:B198: E4 6C        	cpx	ARYTAB+1	; FINISHED WITH SIMPLE VARIABLES?
  3331 00:B19A: D0 04        	bne	GARBAG4		; NO
  3332 00:B19C: C5 6B        	cmp	ARYTAB		; MAYBE, CHECK LO-BYTE
  3333 00:B19E: F0 05        	beq	GARBAG5		; YES, NOW DO ARRAYS
  3334                        GARBAG4:
  3335 00:B1A0: 20 FC B1     	jsr	CHECK_SIMPLE_VARIABLE
  3336 00:B1A3: F0 F3        	beq	GARBAG3		; ...ALWAYS
  3337                        ; ----------------------------------------------------------------------------
  3338                        ; NOW COLLECT ARRAY VARIABLES
  3339                        ; ----------------------------------------------------------------------------
  3340                        GARBAG5:
  3341 00:B1A5: 85 94        	sta	ARYPNT
  3342 00:B1A7: 86 95        	stx	ARYPNT+1
  3343 00:B1A9: A9 03        	lda	#3		; DESCRIPTORS IN ARRAYS ARE 3-BYTES EACH
  3344 00:B1AB: 85 8F        	sta	DSCLEN
  3345                        GARBAG6:
  3346 00:B1AD: A5 94        	lda	ARYPNT		; COMPARE TO END OF ARRAYS
  3347 00:B1AF: A6 95        	ldx	ARYPNT+1
  3348                        GARBAG7:
  3349 00:B1B1: E4 6E        	cpx	STREND+1	; FINISHED WITH ARRAYS YET?
  3350 00:B1B3: D0 07        	bne	GARBAG8		; NOT YET
  3351 00:B1B5: C5 6D        	cmp	STREND		; MAYBE, CHECK LO-BYTE
  3352 00:B1B7: D0 03        	bne	GARBAG8		; NOT FINISHED YET
  3353 00:B1B9: 4C 45 B2     	jmp	MOVE_HIGHEST_STRING_TO_TOP	; FINISHED
  3354                        GARBAG8:
  3355 00:B1BC: 85 5E        	sta	INDEX		; SET UP PNTR TO START OF ARRAY
  3356 00:B1BE: 86 5F        	stx	INDEX+1
  3357 00:B1C0: A0 00        	ldy	#0		; POINT AT NAME OF ARRAY
  3358 00:B1C2: B1 5E        	lda	(INDEX),y
  3359 00:B1C4: AA           	tax			; 1ST LETTER OF NAME IN X-REG
  3360 00:B1C5: C8           	iny
  3361 00:B1C6: B1 5E        	lda	(INDEX),y
  3362 00:B1C8: 08           	php			; STATUS FROM SECOND LETTER OF NAME
  3363 00:B1C9: C8           	iny
  3364 00:B1CA: B1 5E        	lda	(INDEX),y	; OFFSET TO NEXT ARRAY
  3365 00:B1CC: 65 94        	adc	ARYPNT		; (CARRY ALWAYS CLEAR)
  3366 00:B1CE: 85 94        	sta	ARYPNT		; CALCULATE START OF NEXT ARRAY
  3367 00:B1D0: C8           	iny
  3368 00:B1D1: B1 5E        	lda	(INDEX),y	; HI-BYTE OF OFFSET
  3369 00:B1D3: 65 95        	adc	ARYPNT+1
  3370 00:B1D5: 85 95        	sta	ARYPNT+1
  3371 00:B1D7: 28           	plp			; GET STATUS FROM 2ND CHAR OF NAME
  3372 00:B1D8: 10 D3        	bpl	GARBAG6		; NOT A STRING ARRAY
  3373 00:B1DA: 8A           	txa			; SET STATUS WITH 1ST CHAR OF NAME
  3374 00:B1DB: 30 D0        	bmi	GARBAG6		; NOT A STRING ARRAY
  3375 00:B1DD: C8           	iny
  3376 00:B1DE: B1 5E        	lda	(INDEX),y	; # OF DIMENSIONS FOR THIS ARRAY
  3377 00:B1E0: A0 00        	ldy	#0
  3378 00:B1E2: 0A           	asl	a		; PREAMBLE SIZE = 2*#DIMS + 5
  3379 00:B1E3: 69 05        	adc	#5
  3380 00:B1E5: 65 5E        	adc	INDEX		; MAKE INDEX POINT AT FIRST ELEMENT
  3381 00:B1E7: 85 5E        	sta	INDEX		; 	IN THE ARRAY
  3382 00:B1E9: 90 02        	bcc	GARBAG9
  3383 00:B1EB: E6 5F        	inc	INDEX+1
  3384                        GARBAG9:
  3385 00:B1ED: A6 5F        	ldx	INDEX+1		; STEP THRU EACH STRING IN THIS ARRAY
  3386                        GARBAG10:
  3387 00:B1EF: E4 95        	cpx	ARYPNT+1	; ARRAY DONE?
  3388 00:B1F1: D0 04        	bne	GARBAG11		; NO, PROCESS NEXT ELEMENT
  3389 00:B1F3: C5 94        	cmp	ARYPNT		; MAYBE, CHECK LO-BYTE
  3390 00:B1F5: F0 BA        	beq	GARBAG7		; YES, MOVE TO NEXT ARRAY
  3391                        GARBAG11:
  3392 00:B1F7: 20 06 B2     	jsr	CHECK_VARIABLE	; PROCESS THE ARRAY
  3393 00:B1FA: F0 F3        	beq	GARBAG10		; ...ALWAYS
  3394                        
  3395                        
  3396                        ; ----------------------------------------------------------------------------
  3397                        ; PROCESS A SIMPLE VARIABLE
  3398                        ; ----------------------------------------------------------------------------
  3399                        CHECK_SIMPLE_VARIABLE:
  3400 00:B1FC: B1 5E        	lda	(INDEX),y	; LOOK AT 1ST CHAR OF NAME
  3401 00:B1FE: 30 35        	bmi	CHECK_BUMP	; NOT A STRING VARIABLE
  3402 00:B200: C8           	iny
  3403 00:B201: B1 5E        	lda	(INDEX),y	; LOOK AT 2ND CHAR OF NAME
  3404 00:B203: 10 30        	bpl	CHECK_BUMP	; NOT A STRING VARIABLE
  3405 00:B205: C8           	iny
  3406                        
  3407                        
  3408                        ; ----------------------------------------------------------------------------
  3409                        ; IF STRING IS NOT EMPTY, CHECK IF IT IS HIGHEST
  3410                        ; ----------------------------------------------------------------------------
  3411                        CHECK_VARIABLE:
  3412 00:B206: B1 5E        	lda	(INDEX),y	; GET LENGTH OF STRING
  3413 00:B208: F0 2B        	beq	CHECK_BUMP	; IGNORE STRING IF LENGTH IS ZERO
  3414 00:B20A: C8           	iny
  3415 00:B20B: B1 5E        	lda	(INDEX),y	; GET ADDRESS OF STRING
  3416 00:B20D: AA           	tax
  3417 00:B20E: C8           	iny
  3418 00:B20F: B1 5E        	lda	(INDEX),y
  3419 00:B211: C5 70        	cmp	FRETOP+1	; CHECK IF ALREADY COLLECTED
  3420 00:B213: 90 06        	bcc	CHECK_V1		; NO, BELOW FRETOP
  3421 00:B215: D0 1E        	bne	CHECK_BUMP	; YES, ABOVE FRETOP
  3422 00:B217: E4 6F        	cpx	FRETOP		; MAYBE, CHECK LO-BYTE
  3423 00:B219: B0 1A        	bcs	CHECK_BUMP	; YES, ABOVE FRETOP
  3424                        CHECK_V1:
  3425 00:B21B: C5 9C        	cmp	LOWTR+1		; ABOVE HIGHEST STRING FOUND?
  3426 00:B21D: 90 16        	bcc	CHECK_BUMP	; NO, IGNORE FOR NOW
  3427 00:B21F: D0 04        	bne	CHECK_V2		; YES, THIS IS THE NEW HIGHEST
  3428 00:B221: E4 9B        	cpx	LOWTR		; MAYBE, TRY LO-BYTE
  3429 00:B223: 90 10        	bcc	CHECK_BUMP	; NO, IGNORE FOR NOW
  3430                        CHECK_V2:
  3431 00:B225: 86 9B        	stx	LOWTR		; MAKE THIS THE HIGHEST STRING
  3432 00:B227: 85 9C        	sta	LOWTR+1
  3433 00:B229: A5 5E        	lda	INDEX		; SAVE ADDRESS OF DESCRIPTOR TOO
  3434 00:B22B: A6 5F        	ldx	INDEX+1
  3435 00:B22D: 85 8A        	sta	FNCNAM
  3436 00:B22F: 86 8B        	stx	FNCNAM+1
  3437 00:B231: A5 8F        	lda	DSCLEN
  3438 00:B233: 85 91        	sta	LENGTH
  3439                        
  3440                        
  3441                        ; ----------------------------------------------------------------------------
  3442                        ; ADD (DSCLEN) TO PNTR IN INDEX
  3443                        ; RETURN WITH Y=0, PNTR ALSO IN X,A
  3444                        ; ----------------------------------------------------------------------------
  3445                        CHECK_BUMP:
  3446 00:B235: A5 8F        	lda	DSCLEN		; BUMP TO NEXT VARIABLE
  3447 00:B237: 18           	clc
  3448 00:B238: 65 5E        	adc	INDEX
  3449 00:B23A: 85 5E        	sta	INDEX
  3450 00:B23C: 90 02        	bcc	CHECK_EXIT
  3451 00:B23E: E6 5F        	inc	INDEX+1
  3452                        ; ----------------------------------------------------------------------------
  3453                        CHECK_EXIT:
  3454 00:B240: A6 5F        	ldx	INDEX+1
  3455 00:B242: A0 00        	ldy	#0
  3456 00:B244: 60           	rts
  3457                        
  3458                        
  3459                        ; ----------------------------------------------------------------------------
  3460                        ; FOUND HIGHEST NON-EMPTY STRING, SO MOVE IT
  3461                        ; TO TOP AND GO BACK FOR ANOTHER
  3462                        ; ----------------------------------------------------------------------------
  3463                        MOVE_HIGHEST_STRING_TO_TOP:
  3464 00:B245: A6 8B        	ldx	FNCNAM+1	; ANY STRING FOUND?
  3465 00:B247: F0 F7        	beq	CHECK_EXIT	; NO, RETURN
  3466 00:B249: A5 91        	lda	LENGTH		; GET LENGTH OF VARIABLE ELEMENT
  3467 00:B24B: 29 04        	and	#4		; WAS 7 OR 3, MAKE 4 OR 0
  3468 00:B24D: 4A           	lsr	a		; 2 0R 0; IN SIMPLE VARIABLES,
  3469 00:B24E: A8           	tay			; NAME PRECEDES DESCRIPTOR
  3470 00:B24F: 85 91        	sta	LENGTH		; 2 OR 0
  3471 00:B251: B1 8A        	lda	(FNCNAM),y	; GET LENGTH FROM DESCRIPTOR
  3472 00:B253: 65 9B        	adc	LOWTR		; CARRY ALREADY CLEARED BY LSR
  3473 00:B255: 85 96        	sta	HIGHTR		; STRING IS BTWN (LOWTR) AND (HIGHTR)
  3474 00:B257: A5 9C        	lda	LOWTR+1
  3475 00:B259: 69 00        	adc	#0
  3476 00:B25B: 85 97        	sta	HIGHTR+1
  3477 00:B25D: A5 6F        	lda	FRETOP		; HIGH END DESTINATION
  3478 00:B25F: A6 70        	ldx	FRETOP+1
  3479 00:B261: 85 94        	sta	HIGHDS
  3480 00:B263: 86 95        	stx	HIGHDS+1
  3481 00:B265: 20 62 A2     	jsr	BLTU2		; MOVE STRING UP
  3482 00:B268: A4 91        	ldy	LENGTH		; FIX ITS DESCRIPTOR
  3483 00:B26A: C8           	iny			; POINT AT ADDRESS IN DESCRIPTOR
  3484 00:B26B: A5 94        	lda	HIGHDS		; STORE NEW ADDRESS
  3485 00:B26D: 91 8A        	sta	(FNCNAM),y
  3486 00:B26F: AA           	tax
  3487 00:B270: E6 95        	inc	HIGHDS+1	; CORRECT BLTU'S OVERSHOOT
  3488 00:B272: A5 95        	lda	HIGHDS+1
  3489 00:B274: C8           	iny
  3490 00:B275: 91 8A        	sta	(FNCNAM),y
  3491 00:B277: 4C 6B B1     	jmp	FINDHIGHESTSTRING
  3492                        
  3493                        
  3494                        ; ----------------------------------------------------------------------------
  3495                        ; CONCATENATE TWO STRINGS
  3496                        ; ----------------------------------------------------------------------------
  3497 00:B27A: A5 A1        CAT:	lda	FAC+4		; SAVE ADDRESS OF FIRST DESCRIPTOR
  3498 00:B27C: 48           	pha
  3499 00:B27D: A5 A0        	lda	FAC+3
  3500 00:B27F: 48           	pha
  3501 00:B280: 20 2D AC     	jsr	FRM_ELEMENT	; GET SECOND STRING ELEMENT
  3502 00:B283: 20 39 AB     	jsr	CHKSTR		; MUST BE A STRING
  3503 00:B286: 68           	pla			; RECOVER ADDRES OF 1ST DESCRIPTOR
  3504 00:B287: 85 AB        	sta	STRNG1
  3505 00:B289: 68           	pla
  3506 00:B28A: 85 AC        	sta	STRNG1+1
  3507 00:B28C: A0 00        	ldy	#0
  3508 00:B28E: B1 AB        	lda	(STRNG1),y	; ADD LENGTHS, GET CONCATENATED SIZE
  3509 00:B290: 18           	clc
  3510 00:B291: 71 A0        	adc	(FAC+3),y
  3511 00:B293: 90 05        	bcc	CAT_1		; OK IF < $100
  3512 00:B295: A2 6E        	ldx	#ERR_STRLONG
  3513 00:B297: 4C DA A2     	jmp	ERROR
  3514 00:B29A: 20 B8 B0     CAT_1:	jsr	STRINI		; GET SPACE FOR CONCATENATED STRINGS
  3515 00:B29D: 20 B7 B2     	jsr	MOVINS		; MOVE 1ST STRING
  3516 00:B2A0: A5 8C        	lda	DSCPTR
  3517 00:B2A2: A4 8D        	ldy	DSCPTR+1
  3518 00:B2A4: 20 E7 B2     	jsr	FRETMP
  3519 00:B2A7: 20 C9 B2     	jsr	MOVSTR1		; MOVE 2ND STRING
  3520 00:B2AA: A5 AB        	lda	STRNG1
  3521 00:B2AC: A4 AC        	ldy	STRNG1+1
  3522 00:B2AE: 20 E7 B2     	jsr	FRETMP
  3523 00:B2B1: 20 0D B1     	jsr	PUTNEW		; SET UP DESCRIPTOR
  3524 00:B2B4: 4C 62 AB     	jmp	FRMEVL2		; FINISH EXPRESSION
  3525                        
  3526                        
  3527                        ; ----------------------------------------------------------------------------
  3528                        ; GET STRING DESCRIPTOR POINTED AT BY (STRNG1)
  3529                        ; AND MOVE DESCRIBED STRING TO (FRESPC)
  3530                        ; ----------------------------------------------------------------------------
  3531 00:B2B7: A0 00        MOVINS:	ldy	#0
  3532 00:B2B9: B1 AB        	lda	(STRNG1),y
  3533 00:B2BB: 48           	pha			; LENGTH
  3534 00:B2BC: C8           	iny
  3535 00:B2BD: B1 AB        	lda	(STRNG1),y
  3536 00:B2BF: AA           	tax			; PUT STRING POINTER IN X,Y
  3537 00:B2C0: C8           	iny
  3538 00:B2C1: B1 AB        	lda	(STRNG1),y
  3539 00:B2C3: A8           	tay
  3540 00:B2C4: 68           	pla			; RETRIEVE LENGTH
  3541                        
  3542                        
  3543                        ; ----------------------------------------------------------------------------
  3544                        ; MOVE STRING AT (Y,X) WITH LENGTH (A)
  3545                        ; TO DESTINATION WHOSE ADDRESS IS IN FRESPC,FRESPC+1
  3546                        ; ----------------------------------------------------------------------------
  3547 00:B2C5: 86 5E        MOVSTR:	stx	INDEX		; PUT POINTER IN INDEX
  3548 00:B2C7: 84 5F        	sty	INDEX+1
  3549                        MOVSTR1:
  3550 00:B2C9: A8           	tay			; LENGTH TO Y-REG
  3551 00:B2CA: F0 0A        	beq	MOVSTR2		; IF LENGTH IS ZERO, FINISHED
  3552 00:B2CC: 48           	pha			; SAVE LENGTH ON STACK
  3553                        MOVSTR11:
  3554 00:B2CD: 88           	dey			; MOVE BYTES FROM (INDEX) TO (FRESPC)
  3555 00:B2CE: B1 5E        	lda	(INDEX),y
  3556 00:B2D0: 91 71        	sta	(FRESPC),y
  3557 00:B2D2: 98           	tya			; TEST IF ANY LEFT TO MOVE
  3558 00:B2D3: D0 F8        	bne	MOVSTR11		; YES, KEEP MOVING
  3559 00:B2D5: 68           	pla			; NO, FINISHED.  GET LENGTH
  3560                        MOVSTR2:
  3561 00:B2D6: 18           	clc			; AND ADD TO FRESPC, SO
  3562 00:B2D7: 65 71        	adc	FRESPC		; FRESPC POINTS TO NEXT HIGHER
  3563 00:B2D9: 85 71        	sta	FRESPC		; BYTE.  (USED BY CONCATENATION)
  3564 00:B2DB: 90 02        	bcc	MOVSTR4
  3565 00:B2DD: E6 72        	inc	FRESPC+1
  3566 00:B2DF: 60           MOVSTR4:	rts
  3567                        
  3568                        
  3569                        ; ----------------------------------------------------------------------------
  3570                        ; IF (FAC) IS A TEMPORARY STRING, RELEASE DESCRIPTOR
  3571                        ; ----------------------------------------------------------------------------
  3572 00:B2E0: 20 39 AB     FRESTR:	jsr	CHKSTR		; LAST RESULT A STRING?
  3573                        
  3574                        
  3575                        ; ----------------------------------------------------------------------------
  3576                        ; IF STRING DESCRIPTOR POINTED TO BY FAC+3,4 IS
  3577                        ; A TEMPORARY STRING, RELEASE IT.
  3578                        ; ----------------------------------------------------------------------------
  3579 00:B2E3: A5 A0        FREFAC:	lda	FAC+3		; GET DESCRIPTOR POINTER
  3580 00:B2E5: A4 A1        	ldy	FAC+4
  3581                        
  3582                        
  3583                        ; ----------------------------------------------------------------------------
  3584                        ; IF STRING DESCRIPTOR WHOSE ADDRESS IS IN Y,A IS
  3585                        ; A TEMPORARY STRING, RELEASE IT.
  3586                        ; ----------------------------------------------------------------------------
  3587 00:B2E7: 85 5E        FRETMP:	sta	INDEX		; SAVE THE ADDRESS OF THE DESCRIPTOR
  3588 00:B2E9: 84 5F        	sty	INDEX+1
  3589 00:B2EB: 20 18 B3     	jsr	FRETMS		; FREE DESCRIPTOR IF IT IS TEMPORARY
  3590 00:B2EE: 08           	php			; REMEMBER IF TEMP
  3591 00:B2EF: A0 00        	ldy	#0		; POINT AT LENGTH OF STRING
  3592 00:B2F1: B1 5E        	lda	(INDEX),y
  3593 00:B2F3: 48           	pha			; SAVE LENGTH ON STACK
  3594 00:B2F4: C8           	iny
  3595 00:B2F5: B1 5E        	lda	(INDEX),y
  3596 00:B2F7: AA           	tax			; GET ADDRESS OF STRING IN Y,X
  3597 00:B2F8: C8           	iny
  3598 00:B2F9: B1 5E        	lda	(INDEX),y
  3599 00:B2FB: A8           	tay
  3600 00:B2FC: 68           	pla			; LENGTH IN A
  3601 00:B2FD: 28           	plp			; RETRIEVE STATUS, Z=1 IF TEMP
  3602 00:B2FE: D0 13        	bne	FRETMP2		; NOT A TEMPORARY STRING
  3603 00:B300: C4 70        	cpy	FRETOP+1	; IS IT THE LOWEST STRING?
  3604 00:B302: D0 0F        	bne	FRETMP2		; NO
  3605 00:B304: E4 6F        	cpx	FRETOP
  3606 00:B306: D0 0B        	bne	FRETMP2		; NO
  3607 00:B308: 48           	pha			; YES, PUSH LENGTH AGAIN
  3608 00:B309: 18           	clc			; RECOVER THE SPACE USED BY
  3609 00:B30A: 65 6F        	adc	FRETOP		; THE STRING
  3610 00:B30C: 85 6F        	sta	FRETOP
  3611 00:B30E: 90 02        	bcc	FRETMP1
  3612 00:B310: E6 70        	inc	FRETOP+1
  3613                        FRETMP1:
  3614 00:B312: 68           	pla			; RETRIEVE LENGTH AGAIN
  3615                        FRETMP2:
  3616 00:B313: 86 5E        	stx	INDEX		; ADDRESS OF STRING IN Y,X
  3617 00:B315: 84 5F        	sty	INDEX+1		; LENGTH OF STRING IN A-REG
  3618 00:B317: 60           	rts
  3619                        
  3620                        
  3621                        ; ----------------------------------------------------------------------------
  3622                        ; RELEASE TEMPORARY DESCRIPTOR IF Y,A = LASTPT
  3623                        ; ----------------------------------------------------------------------------
  3624 00:B318: C4 54        FRETMS:	cpy	LASTPT+1	; COMPARE Y,A TO LATEST TEMP
  3625 00:B31A: D0 0C        	bne	FRETMS1		; NOT SAME ONE, CANNOT RELEASE
  3626 00:B31C: C5 53        	cmp	LASTPT
  3627 00:B31E: D0 08        	bne	FRETMS1		; NOT SAME ONE, CANNOT RELEASE
  3628 00:B320: 85 52        	sta	TEMPPT		; UPDATE TEMPT FOR NEXT TEMP
  3629 00:B322: E9 03        	sbc	#3		; BACK OFF LASTPT
  3630 00:B324: 85 53        	sta	LASTPT
  3631 00:B326: A0 00        	ldy	#0		; NOW Y,A POINTS TO TOP TEMP
  3632                        FRETMS1:
  3633 00:B328: 60           	rts			; Z=0 IF NOT TEMP, Z=1 IF TEMP
  3634                        
  3635                        
  3636                        ; ----------------------------------------------------------------------------
  3637                        ; "CHR$" FUNCTION
  3638                        ; ----------------------------------------------------------------------------
  3639 00:B329: 20 DE B3     CHRSTR:	jsr	CONINT		; CONVERT ARGUMENT TO BYTE IN X
  3640 00:B32C: 8A           	txa
  3641 00:B32D: 48           	pha			; SAVE IT
  3642 00:B32E: A9 01        	lda	#1		; GET SPACE FOR STRING OF LENGTH 1
  3643 00:B330: 20 C0 B0     	jsr	STRSPA
  3644 00:B333: 68           	pla			; RECALL THE CHARACTER
  3645 00:B334: A0 00        	ldy	#0		; PUT IN STRING
  3646 00:B336: 91 9E        	sta	(FAC+1),y
  3647 00:B338: 68           	pla			; POP RETURN ADDRESS
  3648 00:B339: 68           	pla
  3649 00:B33A: 4C 0D B1     	jmp	PUTNEW		; MAKE IT A TEMPORARY STRING
  3650                        
  3651                        
  3652                        ; ----------------------------------------------------------------------------
  3653                        ; "LEFT$" FUNCTION
  3654                        ; ----------------------------------------------------------------------------
  3655                        LEFTSTR:
  3656 00:B33D: 20 9C B3     	jsr	SUBSTRING_SETUP
  3657 00:B340: D1 8C        	cmp	(DSCPTR),y	; COMPARE 1ST PARAMETER TO LENGTH
  3658 00:B342: 98           	tya			; Y=A=0
  3659                        SUBSTRING1:
  3660 00:B343: 90 04        	bcc	LEFTSTR1		; 1ST PARAMETER SMALLER, USE IT
  3661 00:B345: B1 8C        	lda	(DSCPTR),y	; 1ST IS LONGER, USE STRING LENGTH
  3662 00:B347: AA           	tax			; IN X-REG
  3663 00:B348: 98           	tya			; Y=A=0 AGAIN
  3664                        LEFTSTR1:
  3665 00:B349: 48           	pha			; PUSH LEFT END OF SUBSTRING
  3666                        SUBSTRING2:
  3667 00:B34A: 8A           	txa
  3668                        SUBSTRING3:
  3669 00:B34B: 48           	pha			; PUSH LENGTH OF SUBSTRING
  3670 00:B34C: 20 C0 B0     	jsr	STRSPA		; MAKE ROOM FOR STRING OF (A) BYTES
  3671 00:B34F: A5 8C        	lda	DSCPTR		; RELEASE PARAMETER STRING IF TEMP
  3672 00:B351: A4 8D        	ldy	DSCPTR+1
  3673 00:B353: 20 E7 B2     	jsr	FRETMP
  3674 00:B356: 68           	pla			; GET LENGTH OF SUBSTRING
  3675 00:B357: A8           	tay			; IN Y-REG
  3676 00:B358: 68           	pla			; GET LEFT END OF SUBSTRING
  3677 00:B359: 18           	clc			; ADD TO POINTER TO STRING
  3678 00:B35A: 65 5E        	adc	INDEX
  3679 00:B35C: 85 5E        	sta	INDEX
  3680 00:B35E: 90 02        	bcc	SUBSTRING31
  3681 00:B360: E6 5F        	inc	INDEX+1
  3682                        SUBSTRING31:
  3683 00:B362: 98           	tya			; LENGTH
  3684 00:B363: 20 C9 B2     	jsr	MOVSTR1		; COPY STRING INTO SPACE
  3685 00:B366: 4C 0D B1     	jmp	PUTNEW		; ADD TO TEMPS
  3686                        
  3687                        
  3688                        ; ----------------------------------------------------------------------------
  3689                        ; "RIGHT$" FUNCTION
  3690                        ; ----------------------------------------------------------------------------
  3691                        RIGHTSTR:
  3692 00:B369: 20 9C B3     	jsr	SUBSTRING_SETUP
  3693 00:B36C: 18           	clc			; COMPUTE LENGTH-WIDTH OF SUBSTRING
  3694 00:B36D: F1 8C        	sbc	(DSCPTR),y	; TO GET STARTING POINT IN STRING
  3695 00:B36F: 49 FF        	eor	#$FF
  3696 00:B371: 4C 43 B3     	jmp	SUBSTRING1	; JOIN LEFT$
  3697                        
  3698                        
  3699                        ; ----------------------------------------------------------------------------
  3700                        ; "MID$" FUNCTION
  3701                        ; ----------------------------------------------------------------------------
  3702 00:B374: A9 FF        MIDSTR:	lda	#$FF		; FLAG WHETHER 2ND PARAMETER
  3703 00:B376: 85 A1        	sta	FAC+4
  3704 00:B378: 20 B7 00     	jsr	CHRGOT		; SEE IF ")" YET
  3705 00:B37B: C9 29        	cmp	#')'
  3706 00:B37D: F0 06        	beq	MIDSTR1		; YES, NO 2ND PARAMETER
  3707 00:B37F: 20 84 AC     	jsr	CHKCOM		; NO, MUST HAVE COMMA
  3708 00:B382: 20 DB B3     	jsr	GETBYT		; GET 2ND PARAM IN X-REG
  3709                        MIDSTR1:
  3710 00:B385: 20 9C B3     	jsr	SUBSTRING_SETUP
  3711 00:B388: CA           	dex			; 1ST PARAMETER - 1
  3712 00:B389: 8A           	txa
  3713 00:B38A: 48           	pha
  3714 00:B38B: 18           	clc
  3715 00:B38C: A2 00        	ldx	#0
  3716 00:B38E: F1 8C        	sbc	(DSCPTR),y
  3717 00:B390: B0 B8        	bcs	SUBSTRING2
  3718 00:B392: 49 FF        	eor	#$FF
  3719 00:B394: C5 A1        	cmp	FAC+4		; USE SMALLER OF TWO
  3720 00:B396: 90 B3        	bcc	SUBSTRING3
  3721 00:B398: A5 A1        	lda	FAC+4
  3722 00:B39A: B0 AF        	bcs	SUBSTRING3	; ...ALWAYS
  3723                        
  3724                        
  3725                        ; ----------------------------------------------------------------------------
  3726                        ; COMMON SETUP ROUTINE FOR LEFT$, RIGHT$, MID$:
  3727                        ; REQUIRE ")"; POP RETURN ADRS, GET DESCRIPTOR
  3728                        ; ADDRESS, GET 1ST PARAMETER OF COMMAND
  3729                        ; ----------------------------------------------------------------------------
  3730                        SUBSTRING_SETUP:
  3731 00:B39C: 20 7E AC     	jsr	CHKCLS		; REQUIRE ")"
  3732 00:B39F: 68           	pla			; SAVE RETURN ADDRESS
  3733 00:B3A0: A8           	tay			; IN Y-REG AND LENGTH
  3734 00:B3A1: 68           	pla
  3735 00:B3A2: 85 91        	sta	LENGTH
  3736 00:B3A4: 68           	pla			; POP PREVIOUS RETURN ADDRESS
  3737 00:B3A5: 68           	pla			; (FROM GOROUT).
  3738 00:B3A6: 68           	pla			; RETRIEVE 1ST PARAMETER
  3739 00:B3A7: AA           	tax
  3740 00:B3A8: 68           	pla			; GET ADDRESS OF STRING DESCRIPTOR
  3741 00:B3A9: 85 8C        	sta	DSCPTR
  3742 00:B3AB: 68           	pla
  3743 00:B3AC: 85 8D        	sta	DSCPTR+1
  3744 00:B3AE: A5 91        	lda	LENGTH		; RESTORE RETURN ADDRESS
  3745 00:B3B0: 48           	pha
  3746 00:B3B1: 98           	tya
  3747 00:B3B2: 48           	pha
  3748 00:B3B3: A0 00        	ldy	#0
  3749 00:B3B5: 8A           	txa			; GET 1ST PARAMETER IN A-REG
  3750 00:B3B6: F0 1D        	beq	GOIQ		; ERROR IF 0
  3751 00:B3B8: 60           	rts
  3752                        
  3753                        
  3754                        ; ----------------------------------------------------------------------------
  3755                        ; "LEN" FUNCTION
  3756                        ; ----------------------------------------------------------------------------
  3757 00:B3B9: 20 BF B3     LEN:	jsr	GETSTR		; GET LENTGH IN Y-REG, MAKE FAC NUMERIC
  3758 00:B3BC: 4C 9A B0     	jmp	SNGFLT		; FLOAT Y-REG INTO FAC
  3759                        
  3760                        
  3761                        ; ----------------------------------------------------------------------------
  3762                        ; IF LAST RESULT IS A TEMPORARY STRING, FREE IT
  3763                        ; MAKE VALTYP NUMERIC, RETURN LENGTH IN Y-REG
  3764                        ; ----------------------------------------------------------------------------
  3765 00:B3BF: 20 E0 B2     GETSTR:	jsr	FRESTR		; IF LAST RESULT IS A STRING, FREE IT
  3766 00:B3C2: A2 00        	ldx	#0		; MAKE VALTYP NUMERIC
  3767 00:B3C4: 86 11        	stx	VALTYP
  3768 00:B3C6: A8           	tay			; LENGTH OF STRING TO Y-REG
  3769 00:B3C7: 60           	rts
  3770                        
  3771                        
  3772                        ; ----------------------------------------------------------------------------
  3773                        ; "ASC" FUNCTION
  3774                        ; ----------------------------------------------------------------------------
  3775 00:B3C8: 20 BF B3     ASC:	jsr	GETSTR		; GET STRING, GET LENGTH IN Y-REG
  3776 00:B3CB: F0 08        	beq	GOIQ		; ERROR IF LENGTH 0
  3777 00:B3CD: A0 00        	ldy	#0
  3778 00:B3CF: B1 5E        	lda	(INDEX),y	; GET 1ST CHAR OF STRING
  3779 00:B3D1: A8           	tay
  3780 00:B3D2: 4C 9A B0     	jmp	SNGFLT		; FLOAT Y-REG INTO FAC
  3781                        ; ----------------------------------------------------------------------------
  3782 00:B3D5: 4C 35 AF     GOIQ:	jmp	IQERR		; ILLEGAL QUANTITY ERROR
  3783                        
  3784                        
  3785                        ; ----------------------------------------------------------------------------
  3786                        ; SCAN TO NEXT CHARACTER AND CONVERT EXPRESSION
  3787                        ; TO SINGLE BYTE IN X-REG
  3788                        ; ----------------------------------------------------------------------------
  3789 00:B3D8: 20 B1 00     GTBYTC:	jsr	CHRGET
  3790                        
  3791                        
  3792                        ; ----------------------------------------------------------------------------
  3793                        ; EVALUATE EXPRESSION AT TXTPTR, AND
  3794                        ; CONVERT IT TO SINGLE BYTE IN X-REG
  3795                        ; ----------------------------------------------------------------------------
  3796 00:B3DB: 20 34 AB     GETBYT:	jsr	FRMNUM
  3797                        
  3798                        
  3799                        ; ----------------------------------------------------------------------------
  3800                        ; CONVERT (FAC) TO SINGLE BYTE INTEGER IN X-REG
  3801                        ; ----------------------------------------------------------------------------
  3802 00:B3DE: 20 A4 AE     CONINT:	jsr	MKINT		; CONVERT IF IN RANGE -32767 TO +32767
  3803 00:B3E1: A6 A0        	ldx	FAC+3		; HI-BYTE MUST BE ZERO
  3804 00:B3E3: D0 F0        	bne	GOIQ		; VALUE > 255, ERROR
  3805 00:B3E5: A6 A1        	ldx	FAC+4		; VALUE IN X-REG
  3806 00:B3E7: 4C B7 00     	jmp	CHRGOT		; GET NEXT CHAR IN A-REG
  3807                        
  3808                        
  3809                        ; ----------------------------------------------------------------------------
  3810                        ; "VAL" FUNCTION
  3811                        ; ----------------------------------------------------------------------------
  3812 00:B3EA: 20 BF B3     VAL:	jsr	GETSTR		; GET POINTER TO STRING IN INDEX
  3813 00:B3ED: D0 03        	bne	VAL_1		; LENGTH NON-ZERO
  3814 00:B3EF: 4C 15 B5     	jmp	ZERO_FAC	; RETURN 0 IF LENGTH=0
  3815 00:B3F2: A6 B8        VAL_1:	ldx	TXTPTR		; SAVE CURRENT TXTPTR
  3816 00:B3F4: A4 B9        	ldy	TXTPTR+1
  3817 00:B3F6: 86 AD        	stx	STRNG2
  3818 00:B3F8: 84 AE        	sty	STRNG2+1
  3819 00:B3FA: A6 5E        	ldx	INDEX
  3820 00:B3FC: 86 B8        	stx	TXTPTR		; POINT TXTPTR TO START OF STRING
  3821 00:B3FE: 18           	clc
  3822 00:B3FF: 65 5E        	adc	INDEX		; ADD LENGTH
  3823 00:B401: 85 60        	sta	DEST		; POINT DEST TO END OF STRING + 1
  3824 00:B403: A6 5F        	ldx	INDEX+1
  3825 00:B405: 86 B9        	stx	TXTPTR+1
  3826 00:B407: 90 01        	bcc	VAL_2
  3827 00:B409: E8           	inx
  3828 00:B40A: 86 61        VAL_2:	stx	DEST+1
  3829 00:B40C: A0 00        	ldy	#0		; SAVE BYTE THAT FOLLOWS STRING
  3830 00:B40E: B1 60        	lda	(DEST),y	; ON STACK
  3831 00:B410: 48           	pha
  3832 00:B411: A9 00        	lda	#0		; AND STORE $00 IN ITS PLACE
  3833 00:B413: 91 60        	sta	(DEST),y
  3834 00:B415: 20 B7 00     	jsr	CHRGOT		; PRIME THE PUMP
  3835 00:B418: 20 09 B9     	jsr	FIN		; EVALUATE STRING
  3836 00:B41B: 68           	pla			; GET BYTE THAT SHOULD FOLLOW STRING
  3837 00:B41C: A0 00        	ldy	#0		; AND PUT IT BACK
  3838 00:B41E: 91 60        	sta	(DEST),y
  3839                        
  3840                        
  3841                        ; ----------------------------------------------------------------------------
  3842                        ; COPY STRNG2 INTO TXTPTR
  3843                        ; ----------------------------------------------------------------------------
  3844 00:B420: A6 AD        POINT:	ldx	STRNG2
  3845 00:B422: A4 AE        	ldy	STRNG2+1
  3846 00:B424: 86 B8        	stx	TXTPTR
  3847 00:B426: 84 B9        	sty	TXTPTR+1
  3848 00:B428: 60           	rts
  3849                        
  3850                        
  3851                        ; ----------------------------------------------------------------------------
  3852                        ; EVALUATE "EXP1,EXP2"
  3853                        ;
  3854                        ; CONVERT EXP1 TO 16-BIT NUMBER IN LINNUM
  3855                        ; CONVERT EXP2 TO 8-BIT NUMBER IN X-REG
  3856                        ; ----------------------------------------------------------------------------
  3857 00:B429: 20 34 AB     GTNUM:	jsr	FRMNUM
  3858 00:B42C: 20 35 B4     	jsr	GETADR
  3859                        
  3860                        
  3861                        ; ----------------------------------------------------------------------------
  3862                        ; EVALUATE ",EXPRESSION"
  3863                        ; CONVERT EXPRESSION TO SINGLE BYTE IN X-REG
  3864                        ; ----------------------------------------------------------------------------
  3865                        COMBYTE:
  3866 00:B42F: 20 84 AC     	jsr	CHKCOM		; MUST HAVE COMMA FIRST
  3867 00:B432: 4C DB B3     	jmp	GETBYT		; CONVERT EXPRESSION TO BYTE IN X-REG
  3868                        
  3869                        
  3870                        ; ----------------------------------------------------------------------------
  3871                        ; CONVERT (FAC) TO A 16-BIT VALUE IN LINNUM
  3872                        ; ----------------------------------------------------------------------------
  3873 00:B435: A5 9D        GETADR:	lda	FAC		; FAC < 2^16?
  3874 00:B437: C9 91        	cmp	#$91
  3875 00:B439: B0 9A        	bcs	GOIQ		; NO, ILLEGAL QUANTITY
  3876 00:B43B: 20 B1 B8     	jsr	QINT		; CONVERT TO INTEGER
  3877 00:B43E: A5 A0        	lda	FAC+3		; COPY IT INTO LINNUM
  3878 00:B440: A4 A1        	ldy	FAC+4
  3879 00:B442: 84 50        	sty	LINNUM		; TO LINNUM
  3880 00:B444: 85 51        	sta	LINNUM+1
  3881 00:B446: 60           	rts
  3882                        
  3883                        
  3884                        ; ----------------------------------------------------------------------------
  3885                        ; "PEEK" FUNCTION
  3886                        ; ----------------------------------------------------------------------------
  3887 00:B447: A5 50        PEEK:	lda	LINNUM		; SAVE (LINNUM) ON STACK DURING PEEK
  3888 00:B449: 48           	pha
  3889 00:B44A: A5 51        	lda	LINNUM+1
  3890 00:B44C: 48           	pha
  3891 00:B44D: 20 35 B4     	jsr	GETADR		; GET ADDRESS PEEKING AT
  3892 00:B450: A0 00        	ldy	#0
  3893 00:B452: B1 50        	lda	(LINNUM),y	; TAKE A QUICK LOOK
  3894 00:B454: A8           	tay			; VALUE IN Y-REG
  3895 00:B455: 68           	pla			; RESTORE LINNUM FROM STACK
  3896 00:B456: 85 51        	sta	LINNUM+1
  3897 00:B458: 68           	pla
  3898 00:B459: 85 50        	sta	LINNUM
  3899 00:B45B: 4C 9A B0     	jmp	SNGFLT		; FLOAT Y-REG INTO FAC
  3900                        
  3901                        
  3902                        ; ----------------------------------------------------------------------------
  3903                        ; "POKE" STATEMENT
  3904                        ; ----------------------------------------------------------------------------
  3905 00:B45E: 20 29 B4     POKE:	jsr	GTNUM		; GET THE ADDRESS AND VALUE
  3906 00:B461: 8A           	txa			; VALUE IN A,
  3907 00:B462: A0 00        	ldy	#0
  3908 00:B464: 91 50        	sta	(LINNUM),y	; STORE IT AWAY,
  3909 00:B466: 60           RTS10:	rts			; AND THAT'S ALL FOR TODAY
  3910                        
  3911                        
  3912                        ; ----------------------------------------------------------------------------
  3913                        ; ADD 0.5 TO FAC
  3914                        ; ----------------------------------------------------------------------------
  3915 00:B467: A9 21        FADDH_:	lda	#<CON_HALF	; FAC+1/2 -> FAC
  3916 00:B469: A0 BB        	ldy	#>CON_HALF
  3917 00:B46B: 4C 85 B4     	jmp	FADD
  3918                        
  3919                        
  3920                        ; ----------------------------------------------------------------------------
  3921                        ; FAC = (Y,A) - FAC
  3922                        ; ----------------------------------------------------------------------------
  3923 00:B46E: 20 A8 B6     FSUB:	jsr	LOAD_ARG_FROM_YA
  3924                        
  3925                        
  3926                        ; ----------------------------------------------------------------------------
  3927                        ; FAC = ARG - FAC
  3928                        ; ----------------------------------------------------------------------------
  3929 00:B471: A5 A2        FSUBT:	lda	FACSIGN		; COMPLEMENT FAC AND ADD
  3930 00:B473: 49 FF        	eor	#$FF
  3931 00:B475: 85 A2        	sta	FACSIGN
  3932 00:B477: 45 AA        	eor	ARGSIGN		; FIX SGNCPR TOO
  3933 00:B479: 85 AB        	sta	SGNCPR
  3934 00:B47B: A5 9D        	lda	FAC		; MAKE STATUS SHOW FAC EXPONENT
  3935 00:B47D: 4C 88 B4     	jmp	FADDT		; JOIN FADD
  3936                        
  3937                        
  3938                        ; ----------------------------------------------------------------------------
  3939                        ; SHIFT SMALLER ARGUMENT MORE THAN 7 BITS
  3940                        ; ----------------------------------------------------------------------------
  3941 00:B480: 20 B7 B5     FADD1:	jsr	SHIFT_RIGHT	; ALIGN RADIX BY SHIFTING
  3942 00:B483: 90 3C        	bcc	FADD3		; ...ALWAYS
  3943                        
  3944                        
  3945                        ; ----------------------------------------------------------------------------
  3946                        ; FAC = (Y,A) + FAC
  3947                        ; ----------------------------------------------------------------------------
  3948 00:B485: 20 A8 B6     FADD:	jsr	LOAD_ARG_FROM_YA
  3949                        
  3950                        
  3951                        ; ----------------------------------------------------------------------------
  3952                        ; FAC = ARG + FAC
  3953                        ; ----------------------------------------------------------------------------
  3954 00:B488: D0 03        FADDT:	bne	FADDT1		; FAC IS NON-ZERO
  3955 00:B48A: 4C 15 B8     	jmp	COPY_ARG_TO_FAC	; FAC = 0 + ARG
  3956 00:B48D: A6 AC        FADDT1:	ldx	FACEXTENSION
  3957 00:B48F: 86 92        	stx	ARGEXTENSION
  3958 00:B491: A2 A5        	ldx	#ARG		; SET UP TO SHIFT ARG
  3959 00:B493: A5 A5        	lda	ARG		; EXPONENT
  3960                        
  3961                        ; ----------------------------------------------------------------------------
  3962 00:B495: A8           FADD2:	tay
  3963 00:B496: F0 CE        	beq	RTS10		; IF ARG=0, WE ARE FINISHED
  3964 00:B498: 38           	sec
  3965 00:B499: E5 9D        	sbc	FAC		; GET DIFFNCE OF EXP
  3966 00:B49B: F0 24        	beq	FADD3		; GO ADD IF SAME EXP
  3967 00:B49D: 90 12        	bcc	FADD21		; ARG HAS SMALLER EXPONENT
  3968 00:B49F: 84 9D        	sty	FAC		; EXP HAS SMALLER EXPONENT
  3969 00:B4A1: A4 AA        	ldy	ARGSIGN
  3970 00:B4A3: 84 A2        	sty	FACSIGN
  3971 00:B4A5: 49 FF        	eor	#$FF		; COMPLEMENT SHIFT COUNT
  3972 00:B4A7: 69 00        	adc	#0		; CARRY WAS SET
  3973 00:B4A9: A0 00        	ldy	#0
  3974 00:B4AB: 84 92        	sty	ARGEXTENSION
  3975 00:B4AD: A2 9D        	ldx	#FAC		; SET UP TO SHIFT FAC
  3976 00:B4AF: D0 04        	bne	FADD22		; ...ALWAYS
  3977 00:B4B1: A0 00        FADD21:	ldy	#0
  3978 00:B4B3: 84 AC        	sty	FACEXTENSION
  3979 00:B4B5: C9 F9        FADD22:	cmp	#$F9		; SHIFT MORE THAN 7 BITS?
  3980 00:B4B7: 30 C7        	bmi	FADD1		; YES
  3981 00:B4B9: A8           	tay			; INDEX TO # OF SHIFTS
  3982 00:B4BA: A5 AC        	lda	FACEXTENSION
  3983 00:B4BC: 56 01        	lsr	<1,x		; START SHIFTING...
  3984 00:B4BE: 20 CE B5     	jsr	SHIFT_RIGHT4	; ...COMPLETE SHIFTING
  3985 00:B4C1: 24 AB        FADD3:  bit	SGNCPR		; DO FAC AND ARG HAVE SAME SIGNS?
  3986 00:B4C3: 10 57        	bpl	FADD4		; YES, ADD THE MANTISSAS
  3987 00:B4C5: A0 9D        	ldy	#FAC		; NO, SUBTRACT SMALLER FROM LARGER
  3988 00:B4C7: E0 A5        	cpx	#ARG		; WHICH WAS ADJUSTED?
  3989 00:B4C9: F0 02        	beq	FADD31		; IF ARG, DO FAC-ARG
  3990 00:B4CB: A0 A5        	ldy	#ARG		; IF FAC, DO ARG-FAC
  3991 00:B4CD: 38           FADD31:	sec			; SUBTRACT SMALLER FROM LARGER (WE HOPE)
  3992 00:B4CE: 49 FF        	eor	#$FF		; (IF EXPONENTS WERE EQUAL, WE MIGHT BE
  3993 00:B4D0: 65 92        	adc	ARGEXTENSION	; SUBTRACTING LARGER FROM SMALLER)
  3994 00:B4D2: 85 AC        	sta	FACEXTENSION
  3995 00:B4D4: B9 04 00     	lda	4,y
  3996 00:B4D7: F5 04        	sbc	<4,x
  3997 00:B4D9: 85 A1        	sta	FAC+4
  3998 00:B4DB: B9 03 00     	lda	3,y
  3999 00:B4DE: F5 03        	sbc	<3,x
  4000 00:B4E0: 85 A0        	sta	FAC+3
  4001 00:B4E2: B9 02 00     	lda	2,y
  4002 00:B4E5: F5 02        	sbc	<2,x
  4003 00:B4E7: 85 9F        	sta	FAC+2
  4004 00:B4E9: B9 01 00     	lda	1,y
  4005 00:B4EC: F5 01        	sbc	<1,x
  4006 00:B4EE: 85 9E        	sta	FAC+1
  4007                        
  4008                        
  4009                        ; ----------------------------------------------------------------------------
  4010                        ; NORMALIZE VALUE IN FAC
  4011                        ; ----------------------------------------------------------------------------
  4012                        NORMALIZE_FAC1:
  4013 00:B4F0: B0 03        	bcs	NORMALIZE_FAC2
  4014 00:B4F2: 20 65 B5     	jsr	COMPLEMENT_FAC
  4015                        ; ----------------------------------------------------------------------------
  4016                        NORMALIZE_FAC2:
  4017 00:B4F5: A0 00        	ldy	#0		; SHIFT UP SIGNIF DIGIT
  4018 00:B4F7: 98           	tya			; START A=0, COUNT SHIFTS IN A-REG
  4019 00:B4F8: 18           	clc
  4020                        NORMAL1:
  4021 00:B4F9: A6 9E        	ldx	FAC+1		; LOOK AT MOST SIGNIFICANT BYTE
  4022 00:B4FB: D0 4A        	bne	NORMALIZE_FAC4	; SOME 1-BITS HERE
  4023 00:B4FD: A6 9F        	ldx	FAC+2		; HI-BYTE OF MANTISSA STILL ZERO,
  4024 00:B4FF: 86 9E        	stx	FAC+1		; SO DO A FAST 8-BIT SHUFFLE
  4025 00:B501: A6 A0        	ldx	FAC+3
  4026 00:B503: 86 9F        	stx	FAC+2
  4027 00:B505: A6 A1        	ldx	FAC+4
  4028 00:B507: 86 A0        	stx	FAC+3
  4029 00:B509: A6 AC        	ldx	FACEXTENSION
  4030 00:B50B: 86 A1        	stx	FAC+4
  4031 00:B50D: 84 AC        	sty	FACEXTENSION	; ZERO EXTENSION BYTE
  4032 00:B50F: 69 08        	adc	#8		; BUMP SHIFT COUNT
  4033 00:B511: C9 20        	cmp	#32		; DONE 4 TIMES YET?
  4034 00:B513: D0 E4        	bne	NORMAL1		; NO, STILL MIGHT BE SOME 1'S (YES, VALUE OF FAC IS ZERO)
  4035                        
  4036                        
  4037                        ; ----------------------------------------------------------------------------
  4038                        ; SET FAC = 0
  4039                        ; (ONLY NECESSARY TO ZERO EXPONENT AND SIGN CELLS)
  4040                        ; ----------------------------------------------------------------------------
  4041                        ZERO_FAC:
  4042 00:B515: A9 00        	lda	#0
  4043                        ; ----------------------------------------------------------------------------
  4044                        STA_IN_FAC_SIGN_AND_EXP:
  4045 00:B517: 85 9D        	sta	FAC
  4046                        ; ----------------------------------------------------------------------------
  4047                        STA_IN_FAC_SIGN:
  4048 00:B519: 85 A2        	sta	FACSIGN
  4049 00:B51B: 60           	rts
  4050                        
  4051                        
  4052                        ; ----------------------------------------------------------------------------
  4053                        ; ADD MANTISSAS OF FAC AND ARG INTO FAC
  4054                        ; ----------------------------------------------------------------------------
  4055 00:B51C: 65 92        FADD4:	adc	ARGEXTENSION
  4056 00:B51E: 85 AC        	sta	FACEXTENSION
  4057 00:B520: A5 A1        	lda	FAC+4
  4058 00:B522: 65 A9        	adc	ARG+4
  4059 00:B524: 85 A1        	sta	FAC+4
  4060 00:B526: A5 A0        	lda	FAC+3
  4061 00:B528: 65 A8        	adc	ARG+3
  4062 00:B52A: 85 A0        	sta	FAC+3
  4063 00:B52C: A5 9F        	lda	FAC+2
  4064 00:B52E: 65 A7        	adc	ARG+2
  4065 00:B530: 85 9F        	sta	FAC+2
  4066 00:B532: A5 9E        	lda	FAC+1
  4067 00:B534: 65 A6        	adc	ARG+1
  4068 00:B536: 85 9E        	sta	FAC+1
  4069 00:B538: 4C 54 B5     	jmp	NORMALIZE_FAC5
  4070                        
  4071                        
  4072                        ; ----------------------------------------------------------------------------
  4073                        ; FINISH NORMALIZING FAC
  4074                        ; ----------------------------------------------------------------------------
  4075                        NORMALIZE_FAC3:
  4076 00:B53B: 69 01        	adc	#1		; COUNT BITS SHIFTED
  4077 00:B53D: 06 AC        	asl	FACEXTENSION
  4078 00:B53F: 26 A1        	rol	FAC+4
  4079 00:B541: 26 A0        	rol	FAC+3
  4080 00:B543: 26 9F        	rol	FAC+2
  4081 00:B545: 26 9E        	rol	FAC+1
  4082                        ; ----------------------------------------------------------------------------
  4083                        NORMALIZE_FAC4:
  4084 00:B547: 10 F2        	bpl	NORMALIZE_FAC3	; UNTIL TOP BIT = 1
  4085 00:B549: 38           	sec
  4086 00:B54A: E5 9D        	sbc	FAC		; ADJUST EXPONENT BY BITS SHIFTED
  4087 00:B54C: B0 C7        	bcs	ZERO_FAC	; UNDERFLOW, RETURN ZERO
  4088 00:B54E: 49 FF        	eor	#$FF
  4089 00:B550: 69 01        	adc	#1		; 2'S COMPLEMENT
  4090 00:B552: 85 9D        	sta	FAC		; CARRY=0 NOW
  4091                        ; ----------------------------------------------------------------------------
  4092                        NORMALIZE_FAC5:
  4093 00:B554: 90 0E        	bcc	RTS11		; UNLESS MANTISSA CARRIED
  4094                        ; ----------------------------------------------------------------------------
  4095                        NORMALIZE_FAC6:
  4096 00:B556: E6 9D        	inc	FAC		; MANTISSA CARRIED, SO SHIFT RIGHT
  4097 00:B558: F0 42        	beq	OVERFLOW	; OVERFLOW IF EXPONENT TOO BIG
  4098 00:B55A: 66 9E        	ror	FAC+1
  4099 00:B55C: 66 9F        	ror	FAC+2
  4100 00:B55E: 66 A0        	ror	FAC+3
  4101 00:B560: 66 A1        	ror	FAC+4
  4102 00:B562: 66 AC        	ror	FACEXTENSION
  4103 00:B564: 60           RTS11:	rts
  4104                        
  4105                        
  4106                        ; ----------------------------------------------------------------------------
  4107                        ; 2'S COMPLEMENT OF FAC
  4108                        ; ----------------------------------------------------------------------------
  4109                        COMPLEMENT_FAC:
  4110 00:B565: A5 A2        	lda	FACSIGN
  4111 00:B567: 49 FF        	eor	#$FF
  4112 00:B569: 85 A2        	sta	FACSIGN
  4113                        
  4114                        
  4115                        ; ----------------------------------------------------------------------------
  4116                        ; 2'S COMPLEMENT OF FAC MANTISSA ONLY
  4117                        ; ----------------------------------------------------------------------------
  4118                        COMPLEMENT_FAC_MANTISSA:
  4119 00:B56B: A5 9E        	lda	FAC+1
  4120 00:B56D: 49 FF        	eor	#$FF
  4121 00:B56F: 85 9E        	sta	FAC+1
  4122 00:B571: A5 9F        	lda	FAC+2
  4123 00:B573: 49 FF        	eor	#$FF
  4124 00:B575: 85 9F        	sta	FAC+2
  4125 00:B577: A5 A0        	lda	FAC+3
  4126 00:B579: 49 FF        	eor	#$FF
  4127 00:B57B: 85 A0        	sta	FAC+3
  4128 00:B57D: A5 A1        	lda	FAC+4
  4129 00:B57F: 49 FF        	eor	#$FF
  4130 00:B581: 85 A1        	sta	FAC+4
  4131 00:B583: A5 AC        	lda	FACEXTENSION
  4132 00:B585: 49 FF        	eor	#$FF
  4133 00:B587: 85 AC        	sta	FACEXTENSION
  4134 00:B589: E6 AC        	inc	FACEXTENSION	; START INCREMENTING MANTISSA
  4135 00:B58B: D0 0E        	bne	RTS12
  4136                        
  4137                        
  4138                        ; ----------------------------------------------------------------------------
  4139                        ; INCREMENT FAC MANTISSA
  4140                        ; ----------------------------------------------------------------------------
  4141                        INCREMENT_FAC_MANTISSA:
  4142 00:B58D: E6 A1        	inc	FAC+4		; ADD CARRY FROM EXTRA
  4143 00:B58F: D0 0A        	bne	RTS12
  4144 00:B591: E6 A0        	inc	FAC+3
  4145 00:B593: D0 06        	bne	RTS12
  4146 00:B595: E6 9F        	inc	FAC+2
  4147 00:B597: D0 02        	bne	RTS12
  4148 00:B599: E6 9E        	inc	FAC+1
  4149 00:B59B: 60           RTS12:	rts
  4150                        ; ----------------------------------------------------------------------------
  4151                        OVERFLOW:
  4152 00:B59C: A2 28        	ldx	#ERR_OVERFLOW
  4153 00:B59E: 4C DA A2     	jmp	ERROR
  4154                        
  4155                        
  4156                        ; ----------------------------------------------------------------------------
  4157                        ; SHIFT 1,X THRU 5,X RIGHT
  4158                        ; (A) = NEGATIVE OF SHIFT COUNT
  4159                        ; (X) = POINTER TO BYTES TO BE SHIFTED
  4160                        ;
  4161                        ; RETURN WITH (Y)=0, CARRY=0, EXTENSION BITS IN A-REG
  4162                        ; ----------------------------------------------------------------------------
  4163                        SHIFT_RIGHT1:
  4164 00:B5A1: A2 61        	ldx	#RESULT-1	; SHIFT RESULT RIGHT
  4165                        SHIFT_RIGHT2:
  4166 00:B5A3: B4 04        	ldy	<4,x		; SHIFT 8 BITS RIGHT
  4167 00:B5A5: 84 AC        	sty	FACEXTENSION
  4168 00:B5A7: B4 03        	ldy	<3,x
  4169 00:B5A9: 94 04        	sty	<4,x
  4170 00:B5AB: B4 02        	ldy	<2,x
  4171 00:B5AD: 94 03        	sty	<3,x
  4172 00:B5AF: B4 01        	ldy	<1,x
  4173 00:B5B1: 94 02        	sty	<2,x
  4174 00:B5B3: A4 A4        	ldy	SHIFTSIGNEXT	; $00 IF +, $FF IF -
  4175 00:B5B5: 94 01        	sty	<1,x
  4176                        
  4177                        
  4178                        ; ----------------------------------------------------------------------------
  4179                        ; MAIN ENTRY TO RIGHT SHIFT SUBROUTINE
  4180                        ; ----------------------------------------------------------------------------
  4181                        SHIFT_RIGHT:
  4182 00:B5B7: 69 08        	adc	#8
  4183 00:B5B9: 30 E8        	bmi	SHIFT_RIGHT2	; STILL MORE THAN 8 BITS TO GO
  4184 00:B5BB: F0 E6        	beq	SHIFT_RIGHT2	; EXACTLY 8 MORE BITS TO GO
  4185 00:B5BD: E9 08        	sbc	#8		; UNDO ADC ABOVE
  4186 00:B5BF: A8           	tay			; REMAINING SHIFT COUNT
  4187 00:B5C0: A5 AC        	lda	FACEXTENSION
  4188 00:B5C2: B0 14        	bcs	SHIFT_RIGHT5	; FINISHED SHIFTING
  4189                        SHIFT_RIGHT3:
  4190 00:B5C4: 16 01        	asl	<1,x		; SIGN -> CARRY (SIGN EXTENSION)
  4191 00:B5C6: 90 02        	bcc	SHIFT_R1		; SIGN +
  4192 00:B5C8: F6 01        	inc	<1,x		; PUT SIGN IN LSB
  4193                        SHIFT_R1:
  4194 00:B5CA: 76 01        	ror	<1,x		; RESTORE VALUE, SIGN STILL IN CARRY
  4195 00:B5CC: 76 01        	ror	<1,x		; START RIGHT SHIFT, INSERTING SIGN
  4196                        
  4197                        
  4198                        ; ----------------------------------------------------------------------------
  4199                        ; ENTER HERE FOR SHORT SHIFTS WITH NO SIGN EXTENSION
  4200                        ; ----------------------------------------------------------------------------
  4201                        SHIFT_RIGHT4:
  4202 00:B5CE: 76 02        	ror	<2,x
  4203 00:B5D0: 76 03        	ror	<3,x
  4204 00:B5D2: 76 04        	ror	<4,x
  4205 00:B5D4: 6A           	ror	a		; EXTENSION
  4206 00:B5D5: C8           	iny			; COUNT THE SHIFT
  4207 00:B5D6: D0 EC        	bne	SHIFT_RIGHT3
  4208                        SHIFT_RIGHT5:
  4209 00:B5D8: 18           	clc			; RETURN WITH CARRY CLEAR
  4210 00:B5D9: 60           	rts
  4211                        
  4212                        
  4213                        ; ----------------------------------------------------------------------------
  4214                        CON_ONE:
  4215 00:B5DA: 81 00 00 00  	db	$81,$00,$00,$00,$00
       00:B5DE: 00 
  4216                        ; ----------------------------------------------------------------------------
  4217                        POLY_LOG:
  4218 00:B5DF: 03           	db	$03			; # OF COEFFICIENTS - 1
  4219 00:B5E0: 7F 5E 56 CB  	db	$7F,$5E,$56,$CB,$79	; * X^7 +
       00:B5E4: 79 
  4220 00:B5E5: 80 13 9B 0B  	db	$80,$13,$9B,$0B,$64	; * X^5 +
       00:B5E9: 64 
  4221 00:B5EA: 80 76 38 93  	db	$80,$76,$38,$93,$16	; * X^3 +
       00:B5EE: 16 
  4222 00:B5EF: 82 38 AA 3B  	db	$82,$38,$AA,$3B,$20	; * X
       00:B5F3: 20 
  4223                        ; ----------------------------------------------------------------------------
  4224                        CON_SQR_HALF:
  4225 00:B5F4: 80 35 04 F3  	db	$80,$35,$04,$F3,$34
       00:B5F8: 34 
  4226                        CON_SQR_TWO:
  4227 00:B5F9: 81 35 04 F3  	db	$81,$35,$04,$F3,$34
       00:B5FD: 34 
  4228                        CON_NEG_HALF:
  4229 00:B5FE: 80 80 00 00  	db	$80,$80,$00,$00,$00
       00:B602: 00 
  4230                        CON_LOG_TWO:
  4231 00:B603: 80 31 72 17  	db	$80,$31,$72,$17,$F8
       00:B607: F8 
  4232                        
  4233                        
  4234                        ; ----------------------------------------------------------------------------
  4235                        ; "LOG" FUNCTION
  4236                        ; ----------------------------------------------------------------------------
  4237 00:B608: 20 44 B8     LOG:    jsr     SIGN		; GET -1,0,+1 IN A-REG FOR FAC
  4238 00:B60B: F0 02                beq     GIQ		; LOG (0) IS ILLEGAL
  4239 00:B60D: 10 03                bpl     LOG2		; >0 IS OK
  4240 00:B60F: 4C 35 AF     GIQ:    jmp     IQERR		; <= 0 IS NO GOOD
  4241 00:B612: A5 9D        LOG2:   lda     FAC		; FIRST GET LOG BASE 2
  4242 00:B614: E9 7F                sbc     #$7F		; SAVE UNBIASED EXPONENT
  4243 00:B616: 48                   pha
  4244 00:B617: A9 80                lda     #$80		; NORMALIZE BETWEEN .5 AND 1
  4245 00:B619: 85 9D                sta     FAC
  4246 00:B61B: A9 F4                lda     #<CON_SQR_HALF
  4247 00:B61D: A0 B5                ldy     #>CON_SQR_HALF
  4248 00:B61F: 20 85 B4             jsr     FADD		; COMPUTE VIA SERIES OF ODD
  4249 00:B622: A9 F9                lda     #<CON_SQR_TWO	; POWERS OF
  4250 00:B624: A0 B5                ldy     #>CON_SQR_TWO	; (SQR(2)X-1)/(SQR(2)X+1)
  4251 00:B626: 20 28 B7             jsr     FDIV
  4252 00:B629: A9 DA                lda     #<CON_ONE
  4253 00:B62B: A0 B5                ldy     #>CON_ONE
  4254 00:B62D: 20 6E B4             jsr     FSUB
  4255 00:B630: A9 DF                lda     #<POLY_LOG
  4256 00:B632: A0 B5                ldy     #>POLY_LOG
  4257 00:B634: 20 17 BC             jsr     POLYNOMIAL_ODD
  4258 00:B637: A9 FE                lda     #<CON_NEG_HALF
  4259 00:B639: A0 B5                ldy     #>CON_NEG_HALF
  4260 00:B63B: 20 85 B4             jsr     FADD
  4261 00:B63E: 68                   pla
  4262 00:B63F: 20 93 B9             jsr     ADDACC		; ADD ORIGINAL EXPONENT
  4263 00:B642: A9 03                lda     #<CON_LOG_TWO	; MULTIPLY BY LOG(2) TO FORM
  4264 00:B644: A0 B6                ldy     #>CON_LOG_TWO	; NATURAL LOG OF X
  4265                        
  4266                        
  4267                        ; ----------------------------------------------------------------------------
  4268                        ; FAC = (Y,A) * FAC
  4269                        ; ----------------------------------------------------------------------------
  4270 00:B646: 20 A8 B6     FMULT:	jsr	LOAD_ARG_FROM_YA
  4271                        
  4272                        
  4273                        ; ----------------------------------------------------------------------------
  4274                        ; FAC = ARG * FAC
  4275                        ; ----------------------------------------------------------------------------
  4276 00:B649: D0 01        FMULTT:	bne	FMULTT1		; FAC .NE. ZERO
  4277 00:B64B: 60           	rts			; FAC = 0 * ARG = 0
  4278                        FMULTT1:
  4279 00:B64C: 20 D3 B6     	jsr	ADD_EXPONENTS
  4280 00:B64F: A9 00        	lda	#0
  4281 00:B651: 85 62        	sta	RESULT		; INIT PRODUCT = 0
  4282 00:B653: 85 63        	sta	RESULT+1
  4283 00:B655: 85 64        	sta	RESULT+2
  4284 00:B657: 85 65        	sta	RESULT+3
  4285 00:B659: A5 AC        	lda	FACEXTENSION
  4286 00:B65B: 20 75 B6     	jsr	MULTIPLY1
  4287 00:B65E: A5 A1        	lda	FAC+4
  4288 00:B660: 20 75 B6     	jsr	MULTIPLY1
  4289 00:B663: A5 A0        	lda	FAC+3
  4290 00:B665: 20 75 B6     	jsr	MULTIPLY1
  4291 00:B668: A5 9F        	lda	FAC+2
  4292 00:B66A: 20 75 B6     	jsr	MULTIPLY1
  4293 00:B66D: A5 9E        	lda	FAC+1
  4294 00:B66F: 20 7A B6     	jsr	MULTIPLY2
  4295 00:B672: 4C A8 B7     	jmp	COPY_RESULT_INTO_FAC
  4296                        
  4297                        
  4298                        ; ----------------------------------------------------------------------------
  4299                        ; MULTIPLY ARG BY (A) INTO RESULT
  4300                        ; ----------------------------------------------------------------------------
  4301                        MULTIPLY1:
  4302 00:B675: D0 03        	bne	MULTIPLY2	; THIS BYTE NON-ZERO
  4303 00:B677: 4C A1 B5     	jmp	SHIFT_RIGHT1	; (A)=0, JUST SHIFT ARG RIGHT 8
  4304                        ; ----------------------------------------------------------------------------
  4305                        MULTIPLY2:
  4306 00:B67A: 4A           	lsr 	a		; SHIFT BIT INTO CARRY
  4307 00:B67B: 09 80        	ora	#$80		; SUPPLY SENTINEL BIT
  4308                        MULTIPLY21:
  4309 00:B67D: A8           	tay			; REMAINING MULTIPLIER TO Y
  4310 00:B67E: 90 19        	bcc	MULTIPLY22		; THIS MULTIPLIER BIT = 0
  4311 00:B680: 18           	clc			; = 1, SO ADD ARG TO RESULT
  4312 00:B681: A5 65        	lda	RESULT+3
  4313 00:B683: 65 A9        	adc	ARG+4
  4314 00:B685: 85 65        	sta	RESULT+3
  4315 00:B687: A5 64        	lda	RESULT+2
  4316 00:B689: 65 A8        	adc	ARG+3
  4317 00:B68B: 85 64        	sta	RESULT+2
  4318 00:B68D: A5 63        	lda	RESULT+1
  4319 00:B68F: 65 A7        	adc	ARG+2
  4320 00:B691: 85 63        	sta	RESULT+1
  4321 00:B693: A5 62        	lda	RESULT
  4322 00:B695: 65 A6        	adc	ARG+1
  4323 00:B697: 85 62        	sta	RESULT
  4324                        MULTIPLY22:
  4325 00:B699: 66 62        	ror	RESULT		; SHIFT RESULT RIGHT 1
  4326 00:B69B: 66 63        	ror	RESULT+1
  4327 00:B69D: 66 64        	ror	RESULT+2
  4328 00:B69F: 66 65        	ror	RESULT+3
  4329 00:B6A1: 66 AC        	ror	FACEXTENSION
  4330 00:B6A3: 98           	tya			; REMAINING MULTIPLIER
  4331 00:B6A4: 4A           	lsr	a		; LSB INTO CARRY
  4332 00:B6A5: D0 D6        	bne	MULTIPLY21		; IF SENTINEL STILL HERE, MULTIPLY
  4333 00:B6A7: 60           	rts			; 8 X 32 COMPLETED
  4334                        
  4335                        
  4336                        ; ----------------------------------------------------------------------------
  4337                        ; UNPACK NUMBER AT (Y,A) INTO ARG
  4338                        ; ----------------------------------------------------------------------------
  4339                        LOAD_ARG_FROM_YA:
  4340 00:B6A8: 85 5E        	sta	INDEX		; USE INDEX FOR PNTR
  4341 00:B6AA: 84 5F        	sty	INDEX+1
  4342 00:B6AC: A0 04        	ldy	#4		; FIVE BYTES TO MOVE
  4343 00:B6AE: B1 5E        	lda	(INDEX),y
  4344 00:B6B0: 85 A9        	sta	ARG+4
  4345 00:B6B2: 88           	dey
  4346 00:B6B3: B1 5E        	lda	(INDEX),y
  4347 00:B6B5: 85 A8        	sta	ARG+3
  4348 00:B6B7: 88           	dey
  4349 00:B6B8: B1 5E        	lda	(INDEX),y
  4350 00:B6BA: 85 A7        	sta	ARG+2
  4351 00:B6BC: 88           	dey
  4352 00:B6BD: B1 5E        	lda	(INDEX),y
  4353 00:B6BF: 85 AA        	sta	ARGSIGN
  4354 00:B6C1: 45 A2        	eor	FACSIGN		; SET COMBINED SIGN FOR MULT/DIV
  4355 00:B6C3: 85 AB        	sta	SGNCPR
  4356 00:B6C5: A5 AA        	lda	ARGSIGN		; TURN ON NORMALIZED INVISIBLE BIT
  4357 00:B6C7: 09 80        	ora	#$80		; TO COMPLETE MANTISSA
  4358 00:B6C9: 85 A6        	sta	ARG+1
  4359 00:B6CB: 88           	dey
  4360 00:B6CC: B1 5E        	lda	(INDEX),y
  4361 00:B6CE: 85 A5        	sta	ARG		; EXPONENT
  4362 00:B6D0: A5 9D        	lda	FAC		; SET STATUS BITS ON FAC EXPONENT
  4363 00:B6D2: 60           	rts
  4364                        
  4365                        
  4366                        ; ----------------------------------------------------------------------------
  4367                        ; ADD EXPONENTS OF ARG AND FAC
  4368                        ; (CALLED BY FMULT AND FDIV)
  4369                        ;
  4370                        ; ALSO CHECK FOR OVERFLOW, AND SET RESULT SIGN
  4371                        ; ----------------------------------------------------------------------------
  4372                        ADD_EXPONENTS:
  4373 00:B6D3: A5 A5        	lda	ARG
  4374                        ; ----------------------------------------------------------------------------
  4375                        ADD_EXPONENTS1:
  4376 00:B6D5: F0 1C        	beq	ZERO		; IF ARG=0, RESULT IS ZERO
  4377 00:B6D7: 18           	clc
  4378 00:B6D8: 65 9D        	adc	FAC
  4379 00:B6DA: 90 04        	bcc	ADD_EXP1		; IN RANGE
  4380 00:B6DC: 30 1A        	bmi	JOV		; OVERFLOW
  4381 00:B6DE: 18           	clc
  4382 00:B6DF: 2C           	db	$2C		; TRICK TO SKIP
  4383                        ADD_EXP1:
  4384 00:B6E0: 10 11        	bpl	ZERO		; OVERFLOW
  4385 00:B6E2: 69 80        	adc	#$80		; RE-BIAS
  4386 00:B6E4: 85 9D        	sta	FAC		; RESULT
  4387 00:B6E6: F0 02        	beq	ADD_EXP3
  4388                        ;ADD_EXP2:
  4389 00:B6E8: A5 AB        	lda	SGNCPR		; SET SIGN OF RESULT
  4390                        ADD_EXP3:
  4391 00:B6EA: 85 A2        	sta	FACSIGN
  4392 00:B6EC: 60           	rts
  4393                        
  4394                        
  4395                        ; ----------------------------------------------------------------------------
  4396                        ; IF (FAC) IS POSITIVE, GIVE "OVERFLOW" ERROR
  4397                        ; IF (FAC) IS NEGATIVE, SET FAC=0, POP ONE RETURN, AND RTS
  4398                        ; CALLED FROM "EXP" FUNCTION
  4399                        ; ----------------------------------------------------------------------------
  4400                        OUTOFRNG:
  4401 00:B6ED: A5 A2        	lda	FACSIGN
  4402 00:B6EF: 49 FF        	eor	#$FF
  4403 00:B6F1: 30 05        	bmi	JOV		; ERROR IF POSITIVE #
  4404                        
  4405                        
  4406                        ; ----------------------------------------------------------------------------
  4407                        ; POP RETURN ADDRESS AND SET FAC=0
  4408                        ; ----------------------------------------------------------------------------
  4409 00:B6F3: 68           ZERO:	pla
  4410 00:B6F4: 68           	pla
  4411 00:B6F5: 4C 15 B5     	jmp	ZERO_FAC
  4412                        ; ----------------------------------------------------------------------------
  4413 00:B6F8: 4C 9C B5     JOV:	jmp	OVERFLOW
  4414                        
  4415                        
  4416                        ; ----------------------------------------------------------------------------
  4417                        ; MULTIPLY FAC BY 10
  4418                        ; ----------------------------------------------------------------------------
  4419 00:B6FB: 20 25 B8     MUL10:	jsr	COPY_FAC_TO_ARG_ROUNDED
  4420 00:B6FE: AA           	tax			; TEXT FAC EXPONENT
  4421 00:B6FF: F0 10        	beq	MUL101		; FINISHED IF FAC=0
  4422 00:B701: 18           	clc
  4423 00:B702: 69 02        	adc	#2		; ADD 2 TO EXPONENT GIVES (FAC)*4
  4424 00:B704: B0 F2        	bcs	JOV		; OVERFLOW
  4425 00:B706: A2 00        	ldx	#0
  4426 00:B708: 86 AB        	stx	SGNCPR
  4427 00:B70A: 20 95 B4     	jsr	FADD2		; MAKES (FAC)*5
  4428 00:B70D: E6 9D        	inc	FAC		; *2, MAKES (FAC)*10
  4429 00:B70F: F0 E7        	beq	JOV		; OVERFLOW
  4430 00:B711: 60           MUL101:	rts
  4431                        
  4432                        ; ----------------------------------------------------------------------------
  4433 00:B712: 84 20 00 00  CONTEN:	db	$84,$20,$00,$00,$00
       00:B716: 00 
  4434                        
  4435                        
  4436                        ; ----------------------------------------------------------------------------
  4437                        ; DIVIDE FAC BY 10
  4438                        ; ----------------------------------------------------------------------------
  4439 00:B717: 20 25 B8     DIV10:	jsr	COPY_FAC_TO_ARG_ROUNDED
  4440 00:B71A: A9 12        	lda	#<CONTEN	; SET UP TO PUT
  4441 00:B71C: A0 B7        	ldy	#>CONTEN	; 10 IN FAC
  4442 00:B71E: A2 00        	ldx	#0
  4443                        
  4444                        
  4445                        ; ----------------------------------------------------------------------------
  4446                        ; FAC = ARG / (Y,A)
  4447                        ; ----------------------------------------------------------------------------
  4448 00:B720: 86 AB        DIV:	stx	SGNCPR
  4449 00:B722: 20 BB B7     	jsr	LOAD_FAC_FROM_YA
  4450 00:B725: 4C 2B B7     	jmp	FDIVT		; DIVIDE ARG BY FAC
  4451                        
  4452                        
  4453                        ; ----------------------------------------------------------------------------
  4454                        ; FAC = (Y,A) / FAC
  4455                        ; ----------------------------------------------------------------------------
  4456 00:B728: 20 A8 B6     FDIV:	jsr	LOAD_ARG_FROM_YA
  4457                        
  4458                        
  4459                        ; ----------------------------------------------------------------------------
  4460                        ; FAC = ARG / FAC
  4461                        ; ----------------------------------------------------------------------------
  4462 00:B72B: F0 76        FDIVT:	beq	FDIVT8		; FAC = 0, DIVIDE BY ZERO ERROR
  4463 00:B72D: 20 34 B8     	jsr	ROUND_FAC
  4464 00:B730: A9 00        	lda	#0		; NEGATE FAC EXPONENT, SO
  4465 00:B732: 38           	sec			; ADD.EXPONENTS FORMS DIFFERENCE
  4466 00:B733: E5 9D        	sbc	FAC
  4467 00:B735: 85 9D        	sta	FAC
  4468 00:B737: 20 D3 B6     	jsr	ADD_EXPONENTS
  4469 00:B73A: E6 9D        	inc	FAC
  4470 00:B73C: F0 BA        	beq	JOV		; OVERFLOW
  4471 00:B73E: A2 FC        	ldx	#$FC		; X = -4 : INDEX FOR RESULT
  4472 00:B740: A9 01        	lda	#1		; SENTINEL
  4473 00:B742: A4 A6        FDIVT1:	ldy	ARG+1		; SEE IF FAC CAN BE SUBTRACTED
  4474 00:B744: C4 9E        	cpy	FAC+1
  4475 00:B746: D0 10        	bne	FDIVT2
  4476 00:B748: A4 A7        	ldy	ARG+2
  4477 00:B74A: C4 9F        	cpy	FAC+2
  4478 00:B74C: D0 0A        	bne	FDIVT2
  4479 00:B74E: A4 A8        	ldy	ARG+3
  4480 00:B750: C4 A0        	cpy	FAC+3
  4481 00:B752: D0 04        	bne	FDIVT2
  4482 00:B754: A4 A9        	ldy	ARG+4
  4483 00:B756: C4 A1        	cpy	FAC+4
  4484 00:B758: 08           FDIVT2:	php			; SAVE THE ANSWER, AND ALSO ROLL THE
  4485 00:B759: 2A           	rol	a		; BIT INTO THE QUOTIENT, SENTINEL OUT
  4486 00:B75A: 90 09        	bcc	FDIVT3		; NO SENTINEL, STILL NOT 8 TRIPS
  4487 00:B75C: E8           	inx			; 8 TRIPS, STORE BYTE OF QUOTIENT
  4488 00:B75D: 95 65        	sta	RESULT+3,x
  4489 00:B75F: F0 32        	beq	FDIVT6		; 32-BITS COMPLETED
  4490 00:B761: 10 34        	bpl	FDIVT7		; FINAL EXIT WHEN X=1
  4491 00:B763: A9 01        	lda	#1		; RE-START SENTINEL
  4492 00:B765: 28           FDIVT3:	plp			; GET ANSWER, CAN FAC BE SUBTRACTED?
  4493 00:B766: B0 0E        	bcs	FDIVT5		; YES, DO IT
  4494 00:B768: 06 A9        FDIVT4:	asl	ARG+4		; NO, SHIFT ARG LEFT
  4495 00:B76A: 26 A8        	rol	ARG+3
  4496 00:B76C: 26 A7        	rol	ARG+2
  4497 00:B76E: 26 A6        	rol	ARG+1
  4498 00:B770: B0 E6        	bcs	FDIVT2		; ANOTHER TRIP
  4499 00:B772: 30 CE        	bmi	FDIVT1		; HAVE TO COMPARE FIRST
  4500 00:B774: 10 E2        	bpl	FDIVT2		; ...ALWAYS
  4501 00:B776: A8           FDIVT5:	tay			; SAVE QUOTIENT/SENTINEL BYTE
  4502 00:B777: A5 A9        	lda	ARG+4		; SUBTRACT FAC FROM ARG ONCE
  4503 00:B779: E5 A1        	sbc	FAC+4
  4504 00:B77B: 85 A9        	sta	ARG+4
  4505 00:B77D: A5 A8        	lda	ARG+3
  4506 00:B77F: E5 A0        	sbc	FAC+3
  4507 00:B781: 85 A8        	sta	ARG+3
  4508 00:B783: A5 A7        	lda	ARG+2
  4509 00:B785: E5 9F        	sbc	FAC+2
  4510 00:B787: 85 A7        	sta	ARG+2
  4511 00:B789: A5 A6        	lda	ARG+1
  4512 00:B78B: E5 9E        	sbc	FAC+1
  4513 00:B78D: 85 A6        	sta	ARG+1
  4514 00:B78F: 98           	tya			; RESTORE QUOTIENT/SENTINEL BYTE
  4515 00:B790: 4C 68 B7     	jmp	FDIVT4		; GO TO SHIFT ARG AND CONTINUE
  4516                        ; ----------------------------------------------------------------------------
  4517 00:B793: A9 40        FDIVT6:	lda	#$40		; DO A FEW EXTENSION BITS
  4518 00:B795: D0 CE        	bne	FDIVT3		; ...ALWAYS
  4519                        ; ----------------------------------------------------------------------------
  4520 00:B797: 0A           FDIVT7:	asl	a		; LEFT JUSTIFY THE EXTENSION BITS WE DID
  4521 00:B798: 0A           	asl	a
  4522 00:B799: 0A           	asl	a
  4523 00:B79A: 0A           	asl	a
  4524 00:B79B: 0A           	asl	a
  4525 00:B79C: 0A           	asl	a
  4526 00:B79D: 85 AC        	sta	FACEXTENSION
  4527 00:B79F: 28           	plp
  4528 00:B7A0: 4C A8 B7     	jmp	COPY_RESULT_INTO_FAC
  4529                        ; ----------------------------------------------------------------------------
  4530 00:B7A3: A2 53        FDIVT8:	ldx	#ERR_ZERODIV
  4531 00:B7A5: 4C DA A2     	jmp	ERROR
  4532                        
  4533                        
  4534                        ; ----------------------------------------------------------------------------
  4535                        ; COPY RESULT INTO FAC MANTISSA, AND NORMALIZE
  4536                        ; ----------------------------------------------------------------------------
  4537                        COPY_RESULT_INTO_FAC:
  4538 00:B7A8: A5 62        	lda	RESULT
  4539 00:B7AA: 85 9E        	sta	FAC+1
  4540 00:B7AC: A5 63        	lda	RESULT+1
  4541 00:B7AE: 85 9F        	sta	FAC+2
  4542 00:B7B0: A5 64        	lda	RESULT+2
  4543 00:B7B2: 85 A0        	sta	FAC+3
  4544 00:B7B4: A5 65        	lda	RESULT+3
  4545 00:B7B6: 85 A1        	sta	FAC+4
  4546 00:B7B8: 4C F5 B4     	jmp	NORMALIZE_FAC2
  4547                        
  4548                        
  4549                        ; ----------------------------------------------------------------------------
  4550                        ; UNPACK (Y,A) INTO FAC
  4551                        ; ----------------------------------------------------------------------------
  4552                        LOAD_FAC_FROM_YA:
  4553 00:B7BB: 85 5E        	sta	INDEX		; USE INDEX FOR PNTR
  4554 00:B7BD: 84 5F        	sty	INDEX+1
  4555 00:B7BF: A0 04        	ldy	#4		; PICK UP 5 BYTES
  4556 00:B7C1: B1 5E        	lda	(INDEX),y
  4557 00:B7C3: 85 A1        	sta	FAC+4
  4558 00:B7C5: 88           	dey
  4559 00:B7C6: B1 5E        	lda	(INDEX),y
  4560 00:B7C8: 85 A0        	sta	FAC+3
  4561 00:B7CA: 88           	dey
  4562 00:B7CB: B1 5E        	lda	(INDEX),y
  4563 00:B7CD: 85 9F        	sta	FAC+2
  4564 00:B7CF: 88           	dey
  4565 00:B7D0: B1 5E        	lda	(INDEX),y
  4566 00:B7D2: 85 A2        	sta	FACSIGN		; FIRST BIT IS SIGN
  4567 00:B7D4: 09 80        	ora	#$80		; SET NORMALIZED INVISIBLE BIT
  4568 00:B7D6: 85 9E        	sta	FAC+1
  4569 00:B7D8: 88           	dey
  4570 00:B7D9: B1 5E        	lda	(INDEX),y
  4571 00:B7DB: 85 9D        	sta	FAC		; EXPONENT
  4572 00:B7DD: 84 AC        	sty	FACEXTENSION	; Y=0
  4573 00:B7DF: 60           	rts
  4574                        
  4575                        
  4576                        ; ----------------------------------------------------------------------------
  4577                        ; ROUND FAC, STORE IN TEMP2
  4578                        ; ----------------------------------------------------------------------------
  4579                        STORE_FAC_IN_TEMP2_ROUNDED:
  4580 00:B7E0: A2 98        	ldx	#TEMP2		; PACK FAC INTO TEMP2
  4581 00:B7E2: 2C           	db	$2C		; TRICK TO BRANCH
  4582                        
  4583                        
  4584                        ; ----------------------------------------------------------------------------
  4585                        ; ROUND FAC, STORE IN TEMP1
  4586                        ; ----------------------------------------------------------------------------
  4587                        STORE_FAC_IN_TEMP1_ROUNDED:
  4588 00:B7E3: A2 93        	ldx	#<TEMP1		; PACK FAC INTO TEMP1
  4589 00:B7E5: A0 00        	ldy	#>TEMP1		; HI-BYTE OF TEMP1 SAME AS TEMP2
  4590 00:B7E7: F0 04        	beq	STORE_FAC_AT_YX_ROUNDED	; ...ALWAYS
  4591                        
  4592                        
  4593                        ; ----------------------------------------------------------------------------
  4594                        ; ROUND FAC, AND STORE WHERE FORPNT POINTS
  4595                        ; ----------------------------------------------------------------------------
  4596 00:B7E9: A6 85        SETFOR:	ldx	FORPNT
  4597 00:B7EB: A4 86        	ldy	FORPNT+1
  4598                        
  4599                        
  4600                        ; ----------------------------------------------------------------------------
  4601                        ; ROUND FAC, AND STORE AT (Y,X)
  4602                        ; ----------------------------------------------------------------------------
  4603                        STORE_FAC_AT_YX_ROUNDED:
  4604 00:B7ED: 20 34 B8     	jsr	ROUND_FAC	; ROUND VALUE IN FAC USING EXTENSION
  4605 00:B7F0: 86 5E        	stx	INDEX		; USE INDEX FOR PNTR
  4606 00:B7F2: 84 5F        	sty	INDEX+1
  4607 00:B7F4: A0 04        	ldy	#4		; STORING 5 PACKED BYTES
  4608 00:B7F6: A5 A1        	lda	FAC+4
  4609 00:B7F8: 91 5E        	sta	(INDEX),y
  4610 00:B7FA: 88           	dey
  4611 00:B7FB: A5 A0        	lda	FAC+3
  4612 00:B7FD: 91 5E        	sta	(INDEX),y
  4613 00:B7FF: 88           	dey
  4614 00:B800: A5 9F        	lda	FAC+2
  4615 00:B802: 91 5E        	sta	(INDEX),y
  4616 00:B804: 88           	dey
  4617 00:B805: A5 A2        	lda	FACSIGN		; PACK SIGN IN TOP BIT OF MANTISSA
  4618 00:B807: 09 7F        	ora	#$7F
  4619 00:B809: 25 9E        	and	FAC+1
  4620 00:B80B: 91 5E        	sta	(INDEX),y
  4621 00:B80D: 88           	dey
  4622 00:B80E: A5 9D        	lda	FAC		; EXPONENT
  4623 00:B810: 91 5E        	sta	(INDEX),y
  4624 00:B812: 84 AC        	sty	FACEXTENSION	; ZERO THE EXTENSION
  4625 00:B814: 60           	rts
  4626                        
  4627                        
  4628                        ; ----------------------------------------------------------------------------
  4629                        ; COPY ARG INTO FAC
  4630                        ; ----------------------------------------------------------------------------
  4631                        COPY_ARG_TO_FAC:
  4632 00:B815: A5 AA        	lda	ARGSIGN		; COPY SIGN
  4633 00:B817: 85 A2        MFA:	sta	FACSIGN
  4634 00:B819: A2 05        	ldx	#5		; MOVE 5 BYTES
  4635                        COPY_AR1:
  4636 00:B81B: B5 A4        	lda	ARG-1,x
  4637 00:B81D: 95 9C        	sta	FAC-1,x
  4638 00:B81F: CA           	dex
  4639 00:B820: D0 F9        	bne	COPY_AR1
  4640 00:B822: 86 AC        	stx	FACEXTENSION	; ZERO EXTENSION
  4641 00:B824: 60           	rts
  4642                        
  4643                        
  4644                        ; ----------------------------------------------------------------------------
  4645                        ; ROUND FAC AND COPY TO ARG
  4646                        ; ----------------------------------------------------------------------------
  4647                        COPY_FAC_TO_ARG_ROUNDED:
  4648 00:B825: 20 34 B8     	jsr	ROUND_FAC	; ROUND FAC USING EXTENSION
  4649 00:B828: A2 06        MAF:	ldx	#6		; COPY 6 BYTES, INCLUDES SIGN
  4650                        COPY_FA1:
  4651 00:B82A: B5 9C        	lda	FAC-1,x
  4652 00:B82C: 95 A4        	sta	ARG-1,x
  4653 00:B82E: CA           	dex
  4654 00:B82F: D0 F9        	bne	COPY_FA1
  4655 00:B831: 86 AC        	stx	FACEXTENSION	; ZERO FAC EXTENSION
  4656 00:B833: 60           RTS14:	rts
  4657                        
  4658                        
  4659                        ; ----------------------------------------------------------------------------
  4660                        ; ROUND FAC USING EXTENSION BYTE
  4661                        ; ----------------------------------------------------------------------------
  4662                        ROUND_FAC:
  4663 00:B834: A5 9D        	lda	FAC
  4664 00:B836: F0 FB        	beq	RTS14		; FAC = 0, RETURN
  4665 00:B838: 06 AC        	asl	FACEXTENSION	; IS FAC.EXTENSION >= 128?
  4666 00:B83A: 90 F7        	bcc	RTS14		; NO, FINISHED
  4667                        
  4668                        
  4669                        ; ----------------------------------------------------------------------------
  4670                        ; INCREMENT MANTISSA AND RE-NORMALIZE IF CARRY
  4671                        ; ----------------------------------------------------------------------------
  4672                        INCREMENT_MANTISSA:
  4673 00:B83C: 20 8D B5     	jsr	INCREMENT_FAC_MANTISSA	; YES, INCREMENT FAC
  4674 00:B83F: D0 F2        	bne	RTS14		; HIGH BYTE HAS BITS, FINISHED
  4675 00:B841: 4C 56 B5     	jmp	NORMALIZE_FAC6	; HI-BYTE=0, SO SHIFT LEFT
  4676                        
  4677                        
  4678                        ; ----------------------------------------------------------------------------
  4679                        ; TEST FAC FOR ZERO AND SIGN
  4680                        ;
  4681                        ; FAC > 0, RETURN +1
  4682                        ; FAC = 0, RETURN  0
  4683                        ; FAC < 0, RETURN -1
  4684                        ; ----------------------------------------------------------------------------
  4685 00:B844: A5 9D        SIGN:	lda	FAC		; CHECK SIGN OF FAC AND
  4686 00:B846: F0 09        	beq	RTS15		; RETURN -1,0,1 IN A-REG
  4687                        ; ----------------------------------------------------------------------------
  4688 00:B848: A5 A2        SIGN1:	lda	FACSIGN
  4689                        ; ----------------------------------------------------------------------------
  4690 00:B84A: 2A           SIGN2:	rol	a		; MSBIT TO CARRY
  4691 00:B84B: A9 FF        	lda	#$FF		; -1
  4692 00:B84D: B0 02        	bcs	RTS15		; MSBIT = 1
  4693 00:B84F: A9 01        	lda	#1		; +1
  4694 00:B851: 60           RTS15:	rts
  4695                        
  4696                        
  4697                        ; ----------------------------------------------------------------------------
  4698                        ; "SGN" FUNCTION
  4699                        ; ----------------------------------------------------------------------------
  4700 00:B852: 20 44 B8     SGN:	jsr	SIGN		; CONVERT FAC TO -1,0,1
  4701                        
  4702                        
  4703                        ; ----------------------------------------------------------------------------
  4704                        ; CONVERT (A) INTO FAC, AS SIGNED VALUE -128 TO +127
  4705                        ; ----------------------------------------------------------------------------
  4706 00:B855: 85 9E        FLOAT:	sta	FAC+1		; PUT IN HIGH BYTE OF MANTISSA
  4707 00:B857: A9 00        	lda	#0		; CLEAR 2ND BYTE OF MANTISSA
  4708 00:B859: 85 9F        	sta	FAC+2
  4709 00:B85B: A2 88        	ldx	#$88		; USE EXPONENT 2^9
  4710                        
  4711                        
  4712                        ; ----------------------------------------------------------------------------
  4713                        ; FLOAT UNSIGNED VALUE IN FAC+1,2
  4714                        ; (X) = EXPONENT
  4715                        ; ----------------------------------------------------------------------------
  4716 00:B85D: A5 9E        FLOAT1:	lda	FAC+1		; MSBIT=0, SET CARRY; =1, CLEAR CARRY
  4717 00:B85F: 49 FF        	eor	#$FF
  4718 00:B861: 2A           	rol	a
  4719                        
  4720                        
  4721                        ; ----------------------------------------------------------------------------
  4722                        ; FLOAT UNSIGNED VALUE IN FAC+1,2
  4723                        ; (X) = EXPONENT
  4724                        ; C=0 TO MAKE VALUE NEGATIVE
  4725                        ; C=1 TO MAKE VALUE POSITIVE
  4726                        ; ----------------------------------------------------------------------------
  4727 00:B862: A9 00        FLOAT2:	lda	#0		; CLEAR LOWER 16-BITS OF MANTISSA
  4728 00:B864: 85 A1        	sta	FAC+4
  4729 00:B866: 85 A0        	sta	FAC+3
  4730 00:B868: 86 9D        	stx	FAC		; STORE EXPONENT
  4731 00:B86A: 85 AC        	sta	FACEXTENSION	; CLEAR EXTENSION
  4732 00:B86C: 85 A2        	sta	FACSIGN		; MAKE SIGN POSITIVE
  4733 00:B86E: 4C F0 B4     	jmp	NORMALIZE_FAC1	; IF C=0, WILL NEGATE FAC
  4734                        
  4735                        
  4736                        ; ----------------------------------------------------------------------------
  4737                        ; "ABS" FUNCTION
  4738                        ; ----------------------------------------------------------------------------
  4739 00:B871: 46 A2        ABS:	lsr	FACSIGN		; CHANGE SIGN TO +
  4740 00:B873: 60           	rts
  4741                        
  4742                        
  4743                        ; ----------------------------------------------------------------------------
  4744                        ; COMPARE FAC WITH PACKED # AT (Y,A)
  4745                        ; RETURN A=1,0,-1 AS (Y,A) IS <,=,> FAC
  4746                        ; ----------------------------------------------------------------------------
  4747 00:B874: 85 60        FCOMP:	sta	DEST		; USE DEST FOR PNTR
  4748                        
  4749                        
  4750                        ; ----------------------------------------------------------------------------
  4751                        ; SPECIAL ENTRY FROM "NEXT" PROCESSOR
  4752                        ; "DEST" ALREADY SET UP
  4753                        ; ----------------------------------------------------------------------------
  4754 00:B876: 84 61        FCOMP2:	sty	DEST+1
  4755 00:B878: A0 00        	ldy	#0		; GET EXPONENT OF COMPARAND
  4756 00:B87A: B1 60        	lda	(DEST),y
  4757 00:B87C: C8           	iny			; POINT AT NEXT BYTE
  4758 00:B87D: AA           	tax			; EXPONENT TO X-REG
  4759 00:B87E: F0 C4        	beq	SIGN		; IF COMPARAND=0, "SIGN" COMPARES FAC
  4760 00:B880: B1 60        	lda	(DEST),y	; GET HI-BYTE OF MANTISSA
  4761 00:B882: 45 A2        	eor	FACSIGN		; COMPARE WITH FAC SIGN
  4762 00:B884: 30 C2        	bmi	SIGN1		; DIFFERENT SIGNS, "SIGN" GIVES ANSWER
  4763 00:B886: E4 9D        	cpx	FAC		; SAME SIGN, SO COMPARE EXPONENTS
  4764 00:B888: D0 21        	bne	FCOMP21		; DIFFERENT, SO SUFFICIENT TEST
  4765 00:B88A: B1 60        	lda	(DEST),y	; SAME EXPONENT, COMPARE MANTISSA
  4766 00:B88C: 09 80        	ora	#$80		; SET INVISIBLE NORMALIZED BIT
  4767 00:B88E: C5 9E        	cmp	FAC+1
  4768 00:B890: D0 19        	bne	FCOMP21		; NOT SAME, SO SUFFICIENT
  4769 00:B892: C8           	iny			; SAME, COMPARE MORE MANTISSA
  4770 00:B893: B1 60        	lda	(DEST),y
  4771 00:B895: C5 9F        	cmp	FAC+2
  4772 00:B897: D0 12        	bne	FCOMP21		; NOT SAME, SO SUFFICIENT
  4773 00:B899: C8           	iny			; SAME, COMPARE MORE MANTISSA
  4774 00:B89A: B1 60        	lda	(DEST),y
  4775 00:B89C: C5 A0        	cmp	FAC+3
  4776 00:B89E: D0 0B        	bne	FCOMP21		; NOT SAME, SO SUFFICIENT
  4777 00:B8A0: C8           	iny			; SAME, COMPARE REST OF MANTISSA
  4778 00:B8A1: A9 7F        	lda	#$7F		; ARTIFICIAL EXTENSION BYTE FOR COMPARAND
  4779 00:B8A3: C5 AC        	cmp	FACEXTENSION
  4780 00:B8A5: B1 60        	lda	(DEST),y
  4781 00:B8A7: E5 A1        	sbc	FAC+4
  4782 00:B8A9: F0 25        	beq	RTS16		; NUMBERS ARE EQUAL, RETURN (A)=0
  4783 00:B8AB: 6A           FCOMP21:	ror			; PUT CARRY INTO SIGN BIT
  4784 00:B8AC: 45 A2        	eor	FACSIGN		; TOGGLE WITH SIGN OF FAC
  4785                        ;FCOMP22:
  4786 00:B8AE: 4C 4A B8     	jmp	SIGN2		; CONVERT +1 OR -1
  4787                        
  4788                        
  4789                        ; ----------------------------------------------------------------------------
  4790                        ; QUICK INTEGER FUNCTION
  4791                        ;
  4792                        ; CONVERTS FP VALUE IN FAC TO INTEGER VALUE
  4793                        ; IN FAC+1...FAC+4, BY SHIFTING RIGHT WITH SIGN
  4794                        ; EXTENSION UNTIL FRACTIONAL BITS ARE OUT.
  4795                        ;
  4796                        ; THIS SUBROUTINE ASSUMES THE EXPONENT < 32.
  4797                        ; ----------------------------------------------------------------------------
  4798 00:B8B1: A5 9D        QINT:	lda	FAC		; LOOK AT FAC EXPONENT
  4799 00:B8B3: F0 4A        	beq	QINT3		; FAC=0, SO FINISHED
  4800 00:B8B5: 38           	sec			; GET -(NUMBER OF FRACTIONAL BITS)
  4801 00:B8B6: E9 A0        	sbc	#$A0		; IN A-REG FOR SHIFT COUNT
  4802 00:B8B8: 24 A2        	bit	FACSIGN		; CHECK SIGN OF FAC
  4803 00:B8BA: 10 09        	bpl	QINT1		; POSITIVE, CONTINUE
  4804 00:B8BC: AA           	tax			; NEGATIVE, SO COMPLEMENT MANTISSA
  4805 00:B8BD: A9 FF        	lda	#$FF		; AND SET SIGN EXTENSION FOR SHIFT
  4806 00:B8BF: 85 A4        	sta	SHIFTSIGNEXT
  4807 00:B8C1: 20 6B B5     	jsr	COMPLEMENT_FAC_MANTISSA
  4808 00:B8C4: 8A           	txa			; RESTORE BIT COUNT TO A-REG
  4809 00:B8C5: A2 9D        QINT1:	ldx	#FAC		; POINT SHIFT SUBROUTINE AT FAC
  4810 00:B8C7: C9 F9        	cmp	#$F9		; MORE THAN 7 BITS TO SHIFT?
  4811 00:B8C9: 10 06        	bpl	QINT2		; NO, SHORT SHIFT
  4812 00:B8CB: 20 B7 B5     	jsr	SHIFT_RIGHT	; YES, USE GENERAL ROUTINE
  4813 00:B8CE: 84 A4        	sty	SHIFTSIGNEXT	; Y=0, CLEAR SIGN EXTENSION
  4814 00:B8D0: 60           RTS16:	rts
  4815                        ; ----------------------------------------------------------------------------
  4816 00:B8D1: A8           QINT2:	tay			; SAVE SHIFT COUNT
  4817 00:B8D2: A5 A2        	lda	FACSIGN		; GET SIGN BIT
  4818 00:B8D4: 29 80        	and	#$80
  4819 00:B8D6: 46 9E        	lsr	FAC+1		; START RIGHT SHIFT
  4820 00:B8D8: 05 9E        	ora	FAC+1		; AND MERGE WITH SIGN
  4821 00:B8DA: 85 9E        	sta	FAC+1
  4822 00:B8DC: 20 CE B5     	jsr	SHIFT_RIGHT4	; JUMP INTO MIDDLE OF SHIFTER
  4823 00:B8DF: 84 A4        	sty	SHIFTSIGNEXT	; Y=0, CLEAR SIGN EXTENSION
  4824 00:B8E1: 60           	rts
  4825                        
  4826                        
  4827                        ; ----------------------------------------------------------------------------
  4828                        ; "INT" FUNCTION
  4829                        ;
  4830                        ; USES QINT TO CONVERT (FAC) TO INTEGER FORM,
  4831                        ; AND THEN REFLOATS THE INTEGER.
  4832                        ; ----------------------------------------------------------------------------
  4833 00:B8E2: A5 9D        INT:	lda	FAC		; CHECK IF EXPONENT < 32
  4834 00:B8E4: C9 A0        	cmp	#$A0		; BECAUSE IF > 31 THERE IS NO FRACTION
  4835 00:B8E6: B0 20        	bcs	RTS17		; NO FRACTION, WE ARE FINISHED
  4836 00:B8E8: 20 B1 B8     	jsr	QINT		; USE GENERAL INTEGER CONVERSION
  4837 00:B8EB: 84 AC        	sty	FACEXTENSION	; Y=0, CLEAR EXTENSION
  4838 00:B8ED: A5 A2        	lda	FACSIGN		; GET SIGN OF VALUE
  4839 00:B8EF: 84 A2        	sty	FACSIGN		; Y=0, CLEAR SIGN
  4840 00:B8F1: 49 80        	eor	#$80		; TOGGLE ACTUAL SIGN
  4841 00:B8F3: 2A           	rol	a		; AND SAVE IN CARRY
  4842 00:B8F4: A9 A0        	lda	#$A0		; SET EXPONENT TO 32
  4843 00:B8F6: 85 9D        	sta	FAC		; BECAUSE 4-BYTE INTEGER NOW
  4844 00:B8F8: A5 A1        	lda	FAC+4		; SAVE LOW 8-BITS OF INTEGER FORM
  4845 00:B8FA: 85 0D        	sta	CHARAC		; FOR EXP AND POWER
  4846 00:B8FC: 4C F0 B4     	jmp	NORMALIZE_FAC1	; NORMALIZE TO FINISH CONVERSION
  4847                        ; ----------------------------------------------------------------------------
  4848 00:B8FF: 85 9E        QINT3:	sta	FAC+1		; FAC=0, SO CLEAR ALL 4 BYTES FOR
  4849 00:B901: 85 9F        	sta	FAC+2		; INTEGER VERSION
  4850 00:B903: 85 A0        	sta	FAC+3
  4851 00:B905: 85 A1        	sta	FAC+4
  4852 00:B907: A8           	tay			; Y=0 TOO
  4853 00:B908: 60           RTS17:	rts
  4854                        
  4855                        
  4856                        ; ----------------------------------------------------------------------------
  4857                        ; CONVERT STRING TO FP VALUE IN FAC
  4858                        ;
  4859                        ; STRING POINTED TO BY TXTPTR
  4860                        ; FIRST CHAR ALREADY SCANNED BY CHRGET
  4861                        ; (A) = FIRST CHAR, C=0 IF DIGIT.
  4862                        ; ----------------------------------------------------------------------------
  4863 00:B909: A0 00        FIN:    ldy	#0		; CLEAR WORKING AREA ($99...$A3)
  4864 00:B90B: A2 0A        	ldx	#10		; TMPEXP, EXPON, DPFLG, EXPSGN, FAC, SERLEN
  4865 00:B90D: 94 99        FIN_1:	sty	TMPEXP,x
  4866 00:B90F: CA           	dex
  4867 00:B910: 10 FB        	bpl	FIN_1
  4868                        ; ----------------------------------------------------------------------------
  4869 00:B912: 90 0F        	bcc	FIN2		; FIRST CHAR IS A DIGIT
  4870 00:B914: C9 2D        	cmp	#'-'		; CHECK FOR LEADING SIGN
  4871 00:B916: D0 04        	bne	FIN_2		; NOT MINUS
  4872 00:B918: 86 A3        	stx	SERLEN		; MINUS, SET SERLEN = $FF FOR FLAG
  4873 00:B91A: F0 04        	beq	FIN1		; ...ALWAYS
  4874 00:B91C: C9 2B        FIN_2:	cmp	#'+'		; MIGHT BE PLUS
  4875 00:B91E: D0 05        	bne	FIN3		; NOT PLUS EITHER, CHECK DECIMAL POINT
  4876                        
  4877                        ; ----------------------------------------------------------------------------
  4878 00:B920: 20 B1 00     FIN1:	jsr	CHRGET		; GET NEXT CHAR OF STRING
  4879                        
  4880                        ; ----------------------------------------------------------------------------
  4881 00:B923: 90 5B        FIN2:	bcc	FIN9		; INSERT THIS DIGIT
  4882                        
  4883                        ; ----------------------------------------------------------------------------
  4884 00:B925: C9 2E        FIN3:	cmp	#'.'		; CHECK FOR DECIMAL POINT
  4885 00:B927: F0 2E        	beq	FIN10		; YES
  4886 00:B929: C9 45        	cmp	#'E'		; CHECK FOR EXPONENT PART
  4887 00:B92B: D0 30        	bne	FIN7		; NO, END OF NUMBER
  4888 00:B92D: 20 B1 00     	jsr	CHRGET		; YES, START CONVERTING EXPONENT
  4889 00:B930: 90 17        	bcc	FIN5		; EXPONENT DIGIT
  4890 00:B932: C9 A8        	cmp	#TOKEN_MINUS	; NEGATIVE EXPONENT?
  4891 00:B934: F0 0E        	beq	FIN31		; YES
  4892 00:B936: C9 2D        	cmp	#'-'		; MIGHT NOT BE TOKENIZED YET
  4893 00:B938: F0 0A        	beq	FIN31		; YES, IT IS NEGATIVE
  4894 00:B93A: C9 A7        	cmp	#TOKEN_PLUS	; OPTIONAL "+"
  4895 00:B93C: F0 08        	beq	FIN4		; YES
  4896 00:B93E: C9 2B        	cmp	#'+'		; MIGHT NOT BE TOKENIZED YET
  4897 00:B940: F0 04        	beq	FIN4		; YES, FOUND "+"
  4898 00:B942: D0 07        	bne	FIN6		; ...ALWAYS, NUMBER COMPLETED
  4899 00:B944: 66 9C        FIN31:	ror     EXPSGN		; C=1, SET FLAG NEGATIVE
  4900                        
  4901                        ; ----------------------------------------------------------------------------
  4902 00:B946: 20 B1 00     FIN4:	jsr	CHRGET		; GET NEXT DIGIT OF EXPONENT
  4903                        
  4904                        ; ----------------------------------------------------------------------------
  4905 00:B949: 90 5B        FIN5:	bcc	GETEXP		; CHAR IS A DIGIT OF EXPONENT
  4906                        
  4907                        ; ----------------------------------------------------------------------------
  4908 00:B94B: 24 9C        FIN6:	bit	EXPSGN		; END OF NUMBER, CHECK EXP SIGN
  4909 00:B94D: 10 0E        	bpl	FIN7		; POSITIVE EXPONENT
  4910 00:B94F: A9 00        	lda	#0		; NEGATIVE EXPONENT
  4911 00:B951: 38           	sec			; MAKE 2'S COMPLEMENT OF EXPONENT
  4912 00:B952: E5 9A        	sbc	EXPON
  4913 00:B954: 4C 5F B9     	jmp	FIN8
  4914                        ; ----------------------------------------------------------------------------
  4915                        ; FOUND A DECIMAL POINT
  4916                        ; ----------------------------------------------------------------------------
  4917 00:B957: 66 9B        FIN10:	ror	DPFLG		; C=1, SET DPFLG FOR DECIMAL POINT
  4918 00:B959: 24 9B        	bit	DPFLG		; CHECK IF PREVIOUS DEC. PT.
  4919 00:B95B: 50 C3        	bvc	FIN1		; NO PREVIOUS DECIMAL POINT
  4920                        ; A SECOND DECIMAL POINT IS TAKEN AS A TERMINATOR
  4921                        ; TO THE NUMERIC STRING.
  4922                        ; "A=11..22" WILL GIVE A SYNTAX ERROR, BECAUSE
  4923                        ; IT IS TWO NUMBERS WITH NO OPERATOR BETWEEN.
  4924                        ; "PRINT 11..22" GIVES NO ERROR, BECAUSE IT IS
  4925                        ; JUST THE CONCATENATION OF TWO NUMBERS.
  4926                        
  4927                        ; ----------------------------------------------------------------------------
  4928                        ; NUMBER TERMINATED, ADJUST EXPONENT NOW
  4929                        ; ----------------------------------------------------------------------------
  4930 00:B95D: A5 9A        FIN7:	lda	EXPON		; E-VALUE
  4931 00:B95F: 38           FIN8:	sec			; MODIFY WITH COUNT OF DIGITS
  4932 00:B960: E5 99        	sbc	TMPEXP		; AFTER THE DECIMAL POINT
  4933 00:B962: 85 9A        	sta	EXPON		; COMPLETE CURRENT EXPONENT
  4934 00:B964: F0 12        	beq	FIN815		; NO ADJUST NEEDED IF EXP=0
  4935 00:B966: 10 09        	bpl	FIN814		; EXP>0, MULTIPLY BY TEN
  4936 00:B968: 20 17 B7     FIN813:	jsr	DIV10		; EXP<0, DIVIDE BY TEN
  4937 00:B96B: E6 9A        	inc	EXPON		; UNTIL EXP=0
  4938 00:B96D: D0 F9        	bne	FIN813
  4939 00:B96F: F0 07        	beq	FIN815		; ...ALWAYS, WE ARE FINISHED
  4940 00:B971: 20 FB B6     FIN814:	jsr	MUL10		; EXP>0, MULTIPLY BKY TEN
  4941 00:B974: C6 9A        	dec	EXPON		; UNTIL EXP=0
  4942 00:B976: D0 F9        	bne	FIN814
  4943 00:B978: A5 A3        FIN815:	lda	SERLEN		; IS WHOLE NUMBER NEGATIVE?
  4944 00:B97A: 30 01        	bmi	FIN816		; YES
  4945 00:B97C: 60           	rts			; NO, RETURN, WHOLE JOB DONE!
  4946 00:B97D: 4C 8C BB     FIN816:	jmp	NEGOP		; NEGATIVE NUMBER, SO NEGATE FAC
  4947                        
  4948                        
  4949                        ; ----------------------------------------------------------------------------
  4950                        ; ACCUMULATE A DIGIT INTO FAC
  4951                        ; ----------------------------------------------------------------------------
  4952 00:B980: 48           FIN9:	pha			; SAVE DIGIT
  4953 00:B981: 24 9B        	bit	DPFLG		; SEEN A DECIMAL POINT YET?
  4954 00:B983: 10 02        	bpl	FIN91		; NO, STILL IN INTEGER PART
  4955 00:B985: E6 99        	inc	TMPEXP		; YES, COUNT THE FRACTIONAL DIGIT
  4956 00:B987: 20 FB B6     FIN91:	jsr	MUL10		; FAC = FAC * 10
  4957 00:B98A: 68           	pla			; CURRENT DIGIT
  4958 00:B98B: 29 0F        	and	#$0F
  4959 00:B98D: 20 93 B9     	jsr	ADDACC		; ADD THE DIGIT
  4960 00:B990: 4C 20 B9     	jmp	FIN1		; GO BACK FOR MORE
  4961                        
  4962                        
  4963                        ; ----------------------------------------------------------------------------
  4964                        ; ADD (A) TO FAC
  4965                        ; ----------------------------------------------------------------------------
  4966 00:B993: 48           ADDACC:	pha			; SAVE ADDEND
  4967 00:B994: 20 25 B8     	jsr	COPY_FAC_TO_ARG_ROUNDED
  4968 00:B997: 68           	pla			; GET ADDEND AGAIN
  4969 00:B998: 20 55 B8     	jsr	FLOAT		; CONVERT TO FP VALUE IN FAC
  4970 00:B99B: A5 AA        	lda	ARGSIGN
  4971 00:B99D: 45 A2        	eor	FACSIGN
  4972 00:B99F: 85 AB        	sta	SGNCPR
  4973 00:B9A1: A6 9D        	ldx	FAC		; TO SIGNAL IF FAC=0
  4974 00:B9A3: 4C 88 B4     	jmp	FADDT		; PERFORM THE ADDITION
  4975                        
  4976                        
  4977                        ; ----------------------------------------------------------------------------
  4978                        ; ACCUMULATE DIGIT OF EXPONENT
  4979                        ; ----------------------------------------------------------------------------
  4980 00:B9A6: A5 9A        GETEXP:	lda	EXPON		; CHECK CURRENT VALUE
  4981 00:B9A8: C9 0A        	cmp	#10		; FOR MORE THAN 2 DIGITS
  4982 00:B9AA: 90 09        	bcc	GETEXP1		; NO, THIS IS 1ST OR 2ND DIGIT
  4983 00:B9AC: A9 64        	lda	#100		; EXPONENT TOO BIG
  4984 00:B9AE: 24 9C        	bit	EXPSGN		; UNLESS IT IS NEGATIVE
  4985 00:B9B0: 30 10        	bmi	GETEXP2		; LARGE NEGATIVE EXPONENT MAKES FAC=0
  4986 00:B9B2: 4C 9C B5     	jmp	OVERFLOW	; LARGE POSITIVE EXPONENT IS ERROR
  4987                        GETEXP1:
  4988 00:B9B5: 0A           	asl	a		; EXPONENT TIMES 10
  4989 00:B9B6: 0A           	asl	a
  4990 00:B9B7: 18           	clc
  4991 00:B9B8: 65 9A        	adc	EXPON
  4992 00:B9BA: 0A           	asl	a
  4993 00:B9BB: A0 00        	ldy	#0		; ADD THE NEW DIGIT
  4994 00:B9BD: 71 B8        	adc	(TXTPTR),y	; BUT THIS IS IN ASCII,
  4995 00:B9BF: 38           	sec			; SO ADJUST BACK TO BINARY
  4996 00:B9C0: E9 30        	sbc	#'0'
  4997                        GETEXP2:
  4998 00:B9C2: 85 9A        	sta	EXPON		; NEW VALUE
  4999 00:B9C4: 4C 46 B9     	jmp	FIN4		; BACK FOR MORE
  5000                        
  5001                        ; ----------------------------------------------------------------------------
  5002                        CON_99999999_9:
  5003 00:B9C7: 9B 3E BC 1F  	db	$9B,$3E,$BC,$1F,$FD	; 99,999,999.9
       00:B9CB: FD 
  5004                        
  5005                        CON_999999999:
  5006 00:B9CC: 9E 6E 6B 27  	db	$9E,$6E,$6B,$27,$FD	; 999,999,999
       00:B9D0: FD 
  5007                        
  5008                        CON_BILLION:
  5009 00:B9D1: 9E 6E 6B 28  	db	$9E,$6E,$6B,$28,$00	; 1,000,000,000
       00:B9D5: 00 
  5010                        
  5011                        
  5012                        ; ----------------------------------------------------------------------------
  5013                        ; PRINT "IN <LINE #>"
  5014                        ; ----------------------------------------------------------------------------
  5015 00:B9D6: A9 21        INPRT:	lda	#<QT_IN		; PRINT " IN "
  5016 00:B9D8: A0 A2        	ldy	#>QT_IN
  5017 00:B9DA: 20 2B A9     	jsr	STROUT
  5018 00:B9DD: A5 76        	lda	CURLIN+1
  5019 00:B9DF: A6 75        	ldx	CURLIN
  5020                        
  5021                        
  5022                        ; ----------------------------------------------------------------------------
  5023                        ; PRINT A,X AS DECIMAL INTEGER
  5024                        ; ----------------------------------------------------------------------------
  5025 00:B9E1: 85 9E        LINPRT:	sta	FAC+1		; PRINT A,X IN DECIMAL
  5026 00:B9E3: 86 9F        	stx	FAC+2
  5027 00:B9E5: A2 90        	ldx	#$90		; EXPONENT = 2^16
  5028 00:B9E7: 38           	sec			; CONVERT UNSIGNED
  5029 00:B9E8: 20 62 B8     	jsr	FLOAT2		; CONVERT LINE # TO FP
  5030 00:B9EB: 20 F1 B9     	jsr	FOUT		; CONVERT (FAC) TO STRING AT STACK
  5031 00:B9EE: 4C 2B A9     	jmp	STROUT		; PRINT STRING AT A,Y
  5032                        
  5033                        
  5034                        ; ----------------------------------------------------------------------------
  5035                        ; CONVERT (FAC) TO STRING STARTING AT STACK
  5036                        ; RETURN WITH (Y,A) POINTING AT STRING
  5037                        ; ----------------------------------------------------------------------------
  5038 00:B9F1: A0 01        FOUT:	ldy	#1		; NORMAL ENTRY PUTS STRING AT STACK...
  5039                        
  5040                        
  5041                        ; ----------------------------------------------------------------------------
  5042                        ; "STR$" FUNCTION ENTERS HERE, WITH (Y)=0
  5043                        ; SO THAT RESULT STRING STARTS AT STACK-1
  5044                        ; (THIS IS USED AS A FLAG)
  5045                        ; ----------------------------------------------------------------------------
  5046 00:B9F3: A9 2D        FOUT1:	lda	#'-'		; IN CASE VALUE NEGATIVE
  5047 00:B9F5: 88           	dey			; BACK UP PNTR
  5048 00:B9F6: 24 A2        	bit	FACSIGN
  5049 00:B9F8: 10 04        	bpl	FOUT11		; VALUE IS +
  5050 00:B9FA: C8           	iny			; VALUE IS -
  5051 00:B9FB: 99 FF 00     	sta	STACK-1,y	; EMIT "-"
  5052 00:B9FE: 85 A2        FOUT11:	sta	FACSIGN		; MAKE FAC.SIGN POSITIVE ($2D)
  5053 00:BA00: 84 AD        	sty	STRNG2		; SAVE STRING PNTR
  5054 00:BA02: C8           	iny
  5055 00:BA03: A9 30        	lda	#'0'		; IN CASE (FAC)=0
  5056 00:BA05: A6 9D        	ldx	FAC		; NUMBER=0?
  5057 00:BA07: D0 03        	bne	FOUT12		; NO, (FAC) NOT ZERO
  5058 00:BA09: 4C 14 BB     	jmp	FOUT4		; YES, FINISHED
  5059                        ; ----------------------------------------------------------------------------
  5060 00:BA0C: A9 00        FOUT12:	lda	#0		; STARTING VALUE FOR TMPEXP
  5061 00:BA0E: E0 80        	cpx	#$80		; ANY INTEGER PART?
  5062 00:BA10: F0 02        	beq	FOUT13		; NO, BTWN .5 AND .999999999
  5063 00:BA12: B0 09        	bcs	FOUT14		; YES
  5064                        ; ----------------------------------------------------------------------------
  5065 00:BA14: A9 D1        FOUT13:	lda	#<CON_BILLION	; MULTIPLY BY 1E9
  5066 00:BA16: A0 B9        	ldy	#>CON_BILLION	; TO GIVE ADJUSTMENT A HEAD START
  5067 00:BA18: 20 46 B6     	jsr	FMULT
  5068 00:BA1B: A9 F7        	lda	#$F7		; A = -9 : EXPONENT ADJUSTMENT
  5069 00:BA1D: 85 99        FOUT14:	sta	TMPEXP		; 0 OR -9
  5070                        ; ----------------------------------------------------------------------------
  5071                        ; ADJUST UNTIL 1E8 <= (FAC) <1E9
  5072                        ; ----------------------------------------------------------------------------
  5073 00:BA1F: A9 CC        FOUT15:	lda	#<CON_999999999
  5074 00:BA21: A0 B9        	ldy	#>CON_999999999
  5075 00:BA23: 20 74 B8     	jsr	FCOMP		; COMPARE TO 1E9-1
  5076 00:BA26: F0 1E        	beq	FOUT110		; (FAC) = 1E9-1
  5077 00:BA28: 10 12        	bpl	FOUT18		; TOO LARGE, DIVIDE BY TEN
  5078 00:BA2A: A9 C7        FOUT16:	lda	#<CON_99999999_9	; COMPARE TO 1E8-.1
  5079 00:BA2C: A0 B9        	ldy	#>CON_99999999_9
  5080 00:BA2E: 20 74 B8     	jsr	FCOMP		; COMPARE TO 1E8-.1
  5081 00:BA31: F0 02        	beq	FOUT17		; (FAC) = 1E8-.1
  5082 00:BA33: 10 0E        	bpl	FOUT19		; IN RANGE, ADJUSTMENT FINISHED
  5083 00:BA35: 20 FB B6     FOUT17:	jsr	MUL10		; TOO SMALL, MULTIPLY BY TEN
  5084 00:BA38: C6 99        	dec	TMPEXP		; KEEP TRACK OF MULTIPLIES
  5085 00:BA3A: D0 EE        	bne	FOUT16		; ...ALWAYS
  5086 00:BA3C: 20 17 B7     FOUT18:	jsr	DIV10		; TOO LARGE, DIVIDE BY TEN
  5087 00:BA3F: E6 99        	inc	TMPEXP		; KEEP TRACK OF DIVISIONS
  5088 00:BA41: D0 DC        	bne	FOUT15		; ...ALWAYS
  5089                        ; ----------------------------------------------------------------------------
  5090 00:BA43: 20 67 B4     FOUT19:	jsr	FADDH_		; ROUND ADJUSTED RESULT
  5091                        FOUT110:
  5092 00:BA46: 20 B1 B8     	jsr	QINT		; CONVERT ADJUSTED VALUE TO 32-BIT INTEGER
  5093                        
  5094                        
  5095                        ; ----------------------------------------------------------------------------
  5096                        ; FAC+1...FAC+4 IS NOW IN INTEGER FORM
  5097                        ; WITH POWER OF TEN ADJUSTMENT IN TMPEXP
  5098                        ;
  5099                        ; IF -10 < TMPEXP > 1, PRINT IN DECIMAL FORM
  5100                        ; OTHERWISE, PRINT IN EXPONENTIAL FORM
  5101                        ; ----------------------------------------------------------------------------
  5102 00:BA49: A2 01        FOUT2:	ldx	#1		; ASSUME 1 DIGIT BEFORE "."
  5103 00:BA4B: A5 99        	lda	TMPEXP		; CHECK RANGE
  5104 00:BA4D: 18           	clc
  5105 00:BA4E: 69 0A        	adc	#10
  5106 00:BA50: 30 09        	bmi	FOUT21		; < .01, USE EXPONENTIAL FORM
  5107 00:BA52: C9 0B        	cmp	#11
  5108 00:BA54: B0 06        	bcs	FOUT22		; >= 1E10, USE EXPONENTIAL FORM
  5109 00:BA56: 69 FF        	adc	#$FF		; LESS 1 GIVES INDEX FOR "."
  5110 00:BA58: AA           	tax
  5111 00:BA59: A9 02        	lda	#2		; SET REMAINING EXPONENT = 0
  5112 00:BA5B: 38           FOUT21:	sec			; COMPUTE REMAINING EXPONENT
  5113 00:BA5C: E9 02        FOUT22:	sbc	#2
  5114 00:BA5E: 85 9A        	sta	EXPON		; VALUE FOR "E+XX" OR "E-XX"
  5115 00:BA60: 86 99        	stx	TMPEXP		; INDEX FOR DECIMAL POINT
  5116 00:BA62: 8A           	txa			; SEE IF "." COMES FIRST
  5117 00:BA63: F0 02        	beq	FOUT23		; YES
  5118 00:BA65: 10 13        	bpl	FOUT25		; NO, LATER
  5119 00:BA67: A4 AD        FOUT23:	ldy	STRNG2		; GET INDEX INTO STRING BEING BUILT
  5120 00:BA69: A9 2E        	lda	#'.'		; STORE A DECIMAL POINT
  5121 00:BA6B: C8           	iny
  5122 00:BA6C: 99 FF 00     	sta	STACK-1,y
  5123 00:BA6F: 8A           	txa			; SEE IF NEED ".0"
  5124 00:BA70: F0 06        	beq	FOUT24		; NO
  5125 00:BA72: A9 30        	lda	#'0'		; YES, STORE "0"
  5126 00:BA74: C8           	iny
  5127 00:BA75: 99 FF 00     	sta	STACK-1,y
  5128 00:BA78: 84 AD        FOUT24:	sty	STRNG2		; SAVE OUTPUT INDEX AGAIN
  5129                        ; ----------------------------------------------------------------------------
  5130                        ; NOW DIVIDE BY POWERS OF TEN TO GET SUCCESSIVE DIGITS
  5131                        ; ----------------------------------------------------------------------------
  5132 00:BA7A: A0 00        FOUT25:	ldy	#0		; INDEX TO TABLE OF POWERS OF TEN
  5133 00:BA7C: A2 80        	ldx	#$80		; STARTING VALUE FOR DIGIT WITH DIRECTION
  5134 00:BA7E: A5 A1        FOUT26:	lda	FAC+4		; START BY ADDING -100000000 UNTIL
  5135 00:BA80: 18           	clc			; OVERSHOOT.  THEN ADD +10000000,
  5136 00:BA81: 79 29 BB     	adc	DECTBL+3,y	; THEN ADD -1000000, THEN ADD
  5137 00:BA84: 85 A1        	sta	FAC+4		; +100000, AND SO ON.
  5138 00:BA86: A5 A0        	lda	FAC+3		; THE # OF TIMES EACH POWER IS ADDED
  5139 00:BA88: 79 28 BB     	adc	DECTBL+2,y	; IS 1 MORE THAN CORRESPONDING DIGIT
  5140 00:BA8B: 85 A0        	sta	FAC+3
  5141 00:BA8D: A5 9F        	lda	FAC+2
  5142 00:BA8F: 79 27 BB     	adc	DECTBL+1,y
  5143 00:BA92: 85 9F        	sta	FAC+2
  5144 00:BA94: A5 9E        	lda	FAC+1
  5145 00:BA96: 79 26 BB     	adc	DECTBL,y
  5146 00:BA99: 85 9E        	sta	FAC+1
  5147 00:BA9B: E8           	inx			; COUNT THE ADD
  5148 00:BA9C: B0 04        	bcs	FOUT27		; IF C=1 AND X NEGATIVE, KEEP ADDING
  5149 00:BA9E: 10 DE        	bpl	FOUT26		; IF C=0 AND X POSITIVE, KEEP ADDING
  5150 00:BAA0: 30 02        	bmi	FOUT28		; IF C=0 AND X NEGATIVE, WE OVERSHOT
  5151 00:BAA2: 30 DA        FOUT27:	bmi	FOUT26		; IF C=1 AND X POSITIVE, WE OVERSHOT
  5152 00:BAA4: 8A           FOUT28:	txa			; OVERSHOT, SO MAKE X INTO A DIGIT
  5153 00:BAA5: 90 04        	bcc	FOUT29		; HOW DEPENDS ON DIRECTION WE WERE GOING
  5154 00:BAA7: 49 FF        	eor	#$FF		; DIGIT = 9-X
  5155 00:BAA9: 69 0A        	adc	#10
  5156 00:BAAB: 69 2F        FOUT29:	adc	#'0'-1		; MAKE DIGIT INTO ASCII
  5157 00:BAAD: C8           	iny			; ADVANCE TO NEXT SMALLER POWER OF TEN
  5158 00:BAAE: C8           	iny
  5159 00:BAAF: C8           	iny
  5160 00:BAB0: C8           	iny
  5161 00:BAB1: 84 83        	sty	VARPNT		; SAVE PNTR TO POWERS
  5162 00:BAB3: A4 AD        	ldy	STRNG2		; GET OUTPUT PNTR
  5163 00:BAB5: C8           	iny			; STORE THE DIGIT
  5164 00:BAB6: AA           	tax			; SAVE DIGIT, HI-BIT IS DIRECTION
  5165 00:BAB7: 29 7F        	and	#$7F		; MAKE SURE $30...$39 FOR STRING
  5166 00:BAB9: 99 FF 00     	sta	STACK-1,y
  5167 00:BABC: C6 99        	dec	TMPEXP		; COUNT THE DIGIT
  5168 00:BABE: D0 06        	bne	FOUT210		; NOT TIME FOR "." YET
  5169 00:BAC0: A9 2E        	lda	#'.'		; TIME, SO STORE THE DECIMAL POINT
  5170 00:BAC2: C8           	iny
  5171 00:BAC3: 99 FF 00     	sta	STACK-1,y
  5172                        FOUT210:
  5173 00:BAC6: 84 AD        	sty	STRNG2		; SAVE OUTPUT PNTR AGAIN
  5174 00:BAC8: A4 83        	ldy	VARPNT		; GET PNTR TO POWERS
  5175 00:BACA: 8A           	txa			; GET DIGIT WITH HI-BIT = DIRECTION
  5176 00:BACB: 49 FF        	eor	#$FF		; CHANGE DIRECTION
  5177 00:BACD: 29 80        	and	#$80		; $00 IF ADDING, $80 IF SUBTRACTING
  5178 00:BACF: AA           	tax
  5179 00:BAD0: C0 24        	cpy	#DECTBL_END-DECTBL
  5180 00:BAD2: D0 AA        	bne	FOUT26		; NOT FINISHED YET
  5181                        
  5182                        
  5183                        ; ----------------------------------------------------------------------------
  5184                        ; NINE DIGITS HAVE BEEN STORED IN STRING.  NOW LOOK
  5185                        ; BACK AND LOP OFF TRAILING ZEROES AND A TRAILING
  5186                        ; DECIMAL POINT.
  5187                        ; ----------------------------------------------------------------------------
  5188 00:BAD4: A4 AD        FOUT3:	ldy	STRNG2		; POINTS AT LAST STORED CHAR
  5189 00:BAD6: B9 FF 00     FOUT31:	lda	STACK-1,y	; SEE IF LOPPABLE
  5190 00:BAD9: 88           	dey
  5191 00:BADA: C9 30        	cmp	#'0'		; SUPPRESS TRAILING ZEROES
  5192 00:BADC: F0 F8        	beq	FOUT31		; YES, KEEP LOOPING
  5193 00:BADE: C9 2E        	cmp	#'.'		; SUPPRESS TRAILING DECIMAL POINT
  5194 00:BAE0: F0 01        	beq	FOUT32		; ".", SO WRITE OVER IT
  5195 00:BAE2: C8           	iny			; NOT ".", SO INCLUDE IN STRING AGAIN
  5196 00:BAE3: A9 2B        FOUT32:	lda	#'+'		; PREPARE FOR POSITIVE EXPONENT "E+XX"
  5197 00:BAE5: A6 9A        	ldx	EXPON		; SEE IF ANY E-VALUE
  5198 00:BAE7: F0 2E        	beq	FOUT5		; NO, JUST MARK END OF STRING
  5199 00:BAE9: 10 08        	bpl	FOUT33		; YES, AND IT IS POSITIVE
  5200 00:BAEB: A9 00        	lda	#0		; YES, AND IT IS NEGATIVE
  5201 00:BAED: 38           	sec			; COMPLEMENT THE VALUE
  5202 00:BAEE: E5 9A        	sbc	EXPON
  5203 00:BAF0: AA           	tax			; GET MAGNITUDE IN X
  5204 00:BAF1: A9 2D        	lda	#'-'		; E SIGN
  5205 00:BAF3: 99 01 01     FOUT33:	sta	STACK+1,y	; STORE SIGN IN STRING
  5206 00:BAF6: A9 45        	lda	#'E'		; STORE "E" IN STRING BEFORE SIGN
  5207 00:BAF8: 99 00 01     	sta	STACK,y
  5208 00:BAFB: 8A           	txa			; EXPONENT MAGNITUDE IN A-REG
  5209 00:BAFC: A2 2F        	ldx	#'0'-1		; SEED FOR EXPONENT DIGIT
  5210 00:BAFE: 38           	sec			; CONVERT TO DECIMAL
  5211 00:BAFF: E8           FOUT34:	inx			; COUNT THE SUBTRACTION
  5212 00:BB00: E9 0A        	sbc	#10		; TEN'S DIGIT
  5213 00:BB02: B0 FB        	bcs	FOUT34		; MORE TENS TO SUBTRACT
  5214 00:BB04: 69 3A        	adc	#'0'+10		; CONVERT REMAINDER TO ONE'S DIGIT
  5215 00:BB06: 99 03 01     	sta	STACK+3,y	; STORE ONE'S DIGIT
  5216 00:BB09: 8A           	txa
  5217 00:BB0A: 99 02 01     	sta	STACK+2,y	; STORE TEN'S DIGIT
  5218 00:BB0D: A9 00        	lda	#0		; MARK END OF STRING WITH $00
  5219 00:BB0F: 99 04 01     	sta	STACK+4,y
  5220 00:BB12: F0 08        	beq	FOUT6		; ...ALWAYS
  5221 00:BB14: 99 FF 00     FOUT4:	sta	STACK-1,y	; STORE "0" IN ASCII
  5222 00:BB17: A9 00        FOUT5:	lda	#0		; STORE $00 ON END OF STRING
  5223 00:BB19: 99 00 01     	sta	STACK,y
  5224 00:BB1C: A9 00        FOUT6:	lda	#<STACK		; POINT Y,A AT BEGINNING OF STRING
  5225 00:BB1E: A0 01        	ldy	#>STACK		; (STR$ STARTED STRING AT STACK-1, BUT
  5226 00:BB20: 60           	rts			; STR$ DOESN'T USE Y,A ANYWAY.)
  5227                        
  5228                        
  5229                        ; ----------------------------------------------------------------------------
  5230                        CON_HALF:
  5231 00:BB21: 80 00 00 00  	db	$80,$00,$00,$00,$00	; FP CONSTANT 0.5
       00:BB25: 00 
  5232                        
  5233                        
  5234                        ; ----------------------------------------------------------------------------
  5235                        ; POWERS OF 10 FROM 1E8 DOWN TO 1,
  5236                        ; AS 32-BIT INTEGERS, WITH ALTERNATING SIGNS
  5237                        ; ----------------------------------------------------------------------------
  5238 00:BB26: FA 0A 1F 00  DECTBL: db	$FA,$0A,$1F,$00		; -100000000
  5239 00:BB2A: 00 98 96 80  	db	$00,$98,$96,$80		; 10000000
  5240 00:BB2E: FF F0 BD C0  	db	$FF,$F0,$BD,$C0		; -1000000
  5241 00:BB32: 00 01 86 A0  	db	$00,$01,$86,$A0		; 100000
  5242 00:BB36: FF FF D8 F0  	db	$FF,$FF,$D8,$F0		; -10000
  5243 00:BB3A: 00 00 03 E8  	db	$00,$00,$03,$E8		; 1000
  5244 00:BB3E: FF FF FF 9C  	db	$FF,$FF,$FF,$9C		; -100
  5245 00:BB42: 00 00 00 0A  	db	$00,$00,$00,$0A		; 10
  5246 00:BB46: FF FF FF FF  	db	$FF,$FF,$FF,$FF		; -1
  5247                        DECTBL_END:
  5248                        
  5249                        
  5250                        ; ----------------------------------------------------------------------------
  5251                        ; "SQR" FUNCTION
  5252                        ; ----------------------------------------------------------------------------
  5253 00:BB4A: 20 25 B8     SQR:	jsr	COPY_FAC_TO_ARG_ROUNDED
  5254 00:BB4D: A9 21        	lda	#<CON_HALF		; SET UP POWER OF 0.5
  5255 00:BB4F: A0 BB        	ldy	#>CON_HALF
  5256 00:BB51: 20 BB B7     	jsr	LOAD_FAC_FROM_YA
  5257                        
  5258                        
  5259                        ; ----------------------------------------------------------------------------
  5260                        ; EXPONENTIATION OPERATION
  5261                        ;
  5262                        ; ARG ^ FAC  =  EXP( LOG(ARG) * FAC )
  5263                        ; ----------------------------------------------------------------------------
  5264 00:BB54: F0 6F        FPWRT:	beq	EXP		; IF FAC=0, ARG^FAC=EXP(0)
  5265 00:BB56: A5 A5        	lda	ARG		; IF ARG=0, ARG^FAC=0
  5266 00:BB58: D0 03        	bne	FPWRT1		; NEITHER IS ZERO
  5267 00:BB5A: 4C 17 B5     	jmp	STA_IN_FAC_SIGN_AND_EXP		; SET FAC = 0
  5268 00:BB5D: A2 8A        FPWRT1:	ldx	#TEMP3		; SAVE FAC IN TEMP3
  5269 00:BB5F: A0 00        	ldy	#0
  5270 00:BB61: 20 ED B7     	jsr	STORE_FAC_AT_YX_ROUNDED
  5271 00:BB64: A5 AA        	lda	ARGSIGN		; NORMALLY, ARG MUST BE POSITIVE
  5272 00:BB66: 10 0F        	bpl	FPWRT2		; IT IS POSITIVE, SO ALL IS WELL
  5273 00:BB68: 20 E2 B8     	jsr	INT		; NEGATIVE, BUT OK IF INTEGRAL POWER
  5274 00:BB6B: A9 8A        	lda	#TEMP3		; SEE IF INT(FAC)=FAC
  5275 00:BB6D: A0 00        	ldy	#0
  5276 00:BB6F: 20 74 B8     	jsr	FCOMP		; IS IT AN INTEGER POWER?
  5277 00:BB72: D0 03        	bne	FPWRT2		; NOT INTEGRAL,  WILL CAUSE ERROR LATER
  5278 00:BB74: 98           	tya			; MAKE ARG SIGN + AS IT IS MOVED TO FAC
  5279 00:BB75: A4 0D        	ldy	CHARAC		; INTEGRAL, SO ALLOW NEGATIVE ARG
  5280 00:BB77: 20 17 B8     FPWRT2:	jsr	MFA		; MOVE ARGUMENT TO FAC
  5281 00:BB7A: 98           	tya			; SAVE FLAG FOR NEGATIVE ARG (0=+) 
  5282 00:BB7B: 48           	pha
  5283 00:BB7C: 20 08 B6     	jsr	LOG		; GET LOG(ARG)
  5284 00:BB7F: A9 8A        	lda	#TEMP3		; MULTIPLY BY POWER
  5285 00:BB81: A0 00        	ldy	#0
  5286 00:BB83: 20 46 B6     	jsr	FMULT
  5287 00:BB86: 20 C5 BB     	jsr	EXP		; E ^ LOG(FAC)
  5288 00:BB89: 68           	pla			; GET FLAG FOR NEGATIVE ARG
  5289 00:BB8A: 10 0A        	bpl	RTS18		; NOT NEGATIVE, FINISHED
  5290                        
  5291                        
  5292                        ; ----------------------------------------------------------------------------
  5293                        ; NEGATE VALUE IN FAC
  5294                        ; ----------------------------------------------------------------------------
  5295 00:BB8C: A5 9D        NEGOP:	lda	FAC		; IF FAC=0, NO NEED TO COMPLEMENT
  5296 00:BB8E: F0 06        	beq	RTS18		; YES, FAC=0
  5297 00:BB90: A5 A2        	lda	FACSIGN		; NO, SO TOGGLE SIGN
  5298 00:BB92: 49 FF        	eor	#$FF
  5299 00:BB94: 85 A2        	sta	FACSIGN
  5300 00:BB96: 60           RTS18:	rts
  5301                        
  5302                        
  5303                        ; ----------------------------------------------------------------------------
  5304                        CON_LOG_E:
  5305 00:BB97: 81 38 AA 3B  	db	$81,$38,$AA,$3B,$29	; LOG(E) TO BASE 2
       00:BB9B: 29 
  5306                        ; ----------------------------------------------------------------------------
  5307                        POLY_EXP:
  5308 00:BB9C: 07           	db	$07			; ( # OF TERMS IN POLYNOMIAL) - 1
  5309 00:BB9D: 71 34 58 3E  	db	$71,$34,$58,$3E,$56	; (LOG(2)^7)/8!
       00:BBA1: 56 
  5310 00:BBA2: 74 16 7E B3  	db	$74,$16,$7E,$B3,$1B	; (LOG(2)^6)/7!
       00:BBA6: 1B 
  5311 00:BBA7: 77 2F EE E3  	db	$77,$2F,$EE,$E3,$85	; (LOG(2)^5)/6!
       00:BBAB: 85 
  5312 00:BBAC: 7A 1D 84 1C  	db	$7A,$1D,$84,$1C,$2A	; (LOG(2)^4)/5!
       00:BBB0: 2A 
  5313 00:BBB1: 7C 63 59 58  	db	$7C,$63,$59,$58,$0A	; (LOG(2)^3)/4!
       00:BBB5: 0A 
  5314 00:BBB6: 7E 75 FD E7  	db	$7E,$75,$FD,$E7,$C6	; (LOG(2)^2)/3!
       00:BBBA: C6 
  5315 00:BBBB: 80 31 72 18  	db	$80,$31,$72,$18,$10	; LOG(2)/2!
       00:BBBF: 10 
  5316 00:BBC0: 81 00 00 00  	db	$81,$00,$00,$00,$00	; 1
       00:BBC4: 00 
  5317                        
  5318                        
  5319                        ; ----------------------------------------------------------------------------
  5320                        ; "EXP" FUNCTION
  5321                        ;
  5322                        ; FAC = E ^ FAC
  5323                        ; ----------------------------------------------------------------------------
  5324 00:BBC5: A9 97        EXP:	lda	#<CON_LOG_E	; CONVERT TO POWER OF TWO PROBLEM
  5325 00:BBC7: A0 BB        	ldy	#>CON_LOG_E	; E^X = 2^(LOG2(E)*X)
  5326 00:BBC9: 20 46 B6     	jsr	FMULT
  5327 00:BBCC: A5 AC        	lda	FACEXTENSION	; NON-STANDARD ROUNDING HERE
  5328 00:BBCE: 69 50        	adc	#$50		; ROUND UP IF EXTENSION > $AF
  5329 00:BBD0: 90 03        	bcc	EXP1		; NO, DON'T ROUND UP
  5330 00:BBD2: 20 3C B8     	jsr	INCREMENT_MANTISSA
  5331 00:BBD5: 85 92        EXP1:	sta	ARGEXTENSION	; STRANGE VALUE
  5332 00:BBD7: 20 28 B8     	jsr	MAF		; COPY FAC INTO ARG
  5333 00:BBDA: A5 9D        	lda	FAC		; MAXIMUM EXPONENT IS < 128
  5334 00:BBDC: C9 88        	cmp	#$88		; WITHIN RANGE?
  5335 00:BBDE: 90 03        	bcc	EXP3		; YES
  5336 00:BBE0: 20 ED B6     EXP2:	jsr	OUTOFRNG	; OVERFLOW IF +, RETURN 0.0 IF -
  5337 00:BBE3: 20 E2 B8     EXP3:	jsr	INT		; GET INT(FAC)
  5338 00:BBE6: A5 0D        	lda	CHARAC		; THIS IS THE INETGRAL PART OF THE POWER
  5339 00:BBE8: 18           	clc			; ADD TO EXPONENT BIAS + 1
  5340 00:BBE9: 69 81        	adc	#$81
  5341 00:BBEB: F0 F3        	beq	EXP2		; OVERFLOW
  5342 00:BBED: 38           	sec			; BACK OFF TO NORMAL BIAS
  5343 00:BBEE: E9 01        	sbc	#1
  5344 00:BBF0: 48           	pha			; SAVE EXPONENT
  5345                        ; ----------------------------------------------------------------------------
  5346 00:BBF1: A2 05        	ldx	#5		; SWAP ARG AND FAC
  5347 00:BBF3: B5 A5        EXP4:	lda	ARG,x
  5348 00:BBF5: B4 9D        	ldy	FAC,x
  5349 00:BBF7: 95 9D        	sta	FAC,x
  5350 00:BBF9: 94 A5        	sty	ARG,x
  5351 00:BBFB: CA           	dex
  5352 00:BBFC: 10 F5        	bpl	EXP4
  5353 00:BBFE: A5 92        	lda	ARGEXTENSION
  5354 00:BC00: 85 AC        	sta	FACEXTENSION
  5355 00:BC02: 20 71 B4     	jsr	FSUBT		; POWER-INT(POWER) --> FRACTIONAL PART
  5356 00:BC05: 20 8C BB     	jsr	NEGOP
  5357 00:BC08: A9 9C        	lda	#<POLY_EXP
  5358 00:BC0A: A0 BB        	ldy	#>POLY_EXP
  5359 00:BC0C: 20 2D BC     	jsr	POLYNOMIAL	; COMPUTE F(X) ON FRACTIONAL PART
  5360 00:BC0F: A9 00        	lda	#0
  5361 00:BC11: 85 AB        	sta	SGNCPR
  5362 00:BC13: 68           	pla			; GET EXPONENT
  5363 00:BC14: 4C D5 B6     	jmp	ADD_EXPONENTS1
  5364                        
  5365                        
  5366                        ; ----------------------------------------------------------------------------
  5367                        ; ODD POLYNOMIAL SUBROUTINE
  5368                        ;
  5369                        ; F(X) = X * P(X^2)
  5370                        ;
  5371                        ; WHERE:  X IS VALUE IN FAC
  5372                        ;	Y,A POINTS AT COEFFICIENT TABLE
  5373                        ;	FIRST BYTE OF COEFF. TABLE IS N
  5374                        ;	COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
  5375                        ;
  5376                        ; P(X^2) COMPUTED USING NORMAL POLYNOMIAL SUBROUTINE
  5377                        ; ----------------------------------------------------------------------------
  5378                        POLYNOMIAL_ODD:
  5379 00:BC17: 85 AD        	sta	SERPNT		; SAVE ADDRESS OF COEFFICIENT TABLE
  5380 00:BC19: 84 AE        	sty	SERPNT+1
  5381 00:BC1B: 20 E3 B7     	jsr	STORE_FAC_IN_TEMP1_ROUNDED
  5382 00:BC1E: A9 93        	lda	#TEMP1		; Y=0 ALREADY, SO Y,A POINTS AT TEMP1
  5383 00:BC20: 20 46 B6     	jsr	FMULT		; FORM X^2
  5384 00:BC23: 20 31 BC     	jsr	SERMAIN		; DO SERIES IN X^2
  5385 00:BC26: A9 93        	lda	#<TEMP1		; GET X AGAIN
  5386 00:BC28: A0 00        	ldy	#>TEMP1
  5387 00:BC2A: 4C 46 B6     	jmp	FMULT		; MULTIPLY X BY P(X^2) AND EXIT
  5388                        
  5389                        
  5390                        ; ----------------------------------------------------------------------------
  5391                        ; NORMAL POLYNOMIAL SUBROUTINE
  5392                        ;
  5393                        ; P(X) = C(0)*X^N + C(1)*X^(N-1) + ... + C(N)
  5394                        ;
  5395                        ; WHERE:  X IS VALUE IN FAC
  5396                        ;	Y,A POINTS AT COEFFICIENT TABLE
  5397                        ;	FIRST BYTE OF COEFF. TABLE IS N
  5398                        ;	COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
  5399                        ; ----------------------------------------------------------------------------
  5400                        POLYNOMIAL:
  5401 00:BC2D: 85 AD        	sta	SERPNT		; POINTER TO COEFFICIENT TABLE
  5402 00:BC2F: 84 AE        	sty	SERPNT+1
  5403                        ; ----------------------------------------------------------------------------
  5404                        SERMAIN:
  5405 00:BC31: 20 E0 B7     	jsr	STORE_FAC_IN_TEMP2_ROUNDED
  5406 00:BC34: B1 AD        	lda	(SERPNT),y	; GET N
  5407 00:BC36: 85 A3        	sta	SERLEN		; SAVE N
  5408 00:BC38: A4 AD        	ldy	SERPNT		; BUMP PNTR TO HIGHEST COEFFICIENT
  5409 00:BC3A: C8           	iny			; AND GET PNTR INTO Y,A
  5410 00:BC3B: 98           	tya
  5411 00:BC3C: D0 02        	bne	SERMAIN1
  5412 00:BC3E: E6 AE        	inc	SERPNT+1
  5413                        SERMAIN1:
  5414 00:BC40: 85 AD        	sta	SERPNT
  5415 00:BC42: A4 AE        	ldy	SERPNT+1
  5416                        SERMAIN2:
  5417 00:BC44: 20 46 B6     	jsr	FMULT		; ACCUMULATE SERIES TERMS
  5418 00:BC47: A5 AD        	lda	SERPNT		; BUMP PNTR TO NEXT COEFFICIENT
  5419 00:BC49: A4 AE        	ldy	SERPNT+1
  5420 00:BC4B: 18           	clc
  5421 00:BC4C: 69 05        	adc	#5
  5422 00:BC4E: 90 01        	bcc	SERMAIN3
  5423 00:BC50: C8           	iny
  5424                        SERMAIN3:
  5425 00:BC51: 85 AD        	sta	SERPNT
  5426 00:BC53: 84 AE        	sty	SERPNT+1
  5427 00:BC55: 20 85 B4     	jsr	FADD		; ADD NEXT COEFFICIENT
  5428 00:BC58: A9 98        	lda	#TEMP2		; POINT AT X AGAIN
  5429 00:BC5A: A0 00        	ldy	#0
  5430 00:BC5C: C6 A3        	dec	SERLEN		; IF SERIES NOT FINISHED,
  5431 00:BC5E: D0 E4        	bne	SERMAIN2		; THEN ADD ANOTHER TERM
  5432 00:BC60: 60           RTS19:  rts			; FINISHED
  5433                        
  5434                        ; ----------------------------------------------------------------------------
  5435                        CONRND1:
  5436 00:BC61: 98 35 44 7A  	db	$98,$35,$44,$7A		; THESE ARE MISSING ONE BYTE FOR FP VALUES
  5437                        
  5438                        CONRND2:
  5439 00:BC65: 68 28 B1 46  	db	$68,$28,$B1,$46
  5440                        
  5441                        
  5442                        ; ----------------------------------------------------------------------------
  5443                        ; "RND" FUNCTION
  5444                        ; ----------------------------------------------------------------------------
  5445 00:BC69: 20 44 B8     RND:	jsr	SIGN		; REDUCE ARGUMENT TO -1, 0, OR +1
  5446 00:BC6C: AA           	tax			; SAVE ARGUMENT
  5447 00:BC6D: 30 18        	bmi	RND1		; = -1, USE CURRENT ARGUMENT FOR SEED
  5448 00:BC6F: A9 C9        	lda	#<RNDSEED	; USE CURRENT SEED
  5449 00:BC71: A0 00        	ldy	#>RNDSEED
  5450 00:BC73: 20 BB B7     	jsr	LOAD_FAC_FROM_YA
  5451 00:BC76: 8A           	txa			; RECALL SIGN OF ARGUMENT
  5452 00:BC77: F0 E7        	beq	RTS19		; =0, RETURN SEED UNCHANGED
  5453 00:BC79: A9 61        	lda	#<CONRND1	; VERY POOR RND ALGORITHM
  5454 00:BC7B: A0 BC        	ldy	#>CONRND1
  5455 00:BC7D: 20 46 B6     	jsr	FMULT
  5456 00:BC80: A9 65        	lda	#<CONRND2	; ALSO, CONSTANTS ARE TRUNCATED
  5457 00:BC82: A0 BC        	ldy	#>CONRND2
  5458 00:BC84: 20 85 B4     	jsr	FADD
  5459 00:BC87: A6 A1        RND1:	ldx	FAC+4		; SHUFFLE HI AND LO BYTES
  5460 00:BC89: A5 9E        	lda	FAC+1		; TO SUPPOSEDLY MAKE IT MORE RANDOM
  5461 00:BC8B: 85 A1        	sta	FAC+4
  5462 00:BC8D: 86 9E        	stx	FAC+1
  5463 00:BC8F: A9 00        	lda	#0		; MAKE IT POSITIVE
  5464 00:BC91: 85 A2        	sta	FACSIGN
  5465 00:BC93: A5 9D        	lda	FAC		; A SOMEWHAT RANDOM EXTENSION
  5466 00:BC95: 85 AC        	sta	FACEXTENSION
  5467 00:BC97: A9 80        	lda	#$80		; EXPONENT TO MAKE VALUE < 1.0
  5468 00:BC99: 85 9D        	sta	FAC
  5469 00:BC9B: 20 F5 B4     	jsr	NORMALIZE_FAC2
  5470 00:BC9E: A2 C9        	ldx	#<RNDSEED	; MOVE FAC TO RND SEED
  5471 00:BCA0: A0 00        	ldy	#>RNDSEED
  5472 00:BCA2: 4C ED B7     	jmp	STORE_FAC_AT_YX_ROUNDED
  5473                        
  5474                        
  5475                        ; ----------------------------------------------------------------------------
  5476                        ; GENERIC COPY OF CHRGET SUBROUTINE, WHICH
  5477                        ; IS COPIED INTO $00B1...$00C8 DURING INITIALIZATION
  5478                        ;
  5479                        ; CORNELIS BONGERS DESCRIBED SEVERAL IMPROVEMENTS 
  5480                        ; TO CHRGET IN MICRO MAGAZINE OR CALL A.P.P.L.E.
  5481                        ; (I DON'T REMEMBER WHICH OR EXACTLY WHEN)
  5482                        ; ----------------------------------------------------------------------------
  5483                        GENERIC_CHRGET:
  5484 00:BCA5: E6 B8        	inc	TXTPTR
  5485 00:BCA7: D0 02        	bne	GENERIC1
  5486 00:BCA9: E6 B9        	inc	TXTPTR+1
  5487                        GENERIC1:
  5488 00:BCAB: AD 60 EA     	lda	$EA60		; ACTUAL ADDRESS FILLED IN LATER
  5489 00:BCAE: C9 3A        	cmp	#':'		; EOS, ALSO TOP OF NUMERIC RANGE
  5490 00:BCB0: B0 0A        	bcs	GENERIC2		; NOT NUMBER, MIGHT BE EOS
  5491 00:BCB2: C9 20        	cmp	#' '		; IGNORE BLANKS
  5492 00:BCB4: F0 EF        	beq	GENERIC_CHRGET
  5493 00:BCB6: 38           	sec			; TEST FOR NUMERIC RANGE IN WAY THAT
  5494 00:BCB7: E9 30        	sbc	#'0'		; CLEARS CARRY IF CHAR IS DIGIT
  5495 00:BCB9: 38           	sec			; AND LEAVES CHAR IN A-REG
  5496 00:BCBA: E9 D0        	sbc	#$D0		; -'0'
  5497                        GENERIC2:
  5498 00:BCBC: 60           	rts
  5499                        
  5500                        
  5501                        ; ----------------------------------------------------------------------------
  5502                        ; INITIAL VALUE FOR RANDOM NUMBER, ALSO COPIED
  5503                        ; IN ALONG WITH CHRGET, BUT ERRONEOUSLY:
  5504                        ; THE LAST BYTE IS NOT COPIED
  5505                        ; ----------------------------------------------------------------------------
  5506 00:BCBD: 80 4F C7 52  	db	$80,$4F,$C7,$52,$58	; APPROX. = .811635157
       00:BCC1: 58 
  5507                        GENERIC_END:
  5508                        
  5509                        
  5510                        ; ----------------------------------------------------------------------------
  5511                        COLDSTART:
  5512 00:BCC2: A2 FF        	ldx	#$FF		; SET DIRECT MODE FLAG
  5513 00:BCC4: 86 76        	stx	CURLIN+1
  5514 00:BCC6: A2 FB        	ldx	#$FB		; SET STACK POINTER, LEAVING ROOM FOR
  5515 00:BCC8: 9A           	txs			; LINE BUFFER DURING PARSING
  5516 00:BCC9: A9 C2        	lda	#<COLDSTART	; SET RESTART TO COLD.START
  5517 00:BCCB: A0 BC        	ldy	#>COLDSTART	; UNTIL COLDSTART IS COMPLETED
  5518 00:BCCD: 85 01        	sta	GOWARM+1
  5519 00:BCCF: 84 02        	sty	GOWARM+2
  5520 00:BCD1: 85 04        	sta	GOSTROUTZ+1	; ALSO SECOND USER VECTOR...
  5521 00:BCD3: 84 05        	sty	GOSTROUTZ+2	; ..WE SIMPLY MUST FINISH COLD.START!
  5522 00:BCD5: A9 4C        	lda	#$4C		; "JMP" OPCODE FOR 4 VECTORS
  5523 00:BCD7: 85 00        	sta	GOWARM		; WARM START
  5524 00:BCD9: 85 03        	sta	GOSTROUTZ	; ANYONE EVER USE THIS ONE?
  5525 00:BCDB: 85 90        	sta	JMPADRS		; USED BY FUNCTIONS (JSR JMPADRS)
  5526                        
  5527                        ; ----------------------------------------------------------------------------
  5528                        ; MOVE GENERIC CHRGET AND RANDOM SEED INTO PLACE
  5529                        ;
  5530                        ; NOTE THAT LOOP VALUE IS WRONG! 
  5531                        ; THE LAST BYTE OF THE RANDOM SEED IS NOT
  5532                        ; COPIED INTO PAGE ZERO!
  5533                        ; ----------------------------------------------------------------------------
  5534                        ;	ldx	#GENERIC_END-GENERIC_CHRGET-1
  5535 00:BCDD: A2 1D        	ldx	#GENERIC_END-GENERIC_CHRGET
  5536                        COLDSTART1:
  5537 00:BCDF: BD A4 BC     	lda	GENERIC_CHRGET-1,x
  5538 00:BCE2: 95 B0        	sta	CHRGET-1,x
  5539 00:BCE4: CA           	dex
  5540 00:BCE5: D0 F8        	bne	COLDSTART1
  5541                        ; ----------------------------------------------------------------------------
  5542 00:BCE7: 8A           	txa			; A=0
  5543 00:BCE8: 85 A4        	sta	SHIFTSIGNEXT
  5544 00:BCEA: 85 54        	sta	LASTPT+1
  5545 00:BCEC: 48           	pha			; PUT $00 ON STACK (WHAT FOR?)
  5546 00:BCED: A9 03        	lda	#3		; SET LENGTH OF TEMP. STRING DESCRIPTORS
  5547 00:BCEF: 85 8F        	sta	DSCLEN		; FOR GARBAGE COLLECTION SUBROUTINE
  5548 00:BCF1: 20 46 BE     	jsr	CRDO		; PRINT <RETURN>
  5549 00:BCF4: A9 01        	lda	#1		; SET UP FAKE FORWARD LINK
  5550 00:BCF6: 8D FD 01     	sta	INPUTBUFFER-3
  5551 00:BCF9: 8D FC 01     	sta	INPUTBUFFER-4
  5552 00:BCFC: A2 55        	ldx	#TEMPST		; INIT INDEX TO TEMP STRING DESCRIPTORS
  5553 00:BCFE: 86 52        	stx	TEMPPT
  5554                        ; ----------------------------------------------------------------------------
  5555                        ; FIND HIGH END OF RAM
  5556                        ; ----------------------------------------------------------------------------
  5557 00:BD00: A9 00        	lda	#<$0800		; SET UP POINTER TO LOW END OF RAM (Low)
  5558 00:BD02: A0 08        	ldy	#>$0800		; High
  5559 00:BD04: 85 50        	sta	LINNUM
  5560 00:BD06: 84 51        	sty	LINNUM+1
  5561                        
  5562                        	.if 0
  5563                        	ldy	#0
  5564                        COLDSTART2:
  5565                        	inc	LINNUM+1	; TEST FIRST BYTE OF EACH PAGE
  5566                        	lda	(LINNUM),y	; BY COMPLEMENTING IT AND WATCHING
  5567                        	eor	#$FF		; IT CHANGE THE SAME WAY
  5568                        	sta	(LINNUM),y
  5569                        	cmp	(LINNUM),y	; ROM OR EMPTY SOCKETS WON'T TRACK
  5570                        	bne	COLDSTART3		; NOT RAM HERE
  5571                        	eor	#$FF		; RESTORE ORIGINAL VALUE
  5572                        	sta	(LINNUM),y
  5573                        	cmp	(LINNUM),y	; DID IT TRACK AGAIN?
  5574                        	beq	COLDSTART2		; YES, STILL IN RAM
  5575                        COLDSTART3:
  5576                        	ldy	LINNUM		; NO, END OF RAM
  5577                        	lda	LINNUM+1
  5578                        	and	#$F0		; FORCE A MULTIPLE OF 4096 BYTES
  5579                        	.endif
  5580                        	
  5581 00:BD08: A0 00        	ldy	#<memsize		; SET PROGRAM POINTER TO $0800
  5582 00:BD0A: A9 80        	lda	#>memsize
  5583                        
  5584 00:BD0C: 84 50        	sty	LINNUM
  5585 00:BD0E: 85 51        	sta	LINNUM+1
  5586 00:BD10: 84 73        	sty	MEMSIZ		; (BAD RAM MAY HAVE YIELDED NON-MULTIPLE)
  5587 00:BD12: 85 74        	sta	MEMSIZ+1
  5588 00:BD14: 84 6F        	sty	FRETOP		; SET HIMEM AND BOTTOM OF STRINGS
  5589 00:BD16: 85 70        	sta	FRETOP+1
  5590 00:BD18: A2 00        	ldx	#<$0800		; SET PROGRAM POINTER TO $0800
  5591 00:BD1A: A0 08        	ldy	#>$0800
  5592 00:BD1C: 86 67        	stx	TXTTAB
  5593 00:BD1E: 84 68        	sty	TXTTAB+1
  5594 00:BD20: A0 00        	ldy	#0		; TURN OFF SEMI-SECRET LOCK FLAG
  5595 00:BD22: 84 D6        	sty	LOCK
  5596 00:BD24: 98           	tya			; A=0 TOO
  5597 00:BD25: 91 67        	sta	(TXTTAB),y	; FIRST BYTE IN PROGRAM SPACE = 0
  5598 00:BD27: E6 67        	inc	TXTTAB		; ADVANCE PAST THE $00
  5599 00:BD29: D0 02        	bne	COLDSTART4
  5600 00:BD2B: E6 68        	inc	TXTTAB+1
  5601                        COLDSTART4:
  5602 00:BD2D: A5 67        	lda	TXTTAB
  5603 00:BD2F: A4 68        	ldy	TXTTAB+1
  5604 00:BD31: 20 AB A2     	jsr	REASON		; SET REST OF POINTERS UP
  5605 00:BD34: 20 EC A4     	jsr	SCRTCH		; MORE POINTERS
  5606 00:BD37: A9 2B        	lda	#<STROUT	; PUT CORRECT ADDRESSES IN TWO
  5607 00:BD39: A0 A9        	ldy	#>STROUT	; USER VECTORS
  5608 00:BD3B: 85 04        	sta	GOSTROUTZ+1
  5609 00:BD3D: 84 05        	sty	GOSTROUTZ+2
  5610 00:BD3F: A9 04        	lda	#<RESTART
  5611 00:BD41: A0 A3        	ldy	#>RESTART
  5612 00:BD43: 85 01        	sta	GOWARM+1
  5613 00:BD45: 84 02        	sty	GOWARM+2
  5614                        
  5615             00000000   IN_GOWARM	equ	GOWARM
  5616                        
  5617 00:BD47: 6C 01 00     	jmp	(IN_GOWARM+1)	; SILLY, WHY NOT JUST "JMP RESTART"
  5618                        
  5619                        
  5620                        ; ----------------------------------------------------------------------------
  5621                        ; "CALL" STATEMENT
  5622                        ;
  5623                        ; EFFECTIVELY PERFORMS A "JSR" TO THE SPECIFIED
  5624                        ; ADDRESS, WITH THE FOLLOWING REGISTER CONTENTS:
  5625                        ; 	(A,Y) = CALL ADDRESS
  5626                        ;	(X)   = $9D
  5627                        ;
  5628                        ; THE CALLED ROUTINE CAN RETURN WITH "RTS",
  5629                        ; AND APPLESOFT WILL CONTINUE WITH THE NEXT
  5630                        ; STATEMENT.
  5631                        ; ----------------------------------------------------------------------------
  5632 00:BD4A: 20 34 AB     CALL:	jsr	FRMNUM		; EVALUATE EXPRESSION FOR CALL ADDRESS
  5633 00:BD4D: 20 35 B4     	jsr	GETADR		; CONVERT EXPRESSION TO 16-BIT INTEGER
  5634                        
  5635             00000050   IN_LINNUM	equ	LINNUM
  5636                        
  5637 00:BD50: 6C 50 00     	jmp	(IN_LINNUM)	; IN LINNUM, AND JUMP THERE.
  5638                        
  5639                        
  5640                        ; ----------------------------------------------------------------------------
  5641                        ; "HIMEM:" STATEMENT
  5642                        ; ----------------------------------------------------------------------------
  5643 00:BD53: 20 34 AB     HIMEM:	jsr	FRMNUM		; GET VALUE SPECIFIED FOR HIMEM
  5644 00:BD56: 20 35 B4     	jsr	GETADR		; AS 16-BIT INTEGER
  5645 00:BD59: A5 50        	lda	LINNUM		; MUST BE ABOVE VARIABLES AND ARRAYS
  5646 00:BD5B: C5 6D        	cmp	STREND
  5647 00:BD5D: A5 51        	lda	LINNUM+1
  5648 00:BD5F: E5 6E        	sbc	STREND+1
  5649 00:BD61: B0 03        	bcs	SETHI		; IT IS ABOVE THEM
  5650 00:BD63: 4C D8 A2     JMM:	jmp	MEMERR		; NOT ENOUGH MEMORY
  5651 00:BD66: A5 50        SETHI:	lda	LINNUM		; STORE NEW HIMEM: VALUE
  5652 00:BD68: 85 73        	sta	MEMSIZ
  5653 00:BD6A: 85 6F        	sta	FRETOP		; NOTE THAT "HIMEM:" DOES NOT
  5654 00:BD6C: A5 51        	lda	LINNUM+1	; CLEAR STRING VARIABLES.
  5655 00:BD6E: 85 74        	sta	MEMSIZ+1	; THIS COULD BE DISASTROUS.
  5656 00:BD70: 85 70        	sta	FRETOP+1
  5657 00:BD72: 60           	rts
  5658                        
  5659                        
  5660                        ; ----------------------------------------------------------------------------
  5661                        ; "LOMEM:" STATEMENT
  5662                        ; ----------------------------------------------------------------------------
  5663 00:BD73: 20 34 AB     LOMEM:	jsr	FRMNUM		; GET VALUE SPECIFIED FOR LOMEM
  5664 00:BD76: 20 35 B4     	jsr	GETADR		; AS 16-BIT INTEGER IN LINNUM
  5665 00:BD79: A5 50        	lda	LINNUM		; MUST BE BELOW HIMEM
  5666 00:BD7B: C5 73        	cmp	MEMSIZ
  5667 00:BD7D: A5 51        	lda	LINNUM+1
  5668 00:BD7F: E5 74        	sbc	MEMSIZ+1
  5669 00:BD81: B0 E0        	bcs	JMM		; ABOVE HIMEM, MEMORY ERROR
  5670 00:BD83: A5 50        	lda	LINNUM		; MUST BE ABOVE PROGRAM
  5671 00:BD85: C5 69        	cmp	VARTAB
  5672 00:BD87: A5 51        	lda	LINNUM+1
  5673 00:BD89: E5 6A        	sbc	VARTAB+1
  5674 00:BD8B: 90 D6        	bcc	JMM		; NOT ABOVE PROGRAM, ERROR
  5675 00:BD8D: A5 50        	lda	LINNUM		; STORE NEW LOMEM VALUE
  5676 00:BD8F: 85 69        	sta	VARTAB
  5677 00:BD91: A5 51        	lda	LINNUM+1
  5678 00:BD93: 85 6A        	sta	VARTAB+1
  5679 00:BD95: 4C 0D A5     	jmp	CLEARC		; LOMEM CLEARS VARIABLES AND ARRAYS
  5680                        
  5681                        
  5682                        ; ----------------------------------------------------------------------------
  5683                        ; "ON ERR GO TO" STATEMENT
  5684                        ; ----------------------------------------------------------------------------
  5685 00:BD98: A9 8E        ONERR:	lda	#TOKEN_GOTO	; MUST BE "GOTO" NEXT
  5686 00:BD9A: 20 86 AC     	jsr	SYNCHR
  5687 00:BD9D: A5 B8        	lda	TXTPTR		; SAVE TXTPTR FOR HANDLERR
  5688 00:BD9F: 85 F4        	sta	TXTPSV
  5689 00:BDA1: A5 B9        	lda	TXTPTR+1
  5690 00:BDA3: 85 F5        	sta	TXTPSV+1
  5691 00:BDA5: 38           	sec			; SET SIGN BIT OF ERRFLG
  5692 00:BDA6: 66 D8        	ror	ERRFLG
  5693 00:BDA8: A5 75        	lda	CURLIN		; SAVE LINE # OF CURRENT LINE
  5694 00:BDAA: 85 F6        	sta	CURLSV
  5695 00:BDAC: A5 76        	lda	CURLIN+1
  5696 00:BDAE: 85 F7        	sta	CURLSV+1
  5697 00:BDB0: 20 BF A7     	jsr	REMN		; IGNORE REST OF LINE <<<WHY?>>>
  5698 00:BDB3: 4C B1 A7     	jmp	ADDON		; CONTINUE PROGRAM
  5699                        
  5700                        
  5701                        ; ----------------------------------------------------------------------------
  5702                        ; ROUTINE TO HANDLE ERRORS IF ONERR GOTO ACTIVE
  5703                        ; ----------------------------------------------------------------------------
  5704                        HANDLERR:
  5705 00:BDB6: 86 DE        	stx	ERRNUM		; SAVE ERROR CODE NUMBER
  5706 00:BDB8: A6 F8        	ldx	REMSTK		; GET STACK PNTR SAVED AT NEWSTT
  5707 00:BDBA: 86 DF        	stx	ERRSTK		; REMEMBER IT
  5708 00:BDBC: A5 75        	lda	CURLIN		; GET LINE # OF OFFENDING STATEMENT
  5709 00:BDBE: 85 DA        	sta	ERRLIN		; SO USER CAN SEE IT IF DESIRED
  5710 00:BDC0: A5 76        	lda	CURLIN+1
  5711 00:BDC2: 85 DB        	sta	ERRLIN+1
  5712 00:BDC4: A5 79        	lda	OLDTEXT		; ALSO THE POSITION IN THE LINE
  5713 00:BDC6: 85 DC        	sta	ERRPOS		; IN CASE USER WANTS TO "RESUME"
  5714 00:BDC8: A5 7A        	lda	OLDTEXT+1
  5715 00:BDCA: 85 DD        	sta	ERRPOS+1
  5716 00:BDCC: A5 F4        	lda	TXTPSV		; SET UP TXTPTR TO READ TARGET LINE #
  5717 00:BDCE: 85 B8        	sta	TXTPTR		; IN "ON ERR GO TO XXXX"
  5718 00:BDD0: A5 F5        	lda	TXTPSV+1
  5719 00:BDD2: 85 B9        	sta	TXTPTR+1
  5720 00:BDD4: A5 F6        	lda	CURLSV
  5721 00:BDD6: 85 75        	sta	CURLIN		; LINE # OF "ON ERR" STATEMENT
  5722 00:BDD8: A5 F7        	lda	CURLSV+1
  5723 00:BDDA: 85 76        	sta	CURLIN+1
  5724 00:BDDC: 20 B7 00     	jsr	CHRGOT		; START CONVERSION
  5725 00:BDDF: 20 57 A7     	jsr	GOTO		; GOTO SPECIFIED ONERR LINE
  5726 00:BDE2: 4C 62 A6     	jmp	NEWSTT
  5727                        
  5728                        
  5729                        ; ----------------------------------------------------------------------------
  5730                        ; "RESUME" STATEMENT
  5731                        ; ----------------------------------------------------------------------------
  5732 00:BDE5: A5 DA        RESUME:	lda	ERRLIN		; RESTORE LINE # AND TXTPTR
  5733 00:BDE7: 85 75        	sta	CURLIN		; TO RE-TRY OFFENDING LINE
  5734 00:BDE9: A5 DB        	lda	ERRLIN+1
  5735 00:BDEB: 85 76        	sta	CURLIN+1
  5736 00:BDED: A5 DC        	lda	ERRPOS
  5737 00:BDEF: 85 B8        	sta	TXTPTR
  5738 00:BDF1: A5 DD        	lda	ERRPOS+1
  5739 00:BDF3: 85 B9        	sta	TXTPTR+1
  5740 00:BDF5: A6 DF        	ldx	ERRSTK		; RETRIEVE STACK PNTR AS IT WAS
  5741 00:BDF7: 9A           	txs			; BEFORE STATEMENT SCANNED
  5742 00:BDF8: 4C 62 A6     	jmp	NEWSTT		; DO STATEMENT AGAIN
  5743                        
  5744                        ;###############################################################################
  5745                        
  5746                        ; MEZW65C_RAM I/O routines for Applesoft Lite
  5747                        ; Last modified 2024.11.21
  5748                        
  5749                        ;;;
  5750                        ;;;	Console Driver
  5751                        ;;;
  5752                        
  5753                        ;
  5754                        ; request CONIN, CONST CONOUT to PIC18F47QXX
  5755                        ;
  5756                        ;;; Constants
  5757             0000000D   CR	EQU	$0D
  5758             0000000A   LF	EQU	$0A
  5759             00000008   BS	EQU	$08
  5760             00000009   TAB	EQU	$09
  5761             0000007F   DEL	EQU	$7F
  5762             00000000   NULL	EQU	$00
  5763                        
  5764             00000001   B_CONIN		EQU	$01
  5765             00000002   B_CONOUT	EQU	$02
  5766             00000003   B_CONST		EQU	$03
  5767             000000FF   B_END_P		equ	$ff
  5768                        
  5769                        ; ----------------------------------------------------------------------------
  5770                        ; Get keystroke from keyboard (RDKEY)
  5771                        ; ----------------------------------------------------------------------------
  5772                        ;CONIN
  5773                        RDKEY:
  5774 00:BDFB: 00 01        	brk	B_CONIN
  5775 00:BDFD: 60           	rts
  5776                        
  5777                        CONST
  5778 00:BDFE: 00 03        	brk	B_CONST
  5779 00:BE00: 29 01        	and	#$01
  5780 00:BE02: 60           	rts
  5781                        
  5782                        CONOUT
  5783 00:BE03: 48           	pha
  5784 00:BE04: 00 02        	brk	B_CONOUT
  5785 00:BE06: 68           	pla
  5786 00:BE07: 60           	rts
  5787                        
  5788                        NMI_SIG
  5789 00:BE08: 00 FF        	brk	B_END_P
  5790 00:BE0A: DB           	stp
  5791                        
  5792                        ; ----------------------------------------------------------------------------
  5793                        ; Get keystroke from keyboard (RDKEY)
  5794                        ; ----------------------------------------------------------------------------
  5795                        ;RDKEY:
  5796                        ;	lda	KEYBOARDCR	; Key ready?
  5797                        ;	bpl	RDKEY		; Loop until ready
  5798                        ;	lda	KEYBOARD	; Load character
  5799                        ;	and	#$7F		; Clear hi bit
  5800                        ;	rts
  5801                        
  5802                        ; ----------------------------------------------------------------------------
  5803                        ; Get line of input (GETLN)
  5804                        ; adapted from Apple II monitor
  5805                        ; ----------------------------------------------------------------------------
  5806                        NOTCR:
  5807 00:BE0B: C9 18        	cmp	#$18		; CTRL-X?
  5808 00:BE0D: F0 0A        	beq	CANCEL		; Cancel line if so
  5809 00:BE0F: 20 03 BE     	jsr	CONOUT		; Output using monitor ECHO routine
  5810 00:BE12: C9 08        	cmp	#BS		; backspace?
  5811 00:BE14: F0 0E        	beq	BCKSPC		; Yes, do backspace...
  5812 00:BE16: E8           NOTCR1:	inx
  5813 00:BE17: D0 0F        	bne	NXTCHAR		; Wasn't backspace or CTRL+X, get next key
  5814 00:BE19: 20 36 BE     CANCEL:	jsr	OUTSLASH	; Output a "\" to indicate cancelled line
  5815 00:BE1C: 20 46 BE     GETLNZ:	jsr	CRDO		; new line
  5816                        
  5817 00:BE1F: 20 3A BE     GETLN:	jsr	OUTPROMPT	; Display the prompt
  5818 00:BE22: A2 01        	ldx	#$01		; Set cursor at 1, it gets decremented later
  5819 00:BE24: 8A           BCKSPC:	txa
  5820 00:BE25: F0 F5        	beq	GETLNZ		; Backspace with nothing on the line? start new line
  5821 00:BE27: CA           	dex			; Move "cursor" back one space
  5822                        NXTCHAR:
  5823 00:BE28: 20 FB BD     	jsr	RDKEY		; Read key from keyboard
  5824 00:BE2B: 9D 00 02     ADDINP:	sta	INPUTBUFFER,x	; Put it in the input buffer
  5825 00:BE2E: C9 0D        	cmp	#$0D		; CR?
  5826 00:BE30: D0 D9        	bne	NOTCR		; No, keep looping
  5827 00:BE32: 20 46 BE     	jsr	CRDO		; Output CR
  5828 00:BE35: 60           	rts	
  5829                        
  5830                        
  5831                        ; ----------------------------------------------------------------------------
  5832                        ; These moved here from the main Applesoft code to save a few bytes
  5833                        ; ----------------------------------------------------------------------------
  5834                        OUTSLASH:
  5835 00:BE36: A9 5C        	lda	#'\'	;'
  5836 00:BE38: 80 13        	bra	OUTDO
  5837                        
  5838                        OUTPROMPT:
  5839 00:BE3A: A5 33        	lda	PROMPT
  5840 00:BE3C: 80 0F        	bra	OUTDO
  5841                        
  5842 00:BE3E: A9 20        OUTSP:	lda	#' '
  5843 00:BE40: 80 0B        	bra	OUTDO
  5844                        
  5845                        OUTQUES:
  5846 00:BE42: A9 3F        	lda	#'?'
  5847 00:BE44: 80 07        	bra	OUTDO
  5848                        
  5849 00:BE46: A9 0D        CRDO:	lda	#CR
  5850 00:BE48: 20 03 BE     	jsr	CONOUT	; Send character to monitor ECHO
  5851 00:BE4B: A9 0A        	lda	#LF
  5852                        
  5853 00:BE4D: 29 7F        OUTDO:	and	#$7F
  5854 00:BE4F: 20 03 BE     	jsr	CONOUT	; Send character to monitor ECHO
  5855 00:BE52: 60           	rts
  5856                        
  5857                        
  5858                        ; ----------------------------------------------------------------------------
  5859                        ; Corny method of clearing the screen by sending a bunch of CR's.
  5860                        ; ----------------------------------------------------------------------------
  5861                        CLS:
  5862 00:BE53: A0 18        	ldy	#24	; loop 24 times
  5863 00:BE55: 20 46 BE     CLS1:	jsr	CRDO	; ouput CR
  5864 00:BE58: 88           	dey
  5865 00:BE59: 10 FA        	bpl	CLS1	; ... do it again
  5866 00:BE5B: 60           	rts
  5867                        
  5868                        ;###############################################################################
  5869                        ; CFFA1 I/O routines for Applesoft Lite
  5870                        ; NO SUPPORT
  5871                        ;.export CFFALoad, CFFASave, CFFAMenu
  5872                        
  5873                        CFFALoad:
  5874                        CFFASave:
  5875                        CFFAMenu:
  5876 00:BE5C: 18           	clc
  5877 00:BE5D: 60           	ret
  5878                        
  5879                        ; --------------------------------------------------------
  5880 00:BE5E: D8           RESET:	cld			; Clear decimal arithmetic mode
  5881                        ;	sei
  5882 00:BE5F: A2 FB        	ldx	#$FB		; SET STACK POINTER, LEAVING ROOM FOR
  5883 00:BE61: 9A           	txs			; LINE BUFFER DURING PARSING
  5884 00:BE62: 4C C2 BC     	jmp	COLDSTART
  5885                        
  5886                        	end


      Lines assembled: 5886
      Errors: 0
