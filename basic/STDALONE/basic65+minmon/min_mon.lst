     1                        
     2                        ; minimal monitor for EhBASIC and 6502 simulator V1.05
     3                        
     4                        ; To run EhBASIC on the simulator load and assemble [F7] this file, start the simulator
     5                        ; running [F6] then start the code with the RESET [CTRL][SHIFT]R. Just selecting RUN
     6                        ; will do nothing, you'll still have to do a reset to run the code.
     7                        
     8                        		pl	0
     9                                        pw      132
    10                                        inclist on
    11                        
    12                                .include "basic.asm"
     1                        
     2                        ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.22p5
     3                        
     4                        ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
     5                        
     6                        ; 2.00      new revision numbers start here
     7                        ; 2.01      fixed LCASE$() and UCASE$()
     8                        ; 2.02      new get value routine done
     9                        ; 2.03      changed RND() to galoise method
    10                        ; 2.04      fixed SPC()
    11                        ; 2.05      new get value routine fixed
    12                        ; 2.06      changed USR() code
    13                        ; 2.07      fixed STR$()
    14                        ; 2.08      changed INPUT and READ to remove need for $00 start to input buffer
    15                        ; 2.09      fixed RND()
    16                        ; 2.10      integrated missed changes from an earlier version
    17                        ; 2.20      added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
    18                        ; 2.21      fixed IF .. THEN RETURN to not cause error
    19                        ; 2.22      fixed RND() breaking the get byte routine
    20                        ; 2.22p     patched to disable use of decimal mode and fix Ibuff issues
    21                        ;              (bugsnquirks.txt notes 2, 4 and 5)
    22                        ;              tabs converted to spaces, tabwidth=6
    23                        ; 2.22p2    fixed can't continue error on 1st statement after direct mode
    24                        ;              changed INPUT to throw "break in line ##" on empty line input
    25                        ; 2.22p3    fixed RAM above code / Ibuff above EhBASIC patch breaks STR$()
    26                        ;              fix provided by github user mgcaret
    27                        ; 2.22p4    fixed string compare of equal strings in direct mode returns FALSE
    28                        ;              fixed FALSE stored to a variable after a string compare 
    29                        ;                 is > 0 and < 1E-16
    30                        ;              added additional stack floor protection for background interrupts
    31                        ;              fixed conditional LOOP & NEXT cannot find their data strucure on stack
    32                        ; 2.22p5    fixes issues reported by users Ruud and dclxvi on the 6502.org forum
    33                        ;      5.0     http://forum.6502.org/viewtopic.php?f=5&t=5500
    34                        ;              sanity check for RAM top allows values below RAM base
    35                        ;      5.1-7   http://forum.6502.org/viewtopic.php?f=5&t=5606
    36                        ;              1-7 coresponds to the bug# in the thread
    37                        ;      5.1     TO expression with a subtract may evaluate with the sign bit flipped
    38                        ;      5.3     call to LAB_1B5B may return to an address -$100 (page not incremented)
    39                        ;      5.4     string concatenate followed by MINUS or NOT() crashes EhBASIC
    40                        ;      5.5     garbage collection may cause an overlap with temporary strings
    41                        ;      5.6     floating point multiply rounding bug
    42                        ;      5.7     VAL() may cause string variables to be trashed
    43                        
    44                        ; zero page use ..
    45                        
    46                        ; the following locations are bulk initialized from StrTab at LAB_GMEM
    47             00000000   LAB_WARM        equ $00       ; BASIC warm start entry point
    48             00000001   Wrmjpl          equ LAB_WARM+1; BASIC warm start vector jump low byte
    49             00000002   Wrmjph          equ LAB_WARM+2; BASIC warm start vector jump high byte
    50                        
    51             0000000A   Usrjmp          equ $0A       ; USR function JMP address
    52             0000000B   Usrjpl          equ Usrjmp+1  ; USR function JMP vector low byte
    53             0000000C   Usrjph          equ Usrjmp+2  ; USR function JMP vector high byte
    54             0000000D   Nullct          equ $0D       ; nulls output after each line
    55             0000000E   TPos            equ $0E       ; BASIC terminal position byte
    56             0000000F   TWidth          equ $0F       ; BASIC terminal width byte
    57             00000010   Iclim           equ $10       ; input column limit
    58             00000011   Itempl          equ $11       ; temporary integer low byte
    59             00000012   Itemph          equ Itempl+1  ; temporary integer high byte
    60                        ; end bulk initialize from StrTab at LAB_GMEM
    61                        
    62             00000011   nums_1          equ Itempl    ; number to bin/hex string convert MSB
    63             00000012   nums_2          equ nums_1+1  ; number to bin/hex string convert
    64             00000013   nums_3          equ nums_1+2  ; number to bin/hex string convert LSB
    65                        
    66             0000005B   Srchc           equ $5B       ; search character
    67             0000005B   Temp3           equ Srchc     ; temp byte used in number routines
    68             0000005C   Scnquo          equ $5C       ; scan-between-quotes flag
    69             0000005C   Asrch           equ Scnquo    ; alt search character
    70                        
    71             0000005B   XOAw_l          equ Srchc     ; eXclusive OR, OR and AND word low byte
    72             0000005C   XOAw_h          equ Scnquo    ; eXclusive OR, OR and AND word high byte
    73                        
    74             0000005D   Ibptr           equ $5D       ; input buffer pointer
    75             0000005D   Dimcnt          equ Ibptr     ; # of dimensions
    76             0000005D   Tindx           equ Ibptr     ; token index
    77                        
    78             0000005E   Defdim          equ $5E       ; default DIM flag
    79             0000005F   Dtypef          equ $5F       ; data type flag, $FF=string, $00=numeric
    80             00000060   Oquote          equ $60       ; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
    81             00000060   Gclctd          equ $60       ; garbage collected flag
    82             00000061   Sufnxf          equ $61       ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
    83             00000062   Imode           equ $62       ; input mode flag, $00=INPUT, $80=READ
    84                        
    85             00000063   Cflag           equ $63       ; comparison evaluation flag
    86                        
    87             00000064   TabSiz          equ $64       ; TAB step size (was input flag)
    88                        
    89             00000065   next_s          equ $65       ; next descriptor stack address
    90                        
    91                                                      ; these two bytes form a word pointer to the item
    92                                                      ; currently on top of the descriptor stack
    93             00000066   last_sl         equ $66       ; last descriptor stack address low byte
    94             00000067   last_sh         equ $67       ; last descriptor stack address high byte (always $00)
    95                        
    96             00000068   des_sk          equ $68       ; descriptor stack start address (temp strings)
    97                        
    98                        ;               equ $70       ; End of descriptor stack
    99                        
   100             00000071   ut1_pl          equ $71       ; utility pointer 1 low byte
   101             00000072   ut1_ph          equ ut1_pl+1  ; utility pointer 1 high byte
   102             00000073   ut2_pl          equ $73       ; utility pointer 2 low byte
   103             00000074   ut2_ph          equ ut2_pl+1  ; utility pointer 2 high byte
   104                        
   105             00000071   Temp_2          equ ut1_pl    ; temp byte for block move    
   106                        
   107             00000075   FACt_1          equ $75       ; FAC temp mantissa1
   108             00000076   FACt_2          equ FACt_1+1  ; FAC temp mantissa2
   109             00000077   FACt_3          equ FACt_2+1  ; FAC temp mantissa3
   110                        
   111             00000076   dims_l          equ FACt_2    ; array dimension size low byte
   112             00000077   dims_h          equ FACt_3    ; array dimension size high byte
   113                        
   114             00000078   TempB           equ $78       ; temp page 0 byte
   115                        
   116             00000079   Smeml           equ $79       ; start of mem low byte       (Start-of-Basic)
   117             0000007A   Smemh           equ Smeml+1   ; start of mem high byte      (Start-of-Basic)
   118             0000007B   Svarl           equ $7B       ; start of vars low byte      (Start-of-Variables)
   119             0000007C   Svarh           equ Svarl+1   ; start of vars high byte     (Start-of-Variables)
   120             0000007D   Sarryl          equ $7D       ; var mem end low byte        (Start-of-Arrays)
   121             0000007E   Sarryh          equ Sarryl+1  ; var mem end high byte       (Start-of-Arrays)
   122             0000007F   Earryl          equ $7F       ; array mem end low byte      (End-of-Arrays)
   123             00000080   Earryh          equ Earryl+1  ; array mem end high byte     (End-of-Arrays)
   124             00000081   Sstorl          equ $81       ; string storage low byte     (String storage (moving down))
   125             00000082   Sstorh          equ Sstorl+1  ; string storage high byte    (String storage (moving down))
   126             00000083   Sutill          equ $83       ; string utility ptr low byte
   127             00000084   Sutilh          equ Sutill+1  ; string utility ptr high byte
   128             00000085   Ememl           equ $85       ; end of mem low byte         (Limit-of-memory)
   129             00000086   Ememh           equ Ememl+1   ; end of mem high byte        (Limit-of-memory)
   130             00000087   Clinel          equ $87       ; current line low byte       (Basic line number)
   131             00000088   Clineh          equ Clinel+1  ; current line high byte      (Basic line number)
   132             00000089   Blinel          equ $89       ; break line low byte         (Previous Basic line number)
   133             0000008A   Blineh          equ Blinel+1  ; break line high byte        (Previous Basic line number)
   134                        
   135             0000008B   Cpntrl          equ $8B       ; continue pointer low byte
   136             0000008C   Cpntrh          equ Cpntrl+1  ; continue pointer high byte
   137                        
   138             0000008D   Dlinel          equ $8D       ; current DATA line low byte
   139             0000008E   Dlineh          equ Dlinel+1  ; current DATA line high byte
   140                        
   141             0000008F   Dptrl           equ $8F       ; DATA pointer low byte
   142             00000090   Dptrh           equ Dptrl+1   ; DATA pointer high byte
   143                        
   144             00000091   Rdptrl          equ $91       ; read pointer low byte
   145             00000092   Rdptrh          equ Rdptrl+1  ; read pointer high byte
   146                        
   147             00000093   Varnm1          equ $93       ; current var name 1st byte
   148             00000094   Varnm2          equ Varnm1+1  ; current var name 2nd byte
   149                        
   150             00000095   Cvaral          equ $95       ; current var address low byte
   151             00000096   Cvarah          equ Cvaral+1  ; current var address high byte
   152                        
   153             00000097   Frnxtl          equ $97       ; var pointer for FOR/NEXT low byte
   154             00000098   Frnxth          equ Frnxtl+1  ; var pointer for FOR/NEXT high byte
   155                        
   156             00000097   Tidx1           equ Frnxtl    ; temp line index
   157                        
   158             00000097   Lvarpl          equ Frnxtl    ; let var pointer low byte
   159             00000098   Lvarph          equ Frnxth    ; let var pointer high byte
   160                        
   161             00000099   prstk           equ $99       ; precedence stacked flag
   162                        
   163             0000009B   comp_f          equ $9B       ; compare function flag, bits 0,1 and 2 used
   164                                                      ; bit 2 set if >
   165                                                      ; bit 1 set if =
   166                                                      ; bit 0 set if <
   167                        
   168             0000009C   func_l          equ $9C       ; function pointer low byte
   169             0000009D   func_h          equ func_l+1  ; function pointer high byte
   170                        
   171             0000009C   garb_l          equ func_l    ; garbage collection working pointer low byte
   172             0000009D   garb_h          equ func_h    ; garbage collection working pointer high byte
   173                        
   174             0000009E   des_2l          equ $9E       ; string descriptor_2 pointer low byte
   175             0000009F   des_2h          equ des_2l+1  ; string descriptor_2 pointer high byte
   176                        
   177             000000A0   g_step          equ $A0       ; garbage collect step size
   178                        
   179             000000A1   Fnxjmp          equ $A1       ; jump vector for functions
   180             000000A2   Fnxjpl          equ Fnxjmp+1  ; functions jump vector low byte
   181             000000A3   Fnxjph          equ Fnxjmp+2  ; functions jump vector high byte
   182                        
   183             000000A2   g_indx          equ Fnxjpl    ; garbage collect temp index
   184                        
   185             000000A3   FAC2_r          equ $A3       ; FAC2 rounding byte
   186                        
   187             000000A4   Adatal          equ $A4       ; array data pointer low byte
   188             000000A5   Adatah          equ Adatal+1  ; array data pointer high  byte
   189                        
   190             000000A4   Nbendl          equ Adatal    ; new block end pointer low byte
   191             000000A5   Nbendh          equ Adatah    ; new block end pointer high  byte
   192                        
   193             000000A6   Obendl          equ $A6       ; old block end pointer low byte
   194             000000A7   Obendh          equ Obendl+1  ; old block end pointer high  byte
   195                        
   196             000000A8   numexp          equ $A8       ; string to float number exponent count
   197             000000A9   expcnt          equ $A9       ; string to float exponent count
   198                        
   199             000000A8   numbit          equ numexp    ; bit count for array element calculations
   200                        
   201             000000AA   numdpf          equ $AA       ; string to float decimal point flag
   202             000000AB   expneg          equ $AB       ; string to float eval exponent -ve flag
   203                        
   204             000000AA   Astrtl          equ numdpf    ; array start pointer low byte
   205             000000AB   Astrth          equ expneg    ; array start pointer high  byte
   206                        
   207             000000AA   Histrl          equ numdpf    ; highest string low byte
   208             000000AB   Histrh          equ expneg    ; highest string high  byte
   209                        
   210             000000AA   Baslnl          equ numdpf    ; BASIC search line pointer low byte
   211             000000AB   Baslnh          equ expneg    ; BASIC search line pointer high  byte
   212                        
   213             000000AA   Fvar_l          equ numdpf    ; find/found variable pointer low byte
   214             000000AB   Fvar_h          equ expneg    ; find/found variable pointer high  byte
   215                        
   216             000000AA   Ostrtl          equ numdpf    ; old block start pointer low byte
   217             000000AB   Ostrth          equ expneg    ; old block start pointer high  byte
   218                        
   219             000000AA   Vrschl          equ numdpf    ; variable search pointer low byte
   220             000000AB   Vrschh          equ expneg    ; variable search pointer high  byte
   221                        
   222             000000AC   FAC1_e          equ $AC       ; FAC1 exponent
   223             000000AD   FAC1_1          equ FAC1_e+1  ; FAC1 mantissa1
   224             000000AE   FAC1_2          equ FAC1_e+2  ; FAC1 mantissa2
   225             000000AF   FAC1_3          equ FAC1_e+3  ; FAC1 mantissa3
   226             000000B0   FAC1_s          equ FAC1_e+4  ; FAC1 sign (b7)
   227                        
   228             000000AC   str_ln          equ FAC1_e    ; string length
   229             000000AD   str_pl          equ FAC1_1    ; string pointer low byte
   230             000000AE   str_ph          equ FAC1_2    ; string pointer high byte
   231                        
   232             000000AE   des_pl          equ FAC1_2    ; string descriptor pointer low byte
   233             000000AF   des_ph          equ FAC1_3    ; string descriptor pointer high byte
   234                        
   235             000000AF   mids_l          equ FAC1_3    ; MID$ string temp length byte
   236                        
   237             000000B1   negnum          equ $B1       ; string to float eval -ve flag
   238             000000B1   numcon          equ $B1       ; series evaluation constant count
   239                        
   240             000000B2   FAC1_o          equ $B2       ; FAC1 overflow byte
   241                        
   242             000000B3   FAC2_e          equ $B3       ; FAC2 exponent
   243             000000B4   FAC2_1          equ FAC2_e+1  ; FAC2 mantissa1
   244             000000B5   FAC2_2          equ FAC2_e+2  ; FAC2 mantissa2
   245             000000B6   FAC2_3          equ FAC2_e+3  ; FAC2 mantissa3
   246             000000B7   FAC2_s          equ FAC2_e+4  ; FAC2 sign (b7)
   247                        
   248             000000B8   FAC_sc          equ $B8       ; FAC sign comparison, Acc#1 vs #2
   249             000000B9   FAC1_r          equ $B9       ; FAC1 rounding byte
   250                        
   251             000000B8   ssptr_l         equ FAC_sc    ; string start pointer low byte
   252             000000B9   ssptr_h         equ FAC1_r    ; string start pointer high byte
   253                        
   254             000000B8   sdescr          equ FAC_sc    ; string descriptor pointer
   255                        
   256             000000BA   csidx           equ $BA       ; line crunch save index
   257             000000BA   Asptl           equ csidx     ; array size/pointer low byte
   258             000000BB   Aspth           equ $BB       ; array size/pointer high byte
   259                        
   260             000000BA   Btmpl           equ Asptl     ; BASIC pointer temp low byte
   261             000000BB   Btmph           equ Aspth     ; BASIC pointer temp low byte
   262                        
   263             000000BA   Cptrl           equ Asptl     ; BASIC pointer temp low byte
   264             000000BB   Cptrh           equ Aspth     ; BASIC pointer temp low byte
   265                        
   266             000000BA   Sendl           equ Asptl     ; BASIC pointer temp low byte
   267             000000BB   Sendh           equ Aspth     ; BASIC pointer temp low byte
   268                        
   269                        ; the following locations are bulk initialized from LAB_2CEE at LAB_2D4E
   270             000000BC   LAB_IGBY        equ $BC       ; get next BASIC byte subroutine
   271                        
   272             000000C2   LAB_GBYT        equ $C2       ; get current BASIC byte subroutine
   273             000000C3   Bpntrl          equ $C3       ; BASIC execute (get byte) pointer low byte
   274             000000C4   Bpntrh          equ Bpntrl+1  ; BASIC execute (get byte) pointer high byte
   275                        
   276                        ;               equ $D7       ; end of get BASIC char subroutine
   277                        ; end bulk initialize from LAB_2CEE at LAB_2D4E
   278                        
   279             000000D8   Rbyte4          equ $D8       ; extra PRNG byte
   280             000000D9   Rbyte1          equ Rbyte4+1  ; most significant PRNG byte
   281             000000DA   Rbyte2          equ Rbyte4+2  ; middle PRNG byte
   282             000000DB   Rbyte3          equ Rbyte4+3  ; least significant PRNG byte
   283                        
   284             000000DC   NmiBase         equ $DC       ; NMI handler enabled/setup/triggered flags
   285                                                      ; bit function
   286                                                      ; === ========
   287                                                      ; 7   interrupt enabled
   288                                                      ; 6   interrupt setup
   289                                                      ; 5   interrupt happened
   290                        ;               equ $DD       ; NMI handler addr low byte
   291                        ;               equ $DE       ; NMI handler addr high byte
   292             000000DF   IrqBase         equ $DF       ; IRQ handler enabled/setup/triggered flags
   293                        ;               equ $E0       ; IRQ handler addr low byte
   294                        ;               equ $E1       ; IRQ handler addr high byte
   295                        
   296                        ; *** removed unused comments for $DE-$E1
   297                        
   298                        ;               equ $E2       ; unused
   299                        ;               equ $E3       ; unused
   300                        ;               equ $E4       ; unused
   301                        ;               equ $E5       ; unused
   302                        ;               equ $E6       ; unused
   303                        ;               equ $E7       ; unused
   304                        ;               equ $E8       ; unused
   305                        ;               equ $E9       ; unused
   306                        ;               equ $EA       ; unused
   307                        ;               equ $EB       ; unused
   308                        ;               equ $EC       ; unused
   309                        ;               equ $ED       ; unused
   310                        ;               equ $EE       ; unused
   311                        
   312             000000EF   Decss           equ $EF       ; number to decimal string start
   313             000000F0   Decssp1         equ Decss+1   ; number to decimal string start
   314                        
   315                        ;               equ $FF       ; decimal string end
   316                        
   317                        ; token values needed for BASIC
   318                        
   319                        ; primary command tokens (can start a statement)
   320                        
   321             00000080   TK_END          equ $80             ; END token
   322             00000081   TK_FOR          equ TK_END+1        ; FOR token
   323             00000082   TK_NEXT         equ TK_FOR+1        ; NEXT token
   324             00000083   TK_DATA         equ TK_NEXT+1       ; DATA token
   325             00000084   TK_INPUT        equ TK_DATA+1       ; INPUT token
   326             00000085   TK_DIM          equ TK_INPUT+1      ; DIM token
   327             00000086   TK_READ         equ TK_DIM+1        ; READ token
   328             00000087   TK_LET          equ TK_READ+1       ; LET token
   329             00000088   TK_DEC          equ TK_LET+1        ; DEC token
   330             00000089   TK_GOTO         equ TK_DEC+1        ; GOTO token
   331             0000008A   TK_RUN          equ TK_GOTO+1       ; RUN token
   332             0000008B   TK_IF           equ TK_RUN+1        ; IF token
   333             0000008C   TK_RESTORE      equ TK_IF+1         ; RESTORE token
   334             0000008D   TK_GOSUB        equ TK_RESTORE+1    ; GOSUB token
   335             0000008E   TK_RETIRQ       equ TK_GOSUB+1      ; RETIRQ token
   336             0000008F   TK_RETNMI       equ TK_RETIRQ+1     ; RETNMI token
   337             00000090   TK_RETURN       equ TK_RETNMI+1     ; RETURN token
   338             00000091   TK_REM          equ TK_RETURN+1     ; REM token
   339             00000092   TK_STOP         equ TK_REM+1        ; STOP token
   340             00000093   TK_ON           equ TK_STOP+1       ; ON token
   341             00000094   TK_NULL         equ TK_ON+1         ; NULL token
   342             00000095   TK_INC          equ TK_NULL+1       ; INC token
   343             00000096   TK_WAIT         equ TK_INC+1        ; WAIT token
   344             00000097   TK_LOAD         equ TK_WAIT+1       ; LOAD token
   345             00000098   TK_SAVE         equ TK_LOAD+1       ; SAVE token
   346             00000099   TK_DEF          equ TK_SAVE+1       ; DEF token
   347             0000009A   TK_POKE         equ TK_DEF+1        ; POKE token
   348             0000009B   TK_DOKE         equ TK_POKE+1       ; DOKE token
   349             0000009C   TK_CALL         equ TK_DOKE+1       ; CALL token
   350             0000009D   TK_DO           equ TK_CALL+1       ; DO token
   351             0000009E   TK_LOOP         equ TK_DO+1         ; LOOP token
   352             0000009F   TK_PRINT        equ TK_LOOP+1       ; PRINT token
   353             000000A0   TK_CONT         equ TK_PRINT+1      ; CONT token
   354             000000A1   TK_LIST         equ TK_CONT+1       ; LIST token
   355             000000A2   TK_CLEAR        equ TK_LIST+1       ; CLEAR token
   356             000000A3   TK_NEW          equ TK_CLEAR+1      ; NEW token
   357             000000A4   TK_WIDTH        equ TK_NEW+1        ; WIDTH token
   358             000000A5   TK_GET          equ TK_WIDTH+1      ; GET token
   359             000000A6   TK_SWAP         equ TK_GET+1        ; SWAP token
   360             000000A7   TK_BITSET       equ TK_SWAP+1       ; BITSET token
   361             000000A8   TK_BITCLR       equ TK_BITSET+1     ; BITCLR token
   362             000000A9   TK_IRQ          equ TK_BITCLR+1     ; IRQ token
   363             000000AA   TK_NMI          equ TK_IRQ+1        ; NMI token
   364                        
   365                        ; secondary command tokens, can't start a statement
   366                        
   367             000000AB   TK_TAB          equ TK_NMI+1        ; TAB token
   368             000000AC   TK_ELSE         equ TK_TAB+1        ; ELSE token
   369             000000AD   TK_TO           equ TK_ELSE+1       ; TO token
   370             000000AE   TK_FN           equ TK_TO+1         ; FN token
   371             000000AF   TK_SPC          equ TK_FN+1         ; SPC token
   372             000000B0   TK_THEN         equ TK_SPC+1        ; THEN token
   373             000000B1   TK_NOT          equ TK_THEN+1       ; NOT token
   374             000000B2   TK_STEP         equ TK_NOT+1        ; STEP token
   375             000000B3   TK_UNTIL        equ TK_STEP+1       ; UNTIL token
   376             000000B4   TK_WHILE        equ TK_UNTIL+1      ; WHILE token
   377             000000B5   TK_OFF          equ TK_WHILE+1      ; OFF token
   378                        
   379                        ; opperator tokens
   380                        
   381             000000B6   TK_PLUS         equ TK_OFF+1        ; + token
   382             000000B7   TK_MINUS        equ TK_PLUS+1       ; - token
   383             000000B8   TK_MUL          equ TK_MINUS+1      ; * token
   384             000000B9   TK_DIV          equ TK_MUL+1        ; / token
   385             000000BA   TK_POWER        equ TK_DIV+1        ; ^ token
   386             000000BB   TK_AND          equ TK_POWER+1      ; AND token
   387             000000BC   TK_EOR          equ TK_AND+1        ; EOR token
   388             000000BD   TK_OR           equ TK_EOR+1        ; OR token
   389             000000BE   TK_RSHIFT       equ TK_OR+1         ; RSHIFT token
   390             000000BF   TK_LSHIFT       equ TK_RSHIFT+1     ; LSHIFT token
   391             000000C0   TK_GT           equ TK_LSHIFT+1     ; > token
   392             000000C1   TK_EQUAL        equ TK_GT+1         ; = token
   393             000000C2   TK_LT           equ TK_EQUAL+1      ; < token
   394                        
   395                        ; functions tokens
   396                        
   397             000000C3   TK_SGN          equ TK_LT+1         ; SGN token
   398             000000C4   TK_INT          equ TK_SGN+1        ; INT token
   399             000000C5   TK_ABS          equ TK_INT+1        ; ABS token
   400             000000C6   TK_USR          equ TK_ABS+1        ; USR token
   401             000000C7   TK_FRE          equ TK_USR+1        ; FRE token
   402             000000C8   TK_POS          equ TK_FRE+1        ; POS token
   403             000000C9   TK_SQR          equ TK_POS+1        ; SQR token
   404             000000CA   TK_RND          equ TK_SQR+1        ; RND token
   405             000000CB   TK_LOG          equ TK_RND+1        ; LOG token
   406             000000CC   TK_EXP          equ TK_LOG+1        ; EXP token
   407             000000CD   TK_COS          equ TK_EXP+1        ; COS token
   408             000000CE   TK_SIN          equ TK_COS+1        ; SIN token
   409             000000CF   TK_TAN          equ TK_SIN+1        ; TAN token
   410             000000D0   TK_ATN          equ TK_TAN+1        ; ATN token
   411             000000D1   TK_PEEK         equ TK_ATN+1        ; PEEK token
   412             000000D2   TK_DEEK         equ TK_PEEK+1       ; DEEK token
   413             000000D3   TK_SADD         equ TK_DEEK+1       ; SADD token
   414             000000D4   TK_LEN          equ TK_SADD+1       ; LEN token
   415             000000D5   TK_STRS         equ TK_LEN+1        ; STR$ token
   416             000000D6   TK_VAL          equ TK_STRS+1       ; VAL token
   417             000000D7   TK_ASC          equ TK_VAL+1        ; ASC token
   418             000000D8   TK_UCASES       equ TK_ASC+1        ; UCASE$ token
   419             000000D9   TK_LCASES       equ TK_UCASES+1     ; LCASE$ token
   420             000000DA   TK_CHRS         equ TK_LCASES+1     ; CHR$ token
   421             000000DB   TK_HEXS         equ TK_CHRS+1       ; HEX$ token
   422             000000DC   TK_BINS         equ TK_HEXS+1       ; BIN$ token
   423             000000DD   TK_BITTST       equ TK_BINS+1       ; BITTST token
   424             000000DE   TK_MAX          equ TK_BITTST+1     ; MAX token
   425             000000DF   TK_MIN          equ TK_MAX+1        ; MIN token
   426             000000E0   TK_PI           equ TK_MIN+1        ; PI token
   427             000000E1   TK_TWOPI        equ TK_PI+1         ; TWOPI token
   428             000000E2   TK_VPTR         equ TK_TWOPI+1      ; VARPTR token
   429             000000E3   TK_LEFTS        equ TK_VPTR+1       ; LEFT$ token
   430             000000E4   TK_RIGHTS       equ TK_LEFTS+1      ; RIGHT$ token
   431             000000E5   TK_MIDS         equ TK_RIGHTS+1     ; MID$ token
   432                        
   433                        ; offsets from a base of X or Y
   434                        
   435             00000000   PLUS_0          equ $00       ; X or Y plus 0
   436             00000001   PLUS_1          equ $01       ; X or Y plus 1
   437             00000002   PLUS_2          equ $02       ; X or Y plus 2
   438             00000003   PLUS_3          equ $03       ; X or Y plus 3
   439                        
   440             00000100   LAB_STAK        equ $0100     ; stack bottom, no offset
   441                        
   442             000001FE   LAB_SKFE        equ LAB_STAK+$FE
   443                                                      ; flushed stack address
   444             000001FF   LAB_SKFF        equ LAB_STAK+$FF
   445                                                      ; flushed stack address
   446                        
   447                        ; the following locations are bulk initialized from PG2_TABS at LAB_COLD
   448             00000200   ccflag          equ $0200     ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
   449             00000201   ccbyte          equ ccflag+1  ; BASIC CTRL-C byte
   450             00000202   ccnull          equ ccbyte+1  ; BASIC CTRL-C byte timeout
   451                        
   452             00000203   VEC_CC          equ ccnull+1  ; ctrl c check vector
   453                        ; end bulk initialize from PG2_TABS at LAB_COLD
   454                        
   455                        ; the following locations are bulk initialized by min_mon.asm from LAB_vec at LAB_stlp
   456             00000205   VEC_IN          equ VEC_CC+2  ; input vector
   457             00000207   VEC_OUT         equ VEC_IN+2  ; output vector
   458             00000209   VEC_LD          equ VEC_OUT+2 ; load vector
   459             0000020B   VEC_SV          equ VEC_LD+2  ; save vector
   460                        ; end bulk initialize by min_mon.asm from LAB_vec at LAB_stlp
   461                        
   462                        ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80,
   463                        ; the input buffer must not cross a page boundary and must not overlap with
   464                        ; program RAM pages!
   465                        
   466                        ;Ibuffs          equ IRQ_vec+$14
   467             00000221   Ibuffs          equ VEC_SV+$16
   468                                                      ; start of input buffer after IRQ/NMI code
   469             00000268   Ibuffe          equ Ibuffs+$47; end of input buffer
   470                        
   471             00000300   Ram_base        equ $0300     ; start of user RAM (set as needed, should be page aligned)
   472             0000D700   Ram_top          equ $D700     ; end of user RAM+1 (set as needed, should be page aligned)
   473                        
   474             00000018   UREQ_COM      equ       $18     ; CONIN/CONOUT request command (SYS)
   475             0000001A   CREQ_COM      equ       $1A     ; CONIN/CONOUT request command (User)
   476             0000001B   CBI_CHR         equ       $1B     ; charcter (CONIN/CONOUT) or number of strings
   477                        
   478                        
   479             00000010   Stack_floor     equ 16        ; bytes left free on stack for background interrupts
   480                        
   481                        ; This start can be changed to suit your system
   482                        
   483                              org    Ram_top
   484                        
   485                        ; BASIC cold start entry point
   486                        
   487                        LAB_COLD
   488                        
   489                        ;--------- MEZW65C_RAM file header --------------------------
   490 00:D700: 4C 20 D7     	jmp	COLD_START
   491                        
   492                        	; uinimon config data
   493                        	;
   494 00:D703: 00 00 00 00  	db	0,0,0,0,0
       00:D707: 00 
   495                        	; Unique ID
   496 00:D708: 4D 45 5A 57  mezID	db	"MEZW65C",0
       00:D70C: 36 35 43 00 
   497                        	;start program address
   498 00:D710: 00 D7        start_p	dw	Ram_top		; start address (Low)
   499 00:D712: 00 00        	dw	0		; (high)
   500                        
   501                        	; define Common memory address
   502 00:D714: 18 00        PIC_IF	dw	UREQ_COM	;  Common memory address for PIC (Low)
   503 00:D716: 00 00        	dw	0		; (high)
   504                        
   505 00:D718: 00           SW_816	db	0	; 0 : W65C02
   506                        			; 1 : W65C816 native mode 
   507 00:D719: 00           irq_sw	db	0	; 0 : no use IRQ console I/O
   508                        			; 1 : use IRQ timer interrupt driven console I/O
   509 00:D71A: 00 00 00 00  	db	0,0,0,0,0,0
       00:D71E: 00 00 
   510                        
   511                        ;--------- MEZW65C_RAM file header --------------------------
   512                        
   513                        ; new page 2 initialisation, copy block to ccflag on
   514                        
   515                        COLD_START
   516 00:D720: A0 04              LDY   #PG2_TABE-PG2_TABS-1
   517                                                      ; byte count-1
   518                        LAB_2D13
   519 00:D722: B9 24 F8           LDA   PG2_TABS,Y        ; get byte
   520 00:D725: 99 00 02           STA   ccflag,Y          ; store in page 2
   521 00:D728: 88                 DEY                     ; decrement count
   522 00:D729: 10 F7              BPL   LAB_2D13          ; loop if not done
   523                        
   524 00:D72B: A2 FF              LDX   #$FF              ; set byte
   525 00:D72D: 86 88              STX   Clineh            ; set current line high byte (set immediate mode)
   526 00:D72F: 9A                 TXS                     ; reset stack pointer
   527                        
   528 00:D730: A9 4C              LDA   #$4C              ; code for JMP
   529 00:D732: 85 A1              STA   Fnxjmp            ; save for jump vector for functions
   530                        
   531                        ; copy block from LAB_2CEE to $00BC - $00D7
   532                        
   533 00:D734: A2 1C              LDX   #StrTab-LAB_2CEE  ; set byte count
   534                        LAB_2D4E
   535 00:D736: BD 28 F8           LDA   LAB_2CEE-1,X      ; get byte from table
   536 00:D739: 95 BB              STA   LAB_IGBY-1,X      ; save byte in page zero
   537 00:D73B: CA                 DEX                     ; decrement count
   538 00:D73C: D0 F8              BNE   LAB_2D4E          ; loop if not all done
   539                        
   540                        ; copy block from StrTab to $0000 - $0012
   541                        
   542                        LAB_GMEM
   543 00:D73E: A2 12              LDX   #EndTab-StrTab-1  ; set byte count-1
   544                        TabLoop
   545 00:D740: BD 45 F8           LDA   StrTab,X          ; get byte from table
   546 00:D743: 95 00              STA   PLUS_0,X          ; save byte in page zero
   547 00:D745: CA                 DEX                     ; decrement count
   548 00:D746: 10 F8              BPL   TabLoop           ; loop if not all done
   549                        
   550                        ; set-up start values
   551                        
   552 00:D748: A9 00              LDA   #$00              ; clear A
   553 00:D74A: 85 DC              STA   NmiBase           ; clear NMI handler enabled flag
   554 00:D74C: 85 DF              STA   IrqBase           ; clear IRQ handler enabled flag
   555 00:D74E: 85 B2              STA   FAC1_o            ; clear FAC1 overflow byte
   556 00:D750: 85 67              STA   last_sh           ; clear descriptor stack top item pointer high byte
   557                        
   558 00:D752: A9 0E              LDA   #$0E              ; set default tab size
   559 00:D754: 85 64              STA   TabSiz            ; save it
   560 00:D756: A9 03              LDA   #$03              ; set garbage collect step size for descriptor stack
   561 00:D758: 85 A0              STA   g_step            ; save it
   562 00:D75A: A2 68              LDX   #des_sk           ; descriptor stack start
   563 00:D75C: 86 65              STX   next_s            ; set descriptor stack pointer
   564 00:D75E: 20 B3 DF           JSR   LAB_CRLF          ; print CR/LF
   565 00:D761: A9 58              LDA   #<LAB_MSZM        ; point to memory size message (low addr)
   566 00:D763: A0 F8              LDY   #>LAB_MSZM        ; point to memory size message (high addr)
   567 00:D765: 20 F4 DF           JSR   LAB_18C3          ; print null terminated string from memory
   568 00:D768: 20 63 D9           JSR   LAB_INLN          ; print "? " and get BASIC input
   569 00:D76B: 86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
   570 00:D76D: 84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
   571 00:D76F: 20 C2 00           JSR   LAB_GBYT          ; get last byte back
   572                        
   573 00:D772: D0 1F              BNE   LAB_2DAA          ; branch if not null (user typed something)
   574                        
   575 00:D774: A0 00              LDY   #$00              ; else clear Y
   576                                                      ; character was null so get memory size the hard way
   577                                                      ; we get here with Y=0 and Itempl/h = Ram_base
   578                        LAB_2D93
   579 00:D776: E6 11              INC   Itempl            ; increment temporary integer low byte
   580 00:D778: D0 08              BNE   LAB_2D99          ; branch if no overflow
   581                        
   582 00:D77A: E6 12              INC   Itemph            ; increment temporary integer high byte
   583 00:D77C: A5 12              LDA   Itemph            ; get high byte
   584 00:D77E: C9 D7              CMP   #>Ram_top         ; compare with top of RAM+1
   585 00:D780: F0 1D              BEQ   LAB_2DB6          ; branch if match (end of user RAM)
   586                        
   587                        LAB_2D99
   588 00:D782: A9 55              LDA   #$55              ; set test byte
   589 00:D784: 91 11              STA   (Itempl),Y        ; save via temporary integer
   590 00:D786: D1 11              CMP   (Itempl),Y        ; compare via temporary integer
   591 00:D788: D0 15              BNE   LAB_2DB6          ; branch if fail
   592                        
   593 00:D78A: 0A                 ASL                     ; shift test byte left (now $AA)
   594 00:D78B: 91 11              STA   (Itempl),Y        ; save via temporary integer
   595 00:D78D: D1 11              CMP   (Itempl),Y        ; compare via temporary integer
   596 00:D78F: F0 E5              BEQ   LAB_2D93          ; if ok go do next byte
   597                        
   598 00:D791: D0 0C              BNE   LAB_2DB6          ; branch if fail
   599                        
   600                        LAB_2DAA
   601 00:D793: 20 D3 F0           JSR   LAB_2887          ; get FAC1 from string
   602 00:D796: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
   603 00:D798: C9 98              CMP   #$98              ; compare with exponent = 2^24
   604 00:D79A: B0 A2              BCS   LAB_GMEM          ; if too large go try again
   605                        
   606 00:D79C: 20 24 EC           JSR   LAB_F2FU          ; save integer part of FAC1 in temporary integer
   607                                                      ; (no range check)
   608                        
   609                        LAB_2DB6
   610 00:D79F: A5 11              LDA   Itempl            ; get temporary integer low byte
   611 00:D7A1: A4 12              LDY   Itemph            ; get temporary integer high byte
   612                        ; *** begin patch  2.22p5.0 RAM top sanity check ***
   613                        ; *** replace
   614                        ;      CPY   #<Ram_base+$100      ; compare with start of RAM+$100 high byte
   615                        ; +++ with
   616 00:D7A3: C0 04              CPY   #>Ram_base+$100      ; compare with start of RAM+$100 high byte
   617                        ; *** end patch    2.22p5.0 ***
   618 00:D7A5: 90 97              BCC   LAB_GMEM          ; if too small go try again
   619                        
   620                        
   621                        ; uncomment these lines if you want to check on the high limit of memory. Note if
   622                        ; Ram_top is set too low then this will fail. default is ignore it and assume the
   623                        ; users know what they're doing!
   624                        
   625                        ;     CPY   #>Ram_top         ; compare with top of RAM high byte
   626                        ;     BCC   MEM_OK            ; branch if < RAM top
   627                        
   628                        ;     BNE   LAB_GMEM          ; if too large go try again
   629                                                      ; else was = so compare low bytes
   630                        ;     CMP   #<Ram_top         ; compare with top of RAM low byte
   631                        ;     BEQ   MEM_OK            ; branch if = RAM top
   632                        
   633                        ;     BCS   LAB_GMEM          ; if too large go try again
   634                        
   635                        ;MEM_OK
   636 00:D7A7: 85 85              STA   Ememl             ; set end of mem low byte
   637 00:D7A9: 84 86              STY   Ememh             ; set end of mem high byte
   638 00:D7AB: 85 81              STA   Sstorl            ; set bottom of string space low byte
   639 00:D7AD: 84 82              STY   Sstorh            ; set bottom of string space high byte
   640                        
   641 00:D7AF: A0 00              LDY   #<Ram_base        ; set start addr low byte
   642 00:D7B1: A2 03              LDX   #>Ram_base        ; set start addr high byte
   643 00:D7B3: 84 79              STY   Smeml             ; save start of mem low byte
   644 00:D7B5: 86 7A              STX   Smemh             ; save start of mem high byte
   645                        
   646                        ; this line is only needed if Ram_base is not $xx00
   647                              .IF   Ram_base&$FF>0
   648                              LDY   #$00              ; clear Y
   649                              .ENDIF
   650                        
   651 00:D7B7: 98                 TYA                     ; clear A
   652 00:D7B8: 91 79              STA   (Smeml),Y         ; clear first byte
   653 00:D7BA: E6 79              INC   Smeml             ; increment start of mem low byte
   654                        
   655                        ; these two lines are only needed if Ram_base is $xxFF
   656                              .IF   Ram_base&$FF=$FF
   657                              BNE   LAB_2E05          ; branch if no rollover
   658                              INC   Smemh             ; increment start of mem high byte
   659                        LAB_2E05
   660                              .ENDIF
   661                        
   662 00:D7BC: 20 B3 DF           JSR   LAB_CRLF          ; print CR/LF
   663 00:D7BF: 20 73 DA           JSR   LAB_1463          ; do "NEW" and "CLEAR"
   664 00:D7C2: A5 85              LDA   Ememl             ; get end of mem low byte
   665 00:D7C4: 38                 SEC                     ; set carry for subtract
   666 00:D7C5: E5 79              SBC   Smeml             ; subtract start of mem low byte
   667 00:D7C7: AA                 TAX                     ; copy to X
   668 00:D7C8: A5 86              LDA   Ememh             ; get end of mem high byte
   669 00:D7CA: E5 7A              SBC   Smemh             ; subtract start of mem high byte
   670 00:D7CC: 20 AF F1           JSR   LAB_295E          ; print XA as unsigned integer (bytes free)
   671 00:D7CF: A9 67              LDA   #<LAB_SMSG        ; point to sign-on message (low addr)
   672 00:D7D1: A0 F8              LDY   #>LAB_SMSG        ; point to sign-on message (high addr)
   673 00:D7D3: 20 F4 DF           JSR   LAB_18C3          ; print null terminated string from memory
   674 00:D7D6: A9 7D              LDA   #<LAB_1274        ; warm start vector low byte
   675 00:D7D8: A0 D8              LDY   #>LAB_1274        ; warm start vector high byte
   676 00:D7DA: 85 01              STA   Wrmjpl            ; save warm start vector low byte
   677 00:D7DC: 84 02              STY   Wrmjph            ; save warm start vector high byte
   678 00:D7DE: 6C 01 00           JMP   (Wrmjpl)          ; go do warm start
   679                        
   680                        ; open up space in memory
   681                        ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   682                        
   683                        ; Nbendl,Nbendh - new block end address (A/Y)
   684                        ; Obendl,Obendh - old block end address
   685                        ; Ostrtl,Ostrth - old block start address
   686                        
   687                        ; returns with ..
   688                        
   689                        ; Nbendl,Nbendh - new block start address (high byte - $100)
   690                        ; Obendl,Obendh - old block start address (high byte - $100)
   691                        ; Ostrtl,Ostrth - old block start address (unchanged)
   692                        
   693                        LAB_11CF
   694 00:D7E1: 20 2E D8           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
   695                                                      ; addr to check is in AY (low/high)
   696 00:D7E4: 85 7F              STA   Earryl            ; save new array mem end low byte
   697 00:D7E6: 84 80              STY   Earryh            ; save new array mem end high byte
   698                        
   699                        ; open up space in memory
   700                        ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
   701                        ; don't set array end
   702                        
   703                        LAB_11D6
   704 00:D7E8: 38                 SEC                     ; set carry for subtract
   705 00:D7E9: A5 A6              LDA   Obendl            ; get block end low byte
   706 00:D7EB: E5 AA              SBC   Ostrtl            ; subtract block start low byte
   707 00:D7ED: A8                 TAY                     ; copy MOD(block length/$100) byte to Y
   708 00:D7EE: A5 A7              LDA   Obendh            ; get block end high byte
   709 00:D7F0: E5 AB              SBC   Ostrth            ; subtract block start high byte
   710 00:D7F2: AA                 TAX                     ; copy block length high byte to X
   711 00:D7F3: E8                 INX                     ; +1 to allow for count=0 exit
   712 00:D7F4: 98                 TYA                     ; copy block length low byte to A
   713 00:D7F5: F0 24              BEQ   LAB_120A          ; branch if length low byte=0
   714                        
   715                                                      ; block is (X-1)*256+Y bytes, do the Y bytes first
   716                        
   717 00:D7F7: 38                 SEC                     ; set carry for add + 1, two's complement
   718 00:D7F8: 49 FF              EOR   #$FF              ; invert low byte for subtract
   719 00:D7FA: 65 A6              ADC   Obendl            ; add block end low byte
   720                        
   721 00:D7FC: 85 A6              STA   Obendl            ; save corrected old block end low byte
   722 00:D7FE: B0 03              BCS   LAB_11F3          ; branch if no underflow
   723                        
   724 00:D800: C6 A7              DEC   Obendh            ; else decrement block end high byte
   725 00:D802: 38                 SEC                     ; set carry for add + 1, two's complement
   726                        LAB_11F3
   727 00:D803: 98                 TYA                     ; get MOD(block length/$100) byte
   728 00:D804: 49 FF              EOR   #$FF              ; invert low byte for subtract
   729 00:D806: 65 A4              ADC   Nbendl            ; add destination end low byte
   730 00:D808: 85 A4              STA   Nbendl            ; save modified new block end low byte
   731 00:D80A: B0 08              BCS   LAB_1203          ; branch if no underflow
   732                        
   733 00:D80C: C6 A5              DEC   Nbendh            ; else decrement block end high byte
   734 00:D80E: 90 04              BCC   LAB_1203          ; branch always
   735                        
   736                        LAB_11FF
   737 00:D810: B1 A6              LDA   (Obendl),Y        ; get byte from source
   738 00:D812: 91 A4              STA   (Nbendl),Y        ; copy byte to destination
   739                        LAB_1203
   740 00:D814: 88                 DEY                     ; decrement index
   741 00:D815: D0 F9              BNE   LAB_11FF          ; loop until Y=0
   742                        
   743                                                      ; now do Y=0 indexed byte
   744 00:D817: B1 A6              LDA   (Obendl),Y        ; get byte from source
   745 00:D819: 91 A4              STA   (Nbendl),Y        ; save byte to destination
   746                        LAB_120A
   747 00:D81B: C6 A7              DEC   Obendh            ; decrement source pointer high byte
   748 00:D81D: C6 A5              DEC   Nbendh            ; decrement destination pointer high byte
   749 00:D81F: CA                 DEX                     ; decrement block count
   750 00:D820: D0 F2              BNE   LAB_1203          ; loop until count = $0
   751                        
   752 00:D822: 60                 RTS
   753                        
   754                        ; check room on stack for A bytes
   755                        ; stack too deep? do OM error
   756                        
   757                        LAB_1212
   758                        ; *** patch - additional stack floor protection for background interrupts
   759                        ; *** add
   760                              .IF   Stack_floor
   761 00:D823: 18                 CLC                     ; prep ADC
   762 00:D824: 69 10              ADC   #Stack_floor      ; stack pointer lower limit before interrupts
   763                              .ENDIF
   764                        ; *** end patch
   765 00:D826: 85 78              STA   TempB             ; save result in temp byte
   766 00:D828: BA                 TSX                     ; copy stack
   767 00:D829: E4 78              CPX   TempB             ; compare new "limit" with stack
   768 00:D82B: 90 30              BCC   LAB_OMER          ; if stack < limit do "Out of memory" error then warm start
   769                        
   770 00:D82D: 60                 RTS
   771                        
   772                        ; check available memory, "Out of memory" error if no room
   773                        ; addr to check is in AY (low/high)
   774                        
   775                        LAB_121F
   776 00:D82E: C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
   777 00:D830: 90 2A              BCC   LAB_124B          ; if less then exit (is ok)
   778                        
   779 00:D832: D0 04              BNE   LAB_1229          ; skip next test if greater (tested <)
   780                        
   781                                                      ; high byte was =, now do low byte
   782 00:D834: C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
   783 00:D836: 90 24              BCC   LAB_124B          ; if less then exit (is ok)
   784                        
   785                                                      ; addr is > string storage ptr (oops!)
   786                        LAB_1229
   787 00:D838: 48                 PHA                     ; push addr low byte
   788 00:D839: A2 08              LDX   #$08              ; set index to save Adatal to expneg inclusive
   789 00:D83B: 98                 TYA                     ; copy addr high byte (to push on stack)
   790                        
   791                                                      ; save misc numeric work area
   792                        LAB_122D
   793 00:D83C: 48                 PHA                     ; push byte
   794 00:D83D: B5 A3              LDA   Adatal-1,X        ; get byte from Adatal to expneg ( ,$00 not pushed)
   795 00:D83F: CA                 DEX                     ; decrement index
   796 00:D840: 10 FA              BPL   LAB_122D          ; loop until all done
   797                        
   798 00:D842: 20 0F E9           JSR   LAB_GARB          ; garbage collection routine
   799                        
   800                                                      ; restore misc numeric work area
   801 00:D845: A2 00              LDX   #$00              ; clear the index to restore bytes
   802                        LAB_1238
   803 00:D847: 68                 PLA                     ; pop byte
   804 00:D848: 95 A4              STA   Adatal,X          ; save byte to Adatal to expneg
   805 00:D84A: E8                 INX                     ; increment index
   806 00:D84B: E0 08              CPX   #$08              ; compare with end + 1
   807 00:D84D: 30 F8              BMI   LAB_1238          ; loop if more to do
   808                        
   809 00:D84F: 68                 PLA                     ; pop addr high byte
   810 00:D850: A8                 TAY                     ; copy back to Y
   811 00:D851: 68                 PLA                     ; pop addr low byte
   812 00:D852: C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
   813 00:D854: 90 06              BCC   LAB_124B          ; if less then exit (is ok)
   814                        
   815 00:D856: D0 05              BNE   LAB_OMER          ; if greater do "Out of memory" error then warm start
   816                        
   817                                                      ; high byte was =, now do low byte
   818 00:D858: C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
   819 00:D85A: B0 01              BCS   LAB_OMER          ; if >= do "Out of memory" error then warm start
   820                        
   821                                                      ; ok exit, carry clear
   822                        LAB_124B
   823 00:D85C: 60                 RTS
   824                        
   825                        ; do "Out of memory" error then warm start
   826                        
   827                        LAB_OMER
   828 00:D85D: A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
   829                        
   830                        ; do error #X, then warm start
   831                        
   832                        LAB_XERR
   833 00:D85F: 20 B3 DF           JSR   LAB_CRLF          ; print CR/LF
   834                        
   835 00:D862: BD D9 FD           LDA   LAB_BAER,X        ; get error message pointer low byte
   836 00:D865: BC DA FD           LDY   LAB_BAER+1,X      ; get error message pointer high byte
   837 00:D868: 20 F4 DF           JSR   LAB_18C3          ; print null terminated string from memory
   838                        
   839 00:D86B: 20 AC DA           JSR   LAB_1491          ; flush stack and clear continue flag
   840 00:D86E: A9 16              LDA   #<LAB_EMSG        ; point to " Error" low addr
   841 00:D870: A0 FF              LDY   #>LAB_EMSG        ; point to " Error" high addr
   842                        LAB_1269
   843 00:D872: 20 F4 DF           JSR   LAB_18C3          ; print null terminated string from memory
   844 00:D875: A4 88              LDY   Clineh            ; get current line high byte
   845 00:D877: C8                 INY                     ; increment it
   846 00:D878: F0 03              BEQ   LAB_1274          ; go do warm start (was immediate mode)
   847                        
   848                                                      ; else print line number
   849 00:D87A: 20 A4 F1           JSR   LAB_2953          ; print " in line [LINE #]"
   850                        
   851                        ; BASIC warm start entry point
   852                        ; wait for Basic command
   853                        
   854                        LAB_1274
   855                                                      ; clear ON IRQ/NMI bytes
   856 00:D87D: A9 00              LDA   #$00              ; clear A
   857 00:D87F: 85 DF              STA   IrqBase           ; clear enabled byte
   858 00:D881: 85 DC              STA   NmiBase           ; clear enabled byte
   859 00:D883: A9 27              LDA   #<LAB_RMSG        ; point to "Ready" message low byte
   860 00:D885: A0 FF              LDY   #>LAB_RMSG        ; point to "Ready" message high byte
   861                        
   862 00:D887: 20 F4 DF           JSR   LAB_18C3          ; go do print string
   863                        
   864                        ; wait for Basic command (no "Ready")
   865                        
   866                        LAB_127D
   867 00:D88A: 20 70 D9           JSR   LAB_1357          ; call for BASIC input
   868                        LAB_1280
   869 00:D88D: 86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
   870 00:D88F: 84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
   871 00:D891: 20 C2 00           JSR   LAB_GBYT          ; scan memory
   872 00:D894: F0 F4              BEQ   LAB_127D          ; loop while null
   873                        
   874                        ; got to interpret input line now ..
   875                        
   876 00:D896: A2 FF              LDX   #$FF              ; current line to null value
   877 00:D898: 86 88              STX   Clineh            ; set current line high byte
   878 00:D89A: 90 06              BCC   LAB_1295          ; branch if numeric character (handle new BASIC line)
   879                        
   880                                                      ; no line number .. immediate mode
   881 00:D89C: 20 A1 D9           JSR   LAB_13A6          ; crunch keywords into Basic tokens
   882 00:D89F: 4C 15 DC           JMP   LAB_15F6          ; go scan and interpret code
   883                        
   884                        ; handle new BASIC line
   885                        
   886                        LAB_1295
   887 00:D8A2: 20 76 DE           JSR   LAB_GFPN          ; get fixed-point number into temp integer
   888 00:D8A5: 20 A1 D9           JSR   LAB_13A6          ; crunch keywords into Basic tokens
   889 00:D8A8: 84 5D              STY   Ibptr             ; save index pointer to end of crunched line
   890 00:D8AA: 20 47 DA           JSR   LAB_SSLN          ; search BASIC for temp integer line number
   891 00:D8AD: 90 44              BCC   LAB_12E6          ; branch if not found
   892                        
   893                                                      ; aroooogah! line # already exists! delete it
   894 00:D8AF: A0 01              LDY   #$01              ; set index to next line pointer high byte
   895 00:D8B1: B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
   896 00:D8B3: 85 72              STA   ut1_ph            ; save it
   897 00:D8B5: A5 7B              LDA   Svarl             ; get start of vars low byte
   898 00:D8B7: 85 71              STA   ut1_pl            ; save it
   899 00:D8B9: A5 AB              LDA   Baslnh            ; get found line pointer high byte
   900 00:D8BB: 85 74              STA   ut2_ph            ; save it
   901 00:D8BD: A5 AA              LDA   Baslnl            ; get found line pointer low byte
   902 00:D8BF: 88                 DEY                     ; decrement index
   903 00:D8C0: F1 AA              SBC   (Baslnl),Y        ; subtract next line pointer low byte
   904 00:D8C2: 18                 CLC                     ; clear carry for add
   905 00:D8C3: 65 7B              ADC   Svarl             ; add start of vars low byte
   906 00:D8C5: 85 7B              STA   Svarl             ; save new start of vars low byte
   907 00:D8C7: 85 73              STA   ut2_pl            ; save destination pointer low byte
   908 00:D8C9: A5 7C              LDA   Svarh             ; get start of vars high byte
   909 00:D8CB: 69 FF              ADC   #$FF              ; -1 + carry
   910 00:D8CD: 85 7C              STA   Svarh             ; save start of vars high byte
   911 00:D8CF: E5 AB              SBC   Baslnh            ; subtract found line pointer high byte
   912 00:D8D1: AA                 TAX                     ; copy to block count
   913 00:D8D2: 38                 SEC                     ; set carry for subtract
   914 00:D8D3: A5 AA              LDA   Baslnl            ; get found line pointer low byte
   915 00:D8D5: E5 7B              SBC   Svarl             ; subtract start of vars low byte
   916 00:D8D7: A8                 TAY                     ; copy to bytes in first block count
   917 00:D8D8: B0 03              BCS   LAB_12D0          ; branch if overflow
   918                        
   919 00:D8DA: E8                 INX                     ; increment block count (correct for =0 loop exit)
   920 00:D8DB: C6 74              DEC   ut2_ph            ; decrement destination high byte
   921                        LAB_12D0
   922 00:D8DD: 18                 CLC                     ; clear carry for add
   923 00:D8DE: 65 71              ADC   ut1_pl            ; add source pointer low byte
   924 00:D8E0: 90 03              BCC   LAB_12D8          ; branch if no overflow
   925                        
   926 00:D8E2: C6 72              DEC   ut1_ph            ; else decrement source pointer high byte
   927 00:D8E4: 18                 CLC                     ; clear carry
   928                        
   929                                                      ; close up memory to delete old line
   930                        LAB_12D8
   931 00:D8E5: B1 71              LDA   (ut1_pl),Y        ; get byte from source
   932 00:D8E7: 91 73              STA   (ut2_pl),Y        ; copy to destination
   933 00:D8E9: C8                 INY                     ; increment index
   934 00:D8EA: D0 F9              BNE   LAB_12D8          ; while <> 0 do this block
   935                        
   936 00:D8EC: E6 72              INC   ut1_ph            ; increment source pointer high byte
   937 00:D8EE: E6 74              INC   ut2_ph            ; increment destination pointer high byte
   938 00:D8F0: CA                 DEX                     ; decrement block count
   939 00:D8F1: D0 F2              BNE   LAB_12D8          ; loop until all done
   940                        
   941                                                      ; got new line in buffer and no existing same #
   942                        LAB_12E6
   943 00:D8F3: AD 21 02           LDA   Ibuffs            ; get byte from start of input buffer
   944 00:D8F6: F0 3F              BEQ   LAB_1319          ; if null line just go flush stack/vars and exit
   945                        
   946                                                      ; got new line and it isn't empty line
   947 00:D8F8: A5 85              LDA   Ememl             ; get end of mem low byte
   948 00:D8FA: A4 86              LDY   Ememh             ; get end of mem high byte
   949 00:D8FC: 85 81              STA   Sstorl            ; set bottom of string space low byte
   950 00:D8FE: 84 82              STY   Sstorh            ; set bottom of string space high byte
   951 00:D900: A5 7B              LDA   Svarl             ; get start of vars low byte  (end of BASIC)
   952 00:D902: 85 A6              STA   Obendl            ; save old block end low byte
   953 00:D904: A4 7C              LDY   Svarh             ; get start of vars high byte (end of BASIC)
   954 00:D906: 84 A7              STY   Obendh            ; save old block end high byte
   955 00:D908: 65 5D              ADC   Ibptr             ; add input buffer pointer    (also buffer length)
   956 00:D90A: 90 01              BCC   LAB_1301          ; branch if no overflow from add
   957                        
   958 00:D90C: C8                 INY                     ; else increment high byte
   959                        LAB_1301
   960 00:D90D: 85 A4              STA   Nbendl            ; save new block end low byte (move to, low byte)
   961 00:D90F: 84 A5              STY   Nbendh            ; save new block end high byte
   962 00:D911: 20 E1 D7           JSR   LAB_11CF          ; open up space in memory
   963                                                      ; old start pointer Ostrtl,Ostrth set by the find line call
   964 00:D914: A5 7F              LDA   Earryl            ; get array mem end low byte
   965 00:D916: A4 80              LDY   Earryh            ; get array mem end high byte
   966 00:D918: 85 7B              STA   Svarl             ; save start of vars low byte
   967 00:D91A: 84 7C              STY   Svarh             ; save start of vars high byte
   968 00:D91C: A4 5D              LDY   Ibptr             ; get input buffer pointer    (also buffer length)
   969 00:D91E: 88                 DEY                     ; adjust for loop type
   970                        LAB_1311
   971 00:D91F: B9 1D 02           LDA   Ibuffs-4,Y        ; get byte from crunched line
   972 00:D922: 91 AA              STA   (Baslnl),Y        ; save it to program memory
   973 00:D924: 88                 DEY                     ; decrement count
   974 00:D925: C0 03              CPY   #$03              ; compare with first byte-1
   975 00:D927: D0 F6              BNE   LAB_1311          ; continue while count <> 3
   976                        
   977 00:D929: A5 12              LDA   Itemph            ; get line # high byte
   978 00:D92B: 91 AA              STA   (Baslnl),Y        ; save it to program memory
   979 00:D92D: 88                 DEY                     ; decrement count
   980 00:D92E: A5 11              LDA   Itempl            ; get line # low byte
   981 00:D930: 91 AA              STA   (Baslnl),Y        ; save it to program memory
   982 00:D932: 88                 DEY                     ; decrement count
   983 00:D933: A9 FF              LDA   #$FF              ; set byte to allow chain rebuild. if you didn't set this
   984                                                      ; byte then a zero already here would stop the chain rebuild
   985                                                      ; as it would think it was the [EOT] marker.
   986 00:D935: 91 AA              STA   (Baslnl),Y        ; save it to program memory
   987                        
   988                        LAB_1319
   989 00:D937: 20 88 DA           JSR   LAB_1477          ; reset execution to start, clear vars and flush stack
   990 00:D93A: A6 79              LDX   Smeml             ; get start of mem low byte
   991 00:D93C: A5 7A              LDA   Smemh             ; get start of mem high byte
   992 00:D93E: A0 01              LDY   #$01              ; index to high byte of next line pointer
   993                        LAB_1325
   994 00:D940: 86 71              STX   ut1_pl            ; set line start pointer low byte
   995 00:D942: 85 72              STA   ut1_ph            ; set line start pointer high byte
   996 00:D944: B1 71              LDA   (ut1_pl),Y        ; get it
   997 00:D946: F0 18              BEQ   LAB_133E          ; exit if end of program
   998                        
   999                        ; rebuild chaining of Basic lines
  1000                        
  1001 00:D948: A0 04              LDY   #$04              ; point to first code byte of line
  1002                                                      ; there is always 1 byte + [EOL] as null entries are deleted
  1003                        LAB_1330
  1004 00:D94A: C8                 INY                     ; next code byte
  1005 00:D94B: B1 71              LDA   (ut1_pl),Y        ; get byte
  1006 00:D94D: D0 FB              BNE   LAB_1330          ; loop if not [EOL]
  1007                        
  1008 00:D94F: 38                 SEC                     ; set carry for add + 1
  1009 00:D950: 98                 TYA                     ; copy end index
  1010 00:D951: 65 71              ADC   ut1_pl            ; add to line start pointer low byte
  1011 00:D953: AA                 TAX                     ; copy to X
  1012 00:D954: A0 00              LDY   #$00              ; clear index, point to this line's next line pointer
  1013 00:D956: 91 71              STA   (ut1_pl),Y        ; set next line pointer low byte
  1014 00:D958: 98                 TYA                     ; clear A
  1015 00:D959: 65 72              ADC   ut1_ph            ; add line start pointer high byte + carry
  1016 00:D95B: C8                 INY                     ; increment index to high byte
  1017 00:D95C: 91 71              STA   (ut1_pl),Y        ; save next line pointer low byte
  1018 00:D95E: 90 E0              BCC   LAB_1325          ; go do next line, branch always, carry clear
  1019                        
  1020                        
  1021                        LAB_133E
  1022 00:D960: 4C 8A D8           JMP   LAB_127D          ; else we just wait for Basic command, no "Ready"
  1023                        
  1024                        ; print "? " and get BASIC input
  1025                        
  1026                        LAB_INLN
  1027 00:D963: 20 0C E0           JSR   LAB_18E3          ; print "?" character
  1028 00:D966: 20 09 E0           JSR   LAB_18E0          ; print " "
  1029 00:D969: D0 05              BNE   LAB_1357          ; call for BASIC input and return
  1030                        
  1031                        ; receive line from keyboard
  1032                        
  1033                                                      ; $08 as delete key (BACKSPACE on standard keyboard)
  1034                        LAB_134B
  1035 00:D96B: 20 0E E0           JSR   LAB_PRNA          ; go print the character
  1036 00:D96E: CA                 DEX                     ; decrement the buffer counter (delete)
  1037 00:D96F: 2C                 .byte $2C               ; make LDX into BIT abs
  1038                        
  1039                        ; call for BASIC input (main entry point)
  1040                        
  1041                        LAB_1357
  1042 00:D970: A2 00              LDX   #$00              ; clear BASIC line buffer pointer
  1043                        LAB_1359
  1044 00:D972: 20 18 F8           JSR   V_INPT            ; call scan input device
  1045 00:D975: 90 FB              BCC   LAB_1359          ; loop if no byte
  1046                        
  1047 00:D977: F0 F9              BEQ   LAB_1359          ; loop until valid input (ignore NULLs)
  1048                        
  1049 00:D979: C9 07              CMP   #$07              ; compare with [BELL]
  1050 00:D97B: F0 10              BEQ   LAB_1378          ; branch if [BELL]
  1051                        
  1052 00:D97D: C9 0D              CMP   #$0D              ; compare with [CR]
  1053 00:D97F: F0 19              BEQ   LAB_1384          ; do CR/LF exit if [CR]
  1054                        
  1055 00:D981: E0 00              CPX   #$00              ; compare pointer with $00
  1056 00:D983: D0 04              BNE   LAB_1374          ; branch if not empty
  1057                        
  1058                        ; next two lines ignore any non print character and [SPACE] if input buffer empty
  1059                        
  1060 00:D985: C9 21              CMP   #$21              ; compare with [SP]+1
  1061 00:D987: 90 E9              BCC   LAB_1359          ; if < ignore character
  1062                        
  1063                        LAB_1374
  1064 00:D989: C9 08              CMP   #$08              ; compare with [BACKSPACE] (delete last character)
  1065 00:D98B: F0 DE              BEQ   LAB_134B          ; go delete last character
  1066                        
  1067                        LAB_1378
  1068 00:D98D: E0 47              CPX   #Ibuffe-Ibuffs    ; compare character count with max
  1069 00:D98F: B0 0C              BCS   LAB_138E          ; skip store and do [BELL] if buffer full
  1070                        
  1071 00:D991: 9D 21 02           STA   Ibuffs,X          ; else store in buffer
  1072 00:D994: E8                 INX                     ; increment pointer
  1073                        LAB_137F
  1074 00:D995: 20 0E E0           JSR   LAB_PRNA          ; go print the character
  1075 00:D998: D0 D8              BNE   LAB_1359          ; always loop for next character
  1076                        
  1077                        LAB_1384
  1078 00:D99A: 4C AA DF           JMP   LAB_1866          ; do CR/LF exit to BASIC
  1079                        
  1080                        ; announce buffer full
  1081                        
  1082                        LAB_138E
  1083 00:D99D: A9 07              LDA   #$07              ; [BELL] character into A
  1084 00:D99F: D0 F4              BNE   LAB_137F          ; go print the [BELL] but ignore input character
  1085                                                      ; branch always
  1086                        
  1087                        ; crunch keywords into Basic tokens
  1088                        ; position independent buffer version ..
  1089                        ; faster, dictionary search version ....
  1090                        
  1091                        LAB_13A6
  1092 00:D9A1: A0 FF              LDY   #$FF              ; set save index (makes for easy math later)
  1093                        
  1094 00:D9A3: 38                 SEC                     ; set carry for subtract
  1095 00:D9A4: A5 C3              LDA   Bpntrl            ; get basic execute pointer low byte
  1096 00:D9A6: E9 21              SBC   #<Ibuffs          ; subtract input buffer start pointer
  1097 00:D9A8: AA                 TAX                     ; copy result to X (index past line # if any)
  1098                        
  1099 00:D9A9: 86 60              STX   Oquote            ; clear open quote/DATA flag
  1100                        LAB_13AC
  1101 00:D9AB: BD 21 02           LDA   Ibuffs,X          ; get byte from input buffer
  1102 00:D9AE: F0 51              BEQ   LAB_13EC          ; if null save byte then exit
  1103                        
  1104 00:D9B0: C9 5F              CMP   #'_'              ; compare with "_"
  1105 00:D9B2: B0 4D              BCS   LAB_13EC          ; if >= go save byte then continue crunching
  1106                        
  1107 00:D9B4: C9 3C              CMP   #'<'              ; compare with "<"
  1108 00:D9B6: B0 0E              BCS   LAB_13CC          ; if >= go crunch now
  1109                        
  1110 00:D9B8: C9 30              CMP   #'0'              ; compare with "0"
  1111 00:D9BA: B0 45              BCS   LAB_13EC          ; if >= go save byte then continue crunching
  1112                        
  1113 00:D9BC: 85 5C              STA   Scnquo            ; save buffer byte as search character
  1114 00:D9BE: C9 22              CMP   #$22              ; is it quote character?
  1115 00:D9C0: F0 61              BEQ   LAB_1410          ; branch if so (copy quoted string)
  1116                        
  1117 00:D9C2: C9 2A              CMP   #'*'              ; compare with "*"
  1118 00:D9C4: 90 3B              BCC   LAB_13EC          ; if < go save byte then continue crunching
  1119                        
  1120                                                      ; else crunch now
  1121                        LAB_13CC
  1122 00:D9C6: 24 60              BIT   Oquote            ; get open quote/DATA token flag
  1123 00:D9C8: 70 37              BVS   LAB_13EC          ; branch if b6 of Oquote set (was DATA)
  1124                                                      ; go save byte then continue crunching
  1125                        
  1126 00:D9CA: 86 78              STX   TempB             ; save buffer read index
  1127 00:D9CC: 84 BA              STY   csidx             ; copy buffer save index
  1128 00:D9CE: A0 40              LDY   #<TAB_1STC        ; get keyword first character table low address
  1129 00:D9D0: 84 73              STY   ut2_pl            ; save pointer low byte
  1130 00:D9D2: A0 FA              LDY   #>TAB_1STC        ; get keyword first character table high address
  1131 00:D9D4: 84 74              STY   ut2_ph            ; save pointer high byte
  1132 00:D9D6: A0 00              LDY   #$00              ; clear table pointer
  1133                        
  1134                        LAB_13D0
  1135 00:D9D8: D1 73              CMP   (ut2_pl),Y        ; compare with keyword first character table byte
  1136 00:D9DA: F0 05              BEQ   LAB_13D1          ; go do word_table_chr if match
  1137                        
  1138 00:D9DC: 90 21              BCC   LAB_13EA          ; if < keyword first character table byte go restore
  1139                                                      ; Y and save to crunched
  1140                        
  1141 00:D9DE: C8                 INY                     ; else increment pointer
  1142 00:D9DF: D0 F7              BNE   LAB_13D0          ; and loop (branch always)
  1143                        
  1144                        ; have matched first character of some keyword
  1145                        
  1146                        LAB_13D1
  1147 00:D9E1: 98                 TYA                     ; copy matching index
  1148 00:D9E2: 0A                 ASL                     ; *2 (bytes per pointer)
  1149 00:D9E3: AA                 TAX                     ; copy to new index
  1150 00:D9E4: BD 5E FA           LDA   TAB_CHRT,X        ; get keyword table pointer low byte
  1151 00:D9E7: 85 73              STA   ut2_pl            ; save pointer low byte
  1152 00:D9E9: BD 5F FA           LDA   TAB_CHRT+1,X      ; get keyword table pointer high byte
  1153 00:D9EC: 85 74              STA   ut2_ph            ; save pointer high byte
  1154                        
  1155 00:D9EE: A0 FF              LDY   #$FF              ; clear table pointer (make -1 for start)
  1156                        
  1157 00:D9F0: A6 78              LDX   TempB             ; restore buffer read index
  1158                        
  1159                        LAB_13D6
  1160 00:D9F2: C8                 INY                     ; next table byte
  1161 00:D9F3: B1 73              LDA   (ut2_pl),Y        ; get byte from table
  1162                        LAB_13D8
  1163 00:D9F5: 30 08              BMI   LAB_13EA          ; all bytes matched so go save token
  1164                        
  1165 00:D9F7: E8                 INX                     ; next buffer byte
  1166 00:D9F8: DD 21 02           CMP   Ibuffs,X          ; compare with byte from input buffer
  1167 00:D9FB: F0 F5              BEQ   LAB_13D6          ; go compare next if match
  1168                        
  1169 00:D9FD: D0 2B              BNE   LAB_1417          ; branch if >< (not found keyword)
  1170                        
  1171                        LAB_13EA
  1172 00:D9FF: A4 BA              LDY   csidx             ; restore save index
  1173                        
  1174                                                      ; save crunched to output
  1175                        LAB_13EC
  1176 00:DA01: E8                 INX                     ; increment buffer index (to next input byte)
  1177 00:DA02: C8                 INY                     ; increment save index (to next output byte)
  1178 00:DA03: 99 21 02           STA   Ibuffs,Y          ; save byte to output
  1179 00:DA06: C9 00              CMP   #$00              ; set the flags, set carry
  1180 00:DA08: F0 32              BEQ   LAB_142A          ; do exit if was null [EOL]
  1181                        
  1182                                                      ; A holds token or byte here
  1183 00:DA0A: E9 3A              SBC   #':'              ; subtract ":" (carry set by CMP #00)
  1184 00:DA0C: F0 04              BEQ   LAB_13FF          ; branch if it was ":" (is now $00)
  1185                        
  1186                                                      ; A now holds token-$3A
  1187 00:DA0E: C9 49              CMP   #TK_DATA-$3A      ; compare with DATA token - $3A
  1188 00:DA10: D0 02              BNE   LAB_1401          ; branch if not DATA
  1189                        
  1190                                                      ; token was : or DATA
  1191                        LAB_13FF
  1192 00:DA12: 85 60              STA   Oquote            ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
  1193                        LAB_1401
  1194 00:DA14: 49 57              EOR   #TK_REM-$3A       ; effectively subtract REM token offset
  1195 00:DA16: D0 93              BNE   LAB_13AC          ; If wasn't REM then go crunch rest of line
  1196                        
  1197 00:DA18: 85 5C              STA   Asrch             ; else was REM so set search for [EOL]
  1198                        
  1199                                                      ; loop for REM, "..." etc.
  1200                        LAB_1408
  1201 00:DA1A: BD 21 02           LDA   Ibuffs,X          ; get byte from input buffer
  1202 00:DA1D: F0 E2              BEQ   LAB_13EC          ; branch if null [EOL]
  1203                        
  1204 00:DA1F: C5 5C              CMP   Asrch             ; compare with stored character
  1205 00:DA21: F0 DE              BEQ   LAB_13EC          ; branch if match (end quote)
  1206                        
  1207                                                      ; entry for copy string in quotes, don't crunch
  1208                        LAB_1410
  1209 00:DA23: C8                 INY                     ; increment buffer save index
  1210 00:DA24: 99 21 02           STA   Ibuffs,Y          ; save byte to output
  1211 00:DA27: E8                 INX                     ; increment buffer read index
  1212 00:DA28: D0 F0              BNE   LAB_1408          ; loop while <> 0 (should never be 0!)
  1213                        
  1214                                                      ; not found keyword this go
  1215                        LAB_1417
  1216 00:DA2A: A6 78              LDX   TempB             ; compare has failed, restore buffer index (start byte!)
  1217                        
  1218                                                      ; now find the end of this word in the table
  1219                        LAB_141B
  1220 00:DA2C: B1 73              LDA   (ut2_pl),Y        ; get table byte
  1221 00:DA2E: 08                 PHP                     ; save status
  1222 00:DA2F: C8                 INY                     ; increment table index
  1223 00:DA30: 28                 PLP                     ; restore byte status
  1224 00:DA31: 10 F9              BPL   LAB_141B          ; if not end of keyword go do next
  1225                        
  1226 00:DA33: B1 73              LDA   (ut2_pl),Y        ; get byte from keyword table
  1227 00:DA35: D0 BE              BNE   LAB_13D8          ; go test next word if not zero byte (end of table)
  1228                        
  1229                                                      ; reached end of table with no match
  1230 00:DA37: BD 21 02           LDA   Ibuffs,X          ; restore byte from input buffer
  1231 00:DA3A: 10 C3              BPL   LAB_13EA          ; branch always (all bytes in buffer are $00-$7F)
  1232                                                      ; go save byte in output and continue crunching
  1233                        
  1234                                                      ; reached [EOL]
  1235                        LAB_142A
  1236 00:DA3C: C8                 INY                     ; increment pointer
  1237 00:DA3D: C8                 INY                     ; increment pointer (makes it next line pointer high byte)
  1238 00:DA3E: 99 21 02           STA   Ibuffs,Y          ; save [EOL] (marks [EOT] in immediate mode)
  1239 00:DA41: C8                 INY                     ; adjust for line copy
  1240 00:DA42: C8                 INY                     ; adjust for line copy
  1241 00:DA43: C8                 INY                     ; adjust for line copy
  1242                        ; *** begin patch for when Ibuffs is $xx00 - Daryl Rictor ***
  1243                        ; *** insert
  1244                              .IF   Ibuffs&$FF=0
  1245                              LDA   Bpntrl            ; test for $00
  1246                              BNE   LAB_142P          ; not $00
  1247                              DEC   Bpntrh            ; allow for increment when $xx00
  1248                        LAB_142P
  1249                              .ENDIF
  1250                        ; *** end   patch for when Ibuffs is $xx00 - Daryl Rictor ***
  1251                        ; end of patch
  1252 00:DA44: C6 C3              DEC   Bpntrl            ; allow for increment
  1253 00:DA46: 60                 RTS
  1254                        
  1255                        ; search Basic for temp integer line number from start of mem
  1256                        
  1257                        LAB_SSLN
  1258 00:DA47: A5 79              LDA   Smeml             ; get start of mem low byte
  1259 00:DA49: A6 7A              LDX   Smemh             ; get start of mem high byte
  1260                        
  1261                        ; search Basic for temp integer line number from AX
  1262                        ; returns carry set if found
  1263                        ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
  1264                        
  1265                        ; old 541 new 507
  1266                        
  1267                        LAB_SHLN
  1268 00:DA4B: A0 01              LDY   #$01              ; set index
  1269 00:DA4D: 85 AA              STA   Baslnl            ; save low byte as current
  1270 00:DA4F: 86 AB              STX   Baslnh            ; save high byte as current
  1271 00:DA51: B1 AA              LDA   (Baslnl),Y        ; get pointer high byte from addr
  1272 00:DA53: F0 1A              BEQ   LAB_145F          ; pointer was zero so we're done, do 'not found' exit
  1273                        
  1274 00:DA55: A0 03              LDY   #$03              ; set index to line # high byte
  1275 00:DA57: B1 AA              LDA   (Baslnl),Y        ; get line # high byte
  1276 00:DA59: 88                 DEY                     ; decrement index (point to low byte)
  1277 00:DA5A: C5 12              CMP   Itemph            ; compare with temporary integer high byte
  1278 00:DA5C: D0 04              BNE   LAB_1455          ; if <> skip low byte check
  1279                        
  1280 00:DA5E: B1 AA              LDA   (Baslnl),Y        ; get line # low byte
  1281 00:DA60: C5 11              CMP   Itempl            ; compare with temporary integer low byte
  1282                        LAB_1455
  1283 00:DA62: B0 09              BCS   LAB_145E          ; else if temp < this line, exit (passed line#)
  1284                        
  1285                        LAB_1456
  1286 00:DA64: 88                 DEY                     ; decrement index to next line ptr high byte
  1287 00:DA65: B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
  1288 00:DA67: AA                 TAX                     ; copy to X
  1289 00:DA68: 88                 DEY                     ; decrement index to next line ptr low byte
  1290 00:DA69: B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
  1291 00:DA6B: 90 DE              BCC   LAB_SHLN          ; go search for line # in temp (Itempl/Itemph) from AX
  1292                                                      ; (carry always clear)
  1293                        
  1294                        LAB_145E
  1295 00:DA6D: F0 01              BEQ   LAB_1460          ; exit if temp = found line #, carry is set
  1296                        
  1297                        LAB_145F
  1298 00:DA6F: 18                 CLC                     ; clear found flag
  1299                        LAB_1460
  1300 00:DA70: 60                 RTS
  1301                        
  1302                        ; perform NEW
  1303                        
  1304                        LAB_NEW
  1305 00:DA71: D0 FD              BNE   LAB_1460          ; exit if not end of statement (to do syntax error)
  1306                        
  1307                        LAB_1463
  1308 00:DA73: A9 00              LDA   #$00              ; clear A
  1309 00:DA75: A8                 TAY                     ; clear Y
  1310 00:DA76: 91 79              STA   (Smeml),Y         ; clear first line, next line pointer, low byte
  1311 00:DA78: C8                 INY                     ; increment index
  1312 00:DA79: 91 79              STA   (Smeml),Y         ; clear first line, next line pointer, high byte
  1313 00:DA7B: 18                 CLC                     ; clear carry
  1314 00:DA7C: A5 79              LDA   Smeml             ; get start of mem low byte
  1315 00:DA7E: 69 02              ADC   #$02              ; calculate end of BASIC low byte
  1316 00:DA80: 85 7B              STA   Svarl             ; save start of vars low byte
  1317 00:DA82: A5 7A              LDA   Smemh             ; get start of mem high byte
  1318 00:DA84: 69 00              ADC   #$00              ; add any carry
  1319 00:DA86: 85 7C              STA   Svarh             ; save start of vars high byte
  1320                        
  1321                        ; reset execution to start, clear vars and flush stack
  1322                        
  1323                        LAB_1477
  1324 00:DA88: 18                 CLC                     ; clear carry
  1325 00:DA89: A5 79              LDA   Smeml             ; get start of mem low byte
  1326 00:DA8B: 69 FF              ADC   #$FF              ; -1
  1327 00:DA8D: 85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
  1328 00:DA8F: A5 7A              LDA   Smemh             ; get start of mem high byte
  1329 00:DA91: 69 FF              ADC   #$FF              ; -1+carry
  1330 00:DA93: 85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
  1331                        
  1332                        ; "CLEAR" command gets here
  1333                        
  1334                        LAB_147A
  1335 00:DA95: A5 85              LDA   Ememl             ; get end of mem low byte
  1336 00:DA97: A4 86              LDY   Ememh             ; get end of mem high byte
  1337 00:DA99: 85 81              STA   Sstorl            ; set bottom of string space low byte
  1338 00:DA9B: 84 82              STY   Sstorh            ; set bottom of string space high byte
  1339 00:DA9D: A5 7B              LDA   Svarl             ; get start of vars low byte
  1340 00:DA9F: A4 7C              LDY   Svarh             ; get start of vars high byte
  1341 00:DAA1: 85 7D              STA   Sarryl            ; save var mem end low byte
  1342 00:DAA3: 84 7E              STY   Sarryh            ; save var mem end high byte
  1343 00:DAA5: 85 7F              STA   Earryl            ; save array mem end low byte
  1344 00:DAA7: 84 80              STY   Earryh            ; save array mem end high byte
  1345 00:DAA9: 20 60 DC           JSR   LAB_161A          ; perform RESTORE command
  1346                        
  1347                        ; flush stack and clear continue flag
  1348                        
  1349                        LAB_1491
  1350 00:DAAC: A2 68              LDX   #des_sk           ; set descriptor stack pointer
  1351 00:DAAE: 86 65              STX   next_s            ; save descriptor stack pointer
  1352 00:DAB0: 68                 PLA                     ; pull return address low byte
  1353 00:DAB1: AA                 TAX                     ; copy return address low byte
  1354 00:DAB2: 68                 PLA                     ; pull return address high byte
  1355 00:DAB3: 8E FE 01           STX   LAB_SKFE          ; save to cleared stack
  1356 00:DAB6: 8D FF 01           STA   LAB_SKFF          ; save to cleared stack
  1357 00:DAB9: A2 FD              LDX   #$FD              ; new stack pointer
  1358 00:DABB: 9A                 TXS                     ; reset stack
  1359 00:DABC: A9 00              LDA   #$00              ; clear byte
  1360                        ;*** fix p2: no longer necessary as the continue pointer is saved anyway
  1361                        ;      STA   Cpntrh            ; clear continue pointer high byte
  1362 00:DABE: 85 61              STA   Sufnxf            ; clear subscript/FNX flag
  1363                        LAB_14A6
  1364 00:DAC0: 60                 RTS
  1365                        
  1366                        ; perform CLEAR
  1367                        
  1368                        LAB_CLEAR
  1369 00:DAC1: F0 D2              BEQ   LAB_147A          ; if no following token go do "CLEAR"
  1370                        
  1371                                                      ; else there was a following token (go do syntax error)
  1372 00:DAC3: 60                 RTS
  1373                        
  1374                        ; perform LIST [n][-m]
  1375                        ; bigger, faster version (a _lot_ faster)
  1376                        
  1377                        LAB_LIST
  1378 00:DAC4: 90 06              BCC   LAB_14BD          ; branch if next character numeric (LIST n..)
  1379                        
  1380 00:DAC6: F0 04              BEQ   LAB_14BD          ; branch if next character [NULL] (LIST)
  1381                        
  1382 00:DAC8: C9 B7              CMP   #TK_MINUS         ; compare with token for -
  1383 00:DACA: D0 F4              BNE   LAB_14A6          ; exit if not - (LIST -m)
  1384                        
  1385                                                      ; LIST [[n][-m]]
  1386                                                      ; this bit sets the n , if present, as the start and end
  1387                        LAB_14BD
  1388 00:DACC: 20 76 DE           JSR   LAB_GFPN          ; get fixed-point number into temp integer
  1389 00:DACF: 20 47 DA           JSR   LAB_SSLN          ; search BASIC for temp integer line number
  1390                                                      ; (pointer in Baslnl/Baslnh)
  1391 00:DAD2: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  1392 00:DAD5: F0 0C              BEQ   LAB_14D4          ; branch if no more characters
  1393                        
  1394                                                      ; this bit checks the - is present
  1395 00:DAD7: C9 B7              CMP   #TK_MINUS         ; compare with token for -
  1396 00:DAD9: D0 95              BNE   LAB_1460          ; return if not "-" (will be Syntax error)
  1397                        
  1398                                                      ; LIST [n]-m
  1399                                                      ; the - was there so set m as the end value
  1400 00:DADB: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  1401 00:DADE: 20 76 DE           JSR   LAB_GFPN          ; get fixed-point number into temp integer
  1402 00:DAE1: D0 8D              BNE   LAB_1460          ; exit if not ok
  1403                        
  1404                        LAB_14D4
  1405 00:DAE3: A5 11              LDA   Itempl            ; get temporary integer low byte
  1406 00:DAE5: 05 12              ORA   Itemph            ; OR temporary integer high byte
  1407 00:DAE7: D0 06              BNE   LAB_14E2          ; branch if start set
  1408                        
  1409 00:DAE9: A9 FF              LDA   #$FF              ; set for -1
  1410 00:DAEB: 85 11              STA   Itempl            ; set temporary integer low byte
  1411 00:DAED: 85 12              STA   Itemph            ; set temporary integer high byte
  1412                        LAB_14E2
  1413 00:DAEF: A0 01              LDY   #$01              ; set index for line
  1414 00:DAF1: 84 60              STY   Oquote            ; clear open quote flag
  1415 00:DAF3: 20 B3 DF           JSR   LAB_CRLF          ; print CR/LF
  1416 00:DAF6: B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
  1417                                                      ; pointer initially set by search at LAB_14BD
  1418 00:DAF8: F0 3E              BEQ   LAB_152B          ; if null all done so exit
  1419 00:DAFA: 20 36 DC           JSR   LAB_1629          ; do CRTL-C check vector
  1420                        
  1421 00:DAFD: C8                 INY                     ; increment index for line
  1422 00:DAFE: B1 AA              LDA   (Baslnl),Y        ; get line # low byte
  1423 00:DB00: AA                 TAX                     ; copy to X
  1424 00:DB01: C8                 INY                     ; increment index
  1425 00:DB02: B1 AA              LDA   (Baslnl),Y        ; get line # high byte
  1426 00:DB04: C5 12              CMP   Itemph            ; compare with temporary integer high byte
  1427 00:DB06: D0 04              BNE   LAB_14FF          ; branch if no high byte match
  1428                        
  1429 00:DB08: E4 11              CPX   Itempl            ; compare with temporary integer low byte
  1430 00:DB0A: F0 02              BEQ   LAB_1501          ; branch if = last line to do (< will pass next branch)
  1431                        
  1432                        LAB_14FF                      ; else ..
  1433 00:DB0C: B0 2A              BCS   LAB_152B          ; if greater all done so exit
  1434                        
  1435                        LAB_1501
  1436 00:DB0E: 84 97              STY   Tidx1             ; save index for line
  1437 00:DB10: 20 AF F1           JSR   LAB_295E          ; print XA as unsigned integer
  1438 00:DB13: A9 20              LDA   #$20              ; space is the next character
  1439                        LAB_1508
  1440 00:DB15: A4 97              LDY   Tidx1             ; get index for line
  1441 00:DB17: 29 7F              AND   #$7F              ; mask top out bit of character
  1442                        LAB_150C
  1443 00:DB19: 20 0E E0           JSR   LAB_PRNA          ; go print the character
  1444 00:DB1C: C9 22              CMP   #$22              ; was it " character
  1445 00:DB1E: D0 06              BNE   LAB_1519          ; branch if not
  1446                        
  1447                                                      ; we are either entering or leaving a pair of quotes
  1448 00:DB20: A5 60              LDA   Oquote            ; get open quote flag
  1449 00:DB22: 49 FF              EOR   #$FF              ; toggle it
  1450 00:DB24: 85 60              STA   Oquote            ; save it back
  1451                        LAB_1519
  1452 00:DB26: C8                 INY                     ; increment index
  1453 00:DB27: B1 AA              LDA   (Baslnl),Y        ; get next byte
  1454 00:DB29: D0 0E              BNE   LAB_152E          ; branch if not [EOL] (go print character)
  1455 00:DB2B: A8                 TAY                     ; else clear index
  1456 00:DB2C: B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
  1457 00:DB2E: AA                 TAX                     ; copy to X
  1458 00:DB2F: C8                 INY                     ; increment index
  1459 00:DB30: B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
  1460 00:DB32: 86 AA              STX   Baslnl            ; set pointer to line low byte
  1461 00:DB34: 85 AB              STA   Baslnh            ; set pointer to line high byte
  1462 00:DB36: D0 B7              BNE   LAB_14E2          ; go do next line if not [EOT]
  1463                                                      ; else ..
  1464                        LAB_152B
  1465 00:DB38: 60                 RTS
  1466                        
  1467                        LAB_152E
  1468 00:DB39: 10 DE              BPL   LAB_150C          ; just go print it if not token byte
  1469                        
  1470                                                      ; else was token byte so uncrunch it (maybe)
  1471 00:DB3B: 24 60              BIT   Oquote            ; test the open quote flag
  1472 00:DB3D: 30 DA              BMI   LAB_150C          ; just go print character if open quote set
  1473                        
  1474 00:DB3F: A2 FC              LDX   #>LAB_KEYT        ; get table address high byte
  1475 00:DB41: 0A                 ASL                     ; *2
  1476 00:DB42: 0A                 ASL                     ; *4
  1477 00:DB43: 90 02              BCC   LAB_152F          ; branch if no carry
  1478                        
  1479 00:DB45: E8                 INX                     ; else increment high byte
  1480 00:DB46: 18                 CLC                     ; clear carry for add
  1481                        LAB_152F
  1482 00:DB47: 69 41              ADC   #<LAB_KEYT        ; add low byte
  1483 00:DB49: 90 01              BCC   LAB_1530          ; branch if no carry
  1484                        
  1485 00:DB4B: E8                 INX                     ; else increment high byte
  1486                        LAB_1530
  1487 00:DB4C: 85 73              STA   ut2_pl            ; save table pointer low byte
  1488 00:DB4E: 86 74              STX   ut2_ph            ; save table pointer high byte
  1489 00:DB50: 84 97              STY   Tidx1             ; save index for line
  1490 00:DB52: A0 00              LDY   #$00              ; clear index
  1491 00:DB54: B1 73              LDA   (ut2_pl),Y        ; get length
  1492 00:DB56: AA                 TAX                     ; copy length
  1493 00:DB57: C8                 INY                     ; increment index
  1494 00:DB58: B1 73              LDA   (ut2_pl),Y        ; get 1st character
  1495 00:DB5A: CA                 DEX                     ; decrement length
  1496 00:DB5B: F0 B8              BEQ   LAB_1508          ; if no more characters exit and print
  1497                        
  1498 00:DB5D: 20 0E E0           JSR   LAB_PRNA          ; go print the character
  1499 00:DB60: C8                 INY                     ; increment index
  1500 00:DB61: B1 73              LDA   (ut2_pl),Y        ; get keyword address low byte
  1501 00:DB63: 48                 PHA                     ; save it for now
  1502 00:DB64: C8                 INY                     ; increment index
  1503 00:DB65: B1 73              LDA   (ut2_pl),Y        ; get keyword address high byte
  1504 00:DB67: A0 00              LDY   #$00
  1505 00:DB69: 85 74              STA   ut2_ph            ; save keyword pointer high byte
  1506 00:DB6B: 68                 PLA                     ; pull low byte
  1507 00:DB6C: 85 73              STA   ut2_pl            ; save keyword pointer low byte
  1508                        LAB_1540
  1509 00:DB6E: B1 73              LDA   (ut2_pl),Y        ; get character
  1510 00:DB70: CA                 DEX                     ; decrement character count
  1511 00:DB71: F0 A2              BEQ   LAB_1508          ; if last character exit and print
  1512                        
  1513 00:DB73: 20 0E E0           JSR   LAB_PRNA          ; go print the character
  1514 00:DB76: C8                 INY                     ; increment index
  1515 00:DB77: D0 F5              BNE   LAB_1540          ; loop for next character
  1516                        
  1517                        ; perform FOR
  1518                        
  1519                        LAB_FOR
  1520 00:DB79: A9 80              LDA   #$80              ; set FNX
  1521 00:DB7B: 85 61              STA   Sufnxf            ; set subscript/FNX flag
  1522 00:DB7D: 20 D5 DE           JSR   LAB_LET           ; go do LET
  1523 00:DB80: 68                 PLA                     ; pull return address
  1524 00:DB81: 68                 PLA                     ; pull return address
  1525 00:DB82: A9 10              LDA   #$10              ; we need 16d bytes !
  1526 00:DB84: 20 23 D8           JSR   LAB_1212          ; check room on stack for A bytes
  1527 00:DB87: 20 BB DD           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
  1528 00:DB8A: 18                 CLC                     ; clear carry for add
  1529 00:DB8B: 98                 TYA                     ; copy index to A
  1530 00:DB8C: 65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1531 00:DB8E: 48                 PHA                     ; push onto stack
  1532 00:DB8F: A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
  1533 00:DB91: 69 00              ADC   #$00              ; add carry
  1534 00:DB93: 48                 PHA                     ; push onto stack
  1535 00:DB94: A5 88              LDA   Clineh            ; get current line high byte
  1536 00:DB96: 48                 PHA                     ; push onto stack
  1537 00:DB97: A5 87              LDA   Clinel            ; get current line low byte
  1538 00:DB99: 48                 PHA                     ; push onto stack
  1539 00:DB9A: A9 AD              LDA   #TK_TO            ; get "TO" token
  1540 00:DB9C: 20 11 E3           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
  1541 00:DB9F: 20 F0 E1           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  1542 00:DBA2: 20 ED E1           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  1543                                                      ; else do type mismatch
  1544                        ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
  1545                        ; *** add
  1546 00:DBA5: 20 06 F0           JSR   LAB_27BA          ; round FAC1
  1547                        ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
  1548 00:DBA8: A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
  1549 00:DBAA: 09 7F              ORA   #$7F              ; set all non sign bits
  1550 00:DBAC: 25 AD              AND   FAC1_1            ; and FAC1 mantissa1
  1551 00:DBAE: 85 AD              STA   FAC1_1            ; save FAC1 mantissa1
  1552 00:DBB0: A9 BB              LDA   #<LAB_159F        ; set return address low byte
  1553 00:DBB2: A0 DB              LDY   #>LAB_159F        ; set return address high byte
  1554 00:DBB4: 85 71              STA   ut1_pl            ; save return address low byte
  1555 00:DBB6: 84 72              STY   ut1_ph            ; save return address high byte
  1556 00:DBB8: 4C A7 E2           JMP   LAB_1B66          ; round FAC1 and put on stack (returns to next instruction)
  1557                        
  1558                        LAB_159F
  1559 00:DBBB: A9 10              LDA   #<LAB_259C        ; set 1 pointer low addr (default step size)
  1560 00:DBBD: A0 F9              LDY   #>LAB_259C        ; set 1 pointer high addr
  1561 00:DBBF: 20 AA EF           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  1562 00:DBC2: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  1563 00:DBC5: C9 B2              CMP   #TK_STEP          ; compare with STEP token
  1564 00:DBC7: D0 06              BNE   LAB_15B3          ; jump if not "STEP"
  1565                        
  1566                                                      ;.was step so ..
  1567 00:DBC9: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  1568 00:DBCC: 20 ED E1           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  1569                                                      ; else do type mismatch
  1570                        LAB_15B3
  1571 00:DBCF: 20 16 F0           JSR   LAB_27CA          ; return A=FF,C=1/-ve A=01,C=0/+ve
  1572 00:DBD2: 85 B0              STA   FAC1_s            ; set FAC1 sign (b7)
  1573                                                      ; this is +1 for +ve step and -1 for -ve step, in NEXT we
  1574                                                      ; compare the FOR value and the TO value and return +1 if
  1575                                                      ; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
  1576                                                      ; here (+/-1) is then compared to that result and if they
  1577                                                      ; are the same (+ve and FOR > TO or -ve and FOR < TO) then
  1578                                                      ; the loop is done
  1579                                                     
  1580                        ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
  1581                        ; *** add
  1582                           .IF $&$FF=$FD
  1583                              NOP                     ; return address of JSR +1 (on  next page)
  1584                           .ENDIF  
  1585                        ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
  1586 00:DBD4: 20 99 E2           JSR   LAB_1B5B          ; push sign, round FAC1 and put on stack
  1587 00:DBD7: A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
  1588 00:DBD9: 48                 PHA                     ; push on stack
  1589 00:DBDA: A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
  1590 00:DBDC: 48                 PHA                     ; push on stack
  1591 00:DBDD: A9 81              LDA   #TK_FOR           ; get FOR token
  1592 00:DBDF: 48                 PHA                     ; push on stack
  1593                        
  1594                        ; interpreter inner loop
  1595                        
  1596                        LAB_15C2
  1597 00:DBE0: 20 36 DC           JSR   LAB_1629          ; do CRTL-C check vector
  1598 00:DBE3: A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
  1599 00:DBE5: A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
  1600                        
  1601 00:DBE7: A6 88              LDX   Clineh            ; continue line is $FFxx for immediate mode
  1602                                                      ; ($00xx for RUN from immediate mode)
  1603 00:DBE9: E8                 INX                     ; increment it (now $00 if immediate mode)
  1604                        ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
  1605                        ;      BEQ   LAB_15D1          ; branch if null (immediate mode)
  1606                        
  1607 00:DBEA: 85 8B              STA   Cpntrl            ; save continue pointer low byte
  1608 00:DBEC: 84 8C              STY   Cpntrh            ; save continue pointer high byte
  1609                        LAB_15D1
  1610 00:DBEE: A0 00              LDY   #$00              ; clear index
  1611 00:DBF0: B1 C3              LDA   (Bpntrl),Y        ; get next byte
  1612 00:DBF2: F0 07              BEQ   LAB_15DC          ; branch if null [EOL]
  1613                        
  1614 00:DBF4: C9 3A              CMP   #':'              ; compare with ":"
  1615 00:DBF6: F0 1D              BEQ   LAB_15F6          ; branch if = (statement separator)
  1616                        
  1617                        LAB_15D9
  1618 00:DBF8: 4C 22 E3           JMP   LAB_SNER          ; else syntax error then warm start
  1619                        
  1620                                                      ; have reached [EOL]
  1621                        LAB_15DC
  1622 00:DBFB: A0 02              LDY   #$02              ; set index
  1623 00:DBFD: B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
  1624 00:DBFF: 18                 CLC                     ; clear carry for no "BREAK" message
  1625 00:DC00: F0 50              BEQ   LAB_1651          ; if null go to immediate mode (was immediate or [EOT]
  1626                                                      ; marker)
  1627                        
  1628 00:DC02: C8                 INY                     ; increment index
  1629 00:DC03: B1 C3              LDA   (Bpntrl),Y        ; get line # low byte
  1630 00:DC05: 85 87              STA   Clinel            ; save current line low byte
  1631 00:DC07: C8                 INY                     ; increment index
  1632 00:DC08: B1 C3              LDA   (Bpntrl),Y        ; get line # high byte
  1633 00:DC0A: 85 88              STA   Clineh            ; save current line high byte
  1634 00:DC0C: 98                 TYA                     ; A now = 4
  1635 00:DC0D: 65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1636 00:DC0F: 85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
  1637 00:DC11: 90 02              BCC   LAB_15F6          ; branch if no overflow
  1638                        
  1639 00:DC13: E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
  1640                        LAB_15F6
  1641 00:DC15: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  1642                        
  1643                        LAB_15F9
  1644 00:DC18: 20 1E DC           JSR   LAB_15FF          ; go interpret BASIC code from (Bpntrl)
  1645                        
  1646                        LAB_15FC
  1647 00:DC1B: 4C E0 DB           JMP   LAB_15C2          ; loop
  1648                        
  1649                        ; interpret BASIC code from (Bpntrl)
  1650                        
  1651                        LAB_15FF
  1652 00:DC1E: F0 4E              BEQ   LAB_1628          ; exit if zero [EOL]
  1653                        
  1654                        LAB_1602
  1655 00:DC20: 0A                 ASL                     ; *2 bytes per vector and normalise token
  1656 00:DC21: B0 03              BCS   LAB_1609          ; branch if was token
  1657                        
  1658 00:DC23: 4C D5 DE           JMP   LAB_LET           ; else go do implied LET
  1659                        
  1660                        LAB_1609
  1661 00:DC26: C9 56              CMP   #(TK_TAB-$80)*2   ; compare normalised token * 2 with TAB
  1662 00:DC28: B0 CE              BCS   LAB_15D9          ; branch if A>=TAB (do syntax error then warm start)
  1663                                                      ; only tokens before TAB can start a line
  1664 00:DC2A: A8                 TAY                     ; copy to index
  1665 00:DC2B: B9 38 F9           LDA   LAB_CTBL+1,Y      ; get vector high byte
  1666 00:DC2E: 48                 PHA                     ; onto stack
  1667 00:DC2F: B9 37 F9           LDA   LAB_CTBL,Y        ; get vector low byte
  1668 00:DC32: 48                 PHA                     ; onto stack
  1669 00:DC33: 4C BC 00           JMP   LAB_IGBY          ; jump to increment and scan memory
  1670                                                      ; then "return" to vector
  1671                        
  1672                        ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
  1673                        ; key press is detected.
  1674                        
  1675                        LAB_1629
  1676 00:DC36: 6C 03 02           JMP   (VEC_CC)          ; ctrl c check vector
  1677                        
  1678                        ; if there was a key press it gets back here ..
  1679                        
  1680                        LAB_1636
  1681 00:DC39: C9 03              CMP   #$03              ; compare with CTRL-C
  1682                        
  1683                        ; perform STOP
  1684                        
  1685                        LAB_STOP
  1686 00:DC3B: B0 01              BCS   LAB_163B          ; branch if token follows STOP
  1687                                                      ; else just END
  1688                        ; END
  1689                        
  1690                        LAB_END
  1691 00:DC3D: 18                 CLC                     ; clear the carry, indicate a normal program end
  1692                        LAB_163B
  1693 00:DC3E: D0 61              BNE   LAB_167A          ; if wasn't CTRL-C or there is a following byte return
  1694                        
  1695 00:DC40: A5 C4              LDA   Bpntrh            ; get the BASIC execute pointer high byte
  1696                        ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
  1697                        ;      EOR   #>Ibuffs          ; compare with buffer address high byte (Cb unchanged)
  1698                        ;      BEQ   LAB_164F          ; branch if the BASIC pointer is in the input buffer
  1699                        ;                              ; (can't continue in immediate mode)
  1700                        ;                              ; else ..
  1701                        ;      EOR   #>Ibuffs          ; correct the bits
  1702 00:DC42: A4 C3              LDY   Bpntrl            ; get BASIC execute pointer low byte
  1703 00:DC44: 84 8B              STY   Cpntrl            ; save continue pointer low byte
  1704 00:DC46: 85 8C              STA   Cpntrh            ; save continue pointer high byte
  1705                        LAB_1647
  1706 00:DC48: A5 87              LDA   Clinel            ; get current line low byte
  1707 00:DC4A: A4 88              LDY   Clineh            ; get current line high byte
  1708 00:DC4C: 85 89              STA   Blinel            ; save break line low byte
  1709 00:DC4E: 84 8A              STY   Blineh            ; save break line high byte
  1710                        LAB_164F
  1711 00:DC50: 68                 PLA                     ; pull return address low
  1712 00:DC51: 68                 PLA                     ; pull return address high
  1713                        LAB_1651
  1714 00:DC52: 90 07              BCC   LAB_165E          ; if was program end just do warm start
  1715                        
  1716                                                      ; else ..
  1717 00:DC54: A9 0E              LDA   #<LAB_BMSG        ; point to "Break" low byte
  1718 00:DC56: A0 FF              LDY   #>LAB_BMSG        ; point to "Break" high byte
  1719 00:DC58: 4C 72 D8           JMP   LAB_1269          ; print "Break" and do warm start
  1720                        
  1721                        LAB_165E
  1722 00:DC5B: 4C 7D D8           JMP   LAB_1274          ; go do warm start
  1723                        
  1724                        ; perform RESTORE
  1725                        
  1726                        LAB_RESTORE
  1727 00:DC5E: D0 0F              BNE   LAB_RESTOREn      ; branch if next character not null (RESTORE n)
  1728                        
  1729                        LAB_161A
  1730 00:DC60: 38                 SEC                     ; set carry for subtract
  1731 00:DC61: A5 79              LDA   Smeml             ; get start of mem low byte
  1732 00:DC63: E9 01              SBC   #$01              ; -1
  1733 00:DC65: A4 7A              LDY   Smemh             ; get start of mem high byte
  1734 00:DC67: B0 01              BCS   LAB_1624          ; branch if no underflow
  1735                        
  1736                        LAB_uflow
  1737 00:DC69: 88                 DEY                     ; else decrement high byte
  1738                        LAB_1624
  1739 00:DC6A: 85 8F              STA   Dptrl             ; save DATA pointer low byte
  1740 00:DC6C: 84 90              STY   Dptrh             ; save DATA pointer high byte
  1741                        LAB_1628
  1742 00:DC6E: 60                 RTS
  1743                        
  1744                                                      ; is RESTORE n
  1745                        LAB_RESTOREn
  1746 00:DC6F: 20 76 DE           JSR   LAB_GFPN          ; get fixed-point number into temp integer
  1747 00:DC72: 20 BE DD           JSR   LAB_SNBL          ; scan for next BASIC line
  1748 00:DC75: A5 88              LDA   Clineh            ; get current line high byte
  1749 00:DC77: C5 12              CMP   Itemph            ; compare with temporary integer high byte
  1750 00:DC79: B0 0B              BCS   LAB_reset_search  ; branch if >= (start search from beginning)
  1751                        
  1752 00:DC7B: 98                 TYA                     ; else copy line index to A
  1753 00:DC7C: 38                 SEC                     ; set carry (+1)
  1754 00:DC7D: 65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1755 00:DC7F: A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
  1756 00:DC81: 90 07              BCC   LAB_go_search     ; branch if no overflow to high byte
  1757                        
  1758 00:DC83: E8                 INX                     ; increment high byte
  1759 00:DC84: B0 04              BCS   LAB_go_search     ; branch always (can never be carry clear)
  1760                        
  1761                        ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  1762                        
  1763                        LAB_reset_search
  1764 00:DC86: A5 79              LDA   Smeml             ; get start of mem low byte
  1765 00:DC88: A6 7A              LDX   Smemh             ; get start of mem high byte
  1766                        
  1767                        ; search for line # in temp (Itempl/Itemph) from (AX)
  1768                        
  1769                        LAB_go_search
  1770                        
  1771 00:DC8A: 20 4B DA           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
  1772 00:DC8D: B0 03              BCS   LAB_line_found    ; if carry set go set pointer
  1773                        
  1774 00:DC8F: 4C 90 DD           JMP   LAB_16F7          ; else go do "Undefined statement" error
  1775                        
  1776                        LAB_line_found
  1777                                                      ; carry already set for subtract
  1778 00:DC92: A5 AA              LDA   Baslnl            ; get pointer low byte
  1779 00:DC94: E9 01              SBC   #$01              ; -1
  1780 00:DC96: A4 AB              LDY   Baslnh            ; get pointer high byte
  1781 00:DC98: B0 D0              BCS   LAB_1624          ; branch if no underflow (save DATA pointer and return)
  1782                        
  1783 00:DC9A: 90 CD              BCC   LAB_uflow         ; else decrement high byte then save DATA pointer and
  1784                                                      ; return (branch always)
  1785                        
  1786                        ; perform NULL
  1787                        
  1788                        LAB_NULL
  1789 00:DC9C: 20 C0 EB           JSR   LAB_GTBY          ; get byte parameter
  1790 00:DC9F: 86 0D              STX   Nullct            ; save new NULL count
  1791                        LAB_167A
  1792 00:DCA1: 60                 RTS
  1793                        
  1794                        ; perform CONT
  1795                        
  1796                        LAB_CONT
  1797 00:DCA2: D0 FD              BNE   LAB_167A          ; if following byte exit to do syntax error
  1798                        
  1799 00:DCA4: A4 8C              LDY   Cpntrh            ; get continue pointer high byte
  1800 00:DCA6: C0 02              CPY   #>Ibuffs          ; *** fix p2: test direct mode
  1801 00:DCA8: D0 05              BNE   LAB_166C          ; go do continue if we can
  1802                        
  1803 00:DCAA: A2 1E              LDX   #$1E              ; error code $1E ("Can't continue" error)
  1804 00:DCAC: 4C 5F D8           JMP   LAB_XERR          ; do error #X, then warm start
  1805                        
  1806                                                      ; we can continue so ..
  1807                        LAB_166C
  1808 00:DCAF: A9 93              LDA   #TK_ON            ; set token for ON
  1809 00:DCB1: 20 43 F6           JSR   LAB_IRQ           ; set IRQ flags
  1810 00:DCB4: A9 93              LDA   #TK_ON            ; set token for ON
  1811 00:DCB6: 20 46 F6           JSR   LAB_NMI           ; set NMI flags
  1812                        
  1813 00:DCB9: 84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
  1814 00:DCBB: A5 8B              LDA   Cpntrl            ; get continue pointer low byte
  1815 00:DCBD: 85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
  1816 00:DCBF: A5 89              LDA   Blinel            ; get break line low byte
  1817 00:DCC1: A4 8A              LDY   Blineh            ; get break line high byte
  1818 00:DCC3: 85 87              STA   Clinel            ; set current line low byte
  1819 00:DCC5: 84 88              STY   Clineh            ; set current line high byte
  1820 00:DCC7: 60                 RTS
  1821                        
  1822                        ; perform RUN
  1823                        
  1824                        LAB_RUN
  1825 00:DCC8: D0 03              BNE   LAB_1696          ; branch if RUN n
  1826 00:DCCA: 4C 88 DA           JMP   LAB_1477          ; reset execution to start, clear variables, flush stack and
  1827                                                      ; return
  1828                        
  1829                        ; does RUN n
  1830                        
  1831                        LAB_1696
  1832 00:DCCD: 20 95 DA           JSR   LAB_147A          ; go do "CLEAR"
  1833 00:DCD0: F0 2E              BEQ   LAB_16B0          ; get n and do GOTO n (branch always as CLEAR sets Z=1)
  1834                        
  1835                        ; perform DO
  1836                        
  1837                        LAB_DO
  1838 00:DCD2: A9 05              LDA   #$05              ; need 5 bytes for DO
  1839 00:DCD4: 20 23 D8           JSR   LAB_1212          ; check room on stack for A bytes
  1840 00:DCD7: A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
  1841 00:DCD9: 48                 PHA                     ; push on stack
  1842 00:DCDA: A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
  1843 00:DCDC: 48                 PHA                     ; push on stack
  1844 00:DCDD: A5 88              LDA   Clineh            ; get current line high byte
  1845 00:DCDF: 48                 PHA                     ; push on stack
  1846 00:DCE0: A5 87              LDA   Clinel            ; get current line low byte
  1847 00:DCE2: 48                 PHA                     ; push on stack
  1848 00:DCE3: A9 9D              LDA   #TK_DO            ; token for DO
  1849 00:DCE5: 48                 PHA                     ; push on stack
  1850 00:DCE6: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  1851 00:DCE9: 4C E0 DB           JMP   LAB_15C2          ; go do interpreter inner loop
  1852                        
  1853                        ; perform GOSUB
  1854                        
  1855                        LAB_GOSUB
  1856 00:DCEC: A9 05              LDA   #$05              ; need 5 bytes for GOSUB
  1857 00:DCEE: 20 23 D8           JSR   LAB_1212          ; check room on stack for A bytes
  1858 00:DCF1: A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
  1859 00:DCF3: 48                 PHA                     ; push on stack
  1860 00:DCF4: A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
  1861 00:DCF6: 48                 PHA                     ; push on stack
  1862 00:DCF7: A5 88              LDA   Clineh            ; get current line high byte
  1863 00:DCF9: 48                 PHA                     ; push on stack
  1864 00:DCFA: A5 87              LDA   Clinel            ; get current line low byte
  1865 00:DCFC: 48                 PHA                     ; push on stack
  1866 00:DCFD: A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
  1867 00:DCFF: 48                 PHA                     ; push on stack
  1868                        LAB_16B0
  1869 00:DD00: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  1870 00:DD03: 20 09 DD           JSR   LAB_GOTO          ; perform GOTO n
  1871 00:DD06: 4C E0 DB           JMP   LAB_15C2          ; go do interpreter inner loop
  1872                                                      ; (can't RTS, we used the stack!)
  1873                        
  1874                        ; perform GOTO
  1875                        
  1876                        LAB_GOTO
  1877 00:DD09: 20 76 DE           JSR   LAB_GFPN          ; get fixed-point number into temp integer
  1878 00:DD0C: 20 BE DD           JSR   LAB_SNBL          ; scan for next BASIC line
  1879 00:DD0F: A5 88              LDA   Clineh            ; get current line high byte
  1880 00:DD11: C5 12              CMP   Itemph            ; compare with temporary integer high byte
  1881 00:DD13: B0 0B              BCS   LAB_16D0          ; branch if >= (start search from beginning)
  1882                        
  1883 00:DD15: 98                 TYA                     ; else copy line index to A
  1884 00:DD16: 38                 SEC                     ; set carry (+1)
  1885 00:DD17: 65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
  1886 00:DD19: A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
  1887 00:DD1B: 90 07              BCC   LAB_16D4          ; branch if no overflow to high byte
  1888                        
  1889 00:DD1D: E8                 INX                     ; increment high byte
  1890 00:DD1E: B0 04              BCS   LAB_16D4          ; branch always (can never be carry)
  1891                        
  1892                        ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
  1893                        
  1894                        LAB_16D0
  1895 00:DD20: A5 79              LDA   Smeml             ; get start of mem low byte
  1896 00:DD22: A6 7A              LDX   Smemh             ; get start of mem high byte
  1897                        
  1898                        ; search for line # in temp (Itempl/Itemph) from (AX)
  1899                        
  1900                        LAB_16D4
  1901 00:DD24: 20 4B DA           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
  1902 00:DD27: 90 67              BCC   LAB_16F7          ; if carry clear go do "Undefined statement" error
  1903                                                      ; (unspecified statement)
  1904                        
  1905                                                      ; carry already set for subtract
  1906 00:DD29: A5 AA              LDA   Baslnl            ; get pointer low byte
  1907 00:DD2B: E9 01              SBC   #$01              ; -1
  1908 00:DD2D: 85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
  1909 00:DD2F: A5 AB              LDA   Baslnh            ; get pointer high byte
  1910 00:DD31: E9 00              SBC   #$00              ; subtract carry
  1911 00:DD33: 85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
  1912                        LAB_16E5
  1913 00:DD35: 60                 RTS
  1914                        
  1915                        LAB_DONOK
  1916 00:DD36: A2 22              LDX   #$22              ; error code $22 ("LOOP without DO" error)
  1917 00:DD38: 4C 5F D8           JMP   LAB_XERR          ; do error #X, then warm start
  1918                        
  1919                        ; perform LOOP
  1920                        
  1921                        LAB_LOOP
  1922 00:DD3B: A8                 TAY                     ; save following token
  1923 00:DD3C: BA                 TSX                     ; copy stack pointer
  1924 00:DD3D: BD 03 01           LDA   LAB_STAK+3,X      ; get token byte from stack
  1925 00:DD40: C9 9D              CMP   #TK_DO            ; compare with DO token
  1926 00:DD42: D0 F2              BNE   LAB_DONOK         ; branch if no matching DO
  1927                        
  1928 00:DD44: E8                 INX                     ; dump calling routine return address
  1929 00:DD45: E8                 INX                     ; dump calling routine return address
  1930 00:DD46: 9A                 TXS                     ; correct stack
  1931 00:DD47: 98                 TYA                     ; get saved following token back
  1932 00:DD48: F0 20              BEQ   LoopAlways        ; if no following token loop forever
  1933                                                      ; (stack pointer in X)
  1934                        
  1935 00:DD4A: C9 3A              CMP   #':'              ; could be ':'
  1936 00:DD4C: F0 1C              BEQ   LoopAlways        ; if :... loop forever
  1937                        
  1938 00:DD4E: E9 B3              SBC   #TK_UNTIL         ; subtract token for UNTIL, we know carry is set here
  1939 00:DD50: AA                 TAX                     ; copy to X (if it was UNTIL then Y will be correct)
  1940 00:DD51: F0 04              BEQ   DoRest            ; branch if was UNTIL
  1941                        
  1942 00:DD53: CA                 DEX                     ; decrement result
  1943 00:DD54: D0 62              BNE   LAB_16FC          ; if not WHILE go do syntax error and warm start
  1944                                                      ; only if the token was WHILE will this fail
  1945                        
  1946 00:DD56: CA                 DEX                     ; set invert result byte
  1947                        DoRest
  1948 00:DD57: 86 98              STX   Frnxth            ; save invert result byte
  1949 00:DD59: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  1950 00:DD5C: 20 01 E2           JSR   LAB_EVEX          ; evaluate expression
  1951 00:DD5F: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  1952 00:DD61: F0 02              BEQ   DoCmp             ; if =0 go do straight compare
  1953                        
  1954 00:DD63: A9 FF              LDA   #$FF              ; else set all bits
  1955                        DoCmp
  1956 00:DD65: BA                 TSX                     ; copy stack pointer
  1957 00:DD66: 45 98              EOR   Frnxth            ; EOR with invert byte
  1958 00:DD68: D0 1A              BNE   LoopDone          ; if <> 0 clear stack and back to interpreter loop
  1959                        
  1960                                                      ; loop condition wasn't met so do it again
  1961                        LoopAlways
  1962 00:DD6A: BD 02 01           LDA   LAB_STAK+2,X      ; get current line low byte
  1963 00:DD6D: 85 87              STA   Clinel            ; save current line low byte
  1964 00:DD6F: BD 03 01           LDA   LAB_STAK+3,X      ; get current line high byte
  1965 00:DD72: 85 88              STA   Clineh            ; save current line high byte
  1966 00:DD74: BD 04 01           LDA   LAB_STAK+4,X      ; get BASIC execute pointer low byte
  1967 00:DD77: 85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
  1968 00:DD79: BD 05 01           LDA   LAB_STAK+5,X      ; get BASIC execute pointer high byte
  1969 00:DD7C: 85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
  1970 00:DD7E: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  1971 00:DD81: 4C E0 DB           JMP   LAB_15C2          ; go do interpreter inner loop
  1972                        
  1973                                                      ; clear stack and back to interpreter loop
  1974                        LoopDone
  1975 00:DD84: E8                 INX                     ; dump DO token
  1976 00:DD85: E8                 INX                     ; dump current line low byte
  1977 00:DD86: E8                 INX                     ; dump current line high byte
  1978 00:DD87: E8                 INX                     ; dump BASIC execute pointer low byte
  1979 00:DD88: E8                 INX                     ; dump BASIC execute pointer high byte
  1980 00:DD89: 9A                 TXS                     ; correct stack
  1981 00:DD8A: 4C AA DD           JMP   LAB_DATA          ; go perform DATA (find : or [EOL])
  1982                        
  1983                        ; do the return without gosub error
  1984                        
  1985                        LAB_16F4
  1986 00:DD8D: A2 04              LDX   #$04              ; error code $04 ("RETURN without GOSUB" error)
  1987 00:DD8F: 2C                 .byte $2C               ; makes next line BIT LAB_0EA2
  1988                        
  1989                        LAB_16F7                      ; do undefined statement error
  1990 00:DD90: A2 0E              LDX   #$0E              ; error code $0E ("Undefined statement" error)
  1991 00:DD92: 4C 5F D8           JMP   LAB_XERR          ; do error #X, then warm start
  1992                        
  1993                        ; perform RETURN
  1994                        
  1995                        LAB_RETURN
  1996 00:DD95: D0 9E              BNE   LAB_16E5          ; exit if following token (to allow syntax error)
  1997                        
  1998                        LAB_16E8
  1999 00:DD97: 68                 PLA                     ; dump calling routine return address
  2000 00:DD98: 68                 PLA                     ; dump calling routine return address
  2001 00:DD99: 68                 PLA                     ; pull token
  2002 00:DD9A: C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
  2003 00:DD9C: D0 EF              BNE   LAB_16F4          ; branch if no matching GOSUB
  2004                        
  2005                        LAB_16FF
  2006 00:DD9E: 68                 PLA                     ; pull current line low byte
  2007 00:DD9F: 85 87              STA   Clinel            ; save current line low byte
  2008 00:DDA1: 68                 PLA                     ; pull current line high byte
  2009 00:DDA2: 85 88              STA   Clineh            ; save current line high byte
  2010 00:DDA4: 68                 PLA                     ; pull BASIC execute pointer low byte
  2011 00:DDA5: 85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
  2012 00:DDA7: 68                 PLA                     ; pull BASIC execute pointer high byte
  2013 00:DDA8: 85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
  2014                        
  2015                                                      ; now do the DATA statement as we could be returning into
  2016                                                      ; the middle of an ON <var> GOSUB n,m,p,q line
  2017                                                      ; (the return address used by the DATA statement is the one
  2018                                                      ; pushed before the GOSUB was executed!)
  2019                        
  2020                        ; perform DATA
  2021                        
  2022                        LAB_DATA
  2023 00:DDAA: 20 BB DD           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
  2024                        
  2025                                                      ; set BASIC execute pointer
  2026                        LAB_170F
  2027 00:DDAD: 98                 TYA                     ; copy index to A
  2028 00:DDAE: 18                 CLC                     ; clear carry for add
  2029 00:DDAF: 65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
  2030 00:DDB1: 85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
  2031 00:DDB3: 90 02              BCC   LAB_1719          ; skip next if no carry
  2032                        
  2033 00:DDB5: E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
  2034                        LAB_1719
  2035 00:DDB7: 60                 RTS
  2036                        
  2037                        LAB_16FC
  2038 00:DDB8: 4C 22 E3           JMP   LAB_SNER          ; do syntax error then warm start
  2039                        
  2040                        ; scan for next BASIC statement ([:] or [EOL])
  2041                        ; returns Y as index to [:] or [EOL]
  2042                        
  2043                        LAB_SNBS
  2044 00:DDBB: A2 3A              LDX   #':'              ; set look for character = ":"
  2045 00:DDBD: 2C                 .byte $2C               ; makes next line BIT $00A2
  2046                        
  2047                        ; scan for next BASIC line
  2048                        ; returns Y as index to [EOL]
  2049                        
  2050                        LAB_SNBL
  2051 00:DDBE: A2 00              LDX   #$00              ; set alt search character = [EOL]
  2052 00:DDC0: A0 00              LDY   #$00              ; set search character = [EOL]
  2053 00:DDC2: 84 5C              STY   Asrch             ; store search character
  2054                        LAB_1725
  2055 00:DDC4: 8A                 TXA                     ; get alt search character
  2056 00:DDC5: 45 5C              EOR   Asrch             ; toggle search character, effectively swap with $00
  2057 00:DDC7: 85 5C              STA   Asrch             ; save swapped search character
  2058                        LAB_172D
  2059 00:DDC9: B1 C3              LDA   (Bpntrl),Y        ; get next byte
  2060 00:DDCB: F0 EA              BEQ   LAB_1719          ; exit if null [EOL]
  2061                        
  2062 00:DDCD: C5 5C              CMP   Asrch             ; compare with search character
  2063 00:DDCF: F0 E6              BEQ   LAB_1719          ; exit if found
  2064                        
  2065 00:DDD1: C8                 INY                     ; increment index
  2066 00:DDD2: C9 22              CMP   #$22              ; compare current character with open quote
  2067 00:DDD4: D0 F3              BNE   LAB_172D          ; if not open quote go get next character
  2068                        
  2069 00:DDD6: F0 EC              BEQ   LAB_1725          ; if found go swap search character for alt search character
  2070                        
  2071                        ; perform IF
  2072                        
  2073                        LAB_IF
  2074 00:DDD8: 20 01 E2           JSR   LAB_EVEX          ; evaluate the expression
  2075 00:DDDB: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  2076 00:DDDE: C9 B0              CMP   #TK_THEN          ; compare with THEN token
  2077 00:DDE0: F0 11              BEQ   LAB_174B          ; if it was THEN go do IF
  2078                        
  2079                                                      ; wasn't IF .. THEN so must be IF .. GOTO
  2080 00:DDE2: C9 89              CMP   #TK_GOTO          ; compare with GOTO token
  2081 00:DDE4: D0 D2              BNE   LAB_16FC          ; if it wasn't GOTO go do syntax error
  2082                        
  2083 00:DDE6: A6 C3              LDX   Bpntrl            ; save the basic pointer low byte
  2084 00:DDE8: A4 C4              LDY   Bpntrh            ; save the basic pointer high byte
  2085 00:DDEA: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  2086 00:DDED: B0 C9              BCS   LAB_16FC          ; if not numeric go do syntax error
  2087                        
  2088 00:DDEF: 86 C3              STX   Bpntrl            ; restore the basic pointer low byte
  2089 00:DDF1: 84 C4              STY   Bpntrh            ; restore the basic pointer high byte
  2090                        LAB_174B
  2091 00:DDF3: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  2092 00:DDF5: F0 1E              BEQ   LAB_174E          ; if the result was zero go look for an ELSE
  2093                        
  2094 00:DDF7: 20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
  2095 00:DDFA: B0 03              BCS   LAB_174D          ; if not numeric go do var or keyword
  2096                        
  2097                        LAB_174C
  2098 00:DDFC: 4C 09 DD           JMP   LAB_GOTO          ; else was numeric so do GOTO n
  2099                        
  2100                                                      ; is var or keyword
  2101                        LAB_174D
  2102                        ; *** patch       allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
  2103                        ; *** replace
  2104                        ;      CMP   #TK_RETURN        ; compare the byte with the token for RETURN
  2105                        ;      BNE   LAB_174G          ; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
  2106                        ;                              ; and return to this code to process any following code
  2107                        ;
  2108                        ;      JMP   LAB_1602          ; else it was RETURN so interpret BASIC code from (Bpntrl)
  2109                        ;                              ; but don't return here
  2110                        ;
  2111                        ;LAB_174G
  2112                        ;      JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
  2113                        ;
  2114                        ;; the IF was executed and there may be a following ELSE so the code needs to return
  2115                        ;; here to check and ignore the ELSE if present
  2116                        ;
  2117                        ;      LDY   #$00              ; clear the index
  2118                        ;      LDA   (Bpntrl),Y        ; get the next BASIC byte
  2119                        ;      CMP   #TK_ELSE          ; compare it with the token for ELSE
  2120                        ;      BEQ   LAB_DATA          ; if ELSE ignore the following statement
  2121                        ;
  2122                        ;; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
  2123                        ;; following ELSE will, correctly, cause a syntax error
  2124                        ;
  2125                        ;      RTS                     ; else return to the interpreter inner loop
  2126                        ;
  2127                        ; *** with
  2128 00:DDFF: 68                 PLA                     ; discard interpreter loop return address
  2129 00:DE00: 68                 PLA                     ; so data structures are at the correct stack offset
  2130 00:DE01: 20 C2 00           JSR   LAB_GBYT          ; restore token or variable
  2131 00:DE04: 20 1E DC           JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
  2132                        
  2133                        ; the IF was executed and there may be a following ELSE so the code needs to return
  2134                        ; here to check and ignore the ELSE if present
  2135                        
  2136 00:DE07: A0 00              LDY   #$00              ; clear the index
  2137 00:DE09: B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
  2138 00:DE0B: C9 AC              CMP   #TK_ELSE          ; compare it with the token for ELSE
  2139 00:DE0D: D0 03              BNE   LAB_no_ELSE       ; no - continue on this line
  2140 00:DE0F: 20 AA DD           JSR   LAB_DATA          ; yes - skip the rest of the line
  2141                        
  2142                        ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
  2143                        ; following ELSE will, correctly, cause a syntax error
  2144                        
  2145                        LAB_no_ELSE
  2146 00:DE12: 4C E0 DB           JMP LAB_15C2            ; return to the interpreter inner loop
  2147                        ; *** end patch  allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
  2148                        
  2149                        ; perform ELSE after IF
  2150                        
  2151                        LAB_174E
  2152 00:DE15: A0 00              LDY   #$00              ; clear the BASIC byte index
  2153 00:DE17: A2 01              LDX   #$01              ; clear the nesting depth
  2154                        LAB_1750
  2155 00:DE19: C8                 INY                     ; increment the BASIC byte index
  2156 00:DE1A: B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
  2157 00:DE1C: F0 0F              BEQ   LAB_1753          ; if EOL go add the pointer and return
  2158                        
  2159 00:DE1E: C9 8B              CMP   #TK_IF            ; compare the byte with the token for IF
  2160 00:DE20: D0 03              BNE   LAB_1752          ; if not IF token skip the depth increment
  2161                        
  2162 00:DE22: E8                 INX                     ; else increment the nesting depth ..
  2163 00:DE23: D0 F4              BNE   LAB_1750          ; .. and continue looking
  2164                        
  2165                        LAB_1752
  2166 00:DE25: C9 AC              CMP   #TK_ELSE          ; compare the byte with the token for ELSE
  2167 00:DE27: D0 F0              BNE   LAB_1750          ; if not ELSE token continue looking
  2168                        
  2169 00:DE29: CA                 DEX                     ; was ELSE so decrement the nesting depth
  2170 00:DE2A: D0 ED              BNE   LAB_1750          ; loop if still nested
  2171                        
  2172 00:DE2C: C8                 INY                     ; increment the BASIC byte index past the ELSE
  2173                        
  2174                        ; found the matching ELSE, now do <{n|statement}>
  2175                        
  2176                        LAB_1753
  2177 00:DE2D: 98                 TYA                     ; else copy line index to A
  2178 00:DE2E: 18                 CLC                     ; clear carry for add
  2179 00:DE2F: 65 C3              ADC   Bpntrl            ; add the BASIC execute pointer low byte
  2180 00:DE31: 85 C3              STA   Bpntrl            ; save the BASIC execute pointer low byte
  2181 00:DE33: 90 02              BCC   LAB_1754          ; branch if no overflow to high byte
  2182                        
  2183 00:DE35: E6 C4              INC   Bpntrh            ; else increment the BASIC execute pointer high byte
  2184                        LAB_1754
  2185 00:DE37: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  2186 00:DE3A: 90 C0              BCC   LAB_174C          ; if numeric do GOTO n
  2187                                                      ; the code will return to the interpreter loop at the
  2188                                                      ; tail end of the GOTO <n>
  2189                        
  2190 00:DE3C: 4C 1E DC           JMP   LAB_15FF          ; interpret BASIC code from (Bpntrl)
  2191                                                      ; the code will return to the interpreter loop at the
  2192                                                      ; tail end of the <statement>
  2193                        
  2194                        ; perform REM, skip (rest of) line
  2195                        
  2196                        LAB_REM
  2197 00:DE3F: 20 BE DD           JSR   LAB_SNBL          ; scan for next BASIC line
  2198 00:DE42: 4C AD DD           JMP   LAB_170F          ; go set BASIC execute pointer and return, branch always
  2199                        
  2200                        LAB_16FD
  2201 00:DE45: 4C 22 E3           JMP   LAB_SNER          ; do syntax error then warm start
  2202                        
  2203                        ; perform ON
  2204                        
  2205                        LAB_ON
  2206 00:DE48: C9 A9              CMP   #TK_IRQ           ; was it IRQ token ?
  2207 00:DE4A: D0 03              BNE   LAB_NOIN          ; if not go check NMI
  2208                        
  2209 00:DE4C: 4C 67 F6           JMP   LAB_SIRQ          ; else go set-up IRQ
  2210                        
  2211                        LAB_NOIN
  2212 00:DE4F: C9 AA              CMP   #TK_NMI           ; was it NMI token ?
  2213 00:DE51: D0 03              BNE   LAB_NONM          ; if not go do normal ON command
  2214                        
  2215 00:DE53: 4C 6A F6           JMP   LAB_SNMI          ; else go set-up NMI
  2216                        
  2217                        LAB_NONM
  2218 00:DE56: 20 C0 EB           JSR   LAB_GTBY          ; get byte parameter
  2219 00:DE59: 48                 PHA                     ; push GOTO/GOSUB token
  2220 00:DE5A: C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
  2221 00:DE5C: F0 04              BEQ   LAB_176B          ; branch if GOSUB
  2222                        
  2223 00:DE5E: C9 89              CMP   #TK_GOTO          ; compare with GOTO token
  2224                        LAB_1767
  2225 00:DE60: D0 E3              BNE   LAB_16FD          ; if not GOTO do syntax error then warm start
  2226                        
  2227                        
  2228                        ; next character was GOTO or GOSUB
  2229                        
  2230                        LAB_176B
  2231 00:DE62: C6 AF              DEC   FAC1_3            ; decrement index (byte value)
  2232 00:DE64: D0 04              BNE   LAB_1773          ; branch if not zero
  2233                        
  2234 00:DE66: 68                 PLA                     ; pull GOTO/GOSUB token
  2235 00:DE67: 4C 20 DC           JMP   LAB_1602          ; go execute it
  2236                        
  2237                        LAB_1773
  2238 00:DE6A: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  2239 00:DE6D: 20 76 DE           JSR   LAB_GFPN          ; get fixed-point number into temp integer (skip this n)
  2240                                                      ; (we could LDX #',' and JSR LAB_SNBL+2, then we
  2241                                                      ; just BNE LAB_176B for the loop. should be quicker ..
  2242                                                      ; no we can't, what if we meet a colon or [EOL]?)
  2243 00:DE70: C9 2C              CMP   #$2C              ; compare next character with ","
  2244 00:DE72: F0 EE              BEQ   LAB_176B          ; loop if ","
  2245                        
  2246                        LAB_177E
  2247 00:DE74: 68                 PLA                     ; else pull keyword token (run out of options)
  2248                                                      ; also dump +/-1 pointer low byte and exit
  2249                        LAB_177F
  2250 00:DE75: 60                 RTS
  2251                        
  2252                        ; takes n * 106 + 11 cycles where n is the number of digits
  2253                        
  2254                        ; get fixed-point number into temp integer
  2255                        
  2256                        LAB_GFPN
  2257 00:DE76: A2 00              LDX   #$00              ; clear reg
  2258 00:DE78: 86 11              STX   Itempl            ; clear temporary integer low byte
  2259                        LAB_1785
  2260 00:DE7A: 86 12              STX   Itemph            ; save temporary integer high byte
  2261 00:DE7C: B0 F7              BCS   LAB_177F          ; return if carry set, end of scan, character was
  2262                                                      ; not 0-9
  2263                        
  2264 00:DE7E: E0 19              CPX   #$19              ; compare high byte with $19
  2265 00:DE80: A8                 TAY                     ; ensure Zb = 0 if the branch is taken
  2266 00:DE81: B0 DD              BCS   LAB_1767          ; branch if >=, makes max line # 63999 because next
  2267                                                      ; bit does *$0A, = 64000, compare at target will fail
  2268                                                      ; and do syntax error
  2269                        
  2270 00:DE83: E9 2F              SBC   #'0'-1            ; subtract "0", $2F + carry, from byte
  2271 00:DE85: A8                 TAY                     ; copy binary digit
  2272 00:DE86: A5 11              LDA   Itempl            ; get temporary integer low byte
  2273 00:DE88: 0A                 ASL                     ; *2 low byte
  2274 00:DE89: 26 12              ROL   Itemph            ; *2 high byte
  2275 00:DE8B: 0A                 ASL                     ; *2 low byte
  2276 00:DE8C: 26 12              ROL   Itemph            ; *2 high byte, *4
  2277 00:DE8E: 65 11              ADC   Itempl            ; + low byte, *5
  2278 00:DE90: 85 11              STA   Itempl            ; save it
  2279 00:DE92: 8A                 TXA                     ; get high byte copy to A
  2280 00:DE93: 65 12              ADC   Itemph            ; + high byte, *5
  2281 00:DE95: 06 11              ASL   Itempl            ; *2 low byte, *10d
  2282 00:DE97: 2A                 ROL                     ; *2 high byte, *10d
  2283 00:DE98: AA                 TAX                     ; copy high byte back to X
  2284 00:DE99: 98                 TYA                     ; get binary digit back
  2285 00:DE9A: 65 11              ADC   Itempl            ; add number low byte
  2286 00:DE9C: 85 11              STA   Itempl            ; save number low byte
  2287 00:DE9E: 90 01              BCC   LAB_17B3          ; if no overflow to high byte get next character
  2288                        
  2289 00:DEA0: E8                 INX                     ; else increment high byte
  2290                        LAB_17B3
  2291 00:DEA1: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  2292 00:DEA4: 4C 7A DE           JMP   LAB_1785          ; loop for next character
  2293                        
  2294                        ; perform DEC
  2295                        
  2296                        LAB_DEC
  2297 00:DEA7: A9 14              LDA   #<LAB_2AFD        ; set -1 pointer low byte
  2298 00:DEA9: 2C                 .byte $2C               ; BIT abs to skip the LDA below
  2299                        
  2300                        ; perform INC
  2301                        
  2302                        LAB_INC
  2303 00:DEAA: A9 10              LDA   #<LAB_259C        ; set 1 pointer low byte
  2304                        LAB_17B5
  2305 00:DEAC: 48                 PHA                     ; save +/-1 pointer low byte
  2306                        LAB_17B7
  2307 00:DEAD: 20 D8 E4           JSR   LAB_GVAR          ; get var address
  2308 00:DEB0: A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
  2309 00:DEB2: 30 1E              BMI   IncrErr           ; exit if string
  2310                        
  2311 00:DEB4: 85 97              STA   Lvarpl            ; save var address low byte
  2312 00:DEB6: 84 98              STY   Lvarph            ; save var address high byte
  2313 00:DEB8: 20 AA EF           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  2314 00:DEBB: 68                 PLA                     ; get +/-1 pointer low byte
  2315 00:DEBC: 48                 PHA                     ; save +/-1 pointer low byte
  2316 00:DEBD: A0 F9              LDY   #>LAB_259C        ; set +/-1 pointer high byte (both the same)
  2317 00:DEBF: 20 EB EC           JSR   LAB_246C          ; add (AY) to FAC1
  2318 00:DEC2: 20 D0 EF           JSR   LAB_PFAC          ; pack FAC1 into variable (Lvarpl)
  2319                        
  2320 00:DEC5: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  2321 00:DEC8: C9 2C              CMP   #','              ; compare with ","
  2322 00:DECA: D0 A8              BNE   LAB_177E          ; exit if not "," (either end or error)
  2323                        
  2324                                                      ; was "," so another INCR variable to do
  2325 00:DECC: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  2326 00:DECF: 4C AD DE           JMP   LAB_17B7          ; go do next var
  2327                        
  2328                        IncrErr
  2329 00:DED2: 4C FC E1           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
  2330                        
  2331                        ; perform LET
  2332                        
  2333                        LAB_LET
  2334 00:DED5: 20 D8 E4           JSR   LAB_GVAR          ; get var address
  2335 00:DED8: 85 97              STA   Lvarpl            ; save var address low byte
  2336 00:DEDA: 84 98              STY   Lvarph            ; save var address high byte
  2337 00:DEDC: A9 C1              LDA   #TK_EQUAL         ; get = token
  2338 00:DEDE: 20 11 E3           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  2339 00:DEE1: A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
  2340 00:DEE3: 48                 PHA                     ; push data type flag
  2341 00:DEE4: 20 01 E2           JSR   LAB_EVEX          ; evaluate expression
  2342 00:DEE7: 68                 PLA                     ; pop data type flag
  2343 00:DEE8: 2A                 ROL                     ; set carry if type = string
  2344                        ; *** begin patch  result of a string compare stores string pointer to variable
  2345                        ;                  but should store FAC1 (true/false value)
  2346                        ; *** replace
  2347                        ;      JSR   LAB_CKTM          ; type match check, set C for string
  2348                        ;      BNE   LAB_17D5          ; branch if string
  2349                        ; *** with
  2350 00:DEE9: 20 F3 E1           JSR   LAB_CKTM          ; type match check, keep C (expected type)
  2351 00:DEEC: B0 03              BCS   LAB_17D5          ; branch if string
  2352                        ; *** end patch
  2353                        
  2354 00:DEEE: 4C D0 EF           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
  2355                        
  2356                        ; string LET
  2357                        
  2358                        LAB_17D5
  2359 00:DEF1: A0 02              LDY   #$02              ; set index to pointer high byte
  2360 00:DEF3: B1 AE              LDA   (des_pl),Y        ; get string pointer high byte
  2361 00:DEF5: C5 82              CMP   Sstorh            ; compare bottom of string space high byte
  2362 00:DEF7: 90 17              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
  2363                        
  2364 00:DEF9: D0 07              BNE   LAB_17E6          ; branch if >
  2365                                                      ; else was equal so compare low bytes
  2366 00:DEFB: 88                 DEY                     ; decrement index
  2367 00:DEFC: B1 AE              LDA   (des_pl),Y        ; get pointer low byte
  2368 00:DEFE: C5 81              CMP   Sstorl            ; compare bottom of string space low byte
  2369 00:DF00: 90 0E              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
  2370                        
  2371                                                      ; pointer was >= to bottom of string space pointer
  2372                        LAB_17E6
  2373 00:DF02: A4 AF              LDY   des_ph            ; get descriptor pointer high byte
  2374 00:DF04: C4 7C              CPY   Svarh             ; compare start of vars high byte
  2375 00:DF06: 90 08              BCC   LAB_17F4          ; branch if less (descriptor is on stack)
  2376                        
  2377 00:DF08: D0 0D              BNE   LAB_17FB          ; branch if greater (descriptor is not on stack)
  2378                        
  2379                                                      ; else high bytes were equal so ..
  2380 00:DF0A: A5 AE              LDA   des_pl            ; get descriptor pointer low byte
  2381 00:DF0C: C5 7B              CMP   Svarl             ; compare start of vars low byte
  2382 00:DF0E: B0 07              BCS   LAB_17FB          ; branch if >= (descriptor is not on stack)
  2383                        
  2384                        LAB_17F4
  2385 00:DF10: A5 AE              LDA   des_pl            ; get descriptor pointer low byte
  2386 00:DF12: A4 AF              LDY   des_ph            ; get descriptor pointer high byte
  2387 00:DF14: 4C 2D DF           JMP   LAB_1811          ; clean stack, copy descriptor to variable and return
  2388                        
  2389                                                      ; make space and copy string
  2390                        LAB_17FB
  2391 00:DF17: A0 00              LDY   #$00              ; index to length
  2392 00:DF19: B1 AE              LDA   (des_pl),Y        ; get string length
  2393 00:DF1B: 20 60 E8           JSR   LAB_209C          ; copy string
  2394 00:DF1E: A5 9E              LDA   des_2l            ; get descriptor pointer low byte
  2395 00:DF20: A4 9F              LDY   des_2h            ; get descriptor pointer high byte
  2396 00:DF22: 85 B8              STA   ssptr_l           ; save descriptor pointer low byte
  2397 00:DF24: 84 B9              STY   ssptr_h           ; save descriptor pointer high byte
  2398 00:DF26: 20 45 EA           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
  2399 00:DF29: A9 AC              LDA   #<FAC1_e          ; set descriptor pointer low byte
  2400 00:DF2B: A0 00              LDY   #>FAC1_e          ; get descriptor pointer high byte
  2401                        
  2402                                                      ; clean stack and assign value to string variable
  2403                        LAB_1811
  2404 00:DF2D: 85 9E              STA   des_2l            ; save descriptor_2 pointer low byte
  2405 00:DF2F: 84 9F              STY   des_2h            ; save descriptor_2 pointer high byte
  2406 00:DF31: 20 A7 EA           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
  2407 00:DF34: A0 00              LDY   #$00              ; index to length
  2408 00:DF36: B1 9E              LDA   (des_2l),Y        ; get string length
  2409 00:DF38: 91 97              STA   (Lvarpl),Y        ; copy to let string variable
  2410 00:DF3A: C8                 INY                     ; index to string pointer low byte
  2411 00:DF3B: B1 9E              LDA   (des_2l),Y        ; get string pointer low byte
  2412 00:DF3D: 91 97              STA   (Lvarpl),Y        ; copy to let string variable
  2413 00:DF3F: C8                 INY                     ; index to string pointer high byte
  2414 00:DF40: B1 9E              LDA   (des_2l),Y        ; get string pointer high byte
  2415 00:DF42: 91 97              STA   (Lvarpl),Y        ; copy to let string variable
  2416 00:DF44: 60                 RTS
  2417                        
  2418                        ; perform GET
  2419                        
  2420                        LAB_GET
  2421 00:DF45: 20 D8 E4           JSR   LAB_GVAR          ; get var address
  2422 00:DF48: 85 97              STA   Lvarpl            ; save var address low byte
  2423 00:DF4A: 84 98              STY   Lvarph            ; save var address high byte
  2424 00:DF4C: 20 2F F6           JSR   INGET             ; get input byte
  2425 00:DF4F: A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
  2426 00:DF51: 30 07              BMI   LAB_GETS          ; go get string character
  2427                        
  2428                                                      ; was numeric get
  2429 00:DF53: A8                 TAY                     ; copy character to Y
  2430 00:DF54: 20 94 E7           JSR   LAB_1FD0          ; convert Y to byte in FAC1
  2431 00:DF57: 4C D0 EF           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
  2432                        
  2433                        LAB_GETS
  2434 00:DF5A: 48                 PHA                     ; save character
  2435 00:DF5B: A9 01              LDA   #$01              ; string is single byte
  2436 00:DF5D: B0 01              BCS   LAB_IsByte        ; branch if byte received
  2437                        
  2438 00:DF5F: 68                 PLA                     ; string is null
  2439                        LAB_IsByte
  2440 00:DF60: 20 68 E8           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
  2441                                                      ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  2442 00:DF63: F0 05              BEQ   LAB_NoSt          ; skip store if null string
  2443                        
  2444 00:DF65: 68                 PLA                     ; get character back
  2445 00:DF66: A0 00              LDY   #$00              ; clear index
  2446 00:DF68: 91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
  2447                        LAB_NoSt
  2448 00:DF6A: 20 B5 E8           JSR   LAB_RTST          ; check for space on descriptor stack then put address
  2449                                                      ; and length on descriptor stack and update stack pointers
  2450                        
  2451 00:DF6D: 4C F1 DE           JMP   LAB_17D5          ; do string LET and return
  2452                        
  2453                        ; perform PRINT
  2454                        
  2455                        LAB_1829
  2456 00:DF70: 20 F7 DF           JSR   LAB_18C6          ; print string from Sutill/Sutilh
  2457                        LAB_182C
  2458 00:DF73: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  2459                        
  2460                        ; PRINT
  2461                        
  2462                        LAB_PRINT
  2463 00:DF76: F0 3B              BEQ   LAB_CRLF          ; if nothing following just print CR/LF
  2464                        
  2465                        LAB_1831
  2466 00:DF78: C9 AB              CMP   #TK_TAB           ; compare with TAB( token
  2467 00:DF7A: F0 56              BEQ   LAB_18A2          ; go do TAB/SPC
  2468                        
  2469 00:DF7C: C9 AF              CMP   #TK_SPC           ; compare with SPC( token
  2470 00:DF7E: F0 52              BEQ   LAB_18A2          ; go do TAB/SPC
  2471                        
  2472 00:DF80: C9 2C              CMP   #','              ; compare with ","
  2473 00:DF82: F0 38              BEQ   LAB_188B          ; go do move to next TAB mark
  2474                        
  2475 00:DF84: C9 3B              CMP   #';'              ; compare with ";"
  2476 00:DF86: F0 66              BEQ   LAB_18BD          ; if ";" continue with PRINT processing
  2477                        
  2478 00:DF88: 20 01 E2           JSR   LAB_EVEX          ; evaluate expression
  2479 00:DF8B: 24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
  2480 00:DF8D: 30 E1              BMI   LAB_1829          ; branch if string
  2481                        
  2482 00:DF8F: 20 C2 F1           JSR   LAB_296E          ; convert FAC1 to string
  2483 00:DF92: 20 72 E8           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
  2484 00:DF95: A0 00              LDY   #$00              ; clear index
  2485                        
  2486                        ; don't check fit if terminal width byte is zero
  2487                        
  2488 00:DF97: A5 0F              LDA   TWidth            ; get terminal width byte
  2489 00:DF99: F0 0A              BEQ   LAB_185E          ; skip check if zero
  2490                        
  2491 00:DF9B: 38                 SEC                     ; set carry for subtract
  2492 00:DF9C: E5 0E              SBC   TPos              ; subtract terminal position
  2493 00:DF9E: F1 AE              SBC   (des_pl),Y        ; subtract string length
  2494 00:DFA0: B0 03              BCS   LAB_185E          ; branch if less than terminal width
  2495                        
  2496 00:DFA2: 20 B3 DF           JSR   LAB_CRLF          ; else print CR/LF
  2497                        LAB_185E
  2498 00:DFA5: 20 F7 DF           JSR   LAB_18C6          ; print string from Sutill/Sutilh
  2499 00:DFA8: F0 C9              BEQ   LAB_182C          ; always go continue processing line
  2500                        
  2501                        ; CR/LF return to BASIC from BASIC input handler
  2502                        
  2503                        LAB_1866
  2504 00:DFAA: A9 00              LDA   #$00              ; clear byte
  2505 00:DFAC: 9D 21 02           STA   Ibuffs,X          ; null terminate input
  2506 00:DFAF: A2 21              LDX   #<Ibuffs          ; set X to buffer start-1 low byte
  2507 00:DFB1: A0 02              LDY   #>Ibuffs          ; set Y to buffer start-1 high byte
  2508                        
  2509                        ; print CR/LF
  2510                        
  2511                        LAB_CRLF
  2512 00:DFB3: A9 0D              LDA   #$0D              ; load [CR]
  2513 00:DFB5: 20 0E E0           JSR   LAB_PRNA          ; go print the character
  2514 00:DFB8: A9 0A              LDA   #$0A              ; load [LF]
  2515 00:DFBA: D0 52              BNE   LAB_PRNA          ; go print the character and return, branch always
  2516                        
  2517                        LAB_188B
  2518 00:DFBC: A5 0E              LDA   TPos              ; get terminal position
  2519 00:DFBE: C5 10              CMP   Iclim             ; compare with input column limit
  2520 00:DFC0: 90 05              BCC   LAB_1897          ; branch if less
  2521                        
  2522 00:DFC2: 20 B3 DF           JSR   LAB_CRLF          ; else print CR/LF (next line)
  2523 00:DFC5: D0 27              BNE   LAB_18BD          ; continue with PRINT processing (branch always)
  2524                        
  2525                        LAB_1897
  2526 00:DFC7: 38                 SEC                     ; set carry for subtract
  2527                        LAB_1898
  2528 00:DFC8: E5 64              SBC   TabSiz            ; subtract TAB size
  2529 00:DFCA: B0 FC              BCS   LAB_1898          ; loop if result was +ve
  2530                        
  2531 00:DFCC: 49 FF              EOR   #$FF              ; complement it
  2532 00:DFCE: 69 01              ADC   #$01              ; +1 (twos complement)
  2533 00:DFD0: D0 12              BNE   LAB_18B6          ; always print A spaces (result is never $00)
  2534                        
  2535                                                      ; do TAB/SPC
  2536                        LAB_18A2
  2537 00:DFD2: 48                 PHA                     ; save token
  2538 00:DFD3: 20 BD EB           JSR   LAB_SGBY          ; scan and get byte parameter
  2539 00:DFD6: C9 29              CMP   #$29              ; is next character )
  2540 00:DFD8: D0 7B              BNE   LAB_1910          ; if not do syntax error then warm start
  2541                        
  2542 00:DFDA: 68                 PLA                     ; get token back
  2543 00:DFDB: C9 AB              CMP   #TK_TAB           ; was it TAB ?
  2544 00:DFDD: D0 06              BNE   LAB_18B7          ; if not go do SPC
  2545                        
  2546                                                      ; calculate TAB offset
  2547 00:DFDF: 8A                 TXA                     ; copy integer value to A
  2548 00:DFE0: E5 0E              SBC   TPos              ; subtract terminal position
  2549 00:DFE2: 90 0A              BCC   LAB_18BD          ; branch if result was < 0 (can't TAB backwards)
  2550                        
  2551                                                      ; print A spaces
  2552                        LAB_18B6
  2553 00:DFE4: AA                 TAX                     ; copy result to X
  2554                        LAB_18B7
  2555 00:DFE5: 8A                 TXA                     ; set flags on size for SPC
  2556 00:DFE6: F0 06              BEQ   LAB_18BD          ; branch if result was = $0, already here
  2557                        
  2558                                                      ; print X spaces
  2559                        LAB_18BA
  2560 00:DFE8: 20 09 E0           JSR   LAB_18E0          ; print " "
  2561 00:DFEB: CA                 DEX                     ; decrement count
  2562 00:DFEC: D0 FA              BNE   LAB_18BA          ; loop if not all done
  2563                        
  2564                                                      ; continue with PRINT processing
  2565                        LAB_18BD
  2566 00:DFEE: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  2567 00:DFF1: D0 85              BNE   LAB_1831          ; if more to print go do it
  2568                        
  2569 00:DFF3: 60                 RTS
  2570                        
  2571                        ; print null terminated string from memory
  2572                        
  2573                        LAB_18C3
  2574 00:DFF4: 20 72 E8           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
  2575                        
  2576                        ; print string from Sutill/Sutilh
  2577                        
  2578                        LAB_18C6
  2579 00:DFF7: 20 72 EA           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
  2580                                                      ; space returns with A = length, X=$71=pointer low byte,
  2581                                                      ; Y=$72=pointer high byte
  2582 00:DFFA: A0 00              LDY   #$00              ; reset index
  2583 00:DFFC: AA                 TAX                     ; copy length to X
  2584 00:DFFD: F0 49              BEQ   LAB_188C          ; exit (RTS) if null string
  2585                        
  2586                        LAB_18CD
  2587                        
  2588 00:DFFF: B1 71              LDA   (ut1_pl),Y        ; get next byte
  2589 00:E001: 20 0E E0           JSR   LAB_PRNA          ; go print the character
  2590 00:E004: C8                 INY                     ; increment index
  2591 00:E005: CA                 DEX                     ; decrement count
  2592 00:E006: D0 F7              BNE   LAB_18CD          ; loop if not done yet
  2593                        
  2594 00:E008: 60                 RTS
  2595                        
  2596                                                      ; Print single format character
  2597                        ; print " "
  2598                        
  2599                        LAB_18E0
  2600 00:E009: A9 20              LDA   #$20              ; load " "
  2601 00:E00B: 2C                 .byte $2C               ; change next line to BIT LAB_3FA9
  2602                        
  2603                        ; print "?" character
  2604                        
  2605                        LAB_18E3
  2606 00:E00C: A9 3F              LDA   #$3F              ; load "?" character
  2607                        
  2608                        ; print character in A
  2609                        ; now includes the null handler
  2610                        ; also includes infinite line length code
  2611                        ; note! some routines expect this one to exit with Zb=0
  2612                        
  2613                        LAB_PRNA
  2614 00:E00E: C9 20              CMP   #' '              ; compare with " "
  2615 00:E010: 90 19              BCC   LAB_18F9          ; branch if less (non printing)
  2616                        
  2617                                                      ; else printable character
  2618 00:E012: 48                 PHA                     ; save the character
  2619                        
  2620                        ; don't check fit if terminal width byte is zero
  2621                        
  2622 00:E013: A5 0F              LDA   TWidth            ; get terminal width
  2623 00:E015: D0 0A              BNE   LAB_18F0          ; branch if not zero (not infinite length)
  2624                        
  2625                        ; is "infinite line" so check TAB position
  2626                        
  2627 00:E017: A5 0E              LDA   TPos              ; get position
  2628 00:E019: E5 64              SBC   TabSiz            ; subtract TAB size, carry set by CMP #$20 above
  2629 00:E01B: D0 0B              BNE   LAB_18F7          ; skip reset if different
  2630                        
  2631 00:E01D: 85 0E              STA   TPos              ; else reset position
  2632 00:E01F: F0 07              BEQ   LAB_18F7          ; go print character
  2633                        
  2634                        LAB_18F0
  2635 00:E021: C5 0E              CMP   TPos              ; compare with terminal character position
  2636 00:E023: D0 03              BNE   LAB_18F7          ; branch if not at end of line
  2637                        
  2638 00:E025: 20 B3 DF           JSR   LAB_CRLF          ; else print CR/LF
  2639                        LAB_18F7
  2640 00:E028: E6 0E              INC   TPos              ; increment terminal position
  2641 00:E02A: 68                 PLA                     ; get character back
  2642                        LAB_18F9
  2643 00:E02B: 20 1B F8           JSR   V_OUTP            ; output byte via output vector
  2644 00:E02E: C9 0D              CMP   #$0D              ; compare with [CR]
  2645 00:E030: D0 14              BNE   LAB_188A          ; branch if not [CR]
  2646                        
  2647                                                      ; else print nullct nulls after the [CR]
  2648 00:E032: 86 78              STX   TempB             ; save buffer index
  2649 00:E034: A6 0D              LDX   Nullct            ; get null count
  2650 00:E036: F0 0A              BEQ   LAB_1886          ; branch if no nulls
  2651                        
  2652 00:E038: A9 00              LDA   #$00              ; load [NULL]
  2653                        LAB_1880
  2654 00:E03A: 20 0E E0           JSR   LAB_PRNA          ; go print the character
  2655 00:E03D: CA                 DEX                     ; decrement count
  2656 00:E03E: D0 FA              BNE   LAB_1880          ; loop if not all done
  2657                        
  2658 00:E040: A9 0D              LDA   #$0D              ; restore the character (and set the flags)
  2659                        LAB_1886
  2660 00:E042: 86 0E              STX   TPos              ; clear terminal position (X always = zero when we get here)
  2661 00:E044: A6 78              LDX   TempB             ; restore buffer index
  2662                        LAB_188A
  2663 00:E046: 29 FF              AND   #$FF              ; set the flags
  2664                        LAB_188C
  2665 00:E048: 60                 RTS
  2666                        
  2667                        ; handle bad input data
  2668                        
  2669                        LAB_1904
  2670 00:E049: A5 62              LDA   Imode             ; get input mode flag, $00=INPUT, $00=READ
  2671 00:E04B: 10 0B              BPL   LAB_1913          ; branch if INPUT (go do redo)
  2672                        
  2673 00:E04D: A5 8D              LDA   Dlinel            ; get current DATA line low byte
  2674 00:E04F: A4 8E              LDY   Dlineh            ; get current DATA line high byte
  2675 00:E051: 85 87              STA   Clinel            ; save current line low byte
  2676 00:E053: 84 88              STY   Clineh            ; save current line high byte
  2677                        LAB_1910
  2678 00:E055: 4C 22 E3           JMP   LAB_SNER          ; do syntax error then warm start
  2679                        
  2680                                                      ; mode was INPUT
  2681                        LAB_1913
  2682 00:E058: A9 42              LDA   #<LAB_REDO        ; point to redo message (low addr)
  2683 00:E05A: A0 FF              LDY   #>LAB_REDO        ; point to redo message (high addr)
  2684 00:E05C: 20 F4 DF           JSR   LAB_18C3          ; print null terminated string from memory
  2685 00:E05F: A5 8B              LDA   Cpntrl            ; get continue pointer low byte
  2686 00:E061: A4 8C              LDY   Cpntrh            ; get continue pointer high byte
  2687 00:E063: 85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
  2688 00:E065: 84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
  2689 00:E067: 60                 RTS
  2690                        
  2691                        ; perform INPUT
  2692                        
  2693                        LAB_INPUT
  2694 00:E068: C9 22              CMP   #$22              ; compare next byte with open quote
  2695 00:E06A: D0 0B              BNE   LAB_1934          ; branch if no prompt string
  2696                        
  2697 00:E06C: 20 DE E2           JSR   LAB_1BC1          ; print "..." string
  2698 00:E06F: A9 3B              LDA   #$3B              ; load A with ";"
  2699 00:E071: 20 11 E3           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  2700 00:E074: 20 F7 DF           JSR   LAB_18C6          ; print string from Sutill/Sutilh
  2701                        
  2702                                                      ; done with prompt, now get data
  2703                        LAB_1934
  2704 00:E077: 20 98 E7           JSR   LAB_CKRN          ; check not Direct, back here if ok
  2705 00:E07A: 20 63 D9           JSR   LAB_INLN          ; print "? " and get BASIC input
  2706 00:E07D: A9 00              LDA   #$00              ; set mode = INPUT
  2707 00:E07F: CD 21 02           CMP   Ibuffs            ; test first byte in buffer
  2708 00:E082: D0 09              BNE   LAB_1953          ; branch if not null input
  2709                        
  2710                        ; *** change p2: keep carry set to throw break message
  2711                        ;      CLC                     ; was null input so clear carry to exit program
  2712 00:E084: 4C 48 DC           JMP   LAB_1647          ; go do BREAK exit
  2713                        
  2714                        ; perform READ
  2715                        
  2716                        LAB_READ
  2717 00:E087: A6 8F              LDX   Dptrl             ; get DATA pointer low byte
  2718 00:E089: A4 90              LDY   Dptrh             ; get DATA pointer high byte
  2719 00:E08B: A9 80              LDA   #$80              ; set mode = READ
  2720                        
  2721                        LAB_1953
  2722 00:E08D: 85 62              STA   Imode             ; set input mode flag, $00=INPUT, $80=READ
  2723 00:E08F: 86 91              STX   Rdptrl            ; save READ pointer low byte
  2724 00:E091: 84 92              STY   Rdptrh            ; save READ pointer high byte
  2725                        
  2726                                                      ; READ or INPUT next variable from list
  2727                        LAB_195B
  2728 00:E093: 20 D8 E4           JSR   LAB_GVAR          ; get (var) address
  2729 00:E096: 85 97              STA   Lvarpl            ; save address low byte
  2730 00:E098: 84 98              STY   Lvarph            ; save address high byte
  2731 00:E09A: A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
  2732 00:E09C: A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
  2733 00:E09E: 85 11              STA   Itempl            ; save as temporary integer low byte
  2734 00:E0A0: 84 12              STY   Itemph            ; save as temporary integer high byte
  2735 00:E0A2: A6 91              LDX   Rdptrl            ; get READ pointer low byte
  2736 00:E0A4: A4 92              LDY   Rdptrh            ; get READ pointer high byte
  2737 00:E0A6: 86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
  2738 00:E0A8: 84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
  2739 00:E0AA: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  2740 00:E0AD: D0 11              BNE   LAB_1988          ; branch if not null
  2741                        
  2742                                                      ; pointer was to null entry
  2743 00:E0AF: 24 62              BIT   Imode             ; test input mode flag, $00=INPUT, $80=READ
  2744 00:E0B1: 30 65              BMI   LAB_19DD          ; branch if READ
  2745                        
  2746                                                      ; mode was INPUT
  2747 00:E0B3: 20 0C E0           JSR   LAB_18E3          ; print "?" character (double ? for extended input)
  2748 00:E0B6: 20 63 D9           JSR   LAB_INLN          ; print "? " and get BASIC input
  2749 00:E0B9: 86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
  2750 00:E0BB: 84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
  2751                        LAB_1985
  2752 00:E0BD: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  2753                        LAB_1988
  2754 00:E0C0: 24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
  2755 00:E0C2: 10 24              BPL   LAB_19B0          ; branch if numeric
  2756                        
  2757                                                      ; else get string
  2758 00:E0C4: 85 5B              STA   Srchc             ; save search character
  2759 00:E0C6: C9 22              CMP   #$22              ; was it " ?
  2760 00:E0C8: F0 07              BEQ   LAB_1999          ; branch if so
  2761                        
  2762 00:E0CA: A9 3A              LDA   #':'              ; else search character is ":"
  2763 00:E0CC: 85 5B              STA   Srchc             ; set new search character
  2764 00:E0CE: A9 2C              LDA   #','              ; other search character is ","
  2765 00:E0D0: 18                 CLC                     ; clear carry for add
  2766                        LAB_1999
  2767 00:E0D1: 85 5C              STA   Asrch             ; set second search character
  2768 00:E0D3: A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
  2769 00:E0D5: A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
  2770                        
  2771 00:E0D7: 69 00              ADC   #$00              ; c is =1 if we came via the BEQ LAB_1999, else =0
  2772 00:E0D9: 90 01              BCC   LAB_19A4          ; branch if no execute pointer low byte rollover
  2773                        
  2774 00:E0DB: C8                 INY                     ; else increment high byte
  2775                        LAB_19A4
  2776 00:E0DC: 20 78 E8           JSR   LAB_20B4          ; print Srchc or Asrch terminated string to Sutill/Sutilh
  2777 00:E0DF: 20 FC EB           JSR   LAB_23F3          ; restore BASIC execute pointer from temp (Btmpl/Btmph)
  2778 00:E0E2: 20 F1 DE           JSR   LAB_17D5          ; go do string LET
  2779 00:E0E5: 4C EE E0           JMP   LAB_19B6          ; go check string terminator
  2780                        
  2781                                                      ; get numeric INPUT
  2782                        LAB_19B0
  2783 00:E0E8: 20 D3 F0           JSR   LAB_2887          ; get FAC1 from string
  2784 00:E0EB: 20 D0 EF           JSR   LAB_PFAC          ; pack FAC1 into (Lvarpl)
  2785                        LAB_19B6
  2786 00:E0EE: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  2787 00:E0F1: F0 0A              BEQ   LAB_19C5          ; branch if null (last entry)
  2788                        
  2789 00:E0F3: C9 2C              CMP   #','              ; else compare with ","
  2790 00:E0F5: F0 03              BEQ   LAB_19C2          ; branch if ","
  2791                        
  2792 00:E0F7: 4C 49 E0           JMP   LAB_1904          ; else go handle bad input data
  2793                        
  2794                                                      ; got good input data
  2795                        LAB_19C2
  2796 00:E0FA: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  2797                        LAB_19C5
  2798 00:E0FD: A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
  2799 00:E0FF: A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
  2800 00:E101: 85 91              STA   Rdptrl            ; save for now
  2801 00:E103: 84 92              STY   Rdptrh            ; save for now
  2802 00:E105: A5 11              LDA   Itempl            ; get temporary integer low byte (temp BASIC execute ptr)
  2803 00:E107: A4 12              LDY   Itemph            ; get temporary integer high byte (temp BASIC execute ptr)
  2804 00:E109: 85 C3              STA   Bpntrl            ; set BASIC execute pointer low byte
  2805 00:E10B: 84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
  2806 00:E10D: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  2807 00:E110: F0 2C              BEQ   LAB_1A03          ; if null go do extra ignored message
  2808                        
  2809 00:E112: 20 1E E3           JSR   LAB_1C01          ; else scan for "," , else do syntax error then warm start
  2810 00:E115: 4C 93 E0           JMP   LAB_195B          ; go INPUT next variable from list
  2811                        
  2812                                                      ; find next DATA statement or do "Out of DATA" error
  2813                        LAB_19DD
  2814 00:E118: 20 BB DD           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
  2815 00:E11B: C8                 INY                     ; increment index
  2816 00:E11C: AA                 TAX                     ; copy character ([:] or [EOL])
  2817 00:E11D: D0 12              BNE   LAB_19F6          ; branch if [:]
  2818                        
  2819 00:E11F: A2 06              LDX   #$06              ; set for "Out of DATA" error
  2820 00:E121: C8                 INY                     ; increment index, now points to next line pointer high byte
  2821 00:E122: B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
  2822 00:E124: F0 73              BEQ   LAB_1A54          ; branch if end (eventually does error X)
  2823                        
  2824 00:E126: C8                 INY                     ; increment index
  2825 00:E127: B1 C3              LDA   (Bpntrl),Y        ; get next line # low byte
  2826 00:E129: 85 8D              STA   Dlinel            ; save current DATA line low byte
  2827 00:E12B: C8                 INY                     ; increment index
  2828 00:E12C: B1 C3              LDA   (Bpntrl),Y        ; get next line # high byte
  2829 00:E12E: C8                 INY                     ; increment index
  2830 00:E12F: 85 8E              STA   Dlineh            ; save current DATA line high byte
  2831                        LAB_19F6
  2832 00:E131: B1 C3              LDA   (Bpntrl),Y        ; get byte
  2833 00:E133: C8                 INY                     ; increment index
  2834 00:E134: AA                 TAX                     ; copy to X
  2835 00:E135: 20 AD DD           JSR   LAB_170F          ; set BASIC execute pointer
  2836 00:E138: E0 83              CPX   #TK_DATA          ; compare with "DATA" token
  2837 00:E13A: F0 81              BEQ   LAB_1985          ; was "DATA" so go do next READ
  2838                        
  2839 00:E13C: D0 DA              BNE   LAB_19DD          ; go find next statement if not "DATA"
  2840                        
  2841                        ; end of INPUT/READ routine
  2842                        
  2843                        LAB_1A03
  2844 00:E13E: A5 91              LDA   Rdptrl            ; get temp READ pointer low byte
  2845 00:E140: A4 92              LDY   Rdptrh            ; get temp READ pointer high byte
  2846 00:E142: A6 62              LDX   Imode             ; get input mode flag, $00=INPUT, $80=READ
  2847 00:E144: 10 03              BPL   LAB_1A0E          ; branch if INPUT
  2848                        
  2849 00:E146: 4C 6A DC           JMP   LAB_1624          ; save AY as DATA pointer and return
  2850                        
  2851                                                      ; we were getting INPUT
  2852                        LAB_1A0E
  2853 00:E149: A0 00              LDY   #$00              ; clear index
  2854 00:E14B: B1 91              LDA   (Rdptrl),Y        ; get next byte
  2855 00:E14D: D0 01              BNE   LAB_1A1B          ; error if not end of INPUT
  2856                        
  2857 00:E14F: 60                 RTS
  2858                        
  2859                                                      ; user typed too much
  2860                        LAB_1A1B
  2861 00:E150: A9 31              LDA   #<LAB_IMSG        ; point to extra ignored message (low addr)
  2862 00:E152: A0 FF              LDY   #>LAB_IMSG        ; point to extra ignored message (high addr)
  2863 00:E154: 4C F4 DF           JMP   LAB_18C3          ; print null terminated string from memory and return
  2864                        
  2865                        ; search the stack for FOR activity
  2866                        ; exit with z=1 if FOR else exit with z=0
  2867                        
  2868                        LAB_11A1
  2869 00:E157: BA                 TSX                     ; copy stack pointer
  2870 00:E158: E8                 INX                     ; +1 pass return address
  2871 00:E159: E8                 INX                     ; +2 pass return address
  2872 00:E15A: E8                 INX                     ; +3 pass calling routine return address
  2873 00:E15B: E8                 INX                     ; +4 pass calling routine return address
  2874                        LAB_11A6
  2875 00:E15C: BD 01 01           LDA   LAB_STAK+1,X      ; get token byte from stack
  2876 00:E15F: C9 81              CMP   #TK_FOR           ; is it FOR token
  2877 00:E161: D0 21              BNE   LAB_11CE          ; exit if not FOR token
  2878                        
  2879                                                      ; was FOR token
  2880 00:E163: A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
  2881 00:E165: D0 0A              BNE   LAB_11BB          ; branch if not null
  2882                        
  2883 00:E167: BD 02 01           LDA   LAB_STAK+2,X      ; get FOR variable pointer low byte
  2884 00:E16A: 85 97              STA   Frnxtl            ; save var pointer for FOR/NEXT low byte
  2885 00:E16C: BD 03 01           LDA   LAB_STAK+3,X      ; get FOR variable pointer high byte
  2886 00:E16F: 85 98              STA   Frnxth            ; save var pointer for FOR/NEXT high byte
  2887                        LAB_11BB
  2888 00:E171: DD 03 01           CMP   LAB_STAK+3,X      ; compare var pointer with stacked var pointer (high byte)
  2889 00:E174: D0 07              BNE   LAB_11C7          ; branch if no match
  2890                        
  2891 00:E176: A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
  2892 00:E178: DD 02 01           CMP   LAB_STAK+2,X      ; compare var pointer with stacked var pointer (low byte)
  2893 00:E17B: F0 07              BEQ   LAB_11CE          ; exit if match found
  2894                        
  2895                        LAB_11C7
  2896 00:E17D: 8A                 TXA                     ; copy index
  2897 00:E17E: 18                 CLC                     ; clear carry for add
  2898 00:E17F: 69 10              ADC   #$10              ; add FOR stack use size
  2899 00:E181: AA                 TAX                     ; copy back to index
  2900 00:E182: D0 D8              BNE   LAB_11A6          ; loop if not at start of stack
  2901                        
  2902                        LAB_11CE
  2903 00:E184: 60                 RTS
  2904                        
  2905                        ; perform NEXT
  2906                        
  2907                        LAB_NEXT
  2908 00:E185: D0 04              BNE   LAB_1A46          ; branch if NEXT var
  2909                        
  2910 00:E187: A0 00              LDY   #$00              ; else clear Y
  2911 00:E189: F0 03              BEQ   LAB_1A49          ; branch always (no variable to search for)
  2912                        
  2913                        ; NEXT var
  2914                        
  2915                        LAB_1A46
  2916 00:E18B: 20 D8 E4           JSR   LAB_GVAR          ; get variable address
  2917                        LAB_1A49
  2918 00:E18E: 85 97              STA   Frnxtl            ; store variable pointer low byte
  2919 00:E190: 84 98              STY   Frnxth            ; store variable pointer high byte
  2920                                                      ; (both cleared if no variable defined)
  2921 00:E192: 20 57 E1           JSR   LAB_11A1          ; search the stack for FOR activity
  2922 00:E195: F0 04              BEQ   LAB_1A56          ; branch if found
  2923                        
  2924 00:E197: A2 00              LDX   #$00              ; else set error $00 ("NEXT without FOR" error)
  2925                        LAB_1A54
  2926 00:E199: F0 63              BEQ   LAB_1ABE          ; do error #X, then warm start
  2927                        
  2928                        LAB_1A56
  2929 00:E19B: 9A                 TXS                     ; set stack pointer, X set by search, dumps return addresses
  2930                        
  2931 00:E19C: 8A                 TXA                     ; copy stack pointer
  2932 00:E19D: 38                 SEC                     ; set carry for subtract
  2933 00:E19E: E9 F7              SBC   #$F7              ; point to TO var
  2934 00:E1A0: 85 73              STA   ut2_pl            ; save pointer to TO var for compare
  2935 00:E1A2: 69 FB              ADC   #$FB              ; point to STEP var
  2936                        
  2937 00:E1A4: A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
  2938 00:E1A6: 20 AA EF           JSR   LAB_UFAC          ; unpack memory (STEP value) into FAC1
  2939 00:E1A9: BA                 TSX                     ; get stack pointer back
  2940 00:E1AA: BD 08 01           LDA   LAB_STAK+8,X      ; get step sign
  2941 00:E1AD: 85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
  2942 00:E1AF: A5 97              LDA   Frnxtl            ; get FOR variable pointer low byte
  2943 00:E1B1: A4 98              LDY   Frnxth            ; get FOR variable pointer high byte
  2944 00:E1B3: 20 EB EC           JSR   LAB_246C          ; add (FOR variable) to FAC1
  2945 00:E1B6: 20 D0 EF           JSR   LAB_PFAC          ; pack FAC1 into (FOR variable)
  2946 00:E1B9: A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
  2947 00:E1BB: 20 46 F0           JSR   LAB_27FA          ; compare FAC1 with (Y,ut2_pl) (TO value)
  2948 00:E1BE: BA                 TSX                     ; get stack pointer back
  2949 00:E1BF: DD 08 01           CMP   LAB_STAK+8,X      ; compare step sign
  2950 00:E1C2: F0 17              BEQ   LAB_1A9B          ; branch if = (loop complete)
  2951                        
  2952                                                      ; loop back and do it all again
  2953 00:E1C4: BD 0D 01           LDA   LAB_STAK+$0D,X    ; get FOR line low byte
  2954 00:E1C7: 85 87              STA   Clinel            ; save current line low byte
  2955 00:E1C9: BD 0E 01           LDA   LAB_STAK+$0E,X    ; get FOR line high byte
  2956 00:E1CC: 85 88              STA   Clineh            ; save current line high byte
  2957 00:E1CE: BD 10 01           LDA   LAB_STAK+$10,X    ; get BASIC execute pointer low byte
  2958 00:E1D1: 85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
  2959 00:E1D3: BD 0F 01           LDA   LAB_STAK+$0F,X    ; get BASIC execute pointer high byte
  2960 00:E1D6: 85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
  2961                        LAB_1A98
  2962 00:E1D8: 4C E0 DB           JMP   LAB_15C2          ; go do interpreter inner loop
  2963                        
  2964                                                      ; loop complete so carry on
  2965                        LAB_1A9B
  2966 00:E1DB: 8A                 TXA                     ; stack copy to A
  2967 00:E1DC: 69 0F              ADC   #$0F              ; add $10 ($0F+carry) to dump FOR structure
  2968 00:E1DE: AA                 TAX                     ; copy back to index
  2969 00:E1DF: 9A                 TXS                     ; copy to stack pointer
  2970 00:E1E0: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  2971 00:E1E3: C9 2C              CMP   #','              ; compare with ","
  2972 00:E1E5: D0 F1              BNE   LAB_1A98          ; branch if not "," (go do interpreter inner loop)
  2973                        
  2974                                                      ; was "," so another NEXT variable to do
  2975 00:E1E7: 20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
  2976 00:E1EA: 20 8B E1           JSR   LAB_1A46          ; do NEXT (var)
  2977                        
  2978                        ; evaluate expression and check is numeric, else do type mismatch
  2979                        
  2980                        LAB_EVNM
  2981 00:E1ED: 20 01 E2           JSR   LAB_EVEX          ; evaluate expression
  2982                        
  2983                        ; check if source is numeric, else do type mismatch
  2984                        
  2985                        LAB_CTNM
  2986 00:E1F0: 18                 CLC                     ; destination is numeric
  2987 00:E1F1: 24                 .byte $24               ; makes next line BIT $38
  2988                        
  2989                        ; check if source is string, else do type mismatch
  2990                        
  2991                        LAB_CTST
  2992 00:E1F2: 38                 SEC                     ; required type is string
  2993                        
  2994                        ; type match check, set C for string, clear C for numeric
  2995                        
  2996                        LAB_CKTM
  2997 00:E1F3: 24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
  2998 00:E1F5: 30 03              BMI   LAB_1ABA          ; branch if data type is string
  2999                        
  3000                                                      ; else data type was numeric
  3001 00:E1F7: B0 03              BCS   LAB_1ABC          ; if required type is string do type mismatch error
  3002                        LAB_1AB9
  3003 00:E1F9: 60                 RTS
  3004                        
  3005                                                      ; data type was string, now check required type
  3006                        LAB_1ABA
  3007 00:E1FA: B0 FD              BCS   LAB_1AB9          ; exit if required type is string
  3008                        
  3009                                                      ; else do type mismatch error
  3010                        LAB_1ABC
  3011 00:E1FC: A2 18              LDX   #$18              ; error code $18 ("Type mismatch" error)
  3012                        LAB_1ABE
  3013 00:E1FE: 4C 5F D8           JMP   LAB_XERR          ; do error #X, then warm start
  3014                        
  3015                        ; evaluate expression
  3016                        
  3017                        LAB_EVEX
  3018 00:E201: A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
  3019 00:E203: D0 02              BNE   LAB_1AC7          ; skip next if not zero
  3020                        
  3021 00:E205: C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
  3022                        LAB_1AC7
  3023 00:E207: C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
  3024                        
  3025                        LAB_EVEZ
  3026 00:E209: A9 00              LDA   #$00              ; set null precedence (flag done)
  3027                        LAB_1ACC
  3028 00:E20B: 48                 PHA                     ; push precedence byte
  3029 00:E20C: A9 02              LDA   #$02              ; 2 bytes
  3030 00:E20E: 20 23 D8           JSR   LAB_1212          ; check room on stack for A bytes
  3031 00:E211: 20 ED E2           JSR   LAB_GVAL          ; get value from line
  3032 00:E214: A9 00              LDA   #$00              ; clear A
  3033 00:E216: 85 9B              STA   comp_f            ; clear compare function flag
  3034                        LAB_1ADB
  3035 00:E218: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  3036                        LAB_1ADE
  3037 00:E21B: 38                 SEC                     ; set carry for subtract
  3038 00:E21C: E9 C0              SBC   #TK_GT            ; subtract token for > (lowest comparison function)
  3039 00:E21E: 90 17              BCC   LAB_1AFA          ; branch if < TK_GT
  3040                        
  3041 00:E220: C9 03              CMP   #$03              ; compare with ">" to "<" tokens
  3042 00:E222: B0 13              BCS   LAB_1AFA          ; branch if >= TK_SGN (highest evaluation function +1)
  3043                        
  3044                                                      ; was token for > = or < (A = 0, 1 or 2)
  3045 00:E224: C9 01              CMP   #$01              ; compare with token for =
  3046 00:E226: 2A                 ROL                     ; *2, b0 = carry (=1 if token was = or <)
  3047                                                      ; (A = 0, 3 or 5)
  3048 00:E227: 49 01              EOR   #$01              ; toggle b0
  3049                                                      ; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
  3050 00:E229: 45 9B              EOR   comp_f            ; EOR with compare function flag bits
  3051 00:E22B: C5 9B              CMP   comp_f            ; compare with compare function flag
  3052 00:E22D: 90 67              BCC   LAB_1B53          ; if <(comp_f) do syntax error then warm start
  3053                                                      ; was more than one <, = or >)
  3054                        
  3055 00:E22F: 85 9B              STA   comp_f            ; save new compare function flag
  3056 00:E231: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  3057 00:E234: 4C 1B E2           JMP   LAB_1ADE          ; go do next character
  3058                        
  3059                                                      ; token is < ">" or > "<" tokens
  3060                        LAB_1AFA
  3061 00:E237: A6 9B              LDX   comp_f            ; get compare function flag
  3062 00:E239: D0 2C              BNE   LAB_1B2A          ; branch if compare function
  3063                        
  3064 00:E23B: B0 79              BCS   LAB_1B78          ; go do functions
  3065                        
  3066                                                      ; else was <  TK_GT so is operator or lower
  3067 00:E23D: 69 0A              ADC   #TK_GT-TK_PLUS    ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
  3068 00:E23F: 90 75              BCC   LAB_1B78          ; branch if < + operator
  3069                        
  3070                                                      ; carry was set so token was +, -, *, /, ^, AND, OR or EOR
  3071 00:E241: D0 07              BNE   LAB_1B0B          ; branch if not + token
  3072                        
  3073 00:E243: 24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
  3074 00:E245: 10 03              BPL   LAB_1B0B          ; branch if not string
  3075                        
  3076                                                      ; will only be $00 if type is string and token was +
  3077 00:E247: 4C 08 EA           JMP   LAB_224D          ; add strings, string 1 is in descriptor des_pl, string 2
  3078                                                      ; is in line, and return
  3079                        
  3080                        LAB_1B0B
  3081 00:E24A: 85 71              STA   ut1_pl            ; save it
  3082 00:E24C: 0A                 ASL                     ; *2
  3083 00:E24D: 65 71              ADC   ut1_pl            ; *3
  3084 00:E24F: A8                 TAY                     ; copy to index
  3085                        LAB_1B13
  3086 00:E250: 68                 PLA                     ; pull previous precedence
  3087 00:E251: D9 19 FA           CMP   LAB_OPPT,Y        ; compare with precedence byte
  3088 00:E254: B0 65              BCS   LAB_1B7D          ; branch if A >=
  3089                        
  3090 00:E256: 20 F0 E1           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  3091                        LAB_1B1C
  3092 00:E259: 48                 PHA                     ; save precedence
  3093                        LAB_1B1D
  3094 00:E25A: 20 82 E2           JSR   LAB_1B43          ; get vector, execute function then continue evaluation
  3095 00:E25D: 68                 PLA                     ; restore precedence
  3096 00:E25E: A4 99              LDY   prstk             ; get precedence stacked flag
  3097 00:E260: 10 19              BPL   LAB_1B3C          ; branch if stacked values
  3098                        
  3099 00:E262: AA                 TAX                     ; copy precedence (set flags)
  3100 00:E263: F0 76              BEQ   LAB_1B9D          ; exit if done
  3101                        
  3102 00:E265: D0 5D              BNE   LAB_1B86          ; else pop FAC2 and return, branch always
  3103                        
  3104                        LAB_1B2A
  3105 00:E267: 26 5F              ROL   Dtypef            ; shift data type flag into Cb
  3106 00:E269: 8A                 TXA                     ; copy compare function flag
  3107 00:E26A: 85 5F              STA   Dtypef            ; clear data type flag, X is 0xxx xxxx
  3108 00:E26C: 2A                 ROL                     ; shift data type into compare function byte b0
  3109 00:E26D: A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
  3110 00:E26F: D0 02              BNE   LAB_1B34          ; branch if no underflow
  3111                        
  3112 00:E271: C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
  3113                        LAB_1B34
  3114 00:E273: C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
  3115             0000000C   TK_LT_PLUS  equ TK_LT-TK_PLUS
  3116 00:E275: A0 24              LDY   #TK_LT_PLUS*3     ; set offset to last operator entry
  3117 00:E277: 85 9B              STA   comp_f            ; save new compare function flag
  3118 00:E279: D0 D5              BNE   LAB_1B13          ; branch always
  3119                        
  3120                        LAB_1B3C
  3121 00:E27B: D9 19 FA           CMP   LAB_OPPT,Y        ;.compare with stacked function precedence
  3122 00:E27E: B0 44              BCS   LAB_1B86          ; branch if A >=, pop FAC2 and return
  3123                        
  3124 00:E280: 90 D7              BCC   LAB_1B1C          ; branch always
  3125                        
  3126                        ;.get vector, execute function then continue evaluation
  3127                        
  3128                        LAB_1B43
  3129 00:E282: B9 1B FA           LDA   LAB_OPPT+2,Y      ; get function vector high byte
  3130 00:E285: 48                 PHA                     ; onto stack
  3131 00:E286: B9 1A FA           LDA   LAB_OPPT+1,Y      ; get function vector low byte
  3132 00:E289: 48                 PHA                     ; onto stack
  3133                                                      ; now push sign, round FAC1 and put on stack
  3134                        ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
  3135                        ; *** add
  3136                           .IF $&$FF=$FD
  3137                              NOP                     ; return address of JSR +1 (on  next page)
  3138                           .ENDIF  
  3139                        ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
  3140 00:E28A: 20 99 E2           JSR   LAB_1B5B          ; function will return here, then the next RTS will call
  3141                                                      ; the function
  3142 00:E28D: A5 9B              LDA   comp_f            ; get compare function flag
  3143 00:E28F: 48                 PHA                     ; push compare evaluation byte
  3144 00:E290: B9 19 FA           LDA   LAB_OPPT,Y        ; get precedence byte
  3145 00:E293: 4C 0B E2           JMP   LAB_1ACC          ; continue evaluating expression
  3146                        
  3147                        LAB_1B53
  3148 00:E296: 4C 22 E3           JMP   LAB_SNER          ; do syntax error then warm start
  3149                        
  3150                        ; push sign, round FAC1 and put on stack
  3151                        
  3152                        LAB_1B5B
  3153 00:E299: 68                 PLA                     ; get return addr low byte
  3154 00:E29A: 85 71              STA   ut1_pl            ; save it
  3155 00:E29C: E6 71              INC   ut1_pl            ; increment it (was ret-1 pushed? yes!)
  3156                                                      ; note! no check is made on the high byte! if the calling
  3157                                                      ; routine assembles to a page edge then this all goes
  3158                                                      ; horribly wrong !!!
  3159 00:E29E: 68                 PLA                     ; get return addr high byte
  3160 00:E29F: 85 72              STA   ut1_ph            ; save it
  3161 00:E2A1: A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
  3162 00:E2A3: 48                 PHA                     ; push sign
  3163                        
  3164                        ; round FAC1 and put on stack
  3165                        
  3166                        ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
  3167                        ; *** replace
  3168                        ;LAB_1B66
  3169                        ;      JSR   LAB_27BA          ; round FAC1
  3170                        ; *** with
  3171 00:E2A4: 20 06 F0           JSR   LAB_27BA          ; round FAC1
  3172                        LAB_1B66
  3173                        ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
  3174 00:E2A7: A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
  3175 00:E2A9: 48                 PHA                     ; push on stack
  3176 00:E2AA: A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
  3177 00:E2AC: 48                 PHA                     ; push on stack
  3178 00:E2AD: A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
  3179 00:E2AF: 48                 PHA                     ; push on stack
  3180 00:E2B0: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  3181 00:E2B2: 48                 PHA                     ; push on stack
  3182 00:E2B3: 6C 71 00           JMP   (ut1_pl)          ; return, sort of
  3183                        
  3184                        ; do functions
  3185                        
  3186                        LAB_1B78
  3187 00:E2B6: A0 FF              LDY   #$FF              ; flag function
  3188 00:E2B8: 68                 PLA                     ; pull precedence byte
  3189                        LAB_1B7B
  3190 00:E2B9: F0 20              BEQ   LAB_1B9D          ; exit if done
  3191                        
  3192                        LAB_1B7D
  3193 00:E2BB: C9 64              CMP   #$64              ; compare previous precedence with $64
  3194 00:E2BD: F0 03              BEQ   LAB_1B84          ; branch if was $64 (< function)
  3195                        
  3196 00:E2BF: 20 F0 E1           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  3197                        LAB_1B84
  3198 00:E2C2: 84 99              STY   prstk             ; save precedence stacked flag
  3199                        
  3200                                                      ; pop FAC2 and return
  3201                        LAB_1B86
  3202 00:E2C4: 68                 PLA                     ; pop byte
  3203 00:E2C5: 4A                 LSR                     ; shift out comparison evaluation lowest bit
  3204 00:E2C6: 85 63              STA   Cflag             ; save comparison evaluation flag
  3205 00:E2C8: 68                 PLA                     ; pop exponent
  3206 00:E2C9: 85 B3              STA   FAC2_e            ; save FAC2 exponent
  3207 00:E2CB: 68                 PLA                     ; pop mantissa1
  3208 00:E2CC: 85 B4              STA   FAC2_1            ; save FAC2 mantissa1
  3209 00:E2CE: 68                 PLA                     ; pop mantissa2
  3210 00:E2CF: 85 B5              STA   FAC2_2            ; save FAC2 mantissa2
  3211 00:E2D1: 68                 PLA                     ; pop mantissa3
  3212 00:E2D2: 85 B6              STA   FAC2_3            ; save FAC2 mantissa3
  3213 00:E2D4: 68                 PLA                     ; pop sign
  3214 00:E2D5: 85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
  3215 00:E2D7: 45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
  3216 00:E2D9: 85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  3217                        LAB_1B9D
  3218 00:E2DB: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  3219 00:E2DD: 60                 RTS
  3220                        
  3221                        ; print "..." string to string util area
  3222                        
  3223                        LAB_1BC1
  3224 00:E2DE: A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
  3225 00:E2E0: A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
  3226 00:E2E2: 69 00              ADC   #$00              ; add carry to low byte
  3227 00:E2E4: 90 01              BCC   LAB_1BCA          ; branch if no overflow
  3228                        
  3229 00:E2E6: C8                 INY                     ; increment high byte
  3230                        LAB_1BCA
  3231 00:E2E7: 20 72 E8           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
  3232 00:E2EA: 4C FC EB           JMP   LAB_23F3          ; restore BASIC execute pointer from temp and return
  3233                        
  3234                        ; get value from line
  3235                        
  3236                        LAB_GVAL
  3237 00:E2ED: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  3238 00:E2F0: B0 03              BCS   LAB_1BAC          ; branch if not numeric character
  3239                        
  3240                                                      ; else numeric string found (e.g. 123)
  3241                        LAB_1BA9
  3242 00:E2F2: 4C D3 F0           JMP   LAB_2887          ; get FAC1 from string and return
  3243                        
  3244                        ; get value from line .. continued
  3245                        
  3246                                                      ; wasn't a number so ..
  3247                        LAB_1BAC
  3248 00:E2F5: AA                 TAX                     ; set the flags
  3249 00:E2F6: 30 2F              BMI   LAB_1BD0          ; if -ve go test token values
  3250                        
  3251                                                      ; else it is either a string, number, variable or (<expr>)
  3252 00:E2F8: C9 24              CMP   #'$'              ; compare with "$"
  3253 00:E2FA: F0 F6              BEQ   LAB_1BA9          ; branch if "$", hex number
  3254                        
  3255 00:E2FC: C9 25              CMP   #'%'              ; else compare with "%"
  3256 00:E2FE: F0 F2              BEQ   LAB_1BA9          ; branch if "%", binary number
  3257                        
  3258 00:E300: C9 2E              CMP   #'.'              ; compare with "."
  3259 00:E302: F0 EE              BEQ   LAB_1BA9          ; if so get FAC1 from string and return (e.g. was .123)
  3260                        
  3261                                                      ; it wasn't any sort of number so ..
  3262 00:E304: C9 22              CMP   #$22              ; compare with "
  3263 00:E306: F0 D6              BEQ   LAB_1BC1          ; branch if open quote
  3264                        
  3265                                                      ; wasn't any sort of number so ..
  3266                        
  3267                        ; evaluate expression within parentheses
  3268                        
  3269 00:E308: C9 28              CMP   #'('              ; compare with "("
  3270 00:E30A: D0 5B              BNE   LAB_1C18          ; if not "(" get (var), return value in FAC1 and $ flag
  3271                        
  3272                        LAB_1BF7
  3273 00:E30C: 20 09 E2           JSR   LAB_EVEZ          ; evaluate expression, no decrement
  3274                        
  3275                        ; all the 'scan for' routines return the character after the sought character
  3276                        
  3277                        ; scan for ")" , else do syntax error then warm start
  3278                        
  3279                        LAB_1BFB
  3280 00:E30F: A9 29              LDA   #$29              ; load A with ")"
  3281                        
  3282                        ; scan for CHR$(A) , else do syntax error then warm start
  3283                        
  3284                        LAB_SCCA
  3285 00:E311: A0 00              LDY   #$00              ; clear index
  3286 00:E313: D1 C3              CMP   (Bpntrl),Y        ; check next byte is = A
  3287 00:E315: D0 0B              BNE   LAB_SNER          ; if not do syntax error then warm start
  3288                        
  3289 00:E317: 4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then return
  3290                        
  3291                        ; scan for "(" , else do syntax error then warm start
  3292                        
  3293                        LAB_1BFE
  3294 00:E31A: A9 28              LDA   #$28              ; load A with "("
  3295 00:E31C: D0 F3              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  3296                                                      ; (branch always)
  3297                        
  3298                        ; scan for "," , else do syntax error then warm start
  3299                        
  3300                        LAB_1C01
  3301 00:E31E: A9 2C              LDA   #$2C              ; load A with ","
  3302 00:E320: D0 EF              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  3303                                                      ; (branch always)
  3304                        
  3305                        ; syntax error then warm start
  3306                        
  3307                        LAB_SNER
  3308 00:E322: A2 02              LDX   #$02              ; error code $02 ("Syntax" error)
  3309 00:E324: 4C 5F D8           JMP   LAB_XERR          ; do error #X, then warm start
  3310                        
  3311                        ; get value from line .. continued
  3312                        ; do tokens
  3313                        
  3314                        LAB_1BD0
  3315 00:E327: C9 B7              CMP   #TK_MINUS         ; compare with token for -
  3316 00:E329: F0 29              BEQ   LAB_1C11          ; branch if - token (do set-up for functions)
  3317                        
  3318                                                      ; wasn't -n so ..
  3319 00:E32B: C9 B6              CMP   #TK_PLUS          ; compare with token for +
  3320 00:E32D: F0 BE              BEQ   LAB_GVAL          ; branch if + token (+n = n so ignore leading +)
  3321                        
  3322 00:E32F: C9 B1              CMP   #TK_NOT           ; compare with token for NOT
  3323 00:E331: D0 13              BNE   LAB_1BE7          ; branch if not token for NOT
  3324                        
  3325                                                      ; was NOT token
  3326             0000000B   TK_EQUAL_PLUS   equ TK_EQUAL-TK_PLUS
  3327 00:E333: A0 21              LDY   #TK_EQUAL_PLUS*3  ; offset to NOT function
  3328 00:E335: D0 1F              BNE   LAB_1C13          ; do set-up for function then execute (branch always)
  3329                        
  3330                        ; do = compare
  3331                        
  3332                        LAB_EQUAL
  3333 00:E337: 20 D4 E5           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
  3334 00:E33A: A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
  3335 00:E33C: 49 FF              EOR   #$FF              ; invert it
  3336 00:E33E: A8                 TAY                     ; copy it
  3337 00:E33F: A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
  3338 00:E341: 49 FF              EOR   #$FF              ; invert it
  3339 00:E343: 4C 87 E7           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3340                        
  3341                        ; get value from line .. continued
  3342                        
  3343                                                      ; wasn't +, -, or NOT so ..
  3344                        LAB_1BE7
  3345 00:E346: C9 AE              CMP   #TK_FN            ; compare with token for FN
  3346 00:E348: D0 03              BNE   LAB_1BEE          ; branch if not token for FN
  3347                        
  3348 00:E34A: 4C E2 E7           JMP   LAB_201E          ; go evaluate FNx
  3349                        
  3350                        ; get value from line .. continued
  3351                        
  3352                                                      ; wasn't +, -, NOT or FN so ..
  3353                        LAB_1BEE
  3354 00:E34D: E9 C3              SBC   #TK_SGN           ; subtract with token for SGN
  3355 00:E34F: B0 27              BCS   LAB_1C27          ; if a function token go do it
  3356                        
  3357 00:E351: 4C 22 E3           JMP   LAB_SNER          ; else do syntax error
  3358                        
  3359                        ; set-up for functions
  3360                        
  3361                        LAB_1C11
  3362             0000000A   TK_GT_PLUS  equ TK_GT-TK_PLUS
  3363 00:E354: A0 1E              LDY   #TK_GT_PLUS*3     ; set offset from base to > operator
  3364                        LAB_1C13
  3365 00:E356: 68                 PLA                     ; dump return address low byte
  3366                        ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
  3367                        ; *** replace
  3368                        ;      PLA                     ; dump return address high byte
  3369                        ;      JMP   LAB_1B1D          ; execute function then continue evaluation
  3370                        ; *** with
  3371 00:E357: AA                 TAX                     ; save to trap concatenate
  3372 00:E358: 68                 PLA                     ; dump return address high byte
  3373 00:E359: E0 10              CPX   #<(LAB_224Da+2)   ; from concatenate low return address?
  3374 00:E35B: D0 04              BNE   LAB_1C13b         ; No - continue!
  3375 00:E35D: C9 EA              CMP   #>(LAB_224Da+2)   ; from concatenate high return address?
  3376 00:E35F: F0 03              BEQ   LAB_1C13a         ; Yes - error!
  3377                        LAB_1C13b
  3378 00:E361: 4C 5A E2           JMP   LAB_1B1D          ; execute function then continue evaluation
  3379                        LAB_1C13a
  3380 00:E364: 4C FC E1           JMP   LAB_1ABC          ; throw "type mismatch error" then warm start      
  3381                        ; *** end   patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
  3382                        
  3383                        ; variable name set-up
  3384                        ; get (var), return value in FAC_1 and $ flag
  3385                        
  3386                        LAB_1C18
  3387 00:E367: 20 D8 E4           JSR   LAB_GVAR          ; get (var) address
  3388 00:E36A: 85 AE              STA   FAC1_2            ; save address low byte in FAC1 mantissa2
  3389 00:E36C: 84 AF              STY   FAC1_3            ; save address high byte in FAC1 mantissa3
  3390 00:E36E: A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
  3391 00:E370: 30 03              BMI   LAB_1C25          ; if string then return (does RTS)
  3392                        
  3393                        LAB_1C24
  3394 00:E372: 4C AA EF           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1
  3395                        
  3396                        LAB_1C25
  3397                        ; *** begin patch  string pointer high byte trashed when moved to stack
  3398                        ; *** add
  3399 00:E375: 46 B9              LSR   FAC1_r            ; clear bit 7 (<$80) = do not round up
  3400                        ; *** end patch 
  3401 00:E377: 60                 RTS
  3402                        
  3403                        ; get value from line .. continued
  3404                        ; only functions left so ..
  3405                        
  3406                        ; set up function references
  3407                        
  3408                        ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
  3409                        ; to process function calls. now the function vector is computed and pushed on the stack
  3410                        ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
  3411                        ; is calculated and the routine called, if not this routine just does RTS. whichever
  3412                        ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
  3413                        ; the function code
  3414                        
  3415                        ; this also removes some less than elegant code that was used to bypass type checking
  3416                        ; for functions that returned strings
  3417                        
  3418                        LAB_1C27
  3419 00:E378: 0A                 ASL                     ; *2 (2 bytes per function address)
  3420 00:E379: A8                 TAY                     ; copy to index
  3421                        
  3422 00:E37A: B9 D4 F9           LDA   LAB_FTBM,Y        ; get function jump vector high byte
  3423 00:E37D: 48                 PHA                     ; push functions jump vector high byte
  3424 00:E37E: B9 D3 F9           LDA   LAB_FTBL,Y        ; get function jump vector low byte
  3425 00:E381: 48                 PHA                     ; push functions jump vector low byte
  3426                        
  3427 00:E382: B9 8E F9           LDA   LAB_FTPM,Y        ; get function pre process vector high byte
  3428 00:E385: F0 05              BEQ   LAB_1C56          ; skip pre process if null vector
  3429                        
  3430 00:E387: 48                 PHA                     ; push functions pre process vector high byte
  3431 00:E388: B9 8D F9           LDA   LAB_FTPL,Y        ; get function pre process vector low byte
  3432 00:E38B: 48                 PHA                     ; push functions pre process vector low byte
  3433                        
  3434                        LAB_1C56
  3435 00:E38C: 60                 RTS                     ; do function, or pre process, call
  3436                        
  3437                        ; process string expression in parenthesis
  3438                        
  3439                        LAB_PPFS
  3440 00:E38D: 20 0C E3           JSR   LAB_1BF7          ; process expression in parenthesis
  3441 00:E390: 4C F2 E1           JMP   LAB_CTST          ; check if source is string then do function,
  3442                                                      ; else do type mismatch
  3443                        
  3444                        ; process numeric expression in parenthesis
  3445                        
  3446                        LAB_PPFN
  3447 00:E393: 20 0C E3           JSR   LAB_1BF7          ; process expression in parenthesis
  3448 00:E396: 4C F0 E1           JMP   LAB_CTNM          ; check if source is numeric then do function,
  3449                                                      ; else do type mismatch
  3450                        
  3451                        ; set numeric data type and increment BASIC execute pointer
  3452                        
  3453                        LAB_PPBI
  3454 00:E399: 46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  3455 00:E39B: 4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then do function
  3456                        
  3457                        ; process string for LEFT$, RIGHT$ or MID$
  3458                        
  3459                        LAB_LRMS
  3460 00:E39E: 20 09 E2           JSR   LAB_EVEZ          ; evaluate (should be string) expression
  3461 00:E3A1: 20 1E E3           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
  3462 00:E3A4: 20 F2 E1           JSR   LAB_CTST          ; check if source is string, else do type mismatch
  3463                        
  3464 00:E3A7: 68                 PLA                     ; get function jump vector low byte
  3465 00:E3A8: AA                 TAX                     ; save functions jump vector low byte
  3466 00:E3A9: 68                 PLA                     ; get function jump vector high byte
  3467 00:E3AA: A8                 TAY                     ; save functions jump vector high byte
  3468 00:E3AB: A5 AF              LDA   des_ph            ; get descriptor pointer high byte
  3469 00:E3AD: 48                 PHA                     ; push string pointer high byte
  3470 00:E3AE: A5 AE              LDA   des_pl            ; get descriptor pointer low byte
  3471 00:E3B0: 48                 PHA                     ; push string pointer low byte
  3472 00:E3B1: 98                 TYA                     ; get function jump vector high byte back
  3473 00:E3B2: 48                 PHA                     ; save functions jump vector high byte
  3474 00:E3B3: 8A                 TXA                     ; get function jump vector low byte back
  3475 00:E3B4: 48                 PHA                     ; save functions jump vector low byte
  3476 00:E3B5: 20 C0 EB           JSR   LAB_GTBY          ; get byte parameter
  3477 00:E3B8: 8A                 TXA                     ; copy byte parameter to A
  3478 00:E3B9: 60                 RTS                     ; go do function
  3479                        
  3480                        ; process numeric expression(s) for BIN$ or HEX$
  3481                        
  3482                        LAB_BHSS
  3483 00:E3BA: 20 09 E2           JSR   LAB_EVEZ          ; process expression
  3484 00:E3BD: 20 F0 E1           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  3485 00:E3C0: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  3486 00:E3C2: C9 98              CMP   #$98              ; compare with exponent = 2^24
  3487 00:E3C4: B0 20              BCS   LAB_BHER          ; branch if n>=2^24 (is too big)
  3488                        
  3489 00:E3C6: 20 7D F0           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
  3490 00:E3C9: A2 02              LDX   #$02              ; 3 bytes to do
  3491                        LAB_CFAC
  3492 00:E3CB: B5 AD              LDA   FAC1_1,X          ; get byte from FAC1
  3493 00:E3CD: 95 11              STA   nums_1,X          ; save byte to temp
  3494 00:E3CF: CA                 DEX                     ; decrement index
  3495 00:E3D0: 10 F9              BPL   LAB_CFAC          ; copy FAC1 mantissa to temp
  3496                        
  3497 00:E3D2: 20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
  3498 00:E3D5: A2 00              LDX   #$00              ; set default to no leading "0"s
  3499 00:E3D7: C9 29              CMP   #')'              ; compare with close bracket
  3500 00:E3D9: F0 0A              BEQ   LAB_1C54          ; if ")" go do rest of function
  3501                        
  3502 00:E3DB: 20 0B EC           JSR   LAB_SCGB          ; scan for "," and get byte
  3503 00:E3DE: 20 C2 00           JSR   LAB_GBYT          ; get last byte back
  3504 00:E3E1: C9 29              CMP   #')'              ; is next character )
  3505 00:E3E3: D0 01              BNE   LAB_BHER          ; if not ")" go do error
  3506                        
  3507                        LAB_1C54
  3508 00:E3E5: 60                 RTS                     ; else do function
  3509                        
  3510                        LAB_BHER
  3511 00:E3E6: 4C 57 E6           JMP   LAB_FCER          ; do function call error then warm start
  3512                        
  3513                        ; perform EOR
  3514                        
  3515                        ; added operator format is the same as AND or OR, precedence is the same as OR
  3516                        
  3517                        ; this bit worked first time but it took a while to sort out the operator table
  3518                        ; pointers and offsets afterwards!
  3519                        
  3520                        LAB_EOR
  3521 00:E3E9: 20 10 E4           JSR   GetFirst          ; get first integer expression (no sign check)
  3522 00:E3EC: 45 5B              EOR   XOAw_l            ; EOR with expression 1 low byte
  3523 00:E3EE: A8                 TAY                     ; save in Y
  3524 00:E3EF: A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
  3525 00:E3F1: 45 5C              EOR   XOAw_h            ; EOR with expression 1 high byte
  3526 00:E3F3: 4C 87 E7           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3527                        
  3528                        ; perform OR
  3529                        
  3530                        LAB_OR
  3531 00:E3F6: 20 10 E4           JSR   GetFirst          ; get first integer expression (no sign check)
  3532 00:E3F9: 05 5B              ORA   XOAw_l            ; OR with expression 1 low byte
  3533 00:E3FB: A8                 TAY                     ; save in Y
  3534 00:E3FC: A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
  3535 00:E3FE: 05 5C              ORA   XOAw_h            ; OR with expression 1 high byte
  3536 00:E400: 4C 87 E7           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3537                        
  3538                        ; perform AND
  3539                        
  3540                        LAB_AND
  3541 00:E403: 20 10 E4           JSR   GetFirst          ; get first integer expression (no sign check)
  3542 00:E406: 25 5B              AND   XOAw_l            ; AND with expression 1 low byte
  3543 00:E408: A8                 TAY                     ; save in Y
  3544 00:E409: A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
  3545 00:E40B: 25 5C              AND   XOAw_h            ; AND with expression 1 high byte
  3546 00:E40D: 4C 87 E7           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3547                        
  3548                        ; get first value for OR, AND or EOR
  3549                        
  3550                        GetFirst
  3551 00:E410: 20 D4 E5           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
  3552 00:E413: A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
  3553 00:E415: 85 5C              STA   XOAw_h            ; save it
  3554 00:E417: A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
  3555 00:E419: 85 5B              STA   XOAw_l            ; save it
  3556 00:E41B: 20 F0 EC           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
  3557 00:E41E: 20 D4 E5           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
  3558 00:E421: A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
  3559                        LAB_1C95
  3560 00:E423: 60                 RTS
  3561                        
  3562                        ; perform comparisons
  3563                        
  3564                        ; do < compare
  3565                        
  3566                        LAB_LTHAN
  3567 00:E424: 20 F3 E1           JSR   LAB_CKTM          ; type match check, set C for string
  3568 00:E427: B0 13              BCS   LAB_1CAE          ; branch if string
  3569                        
  3570                                                      ; do numeric < compare
  3571 00:E429: A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
  3572 00:E42B: 09 7F              ORA   #$7F              ; set all non sign bits
  3573 00:E42D: 25 B4              AND   FAC2_1            ; and FAC2 mantissa1 (AND in sign bit)
  3574 00:E42F: 85 B4              STA   FAC2_1            ; save FAC2 mantissa1
  3575 00:E431: A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
  3576 00:E433: A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
  3577 00:E435: 20 44 F0           JSR   LAB_27F8          ; compare FAC1 with FAC2 (AY)
  3578 00:E438: AA                 TAX                     ; copy result
  3579 00:E439: 4C 6D E4           JMP   LAB_1CE1          ; go evaluate result
  3580                        
  3581                                                      ; do string < compare
  3582                        LAB_1CAE
  3583 00:E43C: 46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  3584 00:E43E: C6 9B              DEC   comp_f            ; clear < bit in compare function flag
  3585 00:E440: 20 72 EA           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
  3586                                                      ; space returns with A = length, X=pointer low byte,
  3587                                                      ; Y=pointer high byte
  3588 00:E443: 85 AC              STA   str_ln            ; save length
  3589 00:E445: 86 AD              STX   str_pl            ; save string pointer low byte
  3590 00:E447: 84 AE              STY   str_ph            ; save string pointer high byte
  3591 00:E449: A5 B5              LDA   FAC2_2            ; get descriptor pointer low byte
  3592 00:E44B: A4 B6              LDY   FAC2_3            ; get descriptor pointer high byte
  3593 00:E44D: 20 76 EA           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
  3594                                                      ; returns with A = length, X=pointer low byte,
  3595                                                      ; Y=pointer high byte
  3596 00:E450: 86 B5              STX   FAC2_2            ; save string pointer low byte
  3597 00:E452: 84 B6              STY   FAC2_3            ; save string pointer high byte
  3598 00:E454: AA                 TAX                     ; copy length
  3599 00:E455: 38                 SEC                     ; set carry for subtract
  3600 00:E456: E5 AC              SBC   str_ln            ; subtract string 1 length
  3601 00:E458: F0 08              BEQ   LAB_1CD6          ; branch if str 1 length = string 2 length
  3602                        
  3603 00:E45A: A9 01              LDA   #$01              ; set str 1 length > string 2 length
  3604 00:E45C: 90 04              BCC   LAB_1CD6          ; branch if so
  3605                        
  3606 00:E45E: A6 AC              LDX   str_ln            ; get string 1 length
  3607 00:E460: A9 FF              LDA   #$FF              ; set str 1 length < string 2 length
  3608                        LAB_1CD6
  3609 00:E462: 85 B0              STA   FAC1_s            ; save length compare
  3610 00:E464: A0 FF              LDY   #$FF              ; set index
  3611 00:E466: E8                 INX                     ; adjust for loop
  3612                        LAB_1CDB
  3613 00:E467: C8                 INY                     ; increment index
  3614 00:E468: CA                 DEX                     ; decrement count
  3615 00:E469: D0 07              BNE   LAB_1CE6          ; branch if still bytes to do
  3616                        
  3617 00:E46B: A6 B0              LDX   FAC1_s            ; get length compare back
  3618                        LAB_1CE1
  3619 00:E46D: 30 0F              BMI   LAB_1CF2          ; branch if str 1 < str 2
  3620                        
  3621 00:E46F: 18                 CLC                     ; flag str 1 <= str 2
  3622 00:E470: 90 0C              BCC   LAB_1CF2          ; go evaluate result
  3623                        
  3624                        LAB_1CE6
  3625 00:E472: B1 B5              LDA   (FAC2_2),Y        ; get string 2 byte
  3626 00:E474: D1 AD              CMP   (FAC1_1),Y        ; compare with string 1 byte
  3627 00:E476: F0 EF              BEQ   LAB_1CDB          ; loop if bytes =
  3628                        
  3629 00:E478: A2 FF              LDX   #$FF              ; set str 1 < string 2
  3630 00:E47A: B0 02              BCS   LAB_1CF2          ; branch if so
  3631                        
  3632 00:E47C: A2 01              LDX   #$01              ;  set str 1 > string 2
  3633                        LAB_1CF2
  3634 00:E47E: E8                 INX                     ; x = 0, 1 or 2
  3635 00:E47F: 8A                 TXA                     ; copy to A
  3636 00:E480: 2A                 ROL                     ; *2 (1, 2 or 4)
  3637 00:E481: 25 63              AND   Cflag             ; AND with comparison evaluation flag
  3638 00:E483: F0 02              BEQ   LAB_1CFB          ; branch if 0 (compare is false)
  3639                        
  3640 00:E485: A9 FF              LDA   #$FF              ; else set result true
  3641                        LAB_1CFB
  3642 00:E487: 4C 27 F0           JMP   LAB_27DB          ; save A as integer byte and return
  3643                        
  3644                        LAB_1CFE
  3645 00:E48A: 20 1E E3           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
  3646                        
  3647                        ; perform DIM
  3648                        
  3649                        LAB_DIM
  3650 00:E48D: AA                 TAX                     ; copy "DIM" flag to X
  3651 00:E48E: 20 DD E4           JSR   LAB_1D10          ; search for variable
  3652 00:E491: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  3653 00:E494: D0 F4              BNE   LAB_1CFE          ; scan for "," and loop if not null
  3654                        
  3655 00:E496: 60                 RTS
  3656                        
  3657                        ; perform << (left shift)
  3658                        
  3659                        LAB_LSHIFT
  3660 00:E497: 20 CD E4           JSR   GetPair           ; get integer expression and byte (no sign check)
  3661 00:E49A: A5 AE              LDA   FAC1_2            ; get expression high byte
  3662 00:E49C: A6 78              LDX   TempB             ; get shift count
  3663 00:E49E: F0 22              BEQ   NoShift           ; branch if zero
  3664                        
  3665 00:E4A0: E0 10              CPX   #$10              ; compare bit count with 16d
  3666 00:E4A2: B0 23              BCS   TooBig            ; branch if >=
  3667                        
  3668                        Ls_loop
  3669 00:E4A4: 06 AF              ASL   FAC1_3            ; shift low byte
  3670 00:E4A6: 2A                 ROL                     ; shift high byte
  3671 00:E4A7: CA                 DEX                     ; decrement bit count
  3672 00:E4A8: D0 FA              BNE   Ls_loop           ; loop if shift not complete
  3673                        
  3674 00:E4AA: A4 AF              LDY   FAC1_3            ; get expression low byte
  3675 00:E4AC: 4C 87 E7           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3676                        
  3677                        ; perform >> (right shift)
  3678                        
  3679                        LAB_RSHIFT
  3680 00:E4AF: 20 CD E4           JSR   GetPair           ; get integer expression and byte (no sign check)
  3681 00:E4B2: A5 AE              LDA   FAC1_2            ; get expression high byte
  3682 00:E4B4: A6 78              LDX   TempB             ; get shift count
  3683 00:E4B6: F0 0A              BEQ   NoShift           ; branch if zero
  3684                        
  3685 00:E4B8: E0 10              CPX   #$10              ; compare bit count with 16d
  3686 00:E4BA: B0 0B              BCS   TooBig            ; branch if >=
  3687                        
  3688                        Rs_loop
  3689 00:E4BC: 4A                 LSR                     ; shift high byte
  3690 00:E4BD: 66 AF              ROR   FAC1_3            ; shift low byte
  3691 00:E4BF: CA                 DEX                     ; decrement bit count
  3692 00:E4C0: D0 FA              BNE   Rs_loop           ; loop if shift not complete
  3693                        
  3694                        NoShift
  3695 00:E4C2: A4 AF              LDY   FAC1_3            ; get expression low byte
  3696 00:E4C4: 4C 87 E7           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3697                        
  3698                        TooBig
  3699 00:E4C7: A9 00              LDA   #$00              ; clear high byte
  3700 00:E4C9: A8                 TAY                     ; copy to low byte
  3701 00:E4CA: 4C 87 E7           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  3702                        
  3703                        GetPair
  3704 00:E4CD: 20 C3 EB           JSR   LAB_EVBY          ; evaluate byte expression, result in X
  3705 00:E4D0: 86 78              STX   TempB             ; save it
  3706 00:E4D2: 20 F0 EC           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
  3707 00:E4D5: 4C D4 E5           JMP   LAB_EVIR          ; evaluate integer expression (no sign check)
  3708                        
  3709                        ; search for variable
  3710                        
  3711                        ; return pointer to variable in Cvaral/Cvarah
  3712                        
  3713                        LAB_GVAR
  3714 00:E4D8: A2 00              LDX   #$00              ; set DIM flag = $00
  3715 00:E4DA: 20 C2 00           JSR   LAB_GBYT          ; scan memory (1st character)
  3716                        LAB_1D10
  3717 00:E4DD: 86 5E              STX   Defdim            ; save DIM flag
  3718                        LAB_1D12
  3719 00:E4DF: 85 93              STA   Varnm1            ; save 1st character
  3720 00:E4E1: 29 7F              AND   #$7F              ; clear FN flag bit
  3721 00:E4E3: 20 4C E5           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
  3722 00:E4E6: B0 03              BCS   LAB_1D1F          ; branch if ok
  3723                        
  3724 00:E4E8: 4C 22 E3           JMP   LAB_SNER          ; else syntax error then warm start
  3725                        
  3726                                                      ; was variable name so ..
  3727                        LAB_1D1F
  3728 00:E4EB: A2 00              LDX   #$00              ; clear 2nd character temp
  3729 00:E4ED: 86 5F              STX   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  3730 00:E4EF: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (2nd character)
  3731 00:E4F2: 90 05              BCC   LAB_1D2D          ; branch if character = "0"-"9" (ok)
  3732                        
  3733                                                      ; 2nd character wasn't "0" to "9" so ..
  3734 00:E4F4: 20 4C E5           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
  3735 00:E4F7: 90 0B              BCC   LAB_1D38          ; branch if <"A" or >"Z" (go check if string)
  3736                        
  3737                        LAB_1D2D
  3738 00:E4F9: AA                 TAX                     ; copy 2nd character
  3739                        
  3740                                                      ; ignore further (valid) characters in the variable name
  3741                        LAB_1D2E
  3742 00:E4FA: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (3rd character)
  3743 00:E4FD: 90 FB              BCC   LAB_1D2E          ; loop if character = "0"-"9" (ignore)
  3744                        
  3745 00:E4FF: 20 4C E5           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
  3746 00:E502: B0 F6              BCS   LAB_1D2E          ; loop if character = "A"-"Z" (ignore)
  3747                        
  3748                                                      ; check if string variable
  3749                        LAB_1D38
  3750 00:E504: C9 24              CMP   #'$'              ; compare with "$"
  3751 00:E506: D0 0B              BNE   LAB_1D47          ; branch if not string
  3752                        
  3753                        ; to introduce a new variable type (% suffix for integers say) then this branch
  3754                        ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
  3755                        
  3756                                                      ; type is string
  3757 00:E508: A9 FF              LDA   #$FF              ; set data type = string
  3758 00:E50A: 85 5F              STA   Dtypef            ; set data type flag, $FF=string, $00=numeric
  3759 00:E50C: 8A                 TXA                     ; get 2nd character back
  3760 00:E50D: 09 80              ORA   #$80              ; set top bit (indicate string var)
  3761 00:E50F: AA                 TAX                     ; copy back to 2nd character temp
  3762 00:E510: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  3763                        
  3764                        ; after we have determined the variable type we need to come back here to determine
  3765                        ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
  3766                        
  3767                        
  3768                        LAB_1D47                      ; gets here with character after var name in A
  3769 00:E513: 86 94              STX   Varnm2            ; save 2nd character
  3770 00:E515: 05 61              ORA   Sufnxf            ; or with subscript/FNX flag (or FN name)
  3771 00:E517: C9 28              CMP   #'('              ; compare with "("
  3772 00:E519: D0 03              BNE   LAB_1D53          ; branch if not "("
  3773                        
  3774 00:E51B: 4C E6 E5           JMP   LAB_1E17          ; go find, or make, array
  3775                        
  3776                        ; either find or create var
  3777                        ; var name (1st two characters only!) is in Varnm1,Varnm2
  3778                        
  3779                                                      ; variable name wasn't var(... so look for plain var
  3780                        LAB_1D53
  3781 00:E51E: A9 00              LDA   #$00              ; clear A
  3782 00:E520: 85 61              STA   Sufnxf            ; clear subscript/FNX flag
  3783 00:E522: A5 7B              LDA   Svarl             ; get start of vars low byte
  3784 00:E524: A6 7C              LDX   Svarh             ; get start of vars high byte
  3785 00:E526: A0 00              LDY   #$00              ; clear index
  3786                        LAB_1D5D
  3787 00:E528: 86 AB              STX   Vrschh            ; save search address high byte
  3788                        LAB_1D5F
  3789 00:E52A: 85 AA              STA   Vrschl            ; save search address low byte
  3790 00:E52C: E4 7E              CPX   Sarryh            ; compare high address with var space end
  3791 00:E52E: D0 04              BNE   LAB_1D69          ; skip next compare if <>
  3792                        
  3793                                                      ; high addresses were = so compare low addresses
  3794 00:E530: C5 7D              CMP   Sarryl            ; compare low address with var space end
  3795 00:E532: F0 2C              BEQ   LAB_1D8B          ; if not found go make new var
  3796                        
  3797                        LAB_1D69
  3798 00:E534: A5 93              LDA   Varnm1            ; get 1st character of var to find
  3799 00:E536: D1 AA              CMP   (Vrschl),Y        ; compare with variable name 1st character
  3800 00:E538: D0 08              BNE   LAB_1D77          ; branch if no match
  3801                        
  3802                                                      ; 1st characters match so compare 2nd characters
  3803 00:E53A: A5 94              LDA   Varnm2            ; get 2nd character of var to find
  3804 00:E53C: C8                 INY                     ; index to point to variable name 2nd character
  3805 00:E53D: D1 AA              CMP   (Vrschl),Y        ; compare with variable name 2nd character
  3806 00:E53F: F0 69              BEQ   LAB_1DD7          ; branch if match (found var)
  3807                        
  3808 00:E541: 88                 DEY                     ; else decrement index (now = $00)
  3809                        LAB_1D77
  3810 00:E542: 18                 CLC                     ; clear carry for add
  3811 00:E543: A5 AA              LDA   Vrschl            ; get search address low byte
  3812 00:E545: 69 06              ADC   #$06              ; +6 (offset to next var name)
  3813 00:E547: 90 E1              BCC   LAB_1D5F          ; loop if no overflow to high byte
  3814                        
  3815 00:E549: E8                 INX                     ; else increment high byte
  3816 00:E54A: D0 DC              BNE   LAB_1D5D          ; loop always (RAM doesn't extend to $FFFF !)
  3817                        
  3818                        ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
  3819                        
  3820                        LAB_CASC
  3821 00:E54C: C9 61              CMP   #'a'              ; compare with "a"
  3822 00:E54E: B0 0A              BCS   LAB_1D83          ; go check <"z"+1
  3823                        
  3824                        ; check byte, return C=0 if<"A" or >"Z"
  3825                        
  3826                        LAB_1D82
  3827 00:E550: C9 41              CMP   #'A'              ; compare with "A"
  3828 00:E552: 90 05              BCC   LAB_1D8A          ; exit if less
  3829                        
  3830                                                      ; carry is set
  3831 00:E554: E9 5B              SBC   #$5B              ; subtract "Z"+1
  3832 00:E556: 38                 SEC                     ; set carry
  3833 00:E557: E9 A5              SBC   #$A5              ; subtract $A5 (restore byte)
  3834                                                      ; carry clear if byte>$5A
  3835                        LAB_1D8A
  3836 00:E559: 60                 RTS
  3837                        
  3838                        LAB_1D83
  3839 00:E55A: E9 7B              SBC   #$7B              ; subtract "z"+1
  3840 00:E55C: 38                 SEC                     ; set carry
  3841 00:E55D: E9 85              SBC   #$85              ; subtract $85 (restore byte)
  3842                                                      ; carry clear if byte>$7A
  3843 00:E55F: 60                 RTS
  3844                        
  3845                                                      ; reached end of variable mem without match
  3846                                                      ; .. so create new variable
  3847                        LAB_1D8B
  3848 00:E560: 68                 PLA                     ; pop return address low byte
  3849 00:E561: 48                 PHA                     ; push return address low byte
  3850             0000E369   LAB_1C18p2  equ LAB_1C18+2
  3851 00:E562: C9 69              CMP   #<LAB_1C18p2      ; compare with expected calling routine return low byte
  3852 00:E564: D0 05              BNE   LAB_1D98          ; if not get (var) go create new var
  3853                        
  3854                        ; This will only drop through if the call was from LAB_1C18 and is only called
  3855                        ; from there if it is searching for a variable from the RHS of a LET a=b statement
  3856                        ; it prevents the creation of variables not assigned a value.
  3857                        
  3858                        ; value returned by this is either numeric zero (exponent byte is $00) or null string
  3859                        ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
  3860                        
  3861                        ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
  3862                        
  3863                        ; this is where you would put the undefined variable error call e.g.
  3864                        
  3865                        ;                             ; variable doesn't exist so flag error
  3866                        ;     LDX   #$24              ; error code $24 ("undefined variable" error)
  3867                        ;     JMP   LAB_XERR          ; do error #X then warm start
  3868                        
  3869                        ; the above code has been tested and works a treat! (it replaces the three code lines
  3870                        ; below)
  3871                        
  3872                                                      ; else return dummy null value
  3873 00:E566: A9 11              LDA   #<LAB_1D96        ; low byte point to $00,$00
  3874                                                      ; (uses part of misc constants table)
  3875 00:E568: A0 F9              LDY   #>LAB_1D96        ; high byte point to $00,$00
  3876 00:E56A: 60                 RTS
  3877                        
  3878                                                      ; create new numeric variable
  3879                        LAB_1D98
  3880 00:E56B: A5 7D              LDA   Sarryl            ; get var mem end low byte
  3881 00:E56D: A4 7E              LDY   Sarryh            ; get var mem end high byte
  3882 00:E56F: 85 AA              STA   Ostrtl            ; save old block start low byte
  3883 00:E571: 84 AB              STY   Ostrth            ; save old block start high byte
  3884 00:E573: A5 7F              LDA   Earryl            ; get array mem end low byte
  3885 00:E575: A4 80              LDY   Earryh            ; get array mem end high byte
  3886 00:E577: 85 A6              STA   Obendl            ; save old block end low byte
  3887 00:E579: 84 A7              STY   Obendh            ; save old block end high byte
  3888 00:E57B: 18                 CLC                     ; clear carry for add
  3889 00:E57C: 69 06              ADC   #$06              ; +6 (space for one var)
  3890 00:E57E: 90 01              BCC   LAB_1DAE          ; branch if no overflow to high byte
  3891                        
  3892 00:E580: C8                 INY                     ; else increment high byte
  3893                        LAB_1DAE
  3894 00:E581: 85 A4              STA   Nbendl            ; set new block end low byte
  3895 00:E583: 84 A5              STY   Nbendh            ; set new block end high byte
  3896 00:E585: 20 E1 D7           JSR   LAB_11CF          ; open up space in memory
  3897 00:E588: A5 A4              LDA   Nbendl            ; get new start low byte
  3898 00:E58A: A4 A5              LDY   Nbendh            ; get new start high byte (-$100)
  3899 00:E58C: C8                 INY                     ; correct high byte
  3900 00:E58D: 85 7D              STA   Sarryl            ; save new var mem end low byte
  3901 00:E58F: 84 7E              STY   Sarryh            ; save new var mem end high byte
  3902 00:E591: A0 00              LDY   #$00              ; clear index
  3903 00:E593: A5 93              LDA   Varnm1            ; get var name 1st character
  3904 00:E595: 91 AA              STA   (Vrschl),Y        ; save var name 1st character
  3905 00:E597: C8                 INY                     ; increment index
  3906 00:E598: A5 94              LDA   Varnm2            ; get var name 2nd character
  3907 00:E59A: 91 AA              STA   (Vrschl),Y        ; save var name 2nd character
  3908 00:E59C: A9 00              LDA   #$00              ; clear A
  3909 00:E59E: C8                 INY                     ; increment index
  3910 00:E59F: 91 AA              STA   (Vrschl),Y        ; initialise var byte
  3911 00:E5A1: C8                 INY                     ; increment index
  3912 00:E5A2: 91 AA              STA   (Vrschl),Y        ; initialise var byte
  3913 00:E5A4: C8                 INY                     ; increment index
  3914 00:E5A5: 91 AA              STA   (Vrschl),Y        ; initialise var byte
  3915 00:E5A7: C8                 INY                     ; increment index
  3916 00:E5A8: 91 AA              STA   (Vrschl),Y        ; initialise var byte
  3917                        
  3918                                                      ; found a match for var ((Vrschl) = ptr)
  3919                        LAB_1DD7
  3920 00:E5AA: A5 AA              LDA   Vrschl            ; get var address low byte
  3921 00:E5AC: 18                 CLC                     ; clear carry for add
  3922 00:E5AD: 69 02              ADC   #$02              ; +2 (offset past var name bytes)
  3923 00:E5AF: A4 AB              LDY   Vrschh            ; get var address high byte
  3924 00:E5B1: 90 01              BCC   LAB_1DE1          ; branch if no overflow from add
  3925                        
  3926 00:E5B3: C8                 INY                     ; else increment high byte
  3927                        LAB_1DE1
  3928 00:E5B4: 85 95              STA   Cvaral            ; save current var address low byte
  3929 00:E5B6: 84 96              STY   Cvarah            ; save current var address high byte
  3930 00:E5B8: 60                 RTS
  3931                        
  3932                        ; set-up array pointer (Adatal/h) to first element in array
  3933                        ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
  3934                        
  3935                        LAB_1DE6
  3936 00:E5B9: A5 5D              LDA   Dimcnt            ; get # of dimensions (1, 2 or 3)
  3937 00:E5BB: 0A                 ASL                     ; *2 (also clears the carry !)
  3938 00:E5BC: 69 05              ADC   #$05              ; +5 (result is 7, 9 or 11 here)
  3939 00:E5BE: 65 AA              ADC   Astrtl            ; add array start pointer low byte
  3940 00:E5C0: A4 AB              LDY   Astrth            ; get array pointer high byte
  3941 00:E5C2: 90 01              BCC   LAB_1DF2          ; branch if no overflow
  3942                        
  3943 00:E5C4: C8                 INY                     ; else increment high byte
  3944                        LAB_1DF2
  3945 00:E5C5: 85 A4              STA   Adatal            ; save array data pointer low byte
  3946 00:E5C7: 84 A5              STY   Adatah            ; save array data pointer high byte
  3947 00:E5C9: 60                 RTS
  3948                        
  3949                        ; evaluate integer expression
  3950                        
  3951                        LAB_EVIN
  3952 00:E5CA: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  3953 00:E5CD: 20 ED E1           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  3954                                                      ; else do type mismatch
  3955                        
  3956                        ; evaluate integer expression (no check)
  3957                        
  3958                        LAB_EVPI
  3959 00:E5D0: A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
  3960 00:E5D2: 30 0D              BMI   LAB_1E12          ; do function call error if -ve
  3961                        
  3962                        ; evaluate integer expression (no sign check)
  3963                        
  3964                        LAB_EVIR
  3965 00:E5D4: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  3966 00:E5D6: C9 90              CMP   #$90              ; compare with exponent = 2^16 (n>2^15)
  3967 00:E5D8: 90 09              BCC   LAB_1E14          ; branch if n<2^16 (is ok)
  3968                        
  3969 00:E5DA: A9 18              LDA   #<LAB_1DF7        ; set pointer low byte to -32768
  3970 00:E5DC: A0 F9              LDY   #>LAB_1DF7        ; set pointer high byte to -32768
  3971 00:E5DE: 20 44 F0           JSR   LAB_27F8          ; compare FAC1 with (AY)
  3972                        LAB_1E12
  3973 00:E5E1: D0 74              BNE   LAB_FCER          ; if <> do function call error then warm start
  3974                        
  3975                        LAB_1E14
  3976 00:E5E3: 4C 7D F0           JMP   LAB_2831          ; convert FAC1 floating-to-fixed and return
  3977                        
  3978                        ; find or make array
  3979                        
  3980                        LAB_1E17
  3981 00:E5E6: A5 5E              LDA   Defdim            ; get DIM flag
  3982 00:E5E8: 48                 PHA                     ; push it
  3983 00:E5E9: A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
  3984 00:E5EB: 48                 PHA                     ; push it
  3985 00:E5EC: A0 00              LDY   #$00              ; clear dimensions count
  3986                        
  3987                        ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
  3988                        
  3989                        LAB_1E1F
  3990 00:E5EE: 98                 TYA                     ; copy dimensions count
  3991 00:E5EF: 48                 PHA                     ; save it
  3992 00:E5F0: A5 94              LDA   Varnm2            ; get array name 2nd byte
  3993 00:E5F2: 48                 PHA                     ; save it
  3994 00:E5F3: A5 93              LDA   Varnm1            ; get array name 1st byte
  3995 00:E5F5: 48                 PHA                     ; save it
  3996 00:E5F6: 20 CA E5           JSR   LAB_EVIN          ; evaluate integer expression
  3997 00:E5F9: 68                 PLA                     ; pull array name 1st byte
  3998 00:E5FA: 85 93              STA   Varnm1            ; restore array name 1st byte
  3999 00:E5FC: 68                 PLA                     ; pull array name 2nd byte
  4000 00:E5FD: 85 94              STA   Varnm2            ; restore array name 2nd byte
  4001 00:E5FF: 68                 PLA                     ; pull dimensions count
  4002 00:E600: A8                 TAY                     ; restore it
  4003 00:E601: BA                 TSX                     ; copy stack pointer
  4004 00:E602: BD 02 01           LDA   LAB_STAK+2,X      ; get DIM flag
  4005 00:E605: 48                 PHA                     ; push it
  4006 00:E606: BD 01 01           LDA   LAB_STAK+1,X      ; get data type flag
  4007 00:E609: 48                 PHA                     ; push it
  4008 00:E60A: A5 AE              LDA   FAC1_2            ; get this dimension size high byte
  4009 00:E60C: 9D 02 01           STA   LAB_STAK+2,X      ; stack before flag bytes
  4010 00:E60F: A5 AF              LDA   FAC1_3            ; get this dimension size low byte
  4011 00:E611: 9D 01 01           STA   LAB_STAK+1,X      ; stack before flag bytes
  4012 00:E614: C8                 INY                     ; increment dimensions count
  4013 00:E615: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  4014 00:E618: C9 2C              CMP   #','              ; compare with ","
  4015 00:E61A: F0 D2              BEQ   LAB_1E1F          ; if found go do next dimension
  4016                        
  4017 00:E61C: 84 5D              STY   Dimcnt            ; store dimensions count
  4018 00:E61E: 20 0F E3           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
  4019 00:E621: 68                 PLA                     ; pull data type flag
  4020 00:E622: 85 5F              STA   Dtypef            ; restore data type flag, $FF=string, $00=numeric
  4021 00:E624: 68                 PLA                     ; pull DIM flag
  4022 00:E625: 85 5E              STA   Defdim            ; restore DIM flag
  4023 00:E627: A6 7D              LDX   Sarryl            ; get array mem start low byte
  4024 00:E629: A5 7E              LDA   Sarryh            ; get array mem start high byte
  4025                        
  4026                        ; now check to see if we are at the end of array memory (we would be if there were
  4027                        ; no arrays).
  4028                        
  4029                        LAB_1E5C
  4030 00:E62B: 86 AA              STX   Astrtl            ; save as array start pointer low byte
  4031 00:E62D: 85 AB              STA   Astrth            ; save as array start pointer high byte
  4032 00:E62F: C5 80              CMP   Earryh            ; compare with array mem end high byte
  4033 00:E631: D0 04              BNE   LAB_1E68          ; branch if not reached array mem end
  4034                        
  4035 00:E633: E4 7F              CPX   Earryl            ; else compare with array mem end low byte
  4036 00:E635: F0 39              BEQ   LAB_1EA1          ; go build array if not found
  4037                        
  4038                                                      ; search for array
  4039                        LAB_1E68
  4040 00:E637: A0 00              LDY   #$00              ; clear index
  4041 00:E639: B1 AA              LDA   (Astrtl),Y        ; get array name first byte
  4042 00:E63B: C8                 INY                     ; increment index to second name byte
  4043 00:E63C: C5 93              CMP   Varnm1            ; compare with this array name first byte
  4044 00:E63E: D0 06              BNE   LAB_1E77          ; branch if no match
  4045                        
  4046 00:E640: A5 94              LDA   Varnm2            ; else get this array name second byte
  4047 00:E642: D1 AA              CMP   (Astrtl),Y        ; compare with array name second byte
  4048 00:E644: F0 16              BEQ   LAB_1E8D          ; array found so branch
  4049                        
  4050                                                      ; no match
  4051                        LAB_1E77
  4052 00:E646: C8                 INY                     ; increment index
  4053 00:E647: B1 AA              LDA   (Astrtl),Y        ; get array size low byte
  4054 00:E649: 18                 CLC                     ; clear carry for add
  4055 00:E64A: 65 AA              ADC   Astrtl            ; add array start pointer low byte
  4056 00:E64C: AA                 TAX                     ; copy low byte to X
  4057 00:E64D: C8                 INY                     ; increment index
  4058 00:E64E: B1 AA              LDA   (Astrtl),Y        ; get array size high byte
  4059 00:E650: 65 AB              ADC   Astrth            ; add array mem pointer high byte
  4060 00:E652: 90 D7              BCC   LAB_1E5C          ; if no overflow go check next array
  4061                        
  4062                        ; do array bounds error
  4063                        
  4064                        LAB_1E85
  4065 00:E654: A2 10              LDX   #$10              ; error code $10 ("Array bounds" error)
  4066 00:E656: 2C                 .byte $2C               ; makes next bit BIT LAB_08A2
  4067                        
  4068                        ; do function call error
  4069                        
  4070                        LAB_FCER
  4071 00:E657: A2 08              LDX   #$08              ; error code $08 ("Function call" error)
  4072                        LAB_1E8A
  4073 00:E659: 4C 5F D8           JMP   LAB_XERR          ; do error #X, then warm start
  4074                        
  4075                                                      ; found array, are we trying to dimension it?
  4076                        LAB_1E8D
  4077 00:E65C: A2 12              LDX   #$12              ; set error $12 ("Double dimension" error)
  4078 00:E65E: A5 5E              LDA   Defdim            ; get DIM flag
  4079 00:E660: D0 F7              BNE   LAB_1E8A          ; if we are trying to dimension it do error #X, then warm
  4080                                                      ; start
  4081                        
  4082                        ; found the array and we're not dimensioning it so we must find an element in it
  4083                        
  4084 00:E662: 20 B9 E5           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
  4085                                                      ; (Astrtl,Astrth points to start of array)
  4086 00:E665: A5 5D              LDA   Dimcnt            ; get dimensions count
  4087 00:E667: A0 04              LDY   #$04              ; set index to array's # of dimensions
  4088 00:E669: D1 AA              CMP   (Astrtl),Y        ; compare with no of dimensions
  4089 00:E66B: D0 E7              BNE   LAB_1E85          ; if wrong do array bounds error, could do "Wrong
  4090                                                      ; dimensions" error here .. if we want a different
  4091                                                      ; error message
  4092                        
  4093 00:E66D: 4C F3 E6           JMP   LAB_1F28          ; found array so go get element
  4094                                                      ; (could jump to LAB_1F28 as all LAB_1F24 does is take
  4095                                                      ; Dimcnt and save it at (Astrtl),Y which is already the
  4096                                                      ; same or we would have taken the BNE)
  4097                        
  4098                                                      ; array not found, so build it
  4099                        LAB_1EA1
  4100 00:E670: 20 B9 E5           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
  4101                                                      ; (Astrtl,Astrth points to start of array)
  4102 00:E673: 20 2E D8           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
  4103                                                      ; addr to check is in AY (low/high)
  4104 00:E676: A0 00              LDY   #$00              ; clear Y (don't need to clear A)
  4105 00:E678: 84 BB              STY   Aspth             ; clear array data size high byte
  4106 00:E67A: A5 93              LDA   Varnm1            ; get variable name 1st byte
  4107 00:E67C: 91 AA              STA   (Astrtl),Y        ; save array name 1st byte
  4108 00:E67E: C8                 INY                     ; increment index
  4109 00:E67F: A5 94              LDA   Varnm2            ; get variable name 2nd byte
  4110 00:E681: 91 AA              STA   (Astrtl),Y        ; save array name 2nd byte
  4111 00:E683: A5 5D              LDA   Dimcnt            ; get dimensions count
  4112 00:E685: A0 04              LDY   #$04              ; index to dimension count
  4113 00:E687: 84 BA              STY   Asptl             ; set array data size low byte (four bytes per element)
  4114 00:E689: 91 AA              STA   (Astrtl),Y        ; set array's dimensions count
  4115                        
  4116                                                      ; now calculate the size of the data space for the array
  4117 00:E68B: 18                 CLC                     ; clear carry for add (clear on subsequent loops)
  4118                        LAB_1EC0
  4119 00:E68C: A2 0B              LDX   #$0B              ; set default dimension value low byte
  4120 00:E68E: A9 00              LDA   #$00              ; set default dimension value high byte
  4121 00:E690: 24 5E              BIT   Defdim            ; test default DIM flag
  4122 00:E692: 50 07              BVC   LAB_1ED0          ; branch if b6 of Defdim is clear
  4123                        
  4124 00:E694: 68                 PLA                     ; else pull dimension value low byte
  4125 00:E695: 69 01              ADC   #$01              ; +1 (allow for zeroeth element)
  4126 00:E697: AA                 TAX                     ; copy low byte to X
  4127 00:E698: 68                 PLA                     ; pull dimension value high byte
  4128 00:E699: 69 00              ADC   #$00              ; add carry from low byte
  4129                        
  4130                        LAB_1ED0
  4131 00:E69B: C8                 INY                     ; index to dimension value high byte
  4132 00:E69C: 91 AA              STA   (Astrtl),Y        ; save dimension value high byte
  4133 00:E69E: C8                 INY                     ; index to dimension value high byte
  4134 00:E69F: 8A                 TXA                     ; get dimension value low byte
  4135 00:E6A0: 91 AA              STA   (Astrtl),Y        ; save dimension value low byte
  4136 00:E6A2: 20 42 E7           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
  4137 00:E6A5: 86 BA              STX   Asptl             ; save array data size low byte
  4138 00:E6A7: 85 BB              STA   Aspth             ; save array data size high byte
  4139 00:E6A9: A4 71              LDY   ut1_pl            ; restore index (saved by subroutine)
  4140 00:E6AB: C6 5D              DEC   Dimcnt            ; decrement dimensions count
  4141 00:E6AD: D0 DD              BNE   LAB_1EC0          ; loop while not = 0
  4142                        
  4143 00:E6AF: 65 A5              ADC   Adatah            ; add size high byte to first element high byte
  4144                                                      ; (carry is always clear here)
  4145 00:E6B1: B0 5D              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
  4146                        
  4147 00:E6B3: 85 A5              STA   Adatah            ; save end of array high byte
  4148 00:E6B5: A8                 TAY                     ; copy end high byte to Y
  4149 00:E6B6: 8A                 TXA                     ; get array size low byte
  4150 00:E6B7: 65 A4              ADC   Adatal            ; add array start low byte
  4151 00:E6B9: 90 03              BCC   LAB_1EF3          ; branch if no carry
  4152                        
  4153 00:E6BB: C8                 INY                     ; else increment end of array high byte
  4154 00:E6BC: F0 52              BEQ   LAB_1F45          ; if overflow go do "Out of memory" error
  4155                        
  4156                                                      ; set-up mostly complete, now zero the array
  4157                        LAB_1EF3
  4158 00:E6BE: 20 2E D8           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
  4159                                                      ; addr to check is in AY (low/high)
  4160 00:E6C1: 85 7F              STA   Earryl            ; save array mem end low byte
  4161 00:E6C3: 84 80              STY   Earryh            ; save array mem end high byte
  4162 00:E6C5: A9 00              LDA   #$00              ; clear byte for array clear
  4163 00:E6C7: E6 BB              INC   Aspth             ; increment array size high byte (now block count)
  4164 00:E6C9: A4 BA              LDY   Asptl             ; get array size low byte (now index to block)
  4165 00:E6CB: F0 05              BEQ   LAB_1F07          ; branch if low byte = $00
  4166                        
  4167                        LAB_1F02
  4168 00:E6CD: 88                 DEY                     ; decrement index (do 0 to n-1)
  4169 00:E6CE: 91 A4              STA   (Adatal),Y        ; zero byte
  4170 00:E6D0: D0 FB              BNE   LAB_1F02          ; loop until this block done
  4171                        
  4172                        LAB_1F07
  4173 00:E6D2: C6 A5              DEC   Adatah            ; decrement array pointer high byte
  4174 00:E6D4: C6 BB              DEC   Aspth             ; decrement block count high byte
  4175 00:E6D6: D0 F5              BNE   LAB_1F02          ; loop until all blocks done
  4176                        
  4177 00:E6D8: E6 A5              INC   Adatah            ; correct for last loop
  4178 00:E6DA: 38                 SEC                     ; set carry for subtract
  4179 00:E6DB: A0 02              LDY   #$02              ; index to array size low byte
  4180 00:E6DD: A5 7F              LDA   Earryl            ; get array mem end low byte
  4181 00:E6DF: E5 AA              SBC   Astrtl            ; subtract array start low byte
  4182 00:E6E1: 91 AA              STA   (Astrtl),Y        ; save array size low byte
  4183 00:E6E3: C8                 INY                     ; index to array size high byte
  4184 00:E6E4: A5 80              LDA   Earryh            ; get array mem end high byte
  4185 00:E6E6: E5 AB              SBC   Astrth            ; subtract array start high byte
  4186 00:E6E8: 91 AA              STA   (Astrtl),Y        ; save array size high byte
  4187 00:E6EA: A5 5E              LDA   Defdim            ; get default DIM flag
  4188 00:E6EC: D0 53              BNE   LAB_1F7B          ; exit (RET) if this was a DIM command
  4189                        
  4190                                                      ; else, find element
  4191 00:E6EE: C8                 INY                     ; index to # of dimensions
  4192                        
  4193                        LAB_1F24
  4194 00:E6EF: B1 AA              LDA   (Astrtl),Y        ; get array's dimension count
  4195 00:E6F1: 85 5D              STA   Dimcnt            ; save it
  4196                        
  4197                        ; we have found, or built, the array. now we need to find the element
  4198                        
  4199                        LAB_1F28
  4200 00:E6F3: A9 00              LDA   #$00              ; clear byte
  4201 00:E6F5: 85 BA              STA   Asptl             ; clear array data pointer low byte
  4202                        LAB_1F2C
  4203 00:E6F7: 85 BB              STA   Aspth             ; save array data pointer high byte
  4204 00:E6F9: C8                 INY                     ; increment index (point to array bound high byte)
  4205 00:E6FA: 68                 PLA                     ; pull array index low byte
  4206 00:E6FB: AA                 TAX                     ; copy to X
  4207 00:E6FC: 85 AE              STA   FAC1_2            ; save index low byte to FAC1 mantissa2
  4208 00:E6FE: 68                 PLA                     ; pull array index high byte
  4209 00:E6FF: 85 AF              STA   FAC1_3            ; save index high byte to FAC1 mantissa3
  4210 00:E701: D1 AA              CMP   (Astrtl),Y        ; compare with array bound high byte
  4211 00:E703: 90 0E              BCC   LAB_1F48          ; branch if within bounds
  4212                        
  4213 00:E705: D0 06              BNE   LAB_1F42          ; if outside bounds do array bounds error
  4214                        
  4215                                                      ; else high byte was = so test low bytes
  4216 00:E707: C8                 INY                     ; index to array bound low byte
  4217 00:E708: 8A                 TXA                     ; get array index low byte
  4218 00:E709: D1 AA              CMP   (Astrtl),Y        ; compare with array bound low byte
  4219 00:E70B: 90 07              BCC   LAB_1F49          ; branch if within bounds
  4220                        
  4221                        LAB_1F42
  4222 00:E70D: 4C 54 E6           JMP   LAB_1E85          ; else do array bounds error
  4223                        
  4224                        LAB_1F45
  4225 00:E710: 4C 5D D8           JMP   LAB_OMER          ; do "Out of memory" error then warm start
  4226                        
  4227                        LAB_1F48
  4228 00:E713: C8                 INY                     ; index to array bound low byte
  4229                        LAB_1F49
  4230 00:E714: A5 BB              LDA   Aspth             ; get array data pointer high byte
  4231 00:E716: 05 BA              ORA   Asptl             ; OR with array data pointer low byte
  4232 00:E718: F0 0A              BEQ   LAB_1F5A          ; branch if array data pointer = null (skip multiply)
  4233                        
  4234 00:E71A: 20 42 E7           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
  4235 00:E71D: 8A                 TXA                     ; get result low byte
  4236 00:E71E: 65 AE              ADC   FAC1_2            ; add index low byte from FAC1 mantissa2
  4237 00:E720: AA                 TAX                     ; save result low byte
  4238 00:E721: 98                 TYA                     ; get result high byte
  4239 00:E722: A4 71              LDY   ut1_pl            ; restore index
  4240                        LAB_1F5A
  4241 00:E724: 65 AF              ADC   FAC1_3            ; add index high byte from FAC1 mantissa3
  4242 00:E726: 86 BA              STX   Asptl             ; save array data pointer low byte
  4243 00:E728: C6 5D              DEC   Dimcnt            ; decrement dimensions count
  4244 00:E72A: D0 CB              BNE   LAB_1F2C          ; loop if dimensions still to do
  4245                        
  4246 00:E72C: 06 BA              ASL   Asptl             ; array data pointer low byte * 2
  4247 00:E72E: 2A                 ROL                     ; array data pointer high byte * 2
  4248 00:E72F: 06 BA              ASL   Asptl             ; array data pointer low byte * 4
  4249 00:E731: 2A                 ROL                     ; array data pointer high byte * 4
  4250 00:E732: A8                 TAY                     ; copy high byte
  4251 00:E733: A5 BA              LDA   Asptl             ; get low byte
  4252 00:E735: 65 A4              ADC   Adatal            ; add array data start pointer low byte
  4253 00:E737: 85 95              STA   Cvaral            ; save as current var address low byte
  4254 00:E739: 98                 TYA                     ; get high byte back
  4255 00:E73A: 65 A5              ADC   Adatah            ; add array data start pointer high byte
  4256 00:E73C: 85 96              STA   Cvarah            ; save as current var address high byte
  4257 00:E73E: A8                 TAY                     ; copy high byte to Y
  4258 00:E73F: A5 95              LDA   Cvaral            ; get current var address low byte
  4259                        LAB_1F7B
  4260 00:E741: 60                 RTS
  4261                        
  4262                        ; does XY = (Astrtl),Y * (Asptl)
  4263                        
  4264                        LAB_1F7C
  4265 00:E742: 84 71              STY   ut1_pl            ; save index
  4266 00:E744: B1 AA              LDA   (Astrtl),Y        ; get dimension size low byte
  4267 00:E746: 85 76              STA   dims_l            ; save dimension size low byte
  4268 00:E748: 88                 DEY                     ; decrement index
  4269 00:E749: B1 AA              LDA   (Astrtl),Y        ; get dimension size high byte
  4270 00:E74B: 85 77              STA   dims_h            ; save dimension size high byte
  4271                        
  4272 00:E74D: A9 10              LDA   #$10              ; count = $10 (16 bit multiply)
  4273 00:E74F: 85 A8              STA   numbit            ; save bit count
  4274 00:E751: A2 00              LDX   #$00              ; clear result low byte
  4275 00:E753: A0 00              LDY   #$00              ; clear result high byte
  4276                        LAB_1F8F
  4277 00:E755: 8A                 TXA                     ; get result low byte
  4278 00:E756: 0A                 ASL                     ; *2
  4279 00:E757: AA                 TAX                     ; save result low byte
  4280 00:E758: 98                 TYA                     ; get result high byte
  4281 00:E759: 2A                 ROL                     ; *2
  4282 00:E75A: A8                 TAY                     ; save result high byte
  4283 00:E75B: B0 B3              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
  4284                        
  4285 00:E75D: 06 BA              ASL   Asptl             ; shift multiplier low byte
  4286 00:E75F: 26 BB              ROL   Aspth             ; shift multiplier high byte
  4287 00:E761: 90 0B              BCC   LAB_1FA8          ; skip add if no carry
  4288                        
  4289 00:E763: 18                 CLC                     ; else clear carry for add
  4290 00:E764: 8A                 TXA                     ; get result low byte
  4291 00:E765: 65 76              ADC   dims_l            ; add dimension size low byte
  4292 00:E767: AA                 TAX                     ; save result low byte
  4293 00:E768: 98                 TYA                     ; get result high byte
  4294 00:E769: 65 77              ADC   dims_h            ; add dimension size high byte
  4295 00:E76B: A8                 TAY                     ; save result high byte
  4296 00:E76C: B0 A2              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
  4297                        
  4298                        LAB_1FA8
  4299 00:E76E: C6 A8              DEC   numbit            ; decrement bit count
  4300 00:E770: D0 E3              BNE   LAB_1F8F          ; loop until all done
  4301                        
  4302 00:E772: 60                 RTS
  4303                        
  4304                        ; perform FRE()
  4305                        
  4306                        LAB_FRE
  4307 00:E773: A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
  4308 00:E775: 10 03              BPL   LAB_1FB4          ; branch if numeric
  4309                        
  4310 00:E777: 20 72 EA           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
  4311                                                      ; space returns with A = length, X=$71=pointer low byte,
  4312                                                      ; Y=$72=pointer high byte
  4313                        
  4314                                                      ; FRE(n) was numeric so do this
  4315                        LAB_1FB4
  4316 00:E77A: 20 0F E9           JSR   LAB_GARB          ; go do garbage collection
  4317 00:E77D: 38                 SEC                     ; set carry for subtract
  4318 00:E77E: A5 81              LDA   Sstorl            ; get bottom of string space low byte
  4319 00:E780: E5 7F              SBC   Earryl            ; subtract array mem end low byte
  4320 00:E782: A8                 TAY                     ; copy result to Y
  4321 00:E783: A5 82              LDA   Sstorh            ; get bottom of string space high byte
  4322 00:E785: E5 80              SBC   Earryh            ; subtract array mem end high byte
  4323                        
  4324                        ; save and convert integer AY to FAC1
  4325                        
  4326                        LAB_AYFC
  4327 00:E787: 46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  4328 00:E789: 85 AD              STA   FAC1_1            ; save FAC1 mantissa1
  4329 00:E78B: 84 AE              STY   FAC1_2            ; save FAC1 mantissa2
  4330 00:E78D: A2 90              LDX   #$90              ; set exponent=2^16 (integer)
  4331 00:E78F: 4C 2F F0           JMP   LAB_27E3          ; set exp=X, clear FAC1_3, normalise and return
  4332                        
  4333                        ; perform POS()
  4334                        
  4335                        LAB_POS
  4336 00:E792: A4 0E              LDY   TPos              ; get terminal position
  4337                        
  4338                        ; convert Y to byte in FAC1
  4339                        
  4340                        LAB_1FD0
  4341 00:E794: A9 00              LDA   #$00              ; clear high byte
  4342 00:E796: F0 EF              BEQ   LAB_AYFC          ; always save and convert integer AY to FAC1 and return
  4343                        
  4344                        ; check not Direct (used by DEF and INPUT)
  4345                        
  4346                        LAB_CKRN
  4347 00:E798: A6 88              LDX   Clineh            ; get current line high byte
  4348 00:E79A: E8                 INX                     ; increment it
  4349 00:E79B: D0 A4              BNE   LAB_1F7B          ; return if can continue not direct mode
  4350                        
  4351                                                      ; else do illegal direct error
  4352                        LAB_1FD9
  4353 00:E79D: A2 16              LDX   #$16              ; error code $16 ("Illegal direct" error)
  4354                        LAB_1FDB
  4355 00:E79F: 4C 5F D8           JMP   LAB_XERR          ; go do error #X, then warm start
  4356                        
  4357                        ; perform DEF
  4358                        
  4359                        LAB_DEF
  4360 00:E7A2: 20 D3 E7           JSR   LAB_200B          ; check FNx syntax
  4361 00:E7A5: 85 9C              STA   func_l            ; save function pointer low byte
  4362 00:E7A7: 84 9D              STY   func_h            ; save function pointer high byte
  4363 00:E7A9: 20 98 E7           JSR   LAB_CKRN          ; check not Direct (back here if ok)
  4364 00:E7AC: 20 1A E3           JSR   LAB_1BFE          ; scan for "(" , else do syntax error then warm start
  4365 00:E7AF: A9 80              LDA   #$80              ; set flag for FNx
  4366 00:E7B1: 85 61              STA   Sufnxf            ; save subscript/FNx flag
  4367 00:E7B3: 20 D8 E4           JSR   LAB_GVAR          ; get (var) address
  4368 00:E7B6: 20 F0 E1           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  4369 00:E7B9: 20 0F E3           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
  4370 00:E7BC: A9 C1              LDA   #TK_EQUAL         ; get = token
  4371 00:E7BE: 20 11 E3           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
  4372 00:E7C1: A5 96              LDA   Cvarah            ; get current var address high byte
  4373 00:E7C3: 48                 PHA                     ; push it
  4374 00:E7C4: A5 95              LDA   Cvaral            ; get current var address low byte
  4375 00:E7C6: 48                 PHA                     ; push it
  4376 00:E7C7: A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
  4377 00:E7C9: 48                 PHA                     ; push it
  4378 00:E7CA: A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
  4379 00:E7CC: 48                 PHA                     ; push it
  4380 00:E7CD: 20 AA DD           JSR   LAB_DATA          ; go perform DATA
  4381 00:E7D0: 4C 42 E8           JMP   LAB_207A          ; put execute pointer and variable pointer into function
  4382                                                      ; and return
  4383                        
  4384                        ; check FNx syntax
  4385                        
  4386                        LAB_200B
  4387 00:E7D3: A9 AE              LDA   #TK_FN            ; get FN" token
  4388 00:E7D5: 20 11 E3           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
  4389                                                      ; return character after A
  4390 00:E7D8: 09 80              ORA   #$80              ; set FN flag bit
  4391 00:E7DA: 85 61              STA   Sufnxf            ; save FN flag so array variable test fails
  4392 00:E7DC: 20 DF E4           JSR   LAB_1D12          ; search for FN variable
  4393 00:E7DF: 4C F0 E1           JMP   LAB_CTNM          ; check if source is numeric and return, else do type
  4394                                                      ; mismatch
  4395                        
  4396                                                      ; Evaluate FNx
  4397                        LAB_201E
  4398 00:E7E2: 20 D3 E7           JSR   LAB_200B          ; check FNx syntax
  4399 00:E7E5: 48                 PHA                     ; push function pointer low byte
  4400 00:E7E6: 98                 TYA                     ; copy function pointer high byte
  4401 00:E7E7: 48                 PHA                     ; push function pointer high byte
  4402 00:E7E8: 20 1A E3           JSR   LAB_1BFE          ; scan for "(", else do syntax error then warm start
  4403 00:E7EB: 20 01 E2           JSR   LAB_EVEX          ; evaluate expression
  4404 00:E7EE: 20 0F E3           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
  4405 00:E7F1: 20 F0 E1           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  4406 00:E7F4: 68                 PLA                     ; pop function pointer high byte
  4407 00:E7F5: 85 9D              STA   func_h            ; restore it
  4408 00:E7F7: 68                 PLA                     ; pop function pointer low byte
  4409 00:E7F8: 85 9C              STA   func_l            ; restore it
  4410 00:E7FA: A2 20              LDX   #$20              ; error code $20 ("Undefined function" error)
  4411 00:E7FC: A0 03              LDY   #$03              ; index to variable pointer high byte
  4412 00:E7FE: B1 9C              LDA   (func_l),Y        ; get variable pointer high byte
  4413 00:E800: F0 9D              BEQ   LAB_1FDB          ; if zero go do undefined function error
  4414                        
  4415 00:E802: 85 96              STA   Cvarah            ; save variable address high byte
  4416 00:E804: 88                 DEY                     ; index to variable address low byte
  4417 00:E805: B1 9C              LDA   (func_l),Y        ; get variable address low byte
  4418 00:E807: 85 95              STA   Cvaral            ; save variable address low byte
  4419 00:E809: AA                 TAX                     ; copy address low byte
  4420                        
  4421                                                      ; now stack the function variable value before use
  4422 00:E80A: C8                 INY                     ; index to mantissa_3
  4423                        LAB_2043
  4424 00:E80B: B1 95              LDA   (Cvaral),Y        ; get byte from variable
  4425 00:E80D: 48                 PHA                     ; stack it
  4426 00:E80E: 88                 DEY                     ; decrement index
  4427 00:E80F: 10 FA              BPL   LAB_2043          ; loop until variable stacked
  4428                        
  4429 00:E811: A4 96              LDY   Cvarah            ; get variable address high byte
  4430 00:E813: 20 D4 EF           JSR   LAB_2778          ; pack FAC1 (function expression value) into (XY)
  4431                                                      ; (function variable), return Y=0, always
  4432 00:E816: A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
  4433 00:E818: 48                 PHA                     ; push it
  4434 00:E819: A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
  4435 00:E81B: 48                 PHA                     ; push it
  4436 00:E81C: B1 9C              LDA   (func_l),Y        ; get function execute pointer low byte
  4437 00:E81E: 85 C3              STA   Bpntrl            ; save as BASIC execute pointer low byte
  4438 00:E820: C8                 INY                     ; index to high byte
  4439 00:E821: B1 9C              LDA   (func_l),Y        ; get function execute pointer high byte
  4440 00:E823: 85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
  4441 00:E825: A5 96              LDA   Cvarah            ; get variable address high byte
  4442 00:E827: 48                 PHA                     ; push it
  4443 00:E828: A5 95              LDA   Cvaral            ; get variable address low byte
  4444 00:E82A: 48                 PHA                     ; push it
  4445 00:E82B: 20 ED E1           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  4446                                                      ; else do type mismatch
  4447 00:E82E: 68                 PLA                     ; pull variable address low byte
  4448 00:E82F: 85 9C              STA   func_l            ; save variable address low byte
  4449 00:E831: 68                 PLA                     ; pull variable address high byte
  4450 00:E832: 85 9D              STA   func_h            ; save variable address high byte
  4451 00:E834: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  4452 00:E837: F0 03              BEQ   LAB_2074          ; branch if null (should be [EOL] marker)
  4453                        
  4454 00:E839: 4C 22 E3           JMP   LAB_SNER          ; else syntax error then warm start
  4455                        
  4456                        ; restore Bpntrl,Bpntrh and function variable from stack
  4457                        
  4458                        LAB_2074
  4459 00:E83C: 68                 PLA                     ; pull BASIC execute pointer low byte
  4460 00:E83D: 85 C3              STA   Bpntrl            ; restore BASIC execute pointer low byte
  4461 00:E83F: 68                 PLA                     ; pull BASIC execute pointer high byte
  4462 00:E840: 85 C4              STA   Bpntrh            ; restore BASIC execute pointer high byte
  4463                        
  4464                        ; put execute pointer and variable pointer into function
  4465                        
  4466                        LAB_207A
  4467 00:E842: A0 00              LDY   #$00              ; clear index
  4468 00:E844: 68                 PLA                     ; pull BASIC execute pointer low byte
  4469 00:E845: 91 9C              STA   (func_l),Y        ; save to function
  4470 00:E847: C8                 INY                     ; increment index
  4471 00:E848: 68                 PLA                     ; pull BASIC execute pointer high byte
  4472 00:E849: 91 9C              STA   (func_l),Y        ; save to function
  4473 00:E84B: C8                 INY                     ; increment index
  4474 00:E84C: 68                 PLA                     ; pull current var address low byte
  4475 00:E84D: 91 9C              STA   (func_l),Y        ; save to function
  4476 00:E84F: C8                 INY                     ; increment index
  4477 00:E850: 68                 PLA                     ; pull current var address high byte
  4478 00:E851: 91 9C              STA   (func_l),Y        ; save to function
  4479 00:E853: 60                 RTS
  4480                        
  4481                        ; perform STR$()
  4482                        
  4483                        LAB_STRS
  4484 00:E854: 20 F0 E1           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
  4485 00:E857: 20 C2 F1           JSR   LAB_296E          ; convert FAC1 to string
  4486 00:E85A: A9 F0              LDA   #<Decssp1         ; set result string low pointer
  4487 00:E85C: A0 00              LDY   #>Decssp1         ; set result string high pointer
  4488 00:E85E: F0 12              BEQ   LAB_20AE          ; print null terminated string to Sutill/Sutilh
  4489                        
  4490                        ; Do string vector
  4491                        ; copy des_pl/h to des_2l/h and make string space A bytes long
  4492                        
  4493                        LAB_209C
  4494 00:E860: A6 AE              LDX   des_pl            ; get descriptor pointer low byte
  4495 00:E862: A4 AF              LDY   des_ph            ; get descriptor pointer high byte
  4496 00:E864: 86 9E              STX   des_2l            ; save descriptor pointer low byte
  4497 00:E866: 84 9F              STY   des_2h            ; save descriptor pointer high byte
  4498                        
  4499                        ; make string space A bytes long
  4500                        ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4501                        
  4502                        LAB_MSSP
  4503 00:E868: 20 DD E8           JSR   LAB_2115          ; make space in string memory for string A long
  4504                                                      ; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  4505 00:E86B: 86 AD              STX   str_pl            ; save string pointer low byte
  4506 00:E86D: 84 AE              STY   str_ph            ; save string pointer high byte
  4507 00:E86F: 85 AC              STA   str_ln            ; save length
  4508 00:E871: 60                 RTS
  4509                        
  4510                        ; Scan, set up string
  4511                        ; print " terminated string to Sutill/Sutilh
  4512                        
  4513                        LAB_20AE
  4514 00:E872: A2 22              LDX   #$22              ; set terminator to "
  4515 00:E874: 86 5B              STX   Srchc             ; set search character (terminator 1)
  4516 00:E876: 86 5C              STX   Asrch             ; set terminator 2
  4517                        
  4518                        ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
  4519                        ; source is AY
  4520                        
  4521                        LAB_20B4
  4522 00:E878: 85 B8              STA   ssptr_l           ; store string start low byte
  4523 00:E87A: 84 B9              STY   ssptr_h           ; store string start high byte
  4524 00:E87C: 85 AD              STA   str_pl            ; save string pointer low byte
  4525 00:E87E: 84 AE              STY   str_ph            ; save string pointer high byte
  4526 00:E880: A0 FF              LDY   #$FF              ; set length to -1
  4527                        LAB_20BE
  4528 00:E882: C8                 INY                     ; increment length
  4529 00:E883: B1 B8              LDA   (ssptr_l),Y       ; get byte from string
  4530 00:E885: F0 0C              BEQ   LAB_20CF          ; exit loop if null byte [EOS]
  4531                        
  4532 00:E887: C5 5B              CMP   Srchc             ; compare with search character (terminator 1)
  4533 00:E889: F0 04              BEQ   LAB_20CB          ; branch if terminator
  4534                        
  4535 00:E88B: C5 5C              CMP   Asrch             ; compare with terminator 2
  4536 00:E88D: D0 F3              BNE   LAB_20BE          ; loop if not terminator 2
  4537                        
  4538                        LAB_20CB
  4539 00:E88F: C9 22              CMP   #$22              ; compare with "
  4540 00:E891: F0 01              BEQ   LAB_20D0          ; branch if " (carry set if = !)
  4541                        
  4542                        LAB_20CF
  4543 00:E893: 18                 CLC                     ; clear carry for add (only if [EOL] terminated string)
  4544                        LAB_20D0
  4545 00:E894: 84 AC              STY   str_ln            ; save length in FAC1 exponent
  4546 00:E896: 98                 TYA                     ; copy length to A
  4547 00:E897: 65 B8              ADC   ssptr_l           ; add string start low byte
  4548 00:E899: 85 BA              STA   Sendl             ; save string end low byte
  4549 00:E89B: A6 B9              LDX   ssptr_h           ; get string start high byte
  4550 00:E89D: 90 01              BCC   LAB_20DC          ; branch if no low byte overflow
  4551                        
  4552 00:E89F: E8                 INX                     ; else increment high byte
  4553                        LAB_20DC
  4554 00:E8A0: 86 BB              STX   Sendh             ; save string end high byte
  4555 00:E8A2: A5 B9              LDA   ssptr_h           ; get string start high byte
  4556                        ; *** begin RAM above code / Ibuff above EhBASIC patch V2 ***
  4557                        ; *** replace
  4558                        ;      CMP   #>Ram_base        ; compare with start of program memory
  4559                        ;      BCS   LAB_RTST          ; branch if not in utility area
  4560                        ; *** with
  4561 00:E8A4: F0 04              BEQ   LAB_MVST          ; fix STR$() using page zero via LAB_296E
  4562 00:E8A6: C9 02              CMP   #>Ibuffs          ; compare with location of input buffer page
  4563 00:E8A8: D0 0B              BNE   LAB_RTST          ; branch if not in utility area
  4564                        LAB_MVST      
  4565                        ; *** end   RAM above code / Ibuff above EhBASIC patch V2 ***
  4566                        
  4567                                                      ; string in utility area, move to string memory
  4568 00:E8AA: 98                 TYA                     ; copy length to A
  4569 00:E8AB: 20 60 E8           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
  4570                                                      ; long
  4571 00:E8AE: A6 B8              LDX   ssptr_l           ; get string start low byte
  4572 00:E8B0: A4 B9              LDY   ssptr_h           ; get string start high byte
  4573 00:E8B2: 20 53 EA           JSR   LAB_2298          ; store string A bytes long from XY to (Sutill)
  4574                        
  4575                        ; check for space on descriptor stack then ..
  4576                        ; put string address and length on descriptor stack and update stack pointers
  4577                        
  4578                        LAB_RTST
  4579 00:E8B5: A6 65              LDX   next_s            ; get string stack pointer
  4580 00:E8B7: E0 71              CPX   #des_sk+$09       ; compare with max+1
  4581 00:E8B9: D0 05              BNE   LAB_20F8          ; branch if space on string stack
  4582                        
  4583                                                      ; else do string too complex error
  4584 00:E8BB: A2 1C              LDX   #$1C              ; error code $1C ("String too complex" error)
  4585                        LAB_20F5
  4586 00:E8BD: 4C 5F D8           JMP   LAB_XERR          ; do error #X, then warm start
  4587                        
  4588                        ; put string address and length on descriptor stack and update stack pointers
  4589                        
  4590                        LAB_20F8
  4591 00:E8C0: A5 AC              LDA   str_ln            ; get string length
  4592 00:E8C2: 95 00              STA   PLUS_0,X          ; put on string stack
  4593 00:E8C4: A5 AD              LDA   str_pl            ; get string pointer low byte
  4594 00:E8C6: 95 01              STA   PLUS_1,X          ; put on string stack
  4595 00:E8C8: A5 AE              LDA   str_ph            ; get string pointer high byte
  4596 00:E8CA: 95 02              STA   PLUS_2,X          ; put on string stack
  4597 00:E8CC: A0 00              LDY   #$00              ; clear Y
  4598 00:E8CE: 86 AE              STX   des_pl            ; save string descriptor pointer low byte
  4599 00:E8D0: 84 AF              STY   des_ph            ; save string descriptor pointer high byte (always $00)
  4600 00:E8D2: 88                 DEY                     ; Y = $FF
  4601 00:E8D3: 84 5F              STY   Dtypef            ; save data type flag, $FF=string
  4602 00:E8D5: 86 66              STX   last_sl           ; save old stack pointer (current top item)
  4603 00:E8D7: E8                 INX                     ; update stack pointer
  4604 00:E8D8: E8                 INX                     ; update stack pointer
  4605 00:E8D9: E8                 INX                     ; update stack pointer
  4606 00:E8DA: 86 65              STX   next_s            ; save new top item value
  4607 00:E8DC: 60                 RTS
  4608                        
  4609                        ; Build descriptor
  4610                        ; make space in string memory for string A long
  4611                        ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
  4612                        
  4613                        LAB_2115
  4614 00:E8DD: 46 60              LSR   Gclctd            ; clear garbage collected flag (b7)
  4615                        
  4616                                                      ; make space for string A long
  4617                        LAB_2117
  4618 00:E8DF: 48                 PHA                     ; save string length
  4619 00:E8E0: 49 FF              EOR   #$FF              ; complement it
  4620 00:E8E2: 38                 SEC                     ; set carry for subtract (twos comp add)
  4621 00:E8E3: 65 81              ADC   Sstorl            ; add bottom of string space low byte (subtract length)
  4622 00:E8E5: A4 82              LDY   Sstorh            ; get bottom of string space high byte
  4623 00:E8E7: B0 01              BCS   LAB_2122          ; skip decrement if no underflow
  4624                        
  4625 00:E8E9: 88                 DEY                     ; decrement bottom of string space high byte
  4626                        LAB_2122
  4627 00:E8EA: C4 80              CPY   Earryh            ; compare with array mem end high byte
  4628 00:E8EC: 90 11              BCC   LAB_2137          ; do out of memory error if less
  4629                        
  4630 00:E8EE: D0 04              BNE   LAB_212C          ; if not = skip next test
  4631                        
  4632 00:E8F0: C5 7F              CMP   Earryl            ; compare with array mem end low byte
  4633 00:E8F2: 90 0B              BCC   LAB_2137          ; do out of memory error if less
  4634                        
  4635                        LAB_212C
  4636 00:E8F4: 85 81              STA   Sstorl            ; save bottom of string space low byte
  4637 00:E8F6: 84 82              STY   Sstorh            ; save bottom of string space high byte
  4638 00:E8F8: 85 83              STA   Sutill            ; save string utility ptr low byte
  4639 00:E8FA: 84 84              STY   Sutilh            ; save string utility ptr high byte
  4640 00:E8FC: AA                 TAX                     ; copy low byte to X
  4641 00:E8FD: 68                 PLA                     ; get string length back
  4642 00:E8FE: 60                 RTS
  4643                        
  4644                        LAB_2137
  4645 00:E8FF: A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
  4646 00:E901: A5 60              LDA   Gclctd            ; get garbage collected flag
  4647 00:E903: 30 B8              BMI   LAB_20F5          ; if set then do error code X
  4648                        
  4649 00:E905: 20 0F E9           JSR   LAB_GARB          ; else go do garbage collection
  4650 00:E908: A9 80              LDA   #$80              ; flag for garbage collected
  4651 00:E90A: 85 60              STA   Gclctd            ; set garbage collected flag
  4652 00:E90C: 68                 PLA                     ; pull length
  4653 00:E90D: D0 D0              BNE   LAB_2117          ; go try again (loop always, length should never be = $00)
  4654                        
  4655                        ; garbage collection routine
  4656                        
  4657                        LAB_GARB
  4658 00:E90F: A6 85              LDX   Ememl             ; get end of mem low byte
  4659 00:E911: A5 86              LDA   Ememh             ; get end of mem high byte
  4660                        
  4661                        ; re-run routine from last ending
  4662                        
  4663                        LAB_214B
  4664 00:E913: 86 81              STX   Sstorl            ; set string storage low byte
  4665 00:E915: 85 82              STA   Sstorh            ; set string storage high byte
  4666 00:E917: A0 00              LDY   #$00              ; clear index
  4667 00:E919: 84 9D              STY   garb_h            ; clear working pointer high byte (flag no strings to move)
  4668                        ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
  4669                        ; *** add
  4670 00:E91B: 84 9C              STY   garb_l            ; clear working pointer low byte (flag no strings to move)
  4671                        ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
  4672 00:E91D: A5 7F              LDA   Earryl            ; get array mem end low byte
  4673 00:E91F: A6 80              LDX   Earryh            ; get array mem end high byte
  4674 00:E921: 85 AA              STA   Histrl            ; save as highest string low byte
  4675 00:E923: 86 AB              STX   Histrh            ; save as highest string high byte
  4676 00:E925: A9 68              LDA   #des_sk           ; set descriptor stack pointer
  4677 00:E927: 85 71              STA   ut1_pl            ; save descriptor stack pointer low byte
  4678 00:E929: 84 72              STY   ut1_ph            ; save descriptor stack pointer high byte ($00)
  4679                        LAB_2161
  4680 00:E92B: C5 65              CMP   next_s            ; compare with descriptor stack pointer
  4681 00:E92D: F0 05              BEQ   LAB_216A          ; branch if =
  4682                        
  4683 00:E92F: 20 95 E9           JSR   LAB_21D7          ; go garbage collect descriptor stack
  4684 00:E932: F0 F7              BEQ   LAB_2161          ; loop always
  4685                        
  4686                                                      ; done stacked strings, now do string vars
  4687                        LAB_216A
  4688 00:E934: 06 A0              ASL   g_step            ; set step size = $06
  4689 00:E936: A5 7B              LDA   Svarl             ; get start of vars low byte
  4690 00:E938: A6 7C              LDX   Svarh             ; get start of vars high byte
  4691 00:E93A: 85 71              STA   ut1_pl            ; save as pointer low byte
  4692 00:E93C: 86 72              STX   ut1_ph            ; save as pointer high byte
  4693                        LAB_2176
  4694 00:E93E: E4 7E              CPX   Sarryh            ; compare start of arrays high byte
  4695 00:E940: D0 04              BNE   LAB_217E          ; branch if no high byte match
  4696                        
  4697 00:E942: C5 7D              CMP   Sarryl            ; else compare start of arrays low byte
  4698 00:E944: F0 05              BEQ   LAB_2183          ; branch if = var mem end
  4699                        
  4700                        LAB_217E
  4701 00:E946: 20 8F E9           JSR   LAB_21D1          ; go garbage collect strings
  4702 00:E949: F0 F3              BEQ   LAB_2176          ; loop always
  4703                        
  4704                                                      ; done string vars, now do string arrays
  4705                        LAB_2183
  4706 00:E94B: 85 A4              STA   Nbendl            ; save start of arrays low byte as working pointer
  4707 00:E94D: 86 A5              STX   Nbendh            ; save start of arrays high byte as working pointer
  4708 00:E94F: A9 04              LDA   #$04              ; set step size
  4709 00:E951: 85 A0              STA   g_step            ; save step size
  4710                        LAB_218B
  4711 00:E953: A5 A4              LDA   Nbendl            ; get pointer low byte
  4712 00:E955: A6 A5              LDX   Nbendh            ; get pointer high byte
  4713                        LAB_218F
  4714 00:E957: E4 80              CPX   Earryh            ; compare with array mem end high byte
  4715 00:E959: D0 04              BNE   LAB_219A          ; branch if not at end
  4716                        
  4717 00:E95B: C5 7F              CMP   Earryl            ; else compare with array mem end low byte
  4718 00:E95D: F0 75              BEQ   LAB_2216          ; tidy up and exit if at end
  4719                        
  4720                        LAB_219A
  4721 00:E95F: 85 71              STA   ut1_pl            ; save pointer low byte
  4722 00:E961: 86 72              STX   ut1_ph            ; save pointer high byte
  4723 00:E963: A0 02              LDY   #$02              ; set index
  4724 00:E965: B1 71              LDA   (ut1_pl),Y        ; get array size low byte
  4725 00:E967: 65 A4              ADC   Nbendl            ; add start of this array low byte
  4726 00:E969: 85 A4              STA   Nbendl            ; save start of next array low byte
  4727 00:E96B: C8                 INY                     ; increment index
  4728 00:E96C: B1 71              LDA   (ut1_pl),Y        ; get array size high byte
  4729 00:E96E: 65 A5              ADC   Nbendh            ; add start of this array high byte
  4730 00:E970: 85 A5              STA   Nbendh            ; save start of next array high byte
  4731 00:E972: A0 01              LDY   #$01              ; set index
  4732 00:E974: B1 71              LDA   (ut1_pl),Y        ; get name second byte
  4733 00:E976: 10 DB              BPL   LAB_218B          ; skip if not string array
  4734                        
  4735                        ; was string array so ..
  4736                        
  4737 00:E978: A0 04              LDY   #$04              ; set index
  4738 00:E97A: B1 71              LDA   (ut1_pl),Y        ; get # of dimensions
  4739 00:E97C: 0A                 ASL                     ; *2
  4740 00:E97D: 69 05              ADC   #$05              ; +5 (array header size)
  4741 00:E97F: 20 C7 E9           JSR   LAB_2208          ; go set up for first element
  4742                        LAB_21C4
  4743 00:E982: E4 A5              CPX   Nbendh            ; compare with start of next array high byte
  4744 00:E984: D0 04              BNE   LAB_21CC          ; branch if <> (go do this array)
  4745                        
  4746 00:E986: C5 A4              CMP   Nbendl            ; else compare element pointer low byte with next array
  4747                                                      ; low byte
  4748 00:E988: F0 CD              BEQ   LAB_218F          ; if equal then go do next array
  4749                        
  4750                        LAB_21CC
  4751 00:E98A: 20 95 E9           JSR   LAB_21D7          ; go defrag array strings
  4752 00:E98D: F0 F3              BEQ   LAB_21C4          ; go do next array string (loop always)
  4753                        
  4754                        ; defrag string variables
  4755                        ; enter with XA = variable pointer
  4756                        ; return with XA = next variable pointer
  4757                        
  4758                        LAB_21D1
  4759 00:E98F: C8                 INY                     ; increment index (Y was $00)
  4760 00:E990: B1 71              LDA   (ut1_pl),Y        ; get var name byte 2
  4761 00:E992: 10 30              BPL   LAB_2206          ; if not string, step pointer to next var and return
  4762                        
  4763 00:E994: C8                 INY                     ; else increment index
  4764                        LAB_21D7
  4765 00:E995: B1 71              LDA   (ut1_pl),Y        ; get string length
  4766 00:E997: F0 2B              BEQ   LAB_2206          ; if null, step pointer to next string and return
  4767                        
  4768 00:E999: C8                 INY                     ; else increment index
  4769 00:E99A: B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte
  4770 00:E99C: AA                 TAX                     ; copy to X
  4771 00:E99D: C8                 INY                     ; increment index
  4772 00:E99E: B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte
  4773 00:E9A0: C5 82              CMP   Sstorh            ; compare bottom of string space high byte
  4774 00:E9A2: 90 06              BCC   LAB_21EC          ; branch if less
  4775                        
  4776 00:E9A4: D0 1E              BNE   LAB_2206          ; if greater, step pointer to next string and return
  4777                        
  4778                                                      ; high bytes were = so compare low bytes
  4779 00:E9A6: E4 81              CPX   Sstorl            ; compare bottom of string space low byte
  4780 00:E9A8: B0 1A              BCS   LAB_2206          ; if >=, step pointer to next string and return
  4781                        
  4782                                                      ; string pointer is < string storage pointer (pos in mem)
  4783                        LAB_21EC
  4784 00:E9AA: C5 AB              CMP   Histrh            ; compare to highest string high byte
  4785 00:E9AC: 90 17              BCC   LAB_2207          ; if <, step pointer to next string and return
  4786                        
  4787 00:E9AE: D0 04              BNE   LAB_21F6          ; if > update pointers, step to next and return
  4788                        
  4789                                                      ; high bytes were = so compare low bytes
  4790 00:E9B0: E4 AA              CPX   Histrl            ; compare to highest string low byte
  4791 00:E9B2: 90 11              BCC   LAB_2207          ; if <, step pointer to next string and return
  4792                        
  4793                                                      ; string is in string memory space
  4794                        LAB_21F6
  4795 00:E9B4: 86 AA              STX   Histrl            ; save as new highest string low byte
  4796 00:E9B6: 85 AB              STA   Histrh            ; save as new highest string high byte
  4797 00:E9B8: A5 71              LDA   ut1_pl            ; get start of vars(descriptors) low byte
  4798 00:E9BA: A6 72              LDX   ut1_ph            ; get start of vars(descriptors) high byte
  4799 00:E9BC: 85 9C              STA   garb_l            ; save as working pointer low byte
  4800 00:E9BE: 86 9D              STX   garb_h            ; save as working pointer high byte
  4801 00:E9C0: 88                 DEY                     ; decrement index DIFFERS
  4802 00:E9C1: 88                 DEY                     ; decrement index (should point to descriptor start)
  4803 00:E9C2: 84 A2              STY   g_indx            ; save index pointer
  4804                        
  4805                                                      ; step pointer to next string
  4806                        LAB_2206
  4807 00:E9C4: 18                 CLC                     ; clear carry for add
  4808                        LAB_2207
  4809 00:E9C5: A5 A0              LDA   g_step            ; get step size
  4810                        LAB_2208
  4811 00:E9C7: 65 71              ADC   ut1_pl            ; add pointer low byte
  4812 00:E9C9: 85 71              STA   ut1_pl            ; save pointer low byte
  4813 00:E9CB: 90 02              BCC   LAB_2211          ; branch if no overflow
  4814                        
  4815 00:E9CD: E6 72              INC   ut1_ph            ; else increment high byte
  4816                        LAB_2211
  4817 00:E9CF: A6 72              LDX   ut1_ph            ; get pointer high byte
  4818 00:E9D1: A0 00              LDY   #$00              ; clear Y
  4819 00:E9D3: 60                 RTS
  4820                        
  4821                        ; search complete, now either exit or set-up and move string
  4822                        
  4823                        LAB_2216
  4824 00:E9D4: C6 A0              DEC   g_step            ; decrement step size (now $03 for descriptor stack)
  4825                        ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
  4826                        ; *** replace
  4827                        ;      LDX   garb_h            ; get string to move high byte
  4828                        ; *** with
  4829 00:E9D6: A5 9D              LDA   garb_h            ; any string to move?
  4830 00:E9D8: 05 9C              ORA   garb_l
  4831                        ; *** end   patch  2.22p5.5  garbage collection may overlap temporary strings
  4832 00:E9DA: F0 F3              BEQ   LAB_2211          ; exit if nothing to move
  4833                        
  4834 00:E9DC: A4 A2              LDY   g_indx            ; get index byte back (points to descriptor)
  4835 00:E9DE: 18                 CLC                     ; clear carry for add
  4836 00:E9DF: B1 9C              LDA   (garb_l),Y        ; get string length
  4837 00:E9E1: 65 AA              ADC   Histrl            ; add highest string low byte
  4838 00:E9E3: 85 A6              STA   Obendl            ; save old block end low pointer
  4839 00:E9E5: A5 AB              LDA   Histrh            ; get highest string high byte
  4840 00:E9E7: 69 00              ADC   #$00              ; add any carry
  4841 00:E9E9: 85 A7              STA   Obendh            ; save old block end high byte
  4842 00:E9EB: A5 81              LDA   Sstorl            ; get bottom of string space low byte
  4843 00:E9ED: A6 82              LDX   Sstorh            ; get bottom of string space high byte
  4844 00:E9EF: 85 A4              STA   Nbendl            ; save new block end low byte
  4845 00:E9F1: 86 A5              STX   Nbendh            ; save new block end high byte
  4846 00:E9F3: 20 E8 D7           JSR   LAB_11D6          ; open up space in memory, don't set array end
  4847 00:E9F6: A4 A2              LDY   g_indx            ; get index byte
  4848 00:E9F8: C8                 INY                     ; point to descriptor low byte
  4849 00:E9F9: A5 A4              LDA   Nbendl            ; get string pointer low byte
  4850 00:E9FB: 91 9C              STA   (garb_l),Y        ; save new string pointer low byte
  4851 00:E9FD: AA                 TAX                     ; copy string pointer low byte
  4852 00:E9FE: E6 A5              INC   Nbendh            ; correct high byte (move sets high byte -1)
  4853 00:EA00: A5 A5              LDA   Nbendh            ; get new string pointer high byte
  4854 00:EA02: C8                 INY                     ; point to descriptor high byte
  4855 00:EA03: 91 9C              STA   (garb_l),Y        ; save new string pointer high byte
  4856 00:EA05: 4C 13 E9           JMP   LAB_214B          ; re-run routine from last ending
  4857                                                      ; (but don't collect this string)
  4858                        
  4859                        ; concatenate
  4860                        ; add strings, string 1 is in descriptor des_pl, string 2 is in line
  4861                        
  4862                        LAB_224D
  4863 00:EA08: A5 AF              LDA   des_ph            ; get descriptor pointer high byte
  4864 00:EA0A: 48                 PHA                     ; put on stack
  4865 00:EA0B: A5 AE              LDA   des_pl            ; get descriptor pointer low byte
  4866 00:EA0D: 48                 PHA                     ; put on stack
  4867                        ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
  4868                        ; *** add extra label to verify originating function
  4869                        LAB_224Da
  4870                        ; *** end patch    2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
  4871 00:EA0E: 20 ED E2           JSR   LAB_GVAL          ; get value from line
  4872 00:EA11: 20 F2 E1           JSR   LAB_CTST          ; check if source is string, else do type mismatch
  4873 00:EA14: 68                 PLA                     ; get descriptor pointer low byte back
  4874 00:EA15: 85 B8              STA   ssptr_l           ; set pointer low byte
  4875 00:EA17: 68                 PLA                     ; get descriptor pointer high byte back
  4876 00:EA18: 85 B9              STA   ssptr_h           ; set pointer high byte
  4877 00:EA1A: A0 00              LDY   #$00              ; clear index
  4878 00:EA1C: B1 B8              LDA   (ssptr_l),Y       ; get length_1 from descriptor
  4879 00:EA1E: 18                 CLC                     ; clear carry for add
  4880 00:EA1F: 71 AE              ADC   (des_pl),Y        ; add length_2
  4881 00:EA21: 90 05              BCC   LAB_226D          ; branch if no overflow
  4882                        
  4883 00:EA23: A2 1A              LDX   #$1A              ; else set error code $1A ("String too long" error)
  4884 00:EA25: 4C 5F D8           JMP   LAB_XERR          ; do error #X, then warm start
  4885                        
  4886                        LAB_226D
  4887 00:EA28: 20 60 E8           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
  4888                                                      ; long
  4889 00:EA2B: 20 45 EA           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
  4890 00:EA2E: A5 9E              LDA   des_2l            ; get descriptor pointer low byte
  4891 00:EA30: A4 9F              LDY   des_2h            ; get descriptor pointer high byte
  4892 00:EA32: 20 76 EA           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
  4893                                                      ; returns with A = length, ut1_pl = pointer low byte,
  4894                                                      ; ut1_ph = pointer high byte
  4895 00:EA35: 20 57 EA           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
  4896 00:EA38: A5 B8              LDA   ssptr_l           ;.set descriptor pointer low byte
  4897 00:EA3A: A4 B9              LDY   ssptr_h           ;.set descriptor pointer high byte
  4898 00:EA3C: 20 76 EA           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
  4899                                                      ; returns with A = length, X=ut1_pl=pointer low byte,
  4900                                                      ; Y=ut1_ph=pointer high byte
  4901 00:EA3F: 20 B5 E8           JSR   LAB_RTST          ; check for space on descriptor stack then put string
  4902                                                      ; address and length on descriptor stack and update stack
  4903                                                      ; pointers
  4904 00:EA42: 4C 18 E2           JMP   LAB_1ADB          ;.continue evaluation
  4905                        
  4906                        ; copy string from descriptor (sdescr) to (Sutill)
  4907                        
  4908                        LAB_228A
  4909 00:EA45: A0 00              LDY   #$00              ; clear index
  4910 00:EA47: B1 B8              LDA   (sdescr),Y        ; get string length
  4911 00:EA49: 48                 PHA                     ; save on stack
  4912 00:EA4A: C8                 INY                     ; increment index
  4913 00:EA4B: B1 B8              LDA   (sdescr),Y        ; get source string pointer low byte
  4914 00:EA4D: AA                 TAX                     ; copy to X
  4915 00:EA4E: C8                 INY                     ; increment index
  4916 00:EA4F: B1 B8              LDA   (sdescr),Y        ; get source string pointer high byte
  4917 00:EA51: A8                 TAY                     ; copy to Y
  4918 00:EA52: 68                 PLA                     ; get length back
  4919                        
  4920                        ; store string A bytes long from YX to (Sutill)
  4921                        
  4922                        LAB_2298
  4923 00:EA53: 86 71              STX   ut1_pl            ; save source string pointer low byte
  4924 00:EA55: 84 72              STY   ut1_ph            ; save source string pointer high byte
  4925                        
  4926                        ; store string A bytes long from (ut1_pl) to (Sutill)
  4927                        
  4928                        LAB_229C
  4929 00:EA57: AA                 TAX                     ; copy length to index (don't count with Y)
  4930 00:EA58: F0 14              BEQ   LAB_22B2          ; branch if = $0 (null string) no need to add zero length
  4931                        
  4932 00:EA5A: A0 00              LDY   #$00              ; zero pointer (copy forward)
  4933                        LAB_22A0
  4934 00:EA5C: B1 71              LDA   (ut1_pl),Y        ; get source byte
  4935 00:EA5E: 91 83              STA   (Sutill),Y        ; save destination byte
  4936                        
  4937 00:EA60: C8                 INY                     ; increment index
  4938 00:EA61: CA                 DEX                     ; decrement counter
  4939 00:EA62: D0 F8              BNE   LAB_22A0          ; loop while <> 0
  4940                        
  4941 00:EA64: 98                 TYA                     ; restore length from Y
  4942                        LAB_22A9
  4943 00:EA65: 18                 CLC                     ; clear carry for add
  4944 00:EA66: 65 83              ADC   Sutill            ; add string utility ptr low byte
  4945 00:EA68: 85 83              STA   Sutill            ; save string utility ptr low byte
  4946 00:EA6A: 90 02              BCC   LAB_22B2          ; branch if no carry
  4947                        
  4948 00:EA6C: E6 84              INC   Sutilh            ; else increment string utility ptr high byte
  4949                        LAB_22B2
  4950 00:EA6E: 60                 RTS
  4951                        
  4952                        ; evaluate string
  4953                        
  4954                        LAB_EVST
  4955 00:EA6F: 20 F2 E1           JSR   LAB_CTST          ; check if source is string, else do type mismatch
  4956                        
  4957                        ; pop string off descriptor stack, or from top of string space
  4958                        ; returns with A = length, X=pointer low byte, Y=pointer high byte
  4959                        
  4960                        LAB_22B6
  4961 00:EA72: A5 AE              LDA   des_pl            ; get descriptor pointer low byte
  4962 00:EA74: A4 AF              LDY   des_ph            ; get descriptor pointer high byte
  4963                        
  4964                        ; pop (YA) descriptor off stack or from top of string space
  4965                        ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
  4966                        
  4967                        LAB_22BA
  4968 00:EA76: 85 71              STA   ut1_pl            ; save descriptor pointer low byte
  4969 00:EA78: 84 72              STY   ut1_ph            ; save descriptor pointer high byte
  4970 00:EA7A: 20 A7 EA           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
  4971 00:EA7D: 08                 PHP                     ; save status flags
  4972 00:EA7E: A0 00              LDY   #$00              ; clear index
  4973 00:EA80: B1 71              LDA   (ut1_pl),Y        ; get length from string descriptor
  4974 00:EA82: 48                 PHA                     ; put on stack
  4975 00:EA83: C8                 INY                     ; increment index
  4976 00:EA84: B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte from descriptor
  4977 00:EA86: AA                 TAX                     ; copy to X
  4978 00:EA87: C8                 INY                     ; increment index
  4979 00:EA88: B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte from descriptor
  4980 00:EA8A: A8                 TAY                     ; copy to Y
  4981 00:EA8B: 68                 PLA                     ; get string length back
  4982 00:EA8C: 28                 PLP                     ; restore status
  4983 00:EA8D: D0 13              BNE   LAB_22E6          ; branch if pointer <> last_sl,last_sh
  4984                        
  4985 00:EA8F: C4 82              CPY   Sstorh            ; compare bottom of string space high byte
  4986 00:EA91: D0 0F              BNE   LAB_22E6          ; branch if <>
  4987                        
  4988 00:EA93: E4 81              CPX   Sstorl            ; else compare bottom of string space low byte
  4989 00:EA95: D0 0B              BNE   LAB_22E6          ; branch if <>
  4990                        
  4991 00:EA97: 48                 PHA                     ; save string length
  4992 00:EA98: 18                 CLC                     ; clear carry for add
  4993 00:EA99: 65 81              ADC   Sstorl            ; add bottom of string space low byte
  4994 00:EA9B: 85 81              STA   Sstorl            ; save bottom of string space low byte
  4995 00:EA9D: 90 02              BCC   LAB_22E5          ; skip increment if no overflow
  4996                        
  4997 00:EA9F: E6 82              INC   Sstorh            ; increment bottom of string space high byte
  4998                        LAB_22E5
  4999 00:EAA1: 68                 PLA                     ; restore string length
  5000                        LAB_22E6
  5001 00:EAA2: 86 71              STX   ut1_pl            ; save string pointer low byte
  5002 00:EAA4: 84 72              STY   ut1_ph            ; save string pointer high byte
  5003 00:EAA6: 60                 RTS
  5004                        
  5005                        ; clean descriptor stack, YA = pointer
  5006                        ; checks if AY is on the descriptor stack, if so does a stack discard
  5007                        
  5008                        LAB_22EB
  5009 00:EAA7: C4 67              CPY   last_sh           ; compare pointer high byte
  5010 00:EAA9: D0 0C              BNE   LAB_22FB          ; exit if <>
  5011                        
  5012 00:EAAB: C5 66              CMP   last_sl           ; compare pointer low byte
  5013 00:EAAD: D0 08              BNE   LAB_22FB          ; exit if <>
  5014                        
  5015 00:EAAF: 85 65              STA   next_s            ; save descriptor stack pointer
  5016 00:EAB1: E9 03              SBC   #$03              ; -3
  5017 00:EAB3: 85 66              STA   last_sl           ; save low byte -3
  5018 00:EAB5: A0 00              LDY   #$00              ; clear high byte
  5019                        LAB_22FB
  5020 00:EAB7: 60                 RTS
  5021                        
  5022                        ; perform CHR$()
  5023                        
  5024                        LAB_CHRS
  5025 00:EAB8: 20 C3 EB           JSR   LAB_EVBY          ; evaluate byte expression, result in X
  5026 00:EABB: 8A                 TXA                     ; copy to A
  5027 00:EABC: 48                 PHA                     ; save character
  5028 00:EABD: A9 01              LDA   #$01              ; string is single byte
  5029 00:EABF: 20 68 E8           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
  5030                                                      ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  5031 00:EAC2: 68                 PLA                     ; get character back
  5032 00:EAC3: A0 00              LDY   #$00              ; clear index
  5033 00:EAC5: 91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
  5034 00:EAC7: 4C B5 E8           JMP   LAB_RTST          ; check for space on descriptor stack then put string
  5035                                                      ; address and length on descriptor stack and update stack
  5036                                                      ; pointers
  5037                        
  5038                        ; perform LEFT$()
  5039                        
  5040                        LAB_LEFT
  5041 00:EACA: 48                 PHA                     ; push byte parameter
  5042 00:EACB: 20 2B EB           JSR   LAB_236F          ; pull string data and byte parameter from stack
  5043                                                      ; return pointer in des_2l/h, byte in A (and X), Y=0
  5044 00:EACE: D1 9E              CMP   (des_2l),Y        ; compare byte parameter with string length
  5045 00:EAD0: 98                 TYA                     ; clear A
  5046 00:EAD1: F0 09              BEQ   LAB_2316          ; go do string copy (branch always)
  5047                        
  5048                        ; perform RIGHT$()
  5049                        
  5050                        LAB_RIGHT
  5051 00:EAD3: 48                 PHA                     ; push byte parameter
  5052 00:EAD4: 20 2B EB           JSR   LAB_236F          ; pull string data and byte parameter from stack
  5053                                                      ; return pointer in des_2l/h, byte in A (and X), Y=0
  5054 00:EAD7: 18                 CLC                     ; clear carry for add-1
  5055 00:EAD8: F1 9E              SBC   (des_2l),Y        ; subtract string length
  5056 00:EADA: 49 FF              EOR   #$FF              ; invert it (A=LEN(expression$)-l)
  5057                        
  5058                        LAB_2316
  5059 00:EADC: 90 04              BCC   LAB_231C          ; branch if string length > byte parameter
  5060                        
  5061 00:EADE: B1 9E              LDA   (des_2l),Y        ; else make parameter = length
  5062 00:EAE0: AA                 TAX                     ; copy to byte parameter copy
  5063 00:EAE1: 98                 TYA                     ; clear string start offset
  5064                        LAB_231C
  5065 00:EAE2: 48                 PHA                     ; save string start offset
  5066                        LAB_231D
  5067 00:EAE3: 8A                 TXA                     ; copy byte parameter (or string length if <)
  5068                        LAB_231E
  5069 00:EAE4: 48                 PHA                     ; save string length
  5070 00:EAE5: 20 68 E8           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
  5071                                                      ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
  5072 00:EAE8: A5 9E              LDA   des_2l            ; get descriptor pointer low byte
  5073 00:EAEA: A4 9F              LDY   des_2h            ; get descriptor pointer high byte
  5074 00:EAEC: 20 76 EA           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
  5075                                                      ; returns with A = length, X=ut1_pl=pointer low byte,
  5076                                                      ; Y=ut1_ph=pointer high byte
  5077 00:EAEF: 68                 PLA                     ; get string length back
  5078 00:EAF0: A8                 TAY                     ; copy length to Y
  5079 00:EAF1: 68                 PLA                     ; get string start offset back
  5080 00:EAF2: 18                 CLC                     ; clear carry for add
  5081 00:EAF3: 65 71              ADC   ut1_pl            ; add start offset to string start pointer low byte
  5082 00:EAF5: 85 71              STA   ut1_pl            ; save string start pointer low byte
  5083 00:EAF7: 90 02              BCC   LAB_2335          ; branch if no overflow
  5084                        
  5085 00:EAF9: E6 72              INC   ut1_ph            ; else increment string start pointer high byte
  5086                        LAB_2335
  5087 00:EAFB: 98                 TYA                     ; copy length to A
  5088 00:EAFC: 20 57 EA           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
  5089 00:EAFF: 4C B5 E8           JMP   LAB_RTST          ; check for space on descriptor stack then put string
  5090                                                      ; address and length on descriptor stack and update stack
  5091                                                      ; pointers
  5092                        
  5093                        ; perform MID$()
  5094                        
  5095                        LAB_MIDS
  5096 00:EB02: 48                 PHA                     ; push byte parameter
  5097 00:EB03: A9 FF              LDA   #$FF              ; set default length = 255
  5098 00:EB05: 85 AF              STA   mids_l            ; save default length
  5099 00:EB07: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  5100 00:EB0A: C9 29              CMP   #')'              ; compare with ")"
  5101 00:EB0C: F0 06              BEQ   LAB_2358          ; branch if = ")" (skip second byte get)
  5102                        
  5103 00:EB0E: 20 1E E3           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
  5104 00:EB11: 20 C0 EB           JSR   LAB_GTBY          ; get byte parameter (use copy in mids_l)
  5105                        LAB_2358
  5106 00:EB14: 20 2B EB           JSR   LAB_236F          ; pull string data and byte parameter from stack
  5107                                                      ; return pointer in des_2l/h, byte in A (and X), Y=0
  5108 00:EB17: CA                 DEX                     ; decrement start index
  5109 00:EB18: 8A                 TXA                     ; copy to A
  5110 00:EB19: 48                 PHA                     ; save string start offset
  5111 00:EB1A: 18                 CLC                     ; clear carry for sub-1
  5112 00:EB1B: A2 00              LDX   #$00              ; clear output string length
  5113 00:EB1D: F1 9E              SBC   (des_2l),Y        ; subtract string length
  5114 00:EB1F: B0 C2              BCS   LAB_231D          ; if start>string length go do null string
  5115                        
  5116 00:EB21: 49 FF              EOR   #$FF              ; complement -length
  5117 00:EB23: C5 AF              CMP   mids_l            ; compare byte parameter
  5118 00:EB25: 90 BD              BCC   LAB_231E          ; if length>remaining string go do RIGHT$
  5119                        
  5120 00:EB27: A5 AF              LDA   mids_l            ; get length byte
  5121 00:EB29: B0 B9              BCS   LAB_231E          ; go do string copy (branch always)
  5122                        
  5123                        ; pull string data and byte parameter from stack
  5124                        ; return pointer in des_2l/h, byte in A (and X), Y=0
  5125                        
  5126                        LAB_236F
  5127 00:EB2B: 20 0F E3           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
  5128 00:EB2E: 68                 PLA                     ; pull return address low byte (return address)
  5129 00:EB2F: 85 A2              STA   Fnxjpl            ; save functions jump vector low byte
  5130 00:EB31: 68                 PLA                     ; pull return address high byte (return address)
  5131 00:EB32: 85 A3              STA   Fnxjph            ; save functions jump vector high byte
  5132 00:EB34: 68                 PLA                     ; pull byte parameter
  5133 00:EB35: AA                 TAX                     ; copy byte parameter to X
  5134 00:EB36: 68                 PLA                     ; pull string pointer low byte
  5135 00:EB37: 85 9E              STA   des_2l            ; save it
  5136 00:EB39: 68                 PLA                     ; pull string pointer high byte
  5137 00:EB3A: 85 9F              STA   des_2h            ; save it
  5138 00:EB3C: A0 00              LDY   #$00              ; clear index
  5139 00:EB3E: 8A                 TXA                     ; copy byte parameter
  5140 00:EB3F: F0 79              BEQ   LAB_23A8          ; if null do function call error then warm start
  5141                        
  5142 00:EB41: E6 A2              INC   Fnxjpl            ; increment function jump vector low byte
  5143                                                      ; (JSR pushes return addr-1. this is all very nice
  5144                                                      ; but will go tits up if either call is on a page
  5145                                                      ; boundary!)
  5146 00:EB43: 6C A2 00           JMP   (Fnxjpl)          ; in effect, RTS
  5147                        
  5148                        ; perform LCASE$()
  5149                        
  5150                        LAB_LCASE
  5151 00:EB46: 20 6F EA           JSR   LAB_EVST          ; evaluate string
  5152 00:EB49: 85 AC              STA   str_ln            ; set string length
  5153 00:EB4B: A8                 TAY                     ; copy length to Y
  5154 00:EB4C: F0 38              BEQ   NoString          ; branch if null string
  5155                        
  5156 00:EB4E: 20 68 E8           JSR   LAB_MSSP          ; make string space A bytes long A=length,
  5157                                                      ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  5158 00:EB51: 86 AD              STX   str_pl            ; save string pointer low byte
  5159 00:EB53: 84 AE              STY   str_ph            ; save string pointer high byte
  5160 00:EB55: A8                 TAY                     ; get string length back
  5161                        
  5162                        LC_loop
  5163 00:EB56: 88                 DEY                     ; decrement index
  5164 00:EB57: B1 71              LDA   (ut1_pl),Y        ; get byte from string
  5165 00:EB59: 20 50 E5           JSR   LAB_1D82          ; is character "A" to "Z"
  5166 00:EB5C: 90 02              BCC   NoUcase           ; branch if not upper case alpha
  5167                        
  5168 00:EB5E: 09 20              ORA   #$20              ; convert upper to lower case
  5169                        NoUcase
  5170 00:EB60: 91 83              STA   (Sutill),Y        ; save byte back to string
  5171 00:EB62: 98                 TYA                     ; test index
  5172 00:EB63: D0 F1              BNE   LC_loop           ; loop if not all done
  5173                        
  5174 00:EB65: F0 1F              BEQ   NoString          ; tidy up and exit, branch always
  5175                        
  5176                        ; perform UCASE$()
  5177                        
  5178                        LAB_UCASE
  5179 00:EB67: 20 6F EA           JSR   LAB_EVST          ; evaluate string
  5180 00:EB6A: 85 AC              STA   str_ln            ; set string length
  5181 00:EB6C: A8                 TAY                     ; copy length to Y
  5182 00:EB6D: F0 17              BEQ   NoString          ; branch if null string
  5183                        
  5184 00:EB6F: 20 68 E8           JSR   LAB_MSSP          ; make string space A bytes long A=length,
  5185                                                      ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
  5186 00:EB72: 86 AD              STX   str_pl            ; save string pointer low byte
  5187 00:EB74: 84 AE              STY   str_ph            ; save string pointer high byte
  5188 00:EB76: A8                 TAY                     ; get string length back
  5189                        
  5190                        UC_loop
  5191 00:EB77: 88                 DEY                     ; decrement index
  5192 00:EB78: B1 71              LDA   (ut1_pl),Y        ; get byte from string
  5193 00:EB7A: 20 4C E5           JSR   LAB_CASC          ; is character "a" to "z" (or "A" to "Z")
  5194 00:EB7D: 90 02              BCC   NoLcase           ; branch if not alpha
  5195                        
  5196 00:EB7F: 29 DF              AND   #$DF              ; convert lower to upper case
  5197                        NoLcase
  5198 00:EB81: 91 83              STA   (Sutill),Y        ; save byte back to string
  5199 00:EB83: 98                 TYA                     ; test index
  5200 00:EB84: D0 F1              BNE   UC_loop           ; loop if not all done
  5201                        
  5202                        NoString
  5203 00:EB86: 4C B5 E8           JMP   LAB_RTST          ; check for space on descriptor stack then put string
  5204                                                      ; address and length on descriptor stack and update stack
  5205                                                      ; pointers
  5206                        
  5207                        ; perform SADD()
  5208                        
  5209                        LAB_SADD
  5210 00:EB89: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  5211 00:EB8C: 20 D8 E4           JSR   LAB_GVAR          ; get var address
  5212                        
  5213 00:EB8F: 20 0F E3           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
  5214 00:EB92: 20 F2 E1           JSR   LAB_CTST          ; check if source is string, else do type mismatch
  5215                        
  5216 00:EB95: A0 02              LDY   #$02              ; index to string pointer high byte
  5217 00:EB97: B1 95              LDA   (Cvaral),Y        ; get string pointer high byte
  5218 00:EB99: AA                 TAX                     ; copy string pointer high byte to X
  5219 00:EB9A: 88                 DEY                     ; index to string pointer low byte
  5220 00:EB9B: B1 95              LDA   (Cvaral),Y        ; get string pointer low byte
  5221 00:EB9D: A8                 TAY                     ; copy string pointer low byte to Y
  5222 00:EB9E: 8A                 TXA                     ; copy string pointer high byte to A
  5223 00:EB9F: 4C 87 E7           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  5224                        
  5225                        ; perform LEN()
  5226                        
  5227                        LAB_LENS
  5228 00:EBA2: 20 A8 EB           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
  5229 00:EBA5: 4C 94 E7           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
  5230                        
  5231                        ; evaluate string, get length in Y
  5232                        
  5233                        LAB_ESGL
  5234 00:EBA8: 20 6F EA           JSR   LAB_EVST          ; evaluate string
  5235 00:EBAB: A8                 TAY                     ; copy length to Y
  5236 00:EBAC: 60                 RTS
  5237                        
  5238                        ; perform ASC()
  5239                        
  5240                        LAB_ASC
  5241 00:EBAD: 20 A8 EB           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
  5242 00:EBB0: F0 08              BEQ   LAB_23A8          ; if null do function call error then warm start
  5243                        
  5244 00:EBB2: A0 00              LDY   #$00              ; set index to first character
  5245 00:EBB4: B1 71              LDA   (ut1_pl),Y        ; get byte
  5246 00:EBB6: A8                 TAY                     ; copy to Y
  5247 00:EBB7: 4C 94 E7           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
  5248                        
  5249                        ; do function call error then warm start
  5250                        
  5251                        LAB_23A8
  5252 00:EBBA: 4C 57 E6           JMP   LAB_FCER          ; do function call error then warm start
  5253                        
  5254                        ; scan and get byte parameter
  5255                        
  5256                        LAB_SGBY
  5257 00:EBBD: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  5258                        
  5259                        ; get byte parameter
  5260                        
  5261                        LAB_GTBY
  5262 00:EBC0: 20 ED E1           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  5263                                                      ; else do type mismatch
  5264                        
  5265                        ; evaluate byte expression, result in X
  5266                        
  5267                        LAB_EVBY
  5268 00:EBC3: 20 D0 E5           JSR   LAB_EVPI          ; evaluate integer expression (no check)
  5269                        
  5270 00:EBC6: A4 AE              LDY   FAC1_2            ; get FAC1 mantissa2
  5271 00:EBC8: D0 F0              BNE   LAB_23A8          ; if top byte <> 0 do function call error then warm start
  5272                        
  5273 00:EBCA: A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
  5274 00:EBCC: 4C C2 00           JMP   LAB_GBYT          ; scan memory and return
  5275                        
  5276                        ; perform VAL()
  5277                        
  5278                        LAB_VAL
  5279 00:EBCF: 20 A8 EB           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
  5280 00:EBD2: D0 03              BNE   LAB_23C5          ; branch if not null string
  5281                        
  5282                                                      ; string was null so set result = $00
  5283 00:EBD4: 4C 7D ED           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
  5284                        
  5285                        LAB_23C5
  5286                        ; *** begin patch  2.22p5.7  VAL() may cause string variables to be trashed
  5287                        ; *** replace     
  5288                        ;      LDX   Bpntrl            ; get BASIC execute pointer low byte
  5289                        ;      LDY   Bpntrh            ; get BASIC execute pointer high byte
  5290                        ;      STX   Btmpl             ; save BASIC execute pointer low byte
  5291                        ;      STY   Btmph             ; save BASIC execute pointer high byte
  5292                        ;      LDX   ut1_pl            ; get string pointer low byte
  5293                        ;      STX   Bpntrl            ; save as BASIC execute pointer low byte
  5294                        ;      CLC                     ; clear carry
  5295                        ;      ADC   ut1_pl            ; add string length
  5296                        ;      STA   ut2_pl            ; save string end low byte
  5297                        ;      LDA   ut1_ph            ; get string pointer high byte
  5298                        ;      STA   Bpntrh            ; save as BASIC execute pointer high byte
  5299                        ;      ADC   #$00              ; add carry to high byte
  5300                        ;      STA   ut2_ph            ; save string end high byte
  5301                        ;      LDY   #$00              ; set index to $00
  5302                        ;      LDA   (ut2_pl),Y        ; get string end +1 byte
  5303                        ;      PHA                     ; push it
  5304                        ;      TYA                     ; clear A
  5305                        ;      STA   (ut2_pl),Y        ; terminate string with $00
  5306                        ;      JSR   LAB_GBYT          ; scan memory
  5307                        ;      JSR   LAB_2887          ; get FAC1 from string
  5308                        ;      PLA                     ; restore string end +1 byte
  5309                        ;      LDY   #$00              ; set index to zero
  5310                        ;      STA   (ut2_pl),Y        ; put string end byte back
  5311                        ; *** with
  5312 00:EBD7: 48                 PHA                     ; save length
  5313 00:EBD8: C8                 INY                     ; string length +1
  5314 00:EBD9: 98                 TYA
  5315 00:EBDA: 20 68 E8           JSR   LAB_MSSP          ; allocate temp string +1 bytes long
  5316 00:EBDD: 68                 PLA                     ; get length back
  5317 00:EBDE: 20 57 EA           JSR   LAB_229C          ; copy string (ut1_pl) -> (Sutill) for A bytes
  5318 00:EBE1: A9 00              LDA   #0                ; add delimiter to end of string
  5319 00:EBE3: A8                 TAY
  5320 00:EBE4: 91 83              STA   (Sutill),Y
  5321 00:EBE6: A6 C3              LDX   Bpntrl            ; save BASIC execute pointer low byte
  5322 00:EBE8: A4 C4              LDY   Bpntrh
  5323 00:EBEA: 86 BA              STX   Btmpl
  5324 00:EBEC: 84 BB              STY   Btmph
  5325 00:EBEE: A6 AD              LDX   str_pl            ; point to temporary string
  5326 00:EBF0: A4 AE              LDY   str_ph
  5327 00:EBF2: 86 C3              STX   Bpntrl
  5328 00:EBF4: 84 C4              STY   Bpntrh
  5329 00:EBF6: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  5330 00:EBF9: 20 D3 F0           JSR   LAB_2887          ; get FAC1 from string
  5331                        ; *** end patch    2.22p5.7  VAL() may cause string variables to be trashed
  5332                        
  5333                        ; restore BASIC execute pointer from temp (Btmpl/Btmph)
  5334                        
  5335                        LAB_23F3
  5336 00:EBFC: A6 BA              LDX   Btmpl             ; get BASIC execute pointer low byte back
  5337 00:EBFE: A4 BB              LDY   Btmph             ; get BASIC execute pointer high byte back
  5338 00:EC00: 86 C3              STX   Bpntrl            ; save BASIC execute pointer low byte
  5339 00:EC02: 84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
  5340 00:EC04: 60                 RTS
  5341                        
  5342                        ; get two parameters for POKE or WAIT
  5343                        
  5344                        LAB_GADB
  5345 00:EC05: 20 ED E1           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  5346                                                      ; else do type mismatch
  5347 00:EC08: 20 1E EC           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
  5348                        
  5349                        ; scan for "," and get byte, else do Syntax error then warm start
  5350                        
  5351                        LAB_SCGB
  5352 00:EC0B: 20 1E E3           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
  5353 00:EC0E: A5 12              LDA   Itemph            ; save temporary integer high byte
  5354 00:EC10: 48                 PHA                     ; on stack
  5355 00:EC11: A5 11              LDA   Itempl            ; save temporary integer low byte
  5356 00:EC13: 48                 PHA                     ; on stack
  5357 00:EC14: 20 C0 EB           JSR   LAB_GTBY          ; get byte parameter
  5358 00:EC17: 68                 PLA                     ; pull low byte
  5359 00:EC18: 85 11              STA   Itempl            ; restore temporary integer low byte
  5360 00:EC1A: 68                 PLA                     ; pull high byte
  5361 00:EC1B: 85 12              STA   Itemph            ; restore temporary integer high byte
  5362 00:EC1D: 60                 RTS
  5363                        
  5364                        ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
  5365                        ; -ve and converts it into a right truncated integer in Itempl and Itemph
  5366                        
  5367                        ; save unsigned 16 bit integer part of FAC1 in temporary integer
  5368                        
  5369                        LAB_F2FX
  5370 00:EC1E: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  5371 00:EC20: C9 98              CMP   #$98              ; compare with exponent = 2^24
  5372 00:EC22: B0 96              BCS   LAB_23A8          ; if >= do function call error then warm start
  5373                        
  5374                        LAB_F2FU
  5375 00:EC24: 20 7D F0           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
  5376 00:EC27: A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
  5377 00:EC29: A4 AF              LDY   FAC1_3            ; get FAC1 mantissa3
  5378 00:EC2B: 84 11              STY   Itempl            ; save temporary integer low byte
  5379 00:EC2D: 85 12              STA   Itemph            ; save temporary integer high byte
  5380 00:EC2F: 60                 RTS
  5381                        
  5382                        ; perform PEEK()
  5383                        
  5384                        LAB_PEEK
  5385 00:EC30: 20 1E EC           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
  5386 00:EC33: A2 00              LDX   #$00              ; clear index
  5387 00:EC35: A1 11              LDA   (Itempl,X)        ; get byte via temporary integer (addr)
  5388 00:EC37: A8                 TAY                     ; copy byte to Y
  5389 00:EC38: 4C 94 E7           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
  5390                        
  5391                        ; perform POKE
  5392                        
  5393                        LAB_POKE
  5394 00:EC3B: 20 05 EC           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  5395 00:EC3E: 8A                 TXA                     ; copy byte argument to A
  5396 00:EC3F: A2 00              LDX   #$00              ; clear index
  5397 00:EC41: 81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
  5398 00:EC43: 60                 RTS
  5399                        
  5400                        ; perform DEEK()
  5401                        
  5402                        LAB_DEEK
  5403 00:EC44: 20 1E EC           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
  5404 00:EC47: A2 00              LDX   #$00              ; clear index
  5405 00:EC49: A1 11              LDA   (Itempl,X)        ; PEEK low byte
  5406 00:EC4B: A8                 TAY                     ; copy to Y
  5407 00:EC4C: E6 11              INC   Itempl            ; increment pointer low byte
  5408 00:EC4E: D0 02              BNE   Deekh             ; skip high increment if no rollover
  5409                        
  5410 00:EC50: E6 12              INC   Itemph            ; increment pointer high byte
  5411                        Deekh
  5412 00:EC52: A1 11              LDA   (Itempl,X)        ; PEEK high byte
  5413 00:EC54: 4C 87 E7           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  5414                        
  5415                        ; perform DOKE
  5416                        
  5417                        LAB_DOKE
  5418 00:EC57: 20 ED E1           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  5419                                                      ; else do type mismatch
  5420 00:EC5A: 20 1E EC           JSR   LAB_F2FX          ; convert floating-to-fixed
  5421                        
  5422 00:EC5D: 84 97              STY   Frnxtl            ; save pointer low byte (float to fixed returns word in AY)
  5423 00:EC5F: 85 98              STA   Frnxth            ; save pointer high byte
  5424                        
  5425 00:EC61: 20 1E E3           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
  5426 00:EC64: 20 ED E1           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  5427                                                      ; else do type mismatch
  5428 00:EC67: 20 1E EC           JSR   LAB_F2FX          ; convert floating-to-fixed
  5429                        
  5430 00:EC6A: 98                 TYA                     ; copy value low byte (float to fixed returns word in AY)
  5431 00:EC6B: A2 00              LDX   #$00              ; clear index
  5432 00:EC6D: 81 97              STA   (Frnxtl,X)        ; POKE low byte
  5433 00:EC6F: E6 97              INC   Frnxtl            ; increment pointer low byte
  5434 00:EC71: D0 02              BNE   Dokeh             ; skip high increment if no rollover
  5435                        
  5436 00:EC73: E6 98              INC   Frnxth            ; increment pointer high byte
  5437                        Dokeh
  5438 00:EC75: A5 12              LDA   Itemph            ; get value high byte
  5439 00:EC77: 81 97              STA   (Frnxtl,X)        ; POKE high byte
  5440 00:EC79: 4C C2 00           JMP   LAB_GBYT          ; scan memory and return
  5441                        
  5442                        ; perform SWAP
  5443                        
  5444                        LAB_SWAP
  5445 00:EC7C: 20 D8 E4           JSR   LAB_GVAR          ; get var1 address
  5446 00:EC7F: 85 97              STA   Lvarpl            ; save var1 address low byte
  5447 00:EC81: 84 98              STY   Lvarph            ; save var1 address high byte
  5448 00:EC83: A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
  5449 00:EC85: 48                 PHA                     ; save data type flag
  5450                        
  5451 00:EC86: 20 1E E3           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
  5452 00:EC89: 20 D8 E4           JSR   LAB_GVAR          ; get var2 address (pointer in Cvaral/h)
  5453 00:EC8C: 68                 PLA                     ; pull var1 data type flag
  5454 00:EC8D: 45 5F              EOR   Dtypef            ; compare with var2 data type
  5455 00:EC8F: 10 10              BPL   SwapErr           ; exit if not both the same type
  5456                        
  5457 00:EC91: A0 03              LDY   #$03              ; four bytes to swap (either value or descriptor+1)
  5458                        SwapLp
  5459 00:EC93: B1 97              LDA   (Lvarpl),Y        ; get byte from var1
  5460 00:EC95: AA                 TAX                     ; save var1 byte
  5461 00:EC96: B1 95              LDA   (Cvaral),Y        ; get byte from var2
  5462 00:EC98: 91 97              STA   (Lvarpl),Y        ; save byte to var1
  5463 00:EC9A: 8A                 TXA                     ; restore var1 byte
  5464 00:EC9B: 91 95              STA   (Cvaral),Y        ; save byte to var2
  5465 00:EC9D: 88                 DEY                     ; decrement index
  5466 00:EC9E: 10 F3              BPL   SwapLp            ; loop until done
  5467                        
  5468 00:ECA0: 60                 RTS
  5469                        
  5470                        SwapErr
  5471 00:ECA1: 4C FC E1           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
  5472                        
  5473                        ; perform CALL
  5474                        
  5475                        LAB_CALL
  5476 00:ECA4: 20 ED E1           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  5477                                                      ; else do type mismatch
  5478 00:ECA7: 20 1E EC           JSR   LAB_F2FX          ; convert floating-to-fixed
  5479 00:ECAA: A9 EC              LDA   #>CallExit        ; set return address high byte
  5480 00:ECAC: 48                 PHA                     ; put on stack
  5481 00:ECAD: A9 B2              LDA   #<CallExit-1      ; set return address low byte
  5482 00:ECAF: 48                 PHA                     ; put on stack
  5483 00:ECB0: 6C 11 00           JMP   (Itempl)          ; do indirect jump to user routine
  5484                        
  5485                        ; if the called routine exits correctly then it will return to here. this will then get
  5486                        ; the next byte for the interpreter and return
  5487                        
  5488                        CallExit
  5489 00:ECB3: 4C C2 00           JMP   LAB_GBYT          ; scan memory and return
  5490                        
  5491                        ; perform WAIT
  5492                        
  5493                        LAB_WAIT
  5494 00:ECB6: 20 05 EC           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  5495 00:ECB9: 86 97              STX   Frnxtl            ; save byte
  5496 00:ECBB: A2 00              LDX   #$00              ; clear mask
  5497 00:ECBD: 20 C2 00           JSR   LAB_GBYT          ; scan memory
  5498 00:ECC0: F0 03              BEQ   LAB_2441          ; skip if no third argument
  5499                        
  5500 00:ECC2: 20 0B EC           JSR   LAB_SCGB          ; scan for "," and get byte, else SN error then warm start
  5501                        LAB_2441
  5502 00:ECC5: 86 98              STX   Frnxth            ; save EOR argument
  5503                        LAB_2445
  5504 00:ECC7: B1 11              LDA   (Itempl),Y        ; get byte via temporary integer (addr)
  5505 00:ECC9: 45 98              EOR   Frnxth            ; EOR with second argument (mask)
  5506 00:ECCB: 25 97              AND   Frnxtl            ; AND with first argument (byte)
  5507 00:ECCD: F0 F8              BEQ   LAB_2445          ; loop if result is zero
  5508                        
  5509                        LAB_244D
  5510 00:ECCF: 60                 RTS
  5511                        
  5512                        ; perform subtraction, FAC1 from (AY)
  5513                        
  5514                        LAB_2455
  5515 00:ECD0: 20 B8 EE           JSR   LAB_264D          ; unpack memory (AY) into FAC2
  5516                        
  5517                        ; perform subtraction, FAC1 from FAC2
  5518                        
  5519                        LAB_SUBTRACT
  5520 00:ECD3: A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
  5521 00:ECD5: 49 FF              EOR   #$FF              ; complement it
  5522 00:ECD7: 85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
  5523 00:ECD9: 45 B7              EOR   FAC2_s            ; EOR with FAC2 sign (b7)
  5524 00:ECDB: 85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  5525 00:ECDD: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  5526 00:ECDF: 4C EE EC           JMP   LAB_ADD           ; go add FAC2 to FAC1
  5527                        
  5528                        ; perform addition
  5529                        
  5530                        LAB_2467
  5531 00:ECE2: 20 07 EE           JSR   LAB_257B          ; shift FACX A times right (>8 shifts)
  5532 00:ECE5: 90 4D              BCC   LAB_24A8          ;.go subtract mantissas
  5533                        
  5534                        ; add 0.5 to FAC1
  5535                        
  5536                        LAB_244E
  5537 00:ECE7: A9 19              LDA   #<LAB_2A96        ; set 0.5 pointer low byte
  5538 00:ECE9: A0 F9              LDY   #>LAB_2A96        ; set 0.5 pointer high byte
  5539                        
  5540                        ; add (AY) to FAC1
  5541                        
  5542                        LAB_246C
  5543 00:ECEB: 20 B8 EE           JSR   LAB_264D          ; unpack memory (AY) into FAC2
  5544                        
  5545                        ; add FAC2 to FAC1
  5546                        
  5547                        LAB_ADD
  5548 00:ECEE: D0 10              BNE   LAB_2474          ; branch if FAC1 was not zero
  5549                        
  5550                        ; copy FAC2 to FAC1
  5551                        
  5552                        LAB_279B
  5553 00:ECF0: A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
  5554                        
  5555                        ; save FAC1 sign and copy ABS(FAC2) to FAC1
  5556                        
  5557                        LAB_279D
  5558 00:ECF2: 85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
  5559 00:ECF4: A2 04              LDX   #$04              ; 4 bytes to copy
  5560                        LAB_27A1
  5561 00:ECF6: B5 B2              LDA   FAC1_o,X          ; get byte from FAC2,X
  5562 00:ECF8: 95 AB              STA   FAC1_e-1,X        ; save byte at FAC1,X
  5563 00:ECFA: CA                 DEX                     ; decrement count
  5564 00:ECFB: D0 F9              BNE   LAB_27A1          ; loop if not all done
  5565                        
  5566 00:ECFD: 86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
  5567 00:ECFF: 60                 RTS
  5568                        
  5569                                                      ; FAC1 is non zero
  5570                        LAB_2474
  5571 00:ED00: A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
  5572 00:ED02: 86 A3              STX   FAC2_r            ; save as FAC2 rounding byte
  5573 00:ED04: A2 B3              LDX   #FAC2_e           ; set index to FAC2 exponent addr
  5574 00:ED06: A5 B3              LDA   FAC2_e            ; get FAC2 exponent
  5575                        LAB_247C
  5576 00:ED08: A8                 TAY                     ; copy exponent
  5577 00:ED09: F0 C4              BEQ   LAB_244D          ; exit if zero
  5578                        
  5579 00:ED0B: 38                 SEC                     ; set carry for subtract
  5580 00:ED0C: E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
  5581 00:ED0E: F0 24              BEQ   LAB_24A8          ; branch if = (go add mantissa)
  5582                        
  5583 00:ED10: 90 12              BCC   LAB_2498          ; branch if <
  5584                        
  5585                                                      ; FAC2>FAC1
  5586 00:ED12: 84 AC              STY   FAC1_e            ; save FAC1 exponent
  5587 00:ED14: A4 B7              LDY   FAC2_s            ; get FAC2 sign (b7)
  5588 00:ED16: 84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
  5589 00:ED18: 49 FF              EOR   #$FF              ; complement A
  5590 00:ED1A: 69 00              ADC   #$00              ; +1 (twos complement, carry is set)
  5591 00:ED1C: A0 00              LDY   #$00              ; clear Y
  5592 00:ED1E: 84 A3              STY   FAC2_r            ; clear FAC2 rounding byte
  5593 00:ED20: A2 AC              LDX   #FAC1_e           ; set index to FAC1 exponent addr
  5594 00:ED22: D0 04              BNE   LAB_249C          ; branch always
  5595                        
  5596                        LAB_2498
  5597 00:ED24: A0 00              LDY   #$00              ; clear Y
  5598 00:ED26: 84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
  5599                        LAB_249C
  5600 00:ED28: C9 F9              CMP   #$F9              ; compare exponent diff with $F9
  5601 00:ED2A: 30 B6              BMI   LAB_2467          ; branch if range $79-$F8
  5602                        
  5603 00:ED2C: A8                 TAY                     ; copy exponent difference to Y
  5604 00:ED2D: A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
  5605 00:ED2F: 56 01              LSR   PLUS_1,X          ; shift FAC? mantissa1
  5606 00:ED31: 20 1E EE           JSR   LAB_2592          ; shift FACX Y times right
  5607                        
  5608                                                      ; exponents are equal now do mantissa subtract
  5609                        LAB_24A8
  5610 00:ED34: 24 B8              BIT   FAC_sc            ; test sign compare (FAC1 EOR FAC2)
  5611 00:ED36: 10 4C              BPL   LAB_24F8          ; if = add FAC2 mantissa to FAC1 mantissa and return
  5612                        
  5613 00:ED38: A0 AC              LDY   #FAC1_e           ; set index to FAC1 exponent addr
  5614 00:ED3A: E0 B3              CPX   #FAC2_e           ; compare X to FAC2 exponent addr
  5615 00:ED3C: F0 02              BEQ   LAB_24B4          ; branch if =
  5616                        
  5617 00:ED3E: A0 B3              LDY   #FAC2_e           ; else set index to FAC2 exponent addr
  5618                        
  5619                                                      ; subtract smaller from bigger (take sign of bigger)
  5620                        LAB_24B4
  5621 00:ED40: 38                 SEC                     ; set carry for subtract
  5622 00:ED41: 49 FF              EOR   #$FF              ; ones complement A
  5623 00:ED43: 65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
  5624 00:ED45: 85 B9              STA   FAC1_r            ; save FAC1 rounding byte
  5625 00:ED47: B9 03 00           LDA   PLUS_3,Y          ; get FACY mantissa3
  5626 00:ED4A: F5 03              SBC   PLUS_3,X          ; subtract FACX mantissa3
  5627 00:ED4C: 85 AF              STA   FAC1_3            ; save FAC1 mantissa3
  5628 00:ED4E: B9 02 00           LDA   PLUS_2,Y          ; get FACY mantissa2
  5629 00:ED51: F5 02              SBC   PLUS_2,X          ; subtract FACX mantissa2
  5630 00:ED53: 85 AE              STA   FAC1_2            ; save FAC1 mantissa2
  5631 00:ED55: B9 01 00           LDA   PLUS_1,Y          ; get FACY mantissa1
  5632 00:ED58: F5 01              SBC   PLUS_1,X          ; subtract FACX mantissa1
  5633 00:ED5A: 85 AD              STA   FAC1_1            ; save FAC1 mantissa1
  5634                        
  5635                        ; do ABS and normalise FAC1
  5636                        
  5637                        LAB_24D0
  5638 00:ED5C: B0 03              BCS   LAB_24D5          ; branch if number is +ve
  5639                        
  5640 00:ED5E: 20 C3 ED           JSR   LAB_2537          ; negate FAC1
  5641                        
  5642                        ; normalise FAC1
  5643                        
  5644                        LAB_24D5
  5645 00:ED61: A0 00              LDY   #$00              ; clear Y
  5646 00:ED63: 98                 TYA                     ; clear A
  5647 00:ED64: 18                 CLC                     ; clear carry for add
  5648                        LAB_24D9
  5649 00:ED65: A6 AD              LDX   FAC1_1            ; get FAC1 mantissa1
  5650 00:ED67: D0 3E              BNE   LAB_251B          ; if not zero normalise FAC1
  5651                        
  5652 00:ED69: A6 AE              LDX   FAC1_2            ; get FAC1 mantissa2
  5653 00:ED6B: 86 AD              STX   FAC1_1            ; save FAC1 mantissa1
  5654 00:ED6D: A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
  5655 00:ED6F: 86 AE              STX   FAC1_2            ; save FAC1 mantissa2
  5656 00:ED71: A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
  5657 00:ED73: 86 AF              STX   FAC1_3            ; save FAC1 mantissa3
  5658 00:ED75: 84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
  5659 00:ED77: 69 08              ADC   #$08              ; add x to exponent offset
  5660 00:ED79: C9 18              CMP   #$18              ; compare with $18 (max offset, all bits would be =0)
  5661 00:ED7B: D0 E8              BNE   LAB_24D9          ; loop if not max
  5662                        
  5663                        ; clear FAC1 exponent and sign
  5664                        
  5665                        LAB_24F1
  5666 00:ED7D: A9 00              LDA   #$00              ; clear A
  5667                        LAB_24F3
  5668 00:ED7F: 85 AC              STA   FAC1_e            ; set FAC1 exponent
  5669                        
  5670                        ; save FAC1 sign
  5671                        
  5672                        LAB_24F5
  5673 00:ED81: 85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
  5674 00:ED83: 60                 RTS
  5675                        
  5676                        ; add FAC2 mantissa to FAC1 mantissa
  5677                        
  5678                        LAB_24F8
  5679 00:ED84: 65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
  5680 00:ED86: 85 B9              STA   FAC1_r            ; save FAC1 rounding byte
  5681 00:ED88: A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
  5682 00:ED8A: 65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
  5683 00:ED8C: 85 AF              STA   FAC1_3            ; save FAC1 mantissa3
  5684 00:ED8E: A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
  5685 00:ED90: 65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
  5686 00:ED92: 85 AE              STA   FAC1_2            ; save FAC1 mantissa2
  5687 00:ED94: A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
  5688 00:ED96: 65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
  5689 00:ED98: 85 AD              STA   FAC1_1            ; save FAC1 mantissa1
  5690 00:ED9A: B0 1A              BCS   LAB_252A          ; if carry then normalise FAC1 for C=1
  5691                        
  5692 00:ED9C: 60                 RTS                     ; else just exit
  5693                        
  5694                        LAB_2511
  5695 00:ED9D: 69 01              ADC   #$01              ; add 1 to exponent offset
  5696 00:ED9F: 06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
  5697 00:EDA1: 26 AF              ROL   FAC1_3            ; shift FAC1 mantissa3
  5698 00:EDA3: 26 AE              ROL   FAC1_2            ; shift FAC1 mantissa2
  5699 00:EDA5: 26 AD              ROL   FAC1_1            ; shift FAC1 mantissa1
  5700                        
  5701                        ; normalise FAC1
  5702                        
  5703                        LAB_251B
  5704 00:EDA7: 10 F4              BPL   LAB_2511          ; loop if not normalised
  5705                        
  5706 00:EDA9: 38                 SEC                     ; set carry for subtract
  5707 00:EDAA: E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
  5708 00:EDAC: B0 CF              BCS   LAB_24F1          ; branch if underflow (set result = $0)
  5709                        
  5710 00:EDAE: 49 FF              EOR   #$FF              ; complement exponent
  5711 00:EDB0: 69 01              ADC   #$01              ; +1 (twos complement)
  5712 00:EDB2: 85 AC              STA   FAC1_e            ; save FAC1 exponent
  5713                        
  5714                        ; test and normalise FAC1 for C=0/1
  5715                        
  5716                        LAB_2528
  5717 00:EDB4: 90 0C              BCC   LAB_2536          ; exit if no overflow
  5718                        
  5719                        ; normalise FAC1 for C=1
  5720                        
  5721                        LAB_252A
  5722 00:EDB6: E6 AC              INC   FAC1_e            ; increment FAC1 exponent
  5723 00:EDB8: F0 36              BEQ   LAB_2564          ; if zero do overflow error and warm start
  5724                        
  5725 00:EDBA: 66 AD              ROR   FAC1_1            ; shift FAC1 mantissa1
  5726 00:EDBC: 66 AE              ROR   FAC1_2            ; shift FAC1 mantissa2
  5727 00:EDBE: 66 AF              ROR   FAC1_3            ; shift FAC1 mantissa3
  5728 00:EDC0: 66 B9              ROR   FAC1_r            ; shift FAC1 rounding byte
  5729                        LAB_2536
  5730 00:EDC2: 60                 RTS
  5731                        
  5732                        ; negate FAC1
  5733                        
  5734                        LAB_2537
  5735 00:EDC3: A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
  5736 00:EDC5: 49 FF              EOR   #$FF              ; complement it
  5737 00:EDC7: 85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
  5738                        
  5739                        ; twos complement FAC1 mantissa
  5740                        
  5741                        LAB_253D
  5742 00:EDC9: A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
  5743 00:EDCB: 49 FF              EOR   #$FF              ; complement it
  5744 00:EDCD: 85 AD              STA   FAC1_1            ; save FAC1 mantissa1
  5745 00:EDCF: A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
  5746 00:EDD1: 49 FF              EOR   #$FF              ; complement it
  5747 00:EDD3: 85 AE              STA   FAC1_2            ; save FAC1 mantissa2
  5748 00:EDD5: A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
  5749 00:EDD7: 49 FF              EOR   #$FF              ; complement it
  5750 00:EDD9: 85 AF              STA   FAC1_3            ; save FAC1 mantissa3
  5751 00:EDDB: A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
  5752 00:EDDD: 49 FF              EOR   #$FF              ; complement it
  5753 00:EDDF: 85 B9              STA   FAC1_r            ; save FAC1 rounding byte
  5754 00:EDE1: E6 B9              INC   FAC1_r            ; increment FAC1 rounding byte
  5755 00:EDE3: D0 0A              BNE   LAB_2563          ; exit if no overflow
  5756                        
  5757                        ; increment FAC1 mantissa
  5758                        
  5759                        LAB_2559
  5760 00:EDE5: E6 AF              INC   FAC1_3            ; increment FAC1 mantissa3
  5761 00:EDE7: D0 06              BNE   LAB_2563          ; finished if no rollover
  5762                        
  5763 00:EDE9: E6 AE              INC   FAC1_2            ; increment FAC1 mantissa2
  5764 00:EDEB: D0 02              BNE   LAB_2563          ; finished if no rollover
  5765                        
  5766 00:EDED: E6 AD              INC   FAC1_1            ; increment FAC1 mantissa1
  5767                        LAB_2563
  5768 00:EDEF: 60                 RTS
  5769                        
  5770                        ; do overflow error (overflow exit)
  5771                        
  5772                        LAB_2564
  5773 00:EDF0: A2 0A              LDX   #$0A              ; error code $0A ("Overflow" error)
  5774 00:EDF2: 4C 5F D8           JMP   LAB_XERR          ; do error #X, then warm start
  5775                        
  5776                        ; shift FCAtemp << A+8 times
  5777                        
  5778                        LAB_2569
  5779 00:EDF5: A2 74              LDX   #FACt_1-1         ; set offset to FACtemp
  5780                        LAB_256B
  5781 00:EDF7: B4 03              LDY   PLUS_3,X          ; get FACX mantissa3
  5782 00:EDF9: 84 B9              STY   FAC1_r            ; save as FAC1 rounding byte
  5783 00:EDFB: B4 02              LDY   PLUS_2,X          ; get FACX mantissa2
  5784 00:EDFD: 94 03              STY   PLUS_3,X          ; save FACX mantissa3
  5785 00:EDFF: B4 01              LDY   PLUS_1,X          ; get FACX mantissa1
  5786 00:EE01: 94 02              STY   PLUS_2,X          ; save FACX mantissa2
  5787 00:EE03: A4 B2              LDY   FAC1_o            ; get FAC1 overflow byte
  5788 00:EE05: 94 01              STY   PLUS_1,X          ; save FACX mantissa1
  5789                        
  5790                        ; shift FACX -A times right (> 8 shifts)
  5791                        
  5792                        LAB_257B
  5793 00:EE07: 69 08              ADC   #$08              ; add 8 to shift count
  5794 00:EE09: 30 EC              BMI   LAB_256B          ; go do 8 shift if still -ve
  5795                        
  5796 00:EE0B: F0 EA              BEQ   LAB_256B          ; go do 8 shift if zero
  5797                        
  5798 00:EE0D: E9 08              SBC   #$08              ; else subtract 8 again
  5799 00:EE0F: A8                 TAY                     ; save count to Y
  5800 00:EE10: A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
  5801 00:EE12: B0 12              BCS   LAB_259A          ;.
  5802                        
  5803                        LAB_2588
  5804 00:EE14: 16 01              ASL   PLUS_1,X          ; shift FACX mantissa1
  5805 00:EE16: 90 02              BCC   LAB_258E          ; branch if +ve
  5806                        
  5807 00:EE18: F6 01              INC   PLUS_1,X          ; this sets b7 eventually
  5808                        LAB_258E
  5809 00:EE1A: 76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (correct for ASL)
  5810 00:EE1C: 76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (put carry in b7)
  5811                        
  5812                        ; shift FACX Y times right
  5813                        
  5814                        LAB_2592
  5815 00:EE1E: 76 02              ROR   PLUS_2,X          ; shift FACX mantissa2
  5816 00:EE20: 76 03              ROR   PLUS_3,X          ; shift FACX mantissa3
  5817 00:EE22: 6A                 ROR                     ; shift FACX rounding byte
  5818 00:EE23: C8                 INY                     ; increment exponent diff
  5819 00:EE24: D0 EE              BNE   LAB_2588          ; branch if range adjust not complete
  5820                        
  5821                        LAB_259A
  5822 00:EE26: 18                 CLC                     ; just clear it
  5823 00:EE27: 60                 RTS
  5824                        
  5825                        ; perform LOG()
  5826                        
  5827                        LAB_LOG
  5828 00:EE28: 20 16 F0           JSR   LAB_27CA          ; test sign and zero
  5829 00:EE2B: F0 02              BEQ   LAB_25C4          ; if zero do function call error then warm start
  5830                        
  5831 00:EE2D: 10 03              BPL   LAB_25C7          ; skip error if +ve
  5832                        
  5833                        LAB_25C4
  5834 00:EE2F: 4C 57 E6           JMP   LAB_FCER          ; do function call error then warm start (-ve)
  5835                        
  5836                        LAB_25C7
  5837 00:EE32: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  5838 00:EE34: E9 7F              SBC   #$7F              ; normalise it
  5839 00:EE36: 48                 PHA                     ; save it
  5840 00:EE37: A9 80              LDA   #$80              ; set exponent to zero
  5841 00:EE39: 85 AC              STA   FAC1_e            ; save FAC1 exponent
  5842 00:EE3B: A9 99              LDA   #<LAB_25AD        ; set 1/root2 pointer low byte
  5843 00:EE3D: A0 F8              LDY   #>LAB_25AD        ; set 1/root2 pointer high byte
  5844 00:EE3F: 20 EB EC           JSR   LAB_246C          ; add (AY) to FAC1 (1/root2)
  5845 00:EE42: A9 9D              LDA   #<LAB_25B1        ; set root2 pointer low byte
  5846 00:EE44: A0 F8              LDY   #>LAB_25B1        ; set root2 pointer high byte
  5847 00:EE46: 20 2E EF           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
  5848 00:EE49: A9 10              LDA   #<LAB_259C        ; set 1 pointer low byte
  5849 00:EE4B: A0 F9              LDY   #>LAB_259C        ; set 1 pointer high byte
  5850 00:EE4D: 20 D0 EC           JSR   LAB_2455          ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
  5851 00:EE50: A9 8C              LDA   #<LAB_25A0        ; set pointer low byte to counter
  5852 00:EE52: A0 F8              LDY   #>LAB_25A0        ; set pointer high byte to counter
  5853 00:EE54: 20 7E F3           JSR   LAB_2B6E          ; ^2 then series evaluation
  5854 00:EE57: A9 A1              LDA   #<LAB_25B5        ; set -0.5 pointer low byte
  5855 00:EE59: A0 F8              LDY   #>LAB_25B5        ; set -0.5 pointer high byte
  5856 00:EE5B: 20 EB EC           JSR   LAB_246C          ; add (AY) to FAC1
  5857 00:EE5E: 68                 PLA                     ; restore FAC1 exponent
  5858 00:EE5F: 20 72 F1           JSR   LAB_2912          ; evaluate new ASCII digit
  5859 00:EE62: A9 A5              LDA   #<LAB_25B9        ; set LOG(2) pointer low byte
  5860 00:EE64: A0 F8              LDY   #>LAB_25B9        ; set LOG(2) pointer high byte
  5861                        
  5862                        ; do convert AY, FCA1*(AY)
  5863                        
  5864                        LAB_25FB
  5865 00:EE66: 20 B8 EE           JSR   LAB_264D          ; unpack memory (AY) into FAC2
  5866                        LAB_MULTIPLY
  5867 00:EE69: F0 4C              BEQ   LAB_264C          ; exit if zero
  5868                        
  5869 00:EE6B: 20 DE EE           JSR   LAB_2673          ; test and adjust accumulators
  5870 00:EE6E: A9 00              LDA   #$00              ; clear A
  5871 00:EE70: 85 75              STA   FACt_1            ; clear temp mantissa1
  5872 00:EE72: 85 76              STA   FACt_2            ; clear temp mantissa2
  5873 00:EE74: 85 77              STA   FACt_3            ; clear temp mantissa3
  5874 00:EE76: A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
  5875 00:EE78: 20 8D EE           JSR   LAB_2622          ; go do shift/add FAC2
  5876 00:EE7B: A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
  5877 00:EE7D: 20 8D EE           JSR   LAB_2622          ; go do shift/add FAC2
  5878 00:EE80: A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
  5879 00:EE82: 20 8D EE           JSR   LAB_2622          ; go do shift/add FAC2
  5880 00:EE85: A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
  5881 00:EE87: 20 93 EE           JSR   LAB_2627          ; go do shift/add FAC2
  5882 00:EE8A: 4C 9B EF           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
  5883                        
  5884                        LAB_2622
  5885 00:EE8D: D0 04              BNE   LAB_2627          ; branch if byte <> zero
  5886                        ; *** begin patch  2.22p5.6  floating point multiply rounding bug
  5887                        ; *** replace
  5888                        ;      JMP   LAB_2569          ; shift FCAtemp << A+8 times
  5889                        ;
  5890                        ;                              ; else do shift and add
  5891                        ;LAB_2627
  5892                        ;      LSR                     ; shift byte
  5893                        ;      ORA   #$80              ; set top bit (mark for 8 times)
  5894                        ; *** with
  5895 00:EE8F: 38                 SEC
  5896 00:EE90: 4C F5 ED           JMP   LAB_2569          ; shift FACtemp << A+8 times
  5897                        
  5898                                                      ; else do shift and add
  5899                        LAB_2627
  5900 00:EE93: 38                 SEC                     ; set top bit (mark for 8 times)
  5901 00:EE94: 6A                 ROR
  5902                        ; *** end patch    2.22p5.6  floating point multiply rounding bug
  5903                        LAB_262A
  5904 00:EE95: A8                 TAY                     ; copy result
  5905 00:EE96: 90 13              BCC   LAB_2640          ; skip next if bit was zero
  5906                        
  5907 00:EE98: 18                 CLC                     ; clear carry for add
  5908 00:EE99: A5 77              LDA   FACt_3            ; get temp mantissa3
  5909 00:EE9B: 65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
  5910 00:EE9D: 85 77              STA   FACt_3            ; save temp mantissa3
  5911 00:EE9F: A5 76              LDA   FACt_2            ; get temp mantissa2
  5912 00:EEA1: 65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
  5913 00:EEA3: 85 76              STA   FACt_2            ; save temp mantissa2
  5914 00:EEA5: A5 75              LDA   FACt_1            ; get temp mantissa1
  5915 00:EEA7: 65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
  5916 00:EEA9: 85 75              STA   FACt_1            ; save temp mantissa1
  5917                        LAB_2640
  5918 00:EEAB: 66 75              ROR   FACt_1            ; shift temp mantissa1
  5919 00:EEAD: 66 76              ROR   FACt_2            ; shift temp mantissa2
  5920 00:EEAF: 66 77              ROR   FACt_3            ; shift temp mantissa3
  5921 00:EEB1: 66 B9              ROR   FAC1_r            ; shift temp rounding byte
  5922 00:EEB3: 98                 TYA                     ; get byte back
  5923 00:EEB4: 4A                 LSR                     ; shift byte
  5924 00:EEB5: D0 DE              BNE   LAB_262A          ; loop if all bits not done
  5925                        
  5926                        LAB_264C
  5927 00:EEB7: 60                 RTS
  5928                        
  5929                        ; unpack memory (AY) into FAC2
  5930                        
  5931                        LAB_264D
  5932 00:EEB8: 85 71              STA   ut1_pl            ; save pointer low byte
  5933 00:EEBA: 84 72              STY   ut1_ph            ; save pointer high byte
  5934 00:EEBC: A0 03              LDY   #$03              ; 4 bytes to get (0-3)
  5935 00:EEBE: B1 71              LDA   (ut1_pl),Y        ; get mantissa3
  5936 00:EEC0: 85 B6              STA   FAC2_3            ; save FAC2 mantissa3
  5937 00:EEC2: 88                 DEY                     ; decrement index
  5938 00:EEC3: B1 71              LDA   (ut1_pl),Y        ; get mantissa2
  5939 00:EEC5: 85 B5              STA   FAC2_2            ; save FAC2 mantissa2
  5940 00:EEC7: 88                 DEY                     ; decrement index
  5941 00:EEC8: B1 71              LDA   (ut1_pl),Y        ; get mantissa1+sign
  5942 00:EECA: 85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
  5943 00:EECC: 45 B0              EOR   FAC1_s            ; EOR with FAC1 sign (b7)
  5944 00:EECE: 85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  5945 00:EED0: A5 B7              LDA   FAC2_s            ; recover FAC2 sign (b7)
  5946 00:EED2: 09 80              ORA   #$80              ; set 1xxx xxx (set normal bit)
  5947 00:EED4: 85 B4              STA   FAC2_1            ; save FAC2 mantissa1
  5948 00:EED6: 88                 DEY                     ; decrement index
  5949 00:EED7: B1 71              LDA   (ut1_pl),Y        ; get exponent byte
  5950 00:EED9: 85 B3              STA   FAC2_e            ; save FAC2 exponent
  5951 00:EEDB: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  5952 00:EEDD: 60                 RTS
  5953                        
  5954                        ; test and adjust accumulators
  5955                        
  5956                        LAB_2673
  5957 00:EEDE: A5 B3              LDA   FAC2_e            ; get FAC2 exponent
  5958                        LAB_2675
  5959 00:EEE0: F0 1D              BEQ   LAB_2696          ; branch if FAC2 = $00 (handle underflow)
  5960                        
  5961 00:EEE2: 18                 CLC                     ; clear carry for add
  5962 00:EEE3: 65 AC              ADC   FAC1_e            ; add FAC1 exponent
  5963 00:EEE5: 90 04              BCC   LAB_2680          ; branch if sum of exponents <$0100
  5964                        
  5965 00:EEE7: 30 31              BMI   LAB_269B          ; do overflow error
  5966                        
  5967 00:EEE9: 18                 CLC                     ; clear carry for the add
  5968 00:EEEA: 2C                 .byte $2C               ; makes next line BIT $1410
  5969                        LAB_2680
  5970 00:EEEB: 10 12              BPL   LAB_2696          ; if +ve go handle underflow
  5971                        
  5972 00:EEED: 69 80              ADC   #$80              ; adjust exponent
  5973 00:EEEF: 85 AC              STA   FAC1_e            ; save FAC1 exponent
  5974 00:EEF1: D0 03              BNE   LAB_268B          ; branch if not zero
  5975                        
  5976 00:EEF3: 4C 81 ED           JMP   LAB_24F5          ; save FAC1 sign and return
  5977                        
  5978                        LAB_268B
  5979 00:EEF6: A5 B8              LDA   FAC_sc            ; get sign compare (FAC1 EOR FAC2)
  5980 00:EEF8: 85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
  5981                        LAB_268F
  5982 00:EEFA: 60                 RTS
  5983                        
  5984                        ; handle overflow and underflow
  5985                        
  5986                        LAB_2690
  5987 00:EEFB: A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
  5988 00:EEFD: 10 1B              BPL   LAB_269B          ; do overflow error
  5989                        
  5990                                                      ; handle underflow
  5991                        LAB_2696
  5992 00:EEFF: 68                 PLA                     ; pop return address low byte
  5993 00:EF00: 68                 PLA                     ; pop return address high byte
  5994 00:EF01: 4C 7D ED           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
  5995                        
  5996                        ; multiply by 10
  5997                        
  5998                        LAB_269E
  5999 00:EF04: 20 F7 EF           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  6000 00:EF07: AA                 TAX                     ; copy exponent (set the flags)
  6001 00:EF08: F0 F0              BEQ   LAB_268F          ; exit if zero
  6002                        
  6003 00:EF0A: 18                 CLC                     ; clear carry for add
  6004 00:EF0B: 69 02              ADC   #$02              ; add two to exponent (*4)
  6005 00:EF0D: B0 0B              BCS   LAB_269B          ; do overflow error if > $FF
  6006                        
  6007 00:EF0F: A2 00              LDX   #$00              ; clear byte
  6008 00:EF11: 86 B8              STX   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
  6009 00:EF13: 20 08 ED           JSR   LAB_247C          ; add FAC2 to FAC1 (*5)
  6010 00:EF16: E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*10)
  6011 00:EF18: D0 E0              BNE   LAB_268F          ; if non zero just do RTS
  6012                        
  6013                        LAB_269B
  6014 00:EF1A: 4C F0 ED           JMP   LAB_2564          ; do overflow error and warm start
  6015                        
  6016                        ; divide by 10
  6017                        
  6018                        LAB_26B9
  6019 00:EF1D: 20 F7 EF           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  6020 00:EF20: A9 21              LDA   #<LAB_26B5        ; set pointer to 10d low addr
  6021 00:EF22: A0 F9              LDY   #>LAB_26B5        ; set pointer to 10d high addr
  6022 00:EF24: A2 00              LDX   #$00              ; clear sign
  6023                        
  6024                        ; divide by (AY) (X=sign)
  6025                        
  6026                        LAB_26C2
  6027 00:EF26: 86 B8              STX   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  6028 00:EF28: 20 AA EF           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  6029 00:EF2B: 4C 31 EF           JMP   LAB_DIVIDE        ; do FAC2/FAC1
  6030                        
  6031                                                      ; Perform divide-by
  6032                        ; convert AY and do (AY)/FAC1
  6033                        
  6034                        LAB_26CA
  6035 00:EF2E: 20 B8 EE           JSR   LAB_264D          ; unpack memory (AY) into FAC2
  6036                        
  6037                                                      ; Perform divide-into
  6038                        LAB_DIVIDE
  6039 00:EF31: F0 63              BEQ   LAB_2737          ; if zero go do /0 error
  6040                        
  6041 00:EF33: 20 06 F0           JSR   LAB_27BA          ; round FAC1
  6042 00:EF36: A9 00              LDA   #$00              ; clear A
  6043 00:EF38: 38                 SEC                     ; set carry for subtract
  6044 00:EF39: E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent (2s complement)
  6045 00:EF3B: 85 AC              STA   FAC1_e            ; save FAC1 exponent
  6046 00:EF3D: 20 DE EE           JSR   LAB_2673          ; test and adjust accumulators
  6047 00:EF40: E6 AC              INC   FAC1_e            ; increment FAC1 exponent
  6048 00:EF42: F0 D6              BEQ   LAB_269B          ; if zero do overflow error
  6049                        
  6050 00:EF44: A2 FF              LDX   #$FF              ; set index for pre increment
  6051 00:EF46: A9 01              LDA   #$01              ; set bit to flag byte save
  6052                        LAB_26E4
  6053 00:EF48: A4 B4              LDY   FAC2_1            ; get FAC2 mantissa1
  6054 00:EF4A: C4 AD              CPY   FAC1_1            ; compare FAC1 mantissa1
  6055 00:EF4C: D0 0A              BNE   LAB_26F4          ; branch if <>
  6056                        
  6057 00:EF4E: A4 B5              LDY   FAC2_2            ; get FAC2 mantissa2
  6058 00:EF50: C4 AE              CPY   FAC1_2            ; compare FAC1 mantissa2
  6059 00:EF52: D0 04              BNE   LAB_26F4          ; branch if <>
  6060                        
  6061 00:EF54: A4 B6              LDY   FAC2_3            ; get FAC2 mantissa3
  6062 00:EF56: C4 AF              CPY   FAC1_3            ; compare FAC1 mantissa3
  6063                        LAB_26F4
  6064 00:EF58: 08                 PHP                     ; save FAC2-FAC1 compare status
  6065 00:EF59: 2A                 ROL                     ; shift the result byte
  6066 00:EF5A: 90 0E              BCC   LAB_2702          ; if no carry skip the byte save
  6067                        
  6068 00:EF5C: A0 01              LDY   #$01              ; set bit to flag byte save
  6069 00:EF5E: E8                 INX                     ; else increment the index to FACt
  6070 00:EF5F: E0 02              CPX   #$02              ; compare with the index to FACt_3
  6071 00:EF61: 30 04              BMI   LAB_2701          ; if not last byte just go save it
  6072                        
  6073 00:EF63: D0 28              BNE   LAB_272B          ; if all done go save FAC1 rounding byte, normalise and
  6074                                                      ; return
  6075                        
  6076 00:EF65: A0 40              LDY   #$40              ; set bit to flag byte save for the rounding byte
  6077                        LAB_2701
  6078 00:EF67: 95 75              STA   FACt_1,X          ; write result byte to FACt_1 + index
  6079 00:EF69: 98                 TYA                     ; copy the next save byte flag
  6080                        LAB_2702
  6081 00:EF6A: 28                 PLP                     ; restore FAC2-FAC1 compare status
  6082 00:EF6B: 90 14              BCC   LAB_2704          ; if FAC2 < FAC1 then skip the subtract
  6083                        
  6084 00:EF6D: A8                 TAY                     ; save FAC2-FAC1 compare status
  6085 00:EF6E: A5 B6              LDA   FAC2_3            ; get FAC2 mantissa3
  6086 00:EF70: E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
  6087 00:EF72: 85 B6              STA   FAC2_3            ; save FAC2 mantissa3
  6088 00:EF74: A5 B5              LDA   FAC2_2            ; get FAC2 mantissa2
  6089 00:EF76: E5 AE              SBC   FAC1_2            ; subtract FAC1 mantissa2
  6090 00:EF78: 85 B5              STA   FAC2_2            ; save FAC2 mantissa2
  6091 00:EF7A: A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
  6092 00:EF7C: E5 AD              SBC   FAC1_1            ; subtract FAC1 mantissa1
  6093 00:EF7E: 85 B4              STA   FAC2_1            ; save FAC2 mantissa1
  6094 00:EF80: 98                 TYA                     ; restore FAC2-FAC1 compare status
  6095                        
  6096                                                      ; FAC2 = FAC2*2
  6097                        LAB_2704
  6098 00:EF81: 06 B6              ASL   FAC2_3            ; shift FAC2 mantissa3
  6099 00:EF83: 26 B5              ROL   FAC2_2            ; shift FAC2 mantissa2
  6100 00:EF85: 26 B4              ROL   FAC2_1            ; shift FAC2 mantissa1
  6101 00:EF87: B0 CF              BCS   LAB_26F4          ; loop with no compare
  6102                        
  6103 00:EF89: 30 BD              BMI   LAB_26E4          ; loop with compare
  6104                        
  6105 00:EF8B: 10 CB              BPL   LAB_26F4          ; loop always with no compare
  6106                        
  6107                        ; do A<<6, save as FAC1 rounding byte, normalise and return
  6108                        
  6109                        LAB_272B
  6110 00:EF8D: 4A                 LSR                     ; shift b1 - b0 ..
  6111 00:EF8E: 6A                 ROR                     ; ..
  6112 00:EF8F: 6A                 ROR                     ; .. to b7 - b6
  6113 00:EF90: 85 B9              STA   FAC1_r            ; save FAC1 rounding byte
  6114 00:EF92: 28                 PLP                     ; dump FAC2-FAC1 compare status
  6115 00:EF93: 4C 9B EF           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
  6116                        
  6117                        ; do "Divide by zero" error
  6118                        
  6119                        LAB_2737
  6120 00:EF96: A2 14              LDX   #$14              ; error code $14 ("Divide by zero" error)
  6121 00:EF98: 4C 5F D8           JMP   LAB_XERR          ; do error #X, then warm start
  6122                        
  6123                        ; copy temp to FAC1 and normalise
  6124                        
  6125                        LAB_273C
  6126 00:EF9B: A5 75              LDA   FACt_1            ; get temp mantissa1
  6127 00:EF9D: 85 AD              STA   FAC1_1            ; save FAC1 mantissa1
  6128 00:EF9F: A5 76              LDA   FACt_2            ; get temp mantissa2
  6129 00:EFA1: 85 AE              STA   FAC1_2            ; save FAC1 mantissa2
  6130 00:EFA3: A5 77              LDA   FACt_3            ; get temp mantissa3
  6131 00:EFA5: 85 AF              STA   FAC1_3            ; save FAC1 mantissa3
  6132 00:EFA7: 4C 61 ED           JMP   LAB_24D5          ; normalise FAC1 and return
  6133                        
  6134                        ; unpack memory (AY) into FAC1
  6135                        
  6136                        LAB_UFAC
  6137 00:EFAA: 85 71              STA   ut1_pl            ; save pointer low byte
  6138 00:EFAC: 84 72              STY   ut1_ph            ; save pointer high byte
  6139 00:EFAE: A0 03              LDY   #$03              ; 4 bytes to do
  6140 00:EFB0: B1 71              LDA   (ut1_pl),Y        ; get last byte
  6141 00:EFB2: 85 AF              STA   FAC1_3            ; save FAC1 mantissa3
  6142 00:EFB4: 88                 DEY                     ; decrement index
  6143 00:EFB5: B1 71              LDA   (ut1_pl),Y        ; get last-1 byte
  6144 00:EFB7: 85 AE              STA   FAC1_2            ; save FAC1 mantissa2
  6145 00:EFB9: 88                 DEY                     ; decrement index
  6146 00:EFBA: B1 71              LDA   (ut1_pl),Y        ; get second byte
  6147 00:EFBC: 85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
  6148 00:EFBE: 09 80              ORA   #$80              ; set 1xxx xxxx (add normal bit)
  6149 00:EFC0: 85 AD              STA   FAC1_1            ; save FAC1 mantissa1
  6150 00:EFC2: 88                 DEY                     ; decrement index
  6151 00:EFC3: B1 71              LDA   (ut1_pl),Y        ; get first byte (exponent)
  6152 00:EFC5: 85 AC              STA   FAC1_e            ; save FAC1 exponent
  6153 00:EFC7: 84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
  6154 00:EFC9: 60                 RTS
  6155                        
  6156                        ; pack FAC1 into Adatal
  6157                        
  6158                        LAB_276E
  6159 00:EFCA: A2 A4              LDX   #<Adatal          ; set pointer low byte
  6160                        LAB_2770
  6161 00:EFCC: A0 00              LDY   #>Adatal          ; set pointer high byte
  6162 00:EFCE: F0 04              BEQ   LAB_2778          ; pack FAC1 into (XY) and return
  6163                        
  6164                        ; pack FAC1 into (Lvarpl)
  6165                        
  6166                        LAB_PFAC
  6167 00:EFD0: A6 97              LDX   Lvarpl            ; get destination pointer low byte
  6168 00:EFD2: A4 98              LDY   Lvarph            ; get destination pointer high byte
  6169                        
  6170                        ; pack FAC1 into (XY)
  6171                        
  6172                        LAB_2778
  6173 00:EFD4: 20 06 F0           JSR   LAB_27BA          ; round FAC1
  6174 00:EFD7: 86 71              STX   ut1_pl            ; save pointer low byte
  6175 00:EFD9: 84 72              STY   ut1_ph            ; save pointer high byte
  6176 00:EFDB: A0 03              LDY   #$03              ; set index
  6177 00:EFDD: A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
  6178 00:EFDF: 91 71              STA   (ut1_pl),Y        ; store in destination
  6179 00:EFE1: 88                 DEY                     ; decrement index
  6180 00:EFE2: A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
  6181 00:EFE4: 91 71              STA   (ut1_pl),Y        ; store in destination
  6182 00:EFE6: 88                 DEY                     ; decrement index
  6183 00:EFE7: A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
  6184 00:EFE9: 09 7F              ORA   #$7F              ; set bits x111 1111
  6185 00:EFEB: 25 AD              AND   FAC1_1            ; AND in FAC1 mantissa1
  6186 00:EFED: 91 71              STA   (ut1_pl),Y        ; store in destination
  6187 00:EFEF: 88                 DEY                     ; decrement index
  6188 00:EFF0: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  6189 00:EFF2: 91 71              STA   (ut1_pl),Y        ; store in destination
  6190 00:EFF4: 84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
  6191 00:EFF6: 60                 RTS
  6192                        
  6193                        ; round and copy FAC1 to FAC2
  6194                        
  6195                        LAB_27AB
  6196 00:EFF7: 20 06 F0           JSR   LAB_27BA          ; round FAC1
  6197                        
  6198                        ; copy FAC1 to FAC2
  6199                        
  6200                        LAB_27AE
  6201 00:EFFA: A2 05              LDX   #$05              ; 5 bytes to copy
  6202                        LAB_27B0
  6203 00:EFFC: B5 AB              LDA   FAC1_e-1,X        ; get byte from FAC1,X
  6204 00:EFFE: 95 B2              STA   FAC1_o,X          ; save byte at FAC2,X
  6205 00:F000: CA                 DEX                     ; decrement count
  6206 00:F001: D0 F9              BNE   LAB_27B0          ; loop if not all done
  6207                        
  6208 00:F003: 86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
  6209                        LAB_27B9
  6210 00:F005: 60                 RTS
  6211                        
  6212                        ; round FAC1
  6213                        
  6214                        LAB_27BA
  6215 00:F006: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  6216 00:F008: F0 FB              BEQ   LAB_27B9          ; exit if zero
  6217                        
  6218 00:F00A: 06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
  6219 00:F00C: 90 F7              BCC   LAB_27B9          ; exit if no overflow
  6220                        
  6221                        ; round FAC1 (no check)
  6222                        
  6223                        LAB_27C2
  6224 00:F00E: 20 E5 ED           JSR   LAB_2559          ; increment FAC1 mantissa
  6225 00:F011: D0 F2              BNE   LAB_27B9          ; branch if no overflow
  6226                        
  6227 00:F013: 4C B6 ED           JMP   LAB_252A          ; normalise FAC1 for C=1 and return
  6228                        
  6229                        ; get FAC1 sign
  6230                        ; return A=FF,C=1/-ve A=01,C=0/+ve
  6231                        
  6232                        LAB_27CA
  6233 00:F016: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  6234 00:F018: F0 09              BEQ   LAB_27D7          ; exit if zero (already correct SGN(0)=0)
  6235                        
  6236                        ; return A=FF,C=1/-ve A=01,C=0/+ve
  6237                        ; no = 0 check
  6238                        
  6239                        LAB_27CE
  6240 00:F01A: A5 B0              LDA   FAC1_s            ; else get FAC1 sign (b7)
  6241                        
  6242                        ; return A=FF,C=1/-ve A=01,C=0/+ve
  6243                        ; no = 0 check, sign in A
  6244                        
  6245                        LAB_27D0
  6246 00:F01C: 2A                 ROL                     ; move sign bit to carry
  6247 00:F01D: A9 FF              LDA   #$FF              ; set byte for -ve result
  6248 00:F01F: B0 02              BCS   LAB_27D7          ; return if sign was set (-ve)
  6249                        
  6250 00:F021: A9 01              LDA   #$01              ; else set byte for +ve result
  6251                        LAB_27D7
  6252 00:F023: 60                 RTS
  6253                        
  6254                        ; perform SGN()
  6255                        
  6256                        LAB_SGN
  6257 00:F024: 20 16 F0           JSR   LAB_27CA          ; get FAC1 sign
  6258                                                      ; return A=$FF/-ve A=$01/+ve
  6259                        ; save A as integer byte
  6260                        
  6261                        LAB_27DB
  6262 00:F027: 85 AD              STA   FAC1_1            ; save FAC1 mantissa1
  6263 00:F029: A9 00              LDA   #$00              ; clear A
  6264 00:F02B: 85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
  6265 00:F02D: A2 88              LDX   #$88              ; set exponent
  6266                        
  6267                        ; set exp=X, clearFAC1 mantissa3 and normalise
  6268                        
  6269                        LAB_27E3
  6270 00:F02F: A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
  6271 00:F031: 49 FF              EOR   #$FF              ; complement it
  6272 00:F033: 2A                 ROL                     ; sign bit into carry
  6273                        
  6274                        ; set exp=X, clearFAC1 mantissa3 and normalise
  6275                        
  6276                        LAB_STFA
  6277 00:F034: A9 00              LDA   #$00              ; clear A
  6278 00:F036: 85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
  6279 00:F038: 86 AC              STX   FAC1_e            ; set FAC1 exponent
  6280 00:F03A: 85 B9              STA   FAC1_r            ; clear FAC1 rounding byte
  6281 00:F03C: 85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
  6282 00:F03E: 4C 5C ED           JMP   LAB_24D0          ; do ABS and normalise FAC1
  6283                        
  6284                        ; perform ABS()
  6285                        
  6286                        LAB_ABS
  6287 00:F041: 46 B0              LSR   FAC1_s            ; clear FAC1 sign (put zero in b7)
  6288 00:F043: 60                 RTS
  6289                        
  6290                        ; compare FAC1 with (AY)
  6291                        ; returns A=$00 if FAC1 = (AY)
  6292                        ; returns A=$01 if FAC1 > (AY)
  6293                        ; returns A=$FF if FAC1 < (AY)
  6294                        
  6295                        LAB_27F8
  6296 00:F044: 85 73              STA   ut2_pl            ; save pointer low byte
  6297                        LAB_27FA
  6298 00:F046: 84 74              STY   ut2_ph            ; save pointer high byte
  6299 00:F048: A0 00              LDY   #$00              ; clear index
  6300 00:F04A: B1 73              LDA   (ut2_pl),Y        ; get exponent
  6301 00:F04C: C8                 INY                     ; increment index
  6302 00:F04D: AA                 TAX                     ; copy (AY) exponent to X
  6303 00:F04E: F0 C6              BEQ   LAB_27CA          ; branch if (AY) exponent=0 and get FAC1 sign
  6304                                                      ; A=FF,C=1/-ve A=01,C=0/+ve
  6305                        
  6306 00:F050: B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
  6307 00:F052: 45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
  6308 00:F054: 30 C4              BMI   LAB_27CE          ; if signs <> do return A=FF,C=1/-ve
  6309                                                      ; A=01,C=0/+ve and return
  6310                        
  6311 00:F056: E4 AC              CPX   FAC1_e            ; compare (AY) exponent with FAC1 exponent
  6312 00:F058: D0 1A              BNE   LAB_2828          ; branch if different
  6313                        
  6314 00:F05A: B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
  6315 00:F05C: 09 80              ORA   #$80              ; normalise top bit
  6316 00:F05E: C5 AD              CMP   FAC1_1            ; compare with FAC1 mantissa1
  6317 00:F060: D0 12              BNE   LAB_2828          ; branch if different
  6318                        
  6319 00:F062: C8                 INY                     ; increment index
  6320 00:F063: B1 73              LDA   (ut2_pl),Y        ; get mantissa2
  6321 00:F065: C5 AE              CMP   FAC1_2            ; compare with FAC1 mantissa2
  6322 00:F067: D0 0B              BNE   LAB_2828          ; branch if different
  6323                        
  6324 00:F069: C8                 INY                     ; increment index
  6325 00:F06A: A9 7F              LDA   #$7F              ; set for 1/2 value rounding byte
  6326 00:F06C: C5 B9              CMP   FAC1_r            ; compare with FAC1 rounding byte (set carry)
  6327 00:F06E: B1 73              LDA   (ut2_pl),Y        ; get mantissa3
  6328 00:F070: E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
  6329 00:F072: F0 28              BEQ   LAB_2850          ; exit if mantissa3 equal
  6330                        
  6331                        ; gets here if number <> FAC1
  6332                        
  6333                        LAB_2828
  6334 00:F074: A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
  6335 00:F076: 90 02              BCC   LAB_282E          ; branch if FAC1 > (AY)
  6336                        
  6337 00:F078: 49 FF              EOR   #$FF              ; else toggle FAC1 sign
  6338                        LAB_282E
  6339 00:F07A: 4C 1C F0           JMP   LAB_27D0          ; return A=FF,C=1/-ve A=01,C=0/+ve
  6340                        
  6341                        ; convert FAC1 floating-to-fixed
  6342                        
  6343                        LAB_2831
  6344 00:F07D: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  6345 00:F07F: F0 4A              BEQ   LAB_287F          ; if zero go clear FAC1 and return
  6346                        
  6347 00:F081: 38                 SEC                     ; set carry for subtract
  6348 00:F082: E9 98              SBC   #$98              ; subtract maximum integer range exponent
  6349 00:F084: 24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
  6350 00:F086: 10 09              BPL   LAB_2845          ; branch if FAC1 +ve
  6351                        
  6352                                                      ; FAC1 was -ve
  6353 00:F088: AA                 TAX                     ; copy subtracted exponent
  6354 00:F089: A9 FF              LDA   #$FF              ; overflow for -ve number
  6355 00:F08B: 85 B2              STA   FAC1_o            ; set FAC1 overflow byte
  6356 00:F08D: 20 C9 ED           JSR   LAB_253D          ; twos complement FAC1 mantissa
  6357 00:F090: 8A                 TXA                     ; restore subtracted exponent
  6358                        LAB_2845
  6359 00:F091: A2 AC              LDX   #FAC1_e           ; set index to FAC1
  6360 00:F093: C9 F9              CMP   #$F9              ; compare exponent result
  6361 00:F095: 10 06              BPL   LAB_2851          ; if < 8 shifts shift FAC1 A times right and return
  6362                        
  6363 00:F097: 20 07 EE           JSR   LAB_257B          ; shift FAC1 A times right (> 8 shifts)
  6364 00:F09A: 84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
  6365                        LAB_2850
  6366 00:F09C: 60                 RTS
  6367                        
  6368                        ; shift FAC1 A times right
  6369                        
  6370                        LAB_2851
  6371 00:F09D: A8                 TAY                     ; copy shift count
  6372 00:F09E: A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
  6373 00:F0A0: 29 80              AND   #$80              ; mask sign bit only (x000 0000)
  6374 00:F0A2: 46 AD              LSR   FAC1_1            ; shift FAC1 mantissa1
  6375 00:F0A4: 05 AD              ORA   FAC1_1            ; OR sign in b7 FAC1 mantissa1
  6376 00:F0A6: 85 AD              STA   FAC1_1            ; save FAC1 mantissa1
  6377 00:F0A8: 20 1E EE           JSR   LAB_2592          ; shift FAC1 Y times right
  6378 00:F0AB: 84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
  6379 00:F0AD: 60                 RTS
  6380                        
  6381                        ; perform INT()
  6382                        
  6383                        LAB_INT
  6384 00:F0AE: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  6385 00:F0B0: C9 98              CMP   #$98              ; compare with max int
  6386 00:F0B2: B0 1E              BCS   LAB_2886          ; exit if >= (already int, too big for fractional part!)
  6387                        
  6388 00:F0B4: 20 7D F0           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
  6389 00:F0B7: 84 B9              STY   FAC1_r            ; save FAC1 rounding byte
  6390 00:F0B9: A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
  6391 00:F0BB: 84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
  6392 00:F0BD: 49 80              EOR   #$80              ; toggle FAC1 sign
  6393 00:F0BF: 2A                 ROL                     ; shift into carry
  6394 00:F0C0: A9 98              LDA   #$98              ; set new exponent
  6395 00:F0C2: 85 AC              STA   FAC1_e            ; save FAC1 exponent
  6396 00:F0C4: A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
  6397 00:F0C6: 85 5B              STA   Temp3             ; save for EXP() function
  6398 00:F0C8: 4C 5C ED           JMP   LAB_24D0          ; do ABS and normalise FAC1
  6399                        
  6400                        ; clear FAC1 and return
  6401                        
  6402                        LAB_287F
  6403 00:F0CB: 85 AD              STA   FAC1_1            ; clear FAC1 mantissa1
  6404 00:F0CD: 85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
  6405 00:F0CF: 85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
  6406 00:F0D1: A8                 TAY                     ; clear Y
  6407                        LAB_2886
  6408 00:F0D2: 60                 RTS
  6409                        
  6410                        ; get FAC1 from string
  6411                        ; this routine now handles hex and binary values from strings
  6412                        ; starting with "$" and "%" respectively
  6413                        
  6414                        LAB_2887
  6415 00:F0D3: A0 00              LDY   #$00              ; clear Y
  6416 00:F0D5: 84 5F              STY   Dtypef            ; clear data type flag, $FF=string, $00=numeric
  6417 00:F0D7: A2 09              LDX   #$09              ; set index
  6418                        LAB_288B
  6419 00:F0D9: 94 A8              STY   numexp,X          ; clear byte
  6420 00:F0DB: CA                 DEX                     ; decrement index
  6421 00:F0DC: 10 FB              BPL   LAB_288B          ; loop until numexp to negnum (and FAC1) = $00
  6422                        
  6423 00:F0DE: 90 7F              BCC   LAB_28FE          ; branch if 1st character numeric
  6424                        
  6425                        ; get FAC1 from string .. first character wasn't numeric
  6426                        
  6427 00:F0E0: C9 2D              CMP   #'-'              ; else compare with "-"
  6428 00:F0E2: D0 04              BNE   LAB_289A          ; branch if not "-"
  6429                        
  6430 00:F0E4: 86 B1              STX   negnum            ; set flag for -ve number (X = $FF)
  6431 00:F0E6: F0 04              BEQ   LAB_289C          ; branch always (go scan and check for hex/bin)
  6432                        
  6433                        ; get FAC1 from string .. first character wasn't numeric or -
  6434                        
  6435                        LAB_289A
  6436 00:F0E8: C9 2B              CMP   #'+'              ; else compare with "+"
  6437 00:F0EA: D0 05              BNE   LAB_289D          ; branch if not "+" (go check for hex/bin)
  6438                        
  6439                        ; was "+" or "-" to start, so get next character
  6440                        
  6441                        LAB_289C
  6442 00:F0EC: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  6443 00:F0EF: 90 6E              BCC   LAB_28FE          ; branch if numeric character
  6444                        
  6445                        ; code here for hex and binary numbers
  6446                        
  6447                        LAB_289D
  6448 00:F0F1: C9 24              CMP   #'$'              ; else compare with "$"
  6449 00:F0F3: D0 03              BNE   LAB_NHEX          ; branch if not "$"
  6450                        
  6451 00:F0F5: 4C 9D F5           JMP   LAB_CHEX          ; branch if "$"
  6452                        
  6453                        LAB_NHEX
  6454 00:F0F8: C9 25              CMP   #'%'              ; else compare with "%"
  6455 00:F0FA: D0 08              BNE   LAB_28A3          ; branch if not "%" (continue original code)
  6456                        
  6457 00:F0FC: 4C CB F5           JMP   LAB_CBIN          ; branch if "%"
  6458                        
  6459                        LAB_289E
  6460 00:F0FF: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (ignore + or get next number)
  6461                        LAB_28A1
  6462 00:F102: 90 5B              BCC   LAB_28FE          ; branch if numeric character
  6463                        
  6464                        ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
  6465                        
  6466                        LAB_28A3
  6467 00:F104: C9 2E              CMP   #'.'              ; else compare with "."
  6468 00:F106: F0 2E              BEQ   LAB_28D5          ; branch if "."
  6469                        
  6470                        ; get FAC1 from string .. character wasn't numeric, -, + or .
  6471                        
  6472 00:F108: C9 45              CMP   #'E'              ; else compare with "E"
  6473 00:F10A: D0 30              BNE   LAB_28DB          ; branch if not "E"
  6474                        
  6475                                                      ; was "E" so evaluate exponential part
  6476 00:F10C: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  6477 00:F10F: 90 17              BCC   LAB_28C7          ; branch if numeric character
  6478                        
  6479 00:F111: C9 B7              CMP   #TK_MINUS         ; else compare with token for -
  6480 00:F113: F0 0E              BEQ   LAB_28C2          ; branch if token for -
  6481                        
  6482 00:F115: C9 2D              CMP   #'-'              ; else compare with "-"
  6483 00:F117: F0 0A              BEQ   LAB_28C2          ; branch if "-"
  6484                        
  6485 00:F119: C9 B6              CMP   #TK_PLUS          ; else compare with token for +
  6486 00:F11B: F0 08              BEQ   LAB_28C4          ; branch if token for +
  6487                        
  6488 00:F11D: C9 2B              CMP   #'+'              ; else compare with "+"
  6489 00:F11F: F0 04              BEQ   LAB_28C4          ; branch if "+"
  6490                        
  6491 00:F121: D0 07              BNE   LAB_28C9          ; branch always
  6492                        
  6493                        LAB_28C2
  6494 00:F123: 66 AB              ROR   expneg            ; set exponent -ve flag (C, which=1, into b7)
  6495                        LAB_28C4
  6496 00:F125: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  6497                        LAB_28C7
  6498 00:F128: 90 5B              BCC   LAB_2925          ; branch if numeric character
  6499                        
  6500                        LAB_28C9
  6501 00:F12A: 24 AB              BIT   expneg            ; test exponent -ve flag
  6502 00:F12C: 10 0E              BPL   LAB_28DB          ; if +ve go evaluate exponent
  6503                        
  6504                                                      ; else do exponent = -exponent 
  6505 00:F12E: A9 00              LDA   #$00              ; clear result
  6506 00:F130: 38                 SEC                     ; set carry for subtract
  6507 00:F131: E5 A9              SBC   expcnt            ; subtract exponent byte
  6508 00:F133: 4C 3E F1           JMP   LAB_28DD          ; go evaluate exponent
  6509                        
  6510                        LAB_28D5
  6511 00:F136: 66 AA              ROR   numdpf            ; set decimal point flag
  6512 00:F138: 24 AA              BIT   numdpf            ; test decimal point flag
  6513 00:F13A: 50 C3              BVC   LAB_289E          ; branch if only one decimal point so far
  6514                        
  6515                                                      ; evaluate exponent
  6516                        LAB_28DB
  6517 00:F13C: A5 A9              LDA   expcnt            ; get exponent count byte
  6518                        LAB_28DD
  6519 00:F13E: 38                 SEC                     ; set carry for subtract
  6520 00:F13F: E5 A8              SBC   numexp            ; subtract numerator exponent
  6521 00:F141: 85 A9              STA   expcnt            ; save exponent count byte
  6522 00:F143: F0 12              BEQ   LAB_28F6          ; branch if no adjustment
  6523                        
  6524 00:F145: 10 09              BPL   LAB_28EF          ; else if +ve go do FAC1*10^expcnt
  6525                        
  6526                                                      ; else go do FAC1/10^(0-expcnt)
  6527                        LAB_28E6
  6528 00:F147: 20 1D EF           JSR   LAB_26B9          ; divide by 10
  6529 00:F14A: E6 A9              INC   expcnt            ; increment exponent count byte
  6530 00:F14C: D0 F9              BNE   LAB_28E6          ; loop until all done
  6531                        
  6532 00:F14E: F0 07              BEQ   LAB_28F6          ; branch always
  6533                        
  6534                        LAB_28EF
  6535 00:F150: 20 04 EF           JSR   LAB_269E          ; multiply by 10
  6536 00:F153: C6 A9              DEC   expcnt            ; decrement exponent count byte
  6537 00:F155: D0 F9              BNE   LAB_28EF          ; loop until all done
  6538                        
  6539                        LAB_28F6
  6540 00:F157: A5 B1              LDA   negnum            ; get -ve flag
  6541 00:F159: 30 01              BMI   LAB_28FB          ; if -ve do - FAC1 and return
  6542                        
  6543 00:F15B: 60                 RTS
  6544                        
  6545                        ; do - FAC1 and return
  6546                        
  6547                        LAB_28FB
  6548 00:F15C: 4C 21 F3           JMP   LAB_GTHAN         ; do - FAC1 and return
  6549                        
  6550                        ; do unsigned FAC1*10+number
  6551                        
  6552                        LAB_28FE
  6553 00:F15F: 48                 PHA                     ; save character
  6554 00:F160: 24 AA              BIT   numdpf            ; test decimal point flag
  6555 00:F162: 10 02              BPL   LAB_2905          ; skip exponent increment if not set
  6556                        
  6557 00:F164: E6 A8              INC   numexp            ; else increment number exponent
  6558                        LAB_2905
  6559 00:F166: 20 04 EF           JSR   LAB_269E          ; multiply FAC1 by 10
  6560 00:F169: 68                 PLA                     ; restore character
  6561 00:F16A: 29 0F              AND   #$0F              ; convert to binary
  6562 00:F16C: 20 72 F1           JSR   LAB_2912          ; evaluate new ASCII digit
  6563 00:F16F: 4C FF F0           JMP   LAB_289E          ; go do next character
  6564                        
  6565                        ; evaluate new ASCII digit
  6566                        
  6567                        LAB_2912
  6568 00:F172: 48                 PHA                     ; save digit
  6569 00:F173: 20 F7 EF           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  6570 00:F176: 68                 PLA                     ; restore digit
  6571 00:F177: 20 27 F0           JSR   LAB_27DB          ; save A as integer byte
  6572 00:F17A: A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
  6573 00:F17C: 45 B0              EOR   FAC1_s            ; toggle with FAC1 sign (b7)
  6574 00:F17E: 85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  6575 00:F180: A6 AC              LDX   FAC1_e            ; get FAC1 exponent
  6576 00:F182: 4C EE EC           JMP   LAB_ADD           ; add FAC2 to FAC1 and return
  6577                        
  6578                        ; evaluate next character of exponential part of number
  6579                        
  6580                        LAB_2925
  6581 00:F185: A5 A9              LDA   expcnt            ; get exponent count byte
  6582 00:F187: C9 0A              CMP   #$0A              ; compare with 10 decimal
  6583 00:F189: 90 09              BCC   LAB_2934          ; branch if less
  6584                        
  6585 00:F18B: A9 64              LDA   #$64              ; make all -ve exponents = -100 decimal (causes underflow)
  6586 00:F18D: 24 AB              BIT   expneg            ; test exponent -ve flag
  6587 00:F18F: 30 0E              BMI   LAB_2942          ; branch if -ve
  6588                        
  6589 00:F191: 4C F0 ED           JMP   LAB_2564          ; else do overflow error
  6590                        
  6591                        LAB_2934
  6592 00:F194: 0A                 ASL                     ; * 2
  6593 00:F195: 0A                 ASL                     ; * 4
  6594 00:F196: 65 A9              ADC   expcnt            ; * 5
  6595 00:F198: 0A                 ASL                     ; * 10
  6596 00:F199: A0 00              LDY   #$00              ; set index
  6597 00:F19B: 71 C3              ADC   (Bpntrl),Y        ; add character (will be $30 too much!)
  6598 00:F19D: E9 2F              SBC   #'0'-1            ; convert character to binary
  6599                        LAB_2942
  6600 00:F19F: 85 A9              STA   expcnt            ; save exponent count byte
  6601 00:F1A1: 4C 25 F1           JMP   LAB_28C4          ; go get next character
  6602                        
  6603                        ; print " in line [LINE #]"
  6604                        
  6605                        LAB_2953
  6606 00:F1A4: A9 1D              LDA   #<LAB_LMSG        ; point to " in line " message low byte
  6607 00:F1A6: A0 FF              LDY   #>LAB_LMSG        ; point to " in line " message high byte
  6608 00:F1A8: 20 F4 DF           JSR   LAB_18C3          ; print null terminated string from memory
  6609                        
  6610                                                      ; print Basic line #
  6611 00:F1AB: A5 88              LDA   Clineh            ; get current line high byte
  6612 00:F1AD: A6 87              LDX   Clinel            ; get current line low byte
  6613                        
  6614                        ; print XA as unsigned integer
  6615                        
  6616                        LAB_295E
  6617 00:F1AF: 85 AD              STA   FAC1_1            ; save low byte as FAC1 mantissa1
  6618 00:F1B1: 86 AE              STX   FAC1_2            ; save high byte as FAC1 mantissa2
  6619 00:F1B3: A2 90              LDX   #$90              ; set exponent to 16d bits
  6620 00:F1B5: 38                 SEC                     ; set integer is +ve flag
  6621 00:F1B6: 20 34 F0           JSR   LAB_STFA          ; set exp=X, clearFAC1 mantissa3 and normalise
  6622 00:F1B9: A0 00              LDY   #$00              ; clear index
  6623 00:F1BB: 98                 TYA                     ; clear A
  6624 00:F1BC: 20 CF F1           JSR   LAB_297B          ; convert FAC1 to string, skip sign character save
  6625 00:F1BF: 4C F4 DF           JMP   LAB_18C3          ; print null terminated string from memory and return
  6626                        
  6627                        ; convert FAC1 to ASCII string result in (AY)
  6628                        ; not any more, moved scratchpad to page 0
  6629                        
  6630                        LAB_296E
  6631 00:F1C2: A0 01              LDY   #$01              ; set index = 1
  6632 00:F1C4: A9 20              LDA   #$20              ; character = " " (assume +ve)
  6633 00:F1C6: 24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
  6634 00:F1C8: 10 02              BPL   LAB_2978          ; branch if +ve
  6635                        
  6636 00:F1CA: A9 2D              LDA   #$2D              ; else character = "-"
  6637                        LAB_2978
  6638 00:F1CC: 99 EF 00           STA   Decss,Y           ; save leading character (" " or "-")
  6639                        LAB_297B
  6640 00:F1CF: 85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
  6641 00:F1D1: 84 BA              STY   Sendl             ; save index
  6642 00:F1D3: C8                 INY                     ; increment index
  6643 00:F1D4: A6 AC              LDX   FAC1_e            ; get FAC1 exponent
  6644 00:F1D6: D0 05              BNE   LAB_2989          ; branch if FAC1<>0
  6645                        
  6646                                                      ; exponent was $00 so FAC1 is 0
  6647 00:F1D8: A9 30              LDA   #'0'              ; set character = "0"
  6648 00:F1DA: 4C DB F2           JMP   LAB_2A89          ; save last character, [EOT] and exit
  6649                        
  6650                                                      ; FAC1 is some non zero value
  6651                        LAB_2989
  6652 00:F1DD: A9 00              LDA   #$00              ; clear (number exponent count)
  6653 00:F1DF: E0 81              CPX   #$81              ; compare FAC1 exponent with $81 (>1.00000)
  6654                        
  6655 00:F1E1: B0 09              BCS   LAB_299A          ; branch if FAC1=>1
  6656                        
  6657                                                      ; FAC1<1
  6658 00:F1E3: A9 B1              LDA   #<LAB_294F        ; set pointer low byte to 1,000,000
  6659 00:F1E5: A0 F8              LDY   #>LAB_294F        ; set pointer high byte to 1,000,000
  6660 00:F1E7: 20 66 EE           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
  6661 00:F1EA: A9 FA              LDA   #$FA              ; set number exponent count (-6)
  6662                        LAB_299A
  6663 00:F1EC: 85 A8              STA   numexp            ; save number exponent count
  6664                        LAB_299C
  6665 00:F1EE: A9 AD              LDA   #<LAB_294B        ; set pointer low byte to 999999.4375 (max before sci note)
  6666 00:F1F0: A0 F8              LDY   #>LAB_294B        ; set pointer high byte to 999999.4375
  6667 00:F1F2: 20 44 F0           JSR   LAB_27F8          ; compare FAC1 with (AY)
  6668 00:F1F5: F0 1E              BEQ   LAB_29C3          ; exit if FAC1 = (AY)
  6669                        
  6670 00:F1F7: 10 12              BPL   LAB_29B9          ; go do /10 if FAC1 > (AY)
  6671                        
  6672                                                      ; FAC1 < (AY)
  6673                        LAB_29A7
  6674 00:F1F9: A9 A9              LDA   #<LAB_2947        ; set pointer low byte to 99999.9375
  6675 00:F1FB: A0 F8              LDY   #>LAB_2947        ; set pointer high byte to 99999.9375
  6676 00:F1FD: 20 44 F0           JSR   LAB_27F8          ; compare FAC1 with (AY)
  6677 00:F200: F0 02              BEQ   LAB_29B2          ; branch if FAC1 = (AY) (allow decimal places)
  6678                        
  6679 00:F202: 10 0E              BPL   LAB_29C0          ; branch if FAC1 > (AY) (no decimal places)
  6680                        
  6681                                                      ; FAC1 <= (AY)
  6682                        LAB_29B2
  6683 00:F204: 20 04 EF           JSR   LAB_269E          ; multiply by 10
  6684 00:F207: C6 A8              DEC   numexp            ; decrement number exponent count
  6685 00:F209: D0 EE              BNE   LAB_29A7          ; go test again (branch always)
  6686                        
  6687                        LAB_29B9
  6688 00:F20B: 20 1D EF           JSR   LAB_26B9          ; divide by 10
  6689 00:F20E: E6 A8              INC   numexp            ; increment number exponent count
  6690 00:F210: D0 DC              BNE   LAB_299C          ; go test again (branch always)
  6691                        
  6692                        ; now we have just the digits to do
  6693                        
  6694                        LAB_29C0
  6695 00:F212: 20 E7 EC           JSR   LAB_244E          ; add 0.5 to FAC1 (round FAC1)
  6696                        LAB_29C3
  6697 00:F215: 20 7D F0           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
  6698 00:F218: A2 01              LDX   #$01              ; set default digits before dp = 1
  6699 00:F21A: A5 A8              LDA   numexp            ; get number exponent count
  6700 00:F21C: 18                 CLC                     ; clear carry for add
  6701 00:F21D: 69 07              ADC   #$07              ; up to 6 digits before point
  6702 00:F21F: 30 09              BMI   LAB_29D8          ; if -ve then 1 digit before dp
  6703                        
  6704 00:F221: C9 08              CMP   #$08              ; A>=8 if n>=1E6
  6705 00:F223: B0 06              BCS   LAB_29D9          ; branch if >= $08
  6706                        
  6707                                                      ; carry is clear
  6708 00:F225: 69 FF              ADC   #$FF              ; take 1 from digit count
  6709 00:F227: AA                 TAX                     ; copy to A
  6710 00:F228: A9 02              LDA   #$02              ;.set exponent adjust
  6711                        LAB_29D8
  6712 00:F22A: 38                 SEC                     ; set carry for subtract
  6713                        LAB_29D9
  6714 00:F22B: E9 02              SBC   #$02              ; -2
  6715 00:F22D: 85 A9              STA   expcnt            ;.save exponent adjust
  6716 00:F22F: 86 A8              STX   numexp            ; save digits before dp count
  6717 00:F231: 8A                 TXA                     ; copy to A
  6718 00:F232: F0 02              BEQ   LAB_29E4          ; branch if no digits before dp
  6719                        
  6720 00:F234: 10 13              BPL   LAB_29F7          ; branch if digits before dp
  6721                        
  6722                        LAB_29E4
  6723 00:F236: A4 BA              LDY   Sendl             ; get output string index
  6724 00:F238: A9 2E              LDA   #$2E              ; character "."
  6725 00:F23A: C8                 INY                     ; increment index
  6726 00:F23B: 99 EF 00           STA   Decss,Y           ; save to output string
  6727 00:F23E: 8A                 TXA                     ;.
  6728 00:F23F: F0 06              BEQ   LAB_29F5          ;.
  6729                        
  6730 00:F241: A9 30              LDA   #'0'              ; character "0"
  6731 00:F243: C8                 INY                     ; increment index
  6732 00:F244: 99 EF 00           STA   Decss,Y           ; save to output string
  6733                        LAB_29F5
  6734 00:F247: 84 BA              STY   Sendl             ; save output string index
  6735                        LAB_29F7
  6736 00:F249: A0 00              LDY   #$00              ; clear index (point to 100,000)
  6737 00:F24B: A2 80              LDX   #$80              ; 
  6738                        LAB_29FB
  6739 00:F24D: A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
  6740 00:F24F: 18                 CLC                     ; clear carry for add
  6741 00:F250: 79 27 F9           ADC   LAB_2A9C,Y        ; add -ve LSB
  6742 00:F253: 85 AF              STA   FAC1_3            ; save FAC1 mantissa3
  6743 00:F255: A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
  6744 00:F257: 79 26 F9           ADC   LAB_2A9B,Y        ; add -ve NMSB
  6745 00:F25A: 85 AE              STA   FAC1_2            ; save FAC1 mantissa2
  6746 00:F25C: A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
  6747 00:F25E: 79 25 F9           ADC   LAB_2A9A,Y        ; add -ve MSB
  6748 00:F261: 85 AD              STA   FAC1_1            ; save FAC1 mantissa1
  6749 00:F263: E8                 INX                     ; 
  6750 00:F264: B0 04              BCS   LAB_2A18          ; 
  6751                        
  6752 00:F266: 10 E5              BPL   LAB_29FB          ; not -ve so try again
  6753                        
  6754 00:F268: 30 02              BMI   LAB_2A1A          ; 
  6755                        
  6756                        LAB_2A18
  6757 00:F26A: 30 E1              BMI   LAB_29FB          ; 
  6758                        
  6759                        LAB_2A1A
  6760 00:F26C: 8A                 TXA                     ; 
  6761 00:F26D: 90 04              BCC   LAB_2A21          ; 
  6762                        
  6763 00:F26F: 49 FF              EOR   #$FF              ; 
  6764 00:F271: 69 0A              ADC   #$0A              ; 
  6765                        LAB_2A21
  6766 00:F273: 69 2F              ADC   #'0'-1            ; add "0"-1 to result
  6767 00:F275: C8                 INY                     ; increment index ..
  6768 00:F276: C8                 INY                     ; .. to next less ..
  6769 00:F277: C8                 INY                     ; .. power of ten
  6770 00:F278: 84 95              STY   Cvaral            ; save as current var address low byte
  6771 00:F27A: A4 BA              LDY   Sendl             ; get output string index
  6772 00:F27C: C8                 INY                     ; increment output string index
  6773 00:F27D: AA                 TAX                     ; copy character to X
  6774 00:F27E: 29 7F              AND   #$7F              ; mask out top bit
  6775 00:F280: 99 EF 00           STA   Decss,Y           ; save to output string
  6776 00:F283: C6 A8              DEC   numexp            ; decrement # of characters before the dp
  6777 00:F285: D0 06              BNE   LAB_2A3B          ; branch if still characters to do
  6778                        
  6779                                                      ; else output the point
  6780 00:F287: A9 2E              LDA   #$2E              ; character "."
  6781 00:F289: C8                 INY                     ; increment output string index
  6782 00:F28A: 99 EF 00           STA   Decss,Y           ; save to output string
  6783                        LAB_2A3B
  6784 00:F28D: 84 BA              STY   Sendl             ; save output string index
  6785 00:F28F: A4 95              LDY   Cvaral            ; get current var address low byte
  6786 00:F291: 8A                 TXA                     ; get character back
  6787 00:F292: 49 FF              EOR   #$FF              ; 
  6788 00:F294: 29 80              AND   #$80              ; 
  6789 00:F296: AA                 TAX                     ; 
  6790 00:F297: C0 12              CPY   #$12              ; compare index with max
  6791 00:F299: D0 B2              BNE   LAB_29FB          ; loop if not max
  6792                        
  6793                                                      ; now remove trailing zeroes
  6794 00:F29B: A4 BA              LDY   Sendl             ; get output string index
  6795                        LAB_2A4B
  6796 00:F29D: B9 EF 00           LDA   Decss,Y           ; get character from output string
  6797 00:F2A0: 88                 DEY                     ; decrement output string index
  6798 00:F2A1: C9 30              CMP   #'0'              ; compare with "0"
  6799 00:F2A3: F0 F8              BEQ   LAB_2A4B          ; loop until non "0" character found
  6800                        
  6801 00:F2A5: C9 2E              CMP   #'.'              ; compare with "."
  6802 00:F2A7: F0 01              BEQ   LAB_2A58          ; branch if was dp
  6803                        
  6804                                                      ; restore last character
  6805 00:F2A9: C8                 INY                     ; increment output string index
  6806                        LAB_2A58
  6807 00:F2AA: A9 2B              LDA   #$2B              ; character "+"
  6808 00:F2AC: A6 A9              LDX   expcnt            ; get exponent count
  6809 00:F2AE: F0 2E              BEQ   LAB_2A8C          ; if zero go set null terminator and exit
  6810                        
  6811                                                      ; exponent isn't zero so write exponent
  6812 00:F2B0: 10 08              BPL   LAB_2A68          ; branch if exponent count +ve
  6813                        
  6814 00:F2B2: A9 00              LDA   #$00              ; clear A
  6815 00:F2B4: 38                 SEC                     ; set carry for subtract
  6816 00:F2B5: E5 A9              SBC   expcnt            ; subtract exponent count adjust (convert -ve to +ve)
  6817 00:F2B7: AA                 TAX                     ; copy exponent count to X
  6818 00:F2B8: A9 2D              LDA   #'-'              ; character "-"
  6819                        LAB_2A68
  6820 00:F2BA: 99 F1 00           STA   Decss+2,Y         ; save to output string
  6821 00:F2BD: A9 45              LDA   #$45              ; character "E"
  6822 00:F2BF: 99 F0 00           STA   Decss+1,Y         ; save exponent sign to output string
  6823 00:F2C2: 8A                 TXA                     ; get exponent count back
  6824 00:F2C3: A2 2F              LDX   #'0'-1            ; one less than "0" character
  6825 00:F2C5: 38                 SEC                     ; set carry for subtract
  6826                        LAB_2A74
  6827 00:F2C6: E8                 INX                     ; increment 10's character
  6828 00:F2C7: E9 0A              SBC   #$0A              ;.subtract 10 from exponent count
  6829 00:F2C9: B0 FB              BCS   LAB_2A74          ; loop while still >= 0
  6830                        
  6831 00:F2CB: 69 3A              ADC   #':'              ; add character ":" ($30+$0A, result is 10 less that value)
  6832 00:F2CD: 99 F3 00           STA   Decss+4,Y         ; save to output string
  6833 00:F2D0: 8A                 TXA                     ; copy 10's character
  6834 00:F2D1: 99 F2 00           STA   Decss+3,Y         ; save to output string
  6835 00:F2D4: A9 00              LDA   #$00              ; set null terminator
  6836 00:F2D6: 99 F4 00           STA   Decss+5,Y         ; save to output string
  6837 00:F2D9: F0 08              BEQ   LAB_2A91          ; go set string pointer (AY) and exit (branch always)
  6838                        
  6839                                                      ; save last character, [EOT] and exit
  6840                        LAB_2A89
  6841 00:F2DB: 99 EF 00           STA   Decss,Y           ; save last character to output string
  6842                        
  6843                                                      ; set null terminator and exit
  6844                        LAB_2A8C
  6845 00:F2DE: A9 00              LDA   #$00              ; set null terminator
  6846 00:F2E0: 99 F0 00           STA   Decss+1,Y         ; save after last character
  6847                        
  6848                                                      ; set string pointer (AY) and exit
  6849                        LAB_2A91
  6850 00:F2E3: A9 F0              LDA   #<Decssp1         ; set result string low pointer
  6851 00:F2E5: A0 00              LDY   #>Decssp1         ; set result string high pointer
  6852 00:F2E7: 60                 RTS
  6853                        
  6854                        ; perform power function
  6855                        
  6856                        LAB_POWER
  6857 00:F2E8: F0 42              BEQ   LAB_EXP           ; go do  EXP()
  6858                        
  6859 00:F2EA: A5 B3              LDA   FAC2_e            ; get FAC2 exponent
  6860 00:F2EC: D0 03              BNE   LAB_2ABF          ; branch if FAC2<>0
  6861                        
  6862 00:F2EE: 4C 7F ED           JMP   LAB_24F3          ; clear FAC1 exponent and sign and return
  6863                        
  6864                        LAB_2ABF
  6865 00:F2F1: A2 9C              LDX   #<func_l          ; set destination pointer low byte
  6866 00:F2F3: A0 00              LDY   #>func_l          ; set destination pointer high byte
  6867 00:F2F5: 20 D4 EF           JSR   LAB_2778          ; pack FAC1 into (XY)
  6868 00:F2F8: A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
  6869 00:F2FA: 10 0F              BPL   LAB_2AD9          ; branch if FAC2>0
  6870                        
  6871                                                      ; else FAC2 is -ve and can only be raised to an
  6872                                                      ; integer power which gives an x +j0 result
  6873 00:F2FC: 20 AE F0           JSR   LAB_INT           ; perform INT
  6874 00:F2FF: A9 9C              LDA   #<func_l          ; set source pointer low byte
  6875 00:F301: A0 00              LDY   #>func_l          ; set source pointer high byte
  6876 00:F303: 20 44 F0           JSR   LAB_27F8          ; compare FAC1 with (AY)
  6877 00:F306: D0 03              BNE   LAB_2AD9          ; branch if FAC1 <> (AY) to allow Function Call error
  6878                                                      ; this will leave FAC1 -ve and cause a Function Call
  6879                                                      ; error when LOG() is called
  6880                        
  6881 00:F308: 98                 TYA                     ; clear sign b7
  6882 00:F309: A4 5B              LDY   Temp3             ; save mantissa 3 from INT() function as sign in Y
  6883                                                      ; for possible later negation, b0
  6884                        LAB_2AD9
  6885 00:F30B: 20 F2 EC           JSR   LAB_279D          ; save FAC1 sign and copy ABS(FAC2) to FAC1
  6886 00:F30E: 98                 TYA                     ; copy sign back ..
  6887 00:F30F: 48                 PHA                     ; .. and save it
  6888 00:F310: 20 28 EE           JSR   LAB_LOG           ; do LOG(n)
  6889 00:F313: A9 9C              LDA   #<garb_l          ; set pointer low byte
  6890 00:F315: A0 00              LDY   #>garb_l          ; set pointer high byte
  6891 00:F317: 20 66 EE           JSR   LAB_25FB          ; do convert AY, FCA1*(AY) (square the value)
  6892 00:F31A: 20 2C F3           JSR   LAB_EXP           ; go do EXP(n)
  6893 00:F31D: 68                 PLA                     ; pull sign from stack
  6894 00:F31E: 4A                 LSR                     ; b0 is to be tested, shift to Cb
  6895 00:F31F: 90 0A              BCC   LAB_2AF9          ; if no bit then exit
  6896                        
  6897                                                      ; Perform negation
  6898                        ; do - FAC1
  6899                        
  6900                        LAB_GTHAN
  6901 00:F321: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  6902 00:F323: F0 06              BEQ   LAB_2AF9          ; exit if FAC1_e = $00
  6903                        
  6904 00:F325: A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
  6905 00:F327: 49 FF              EOR   #$FF              ; complement it
  6906 00:F329: 85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
  6907                        LAB_2AF9
  6908 00:F32B: 60                 RTS
  6909                        
  6910                        ; perform EXP()   (x^e)
  6911                        
  6912                        LAB_EXP
  6913 00:F32C: A9 B5              LDA   #<LAB_2AFA        ; set 1.443 pointer low byte
  6914 00:F32E: A0 F8              LDY   #>LAB_2AFA        ; set 1.443 pointer high byte
  6915 00:F330: 20 66 EE           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
  6916 00:F333: A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
  6917 00:F335: 69 50              ADC   #$50              ; +$50/$100
  6918 00:F337: 90 03              BCC   LAB_2B2B          ; skip rounding if no carry
  6919                        
  6920 00:F339: 20 0E F0           JSR   LAB_27C2          ; round FAC1 (no check)
  6921                        LAB_2B2B
  6922 00:F33C: 85 A3              STA   FAC2_r            ; save FAC2 rounding byte
  6923 00:F33E: 20 FA EF           JSR   LAB_27AE          ; copy FAC1 to FAC2
  6924 00:F341: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  6925 00:F343: C9 88              CMP   #$88              ; compare with EXP limit (256d)
  6926 00:F345: 90 03              BCC   LAB_2B39          ; branch if less
  6927                        
  6928                        LAB_2B36
  6929 00:F347: 20 FB EE           JSR   LAB_2690          ; handle overflow and underflow
  6930                        LAB_2B39
  6931 00:F34A: 20 AE F0           JSR   LAB_INT           ; perform INT
  6932 00:F34D: A5 5B              LDA   Temp3             ; get mantissa 3 from INT() function
  6933 00:F34F: 18                 CLC                     ; clear carry for add
  6934 00:F350: 69 81              ADC   #$81              ; normalise +1
  6935 00:F352: F0 F3              BEQ   LAB_2B36          ; if $00 go handle overflow
  6936                        
  6937 00:F354: 38                 SEC                     ; set carry for subtract
  6938 00:F355: E9 01              SBC   #$01              ; now correct for exponent
  6939 00:F357: 48                 PHA                     ; save FAC2 exponent
  6940                        
  6941                                                      ; swap FAC1 and FAC2
  6942 00:F358: A2 04              LDX   #$04              ; 4 bytes to do
  6943                        LAB_2B49
  6944 00:F35A: B5 B3              LDA   FAC2_e,X          ; get FAC2,X
  6945 00:F35C: B4 AC              LDY   FAC1_e,X          ; get FAC1,X
  6946 00:F35E: 95 AC              STA   FAC1_e,X          ; save FAC1,X
  6947 00:F360: 94 B3              STY   FAC2_e,X          ; save FAC2,X
  6948 00:F362: CA                 DEX                     ; decrement count/index
  6949 00:F363: 10 F5              BPL   LAB_2B49          ; loop if not all done
  6950                        
  6951 00:F365: A5 A3              LDA   FAC2_r            ; get FAC2 rounding byte
  6952 00:F367: 85 B9              STA   FAC1_r            ; save as FAC1 rounding byte
  6953 00:F369: 20 D3 EC           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
  6954 00:F36C: 20 21 F3           JSR   LAB_GTHAN         ; do - FAC1
  6955 00:F36F: A9 B9              LDA   #<LAB_2AFE        ; set counter pointer low byte
  6956 00:F371: A0 F8              LDY   #>LAB_2AFE        ; set counter pointer high byte
  6957 00:F373: 20 94 F3           JSR   LAB_2B84          ; go do series evaluation
  6958 00:F376: A9 00              LDA   #$00              ; clear A
  6959 00:F378: 85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
  6960 00:F37A: 68                 PLA                     ;.get saved FAC2 exponent
  6961 00:F37B: 4C E0 EE           JMP   LAB_2675          ; test and adjust accumulators and return
  6962                        
  6963                        ; ^2 then series evaluation
  6964                        
  6965                        LAB_2B6E
  6966 00:F37E: 85 BA              STA   Cptrl             ; save count pointer low byte
  6967 00:F380: 84 BB              STY   Cptrh             ; save count pointer high byte
  6968 00:F382: 20 CA EF           JSR   LAB_276E          ; pack FAC1 into Adatal
  6969 00:F385: A9 A4              LDA   #<Adatal          ; set pointer low byte (Y already $00)
  6970 00:F387: 20 66 EE           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
  6971 00:F38A: 20 98 F3           JSR   LAB_2B88          ; go do series evaluation
  6972 00:F38D: A9 A4              LDA   #<Adatal          ; pointer to original # low byte
  6973 00:F38F: A0 00              LDY   #>Adatal          ; pointer to original # high byte
  6974 00:F391: 4C 66 EE           JMP   LAB_25FB          ; do convert AY, FCA1*(AY) and return
  6975                        
  6976                        ; series evaluation
  6977                        
  6978                        LAB_2B84
  6979 00:F394: 85 BA              STA   Cptrl             ; save count pointer low byte
  6980 00:F396: 84 BB              STY   Cptrh             ; save count pointer high byte
  6981                        LAB_2B88
  6982 00:F398: A2 A8              LDX   #<numexp          ; set pointer low byte
  6983 00:F39A: 20 CC EF           JSR   LAB_2770          ; set pointer high byte and pack FAC1 into numexp
  6984 00:F39D: B1 BA              LDA   (Cptrl),Y         ; get constants count
  6985 00:F39F: 85 B1              STA   numcon            ; save constants count
  6986 00:F3A1: A4 BA              LDY   Cptrl             ; get count pointer low byte
  6987 00:F3A3: C8                 INY                     ; increment it (now constants pointer)
  6988 00:F3A4: 98                 TYA                     ; copy it
  6989 00:F3A5: D0 02              BNE   LAB_2B97          ; skip next if no overflow
  6990                        
  6991 00:F3A7: E6 BB              INC   Cptrh             ; else increment high byte
  6992                        LAB_2B97
  6993 00:F3A9: 85 BA              STA   Cptrl             ; save low byte
  6994 00:F3AB: A4 BB              LDY   Cptrh             ; get high byte
  6995                        LAB_2B9B
  6996 00:F3AD: 20 66 EE           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
  6997 00:F3B0: A5 BA              LDA   Cptrl             ; get constants pointer low byte
  6998 00:F3B2: A4 BB              LDY   Cptrh             ; get constants pointer high byte
  6999 00:F3B4: 18                 CLC                     ; clear carry for add
  7000 00:F3B5: 69 04              ADC   #$04              ; +4 to  low pointer (4 bytes per constant)
  7001 00:F3B7: 90 01              BCC   LAB_2BA8          ; skip next if no overflow
  7002                        
  7003 00:F3B9: C8                 INY                     ; increment high byte
  7004                        LAB_2BA8
  7005 00:F3BA: 85 BA              STA   Cptrl             ; save pointer low byte
  7006 00:F3BC: 84 BB              STY   Cptrh             ; save pointer high byte
  7007 00:F3BE: 20 EB EC           JSR   LAB_246C          ; add (AY) to FAC1
  7008 00:F3C1: A9 A8              LDA   #<numexp          ; set pointer low byte to partial @ numexp
  7009 00:F3C3: A0 00              LDY   #>numexp          ; set pointer high byte to partial @ numexp
  7010 00:F3C5: C6 B1              DEC   numcon            ; decrement constants count
  7011 00:F3C7: D0 E4              BNE   LAB_2B9B          ; loop until all done
  7012                        
  7013 00:F3C9: 60                 RTS
  7014                        
  7015                        ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
  7016                        ; to get 19th next number in sequence after seed n. This version of the PRNG uses
  7017                        ; the Galois method and a sample of 65536 bytes produced gives the following values.
  7018                        
  7019                        ; Entropy = 7.997442 bits per byte
  7020                        ; Optimum compression would reduce these 65536 bytes by 0 percent
  7021                        
  7022                        ; Chi square distribution for 65536 samples is 232.01, and
  7023                        ; randomly would exceed this value 75.00 percent of the time
  7024                        
  7025                        ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
  7026                        ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
  7027                        ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
  7028                        
  7029                        LAB_RND
  7030 00:F3CA: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  7031 00:F3CC: F0 07              BEQ   NextPRN           ; do next random # if zero
  7032                        
  7033                                                      ; else get seed into random number store
  7034 00:F3CE: A2 D8              LDX   #Rbyte4           ; set PRNG pointer low byte
  7035 00:F3D0: A0 00              LDY   #$00              ; set PRNG pointer high byte
  7036 00:F3D2: 20 D4 EF           JSR   LAB_2778          ; pack FAC1 into (XY)
  7037                        NextPRN
  7038 00:F3D5: A2 AF              LDX   #$AF              ; set EOR byte
  7039 00:F3D7: A0 13              LDY   #$13              ; do this nineteen times
  7040                        LoopPRN
  7041 00:F3D9: 06 D9              ASL   Rbyte1            ; shift PRNG most significant byte
  7042 00:F3DB: 26 DA              ROL   Rbyte2            ; shift PRNG middle byte
  7043 00:F3DD: 26 DB              ROL   Rbyte3            ; shift PRNG least significant byte
  7044 00:F3DF: 26 D8              ROL   Rbyte4            ; shift PRNG extra byte
  7045 00:F3E1: 90 05              BCC   Ninc1             ; branch if bit 32 clear
  7046                        
  7047 00:F3E3: 8A                 TXA                     ; set EOR byte
  7048 00:F3E4: 45 D9              EOR   Rbyte1            ; EOR PRNG extra byte
  7049 00:F3E6: 85 D9              STA   Rbyte1            ; save new PRNG extra byte
  7050                        Ninc1
  7051 00:F3E8: 88                 DEY                     ; decrement loop count
  7052 00:F3E9: D0 EE              BNE   LoopPRN           ; loop if not all done
  7053                        
  7054 00:F3EB: A2 02              LDX   #$02              ; three bytes to copy
  7055                        CopyPRNG
  7056 00:F3ED: B5 D9              LDA   Rbyte1,X          ; get PRNG byte
  7057 00:F3EF: 95 AD              STA   FAC1_1,X          ; save FAC1 byte
  7058 00:F3F1: CA                 DEX
  7059 00:F3F2: 10 F9              BPL   CopyPRNG          ; loop if not complete
  7060                        
  7061 00:F3F4: A9 80              LDA   #$80              ; set the exponent
  7062 00:F3F6: 85 AC              STA   FAC1_e            ; save FAC1 exponent
  7063                        
  7064 00:F3F8: 0A                 ASL                     ; clear A
  7065 00:F3F9: 85 B0              STA   FAC1_s            ; save FAC1 sign
  7066                        
  7067 00:F3FB: 4C 61 ED           JMP   LAB_24D5          ; normalise FAC1 and return
  7068                        
  7069                        ; perform COS()
  7070                        
  7071                        LAB_COS
  7072 00:F3FE: A9 D6              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
  7073 00:F400: A0 F8              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
  7074 00:F402: 20 EB EC           JSR   LAB_246C          ; add (AY) to FAC1
  7075                        
  7076                        ; perform SIN()
  7077                        
  7078                        LAB_SIN
  7079 00:F405: 20 F7 EF           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  7080 00:F408: A9 EB              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
  7081 00:F40A: A0 F8              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
  7082 00:F40C: A6 B7              LDX   FAC2_s            ; get FAC2 sign (b7)
  7083 00:F40E: 20 26 EF           JSR   LAB_26C2          ; divide by (AY) (X=sign)
  7084 00:F411: 20 F7 EF           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  7085 00:F414: 20 AE F0           JSR   LAB_INT           ; perform INT
  7086 00:F417: A9 00              LDA   #$00              ; clear byte
  7087 00:F419: 85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
  7088 00:F41B: 20 D3 EC           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
  7089 00:F41E: A9 1D              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
  7090 00:F420: A0 F9              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
  7091 00:F422: 20 D0 EC           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
  7092 00:F425: A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
  7093 00:F427: 48                 PHA                     ; save FAC1 sign
  7094 00:F428: 10 0D              BPL   LAB_2C35          ; branch if +ve
  7095                        
  7096                                                      ; FAC1 sign was -ve
  7097 00:F42A: 20 E7 EC           JSR   LAB_244E          ; add 0.5 to FAC1
  7098 00:F42D: A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
  7099 00:F42F: 30 09              BMI   LAB_2C38          ; branch if -ve
  7100                        
  7101 00:F431: A5 63              LDA   Cflag             ; get comparison evaluation flag
  7102 00:F433: 49 FF              EOR   #$FF              ; toggle flag
  7103 00:F435: 85 63              STA   Cflag             ; save comparison evaluation flag
  7104                        LAB_2C35
  7105 00:F437: 20 21 F3           JSR   LAB_GTHAN         ; do - FAC1
  7106                        LAB_2C38
  7107 00:F43A: A9 1D              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
  7108 00:F43C: A0 F9              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
  7109 00:F43E: 20 EB EC           JSR   LAB_246C          ; add (AY) to FAC1
  7110 00:F441: 68                 PLA                     ; restore FAC1 sign
  7111 00:F442: 10 03              BPL   LAB_2C45          ; branch if was +ve
  7112                        
  7113                                                      ; else correct FAC1
  7114 00:F444: 20 21 F3           JSR   LAB_GTHAN         ; do - FAC1
  7115                        LAB_2C45
  7116 00:F447: A9 DA              LDA   #<LAB_2C84        ; set pointer low byte to counter
  7117 00:F449: A0 F8              LDY   #>LAB_2C84        ; set pointer high byte to counter
  7118 00:F44B: 4C 7E F3           JMP   LAB_2B6E          ; ^2 then series evaluation and return
  7119                        
  7120                        ; perform TAN()
  7121                        
  7122                        LAB_TAN
  7123 00:F44E: 20 CA EF           JSR   LAB_276E          ; pack FAC1 into Adatal
  7124 00:F451: A9 00              LDA   #$00              ; clear byte
  7125 00:F453: 85 63              STA   Cflag             ; clear comparison evaluation flag
  7126 00:F455: 20 05 F4           JSR   LAB_SIN           ; go do SIN(n)
  7127 00:F458: A2 9C              LDX   #<func_l          ; set sin(n) pointer low byte
  7128 00:F45A: A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
  7129 00:F45C: 20 D4 EF           JSR   LAB_2778          ; pack FAC1 into (XY)
  7130 00:F45F: A9 A4              LDA   #<Adatal          ; set n pointer low addr
  7131 00:F461: A0 00              LDY   #>Adatal          ; set n pointer high addr
  7132 00:F463: 20 AA EF           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  7133 00:F466: A9 00              LDA   #$00              ; clear byte
  7134 00:F468: 85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
  7135 00:F46A: A5 63              LDA   Cflag             ; get comparison evaluation flag
  7136 00:F46C: 20 76 F4           JSR   LAB_2C74          ; save flag and go do series evaluation
  7137                        
  7138 00:F46F: A9 9C              LDA   #<func_l          ; set sin(n) pointer low byte
  7139 00:F471: A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
  7140 00:F473: 4C 2E EF           JMP   LAB_26CA          ; convert AY and do (AY)/FAC1
  7141                        
  7142                        LAB_2C74
  7143 00:F476: 48                 PHA                     ; save comparison evaluation flag
  7144 00:F477: 4C 37 F4           JMP   LAB_2C35          ; go do series evaluation
  7145                        
  7146                        ; perform USR()
  7147                        
  7148                        LAB_USR
  7149 00:F47A: 20 0A 00           JSR   Usrjmp            ; call user code
  7150 00:F47D: 4C 0F E3           JMP   LAB_1BFB          ; scan for ")", else do syntax error then warm start
  7151                        
  7152                        ; perform ATN()
  7153                        
  7154                        LAB_ATN
  7155 00:F480: A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
  7156 00:F482: 48                 PHA                     ; save sign
  7157 00:F483: 10 03              BPL   LAB_2CA1          ; branch if +ve
  7158                        
  7159 00:F485: 20 21 F3           JSR   LAB_GTHAN         ; else do - FAC1
  7160                        LAB_2CA1
  7161 00:F488: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  7162 00:F48A: 48                 PHA                     ; push exponent
  7163 00:F48B: C9 81              CMP   #$81              ; compare with 1
  7164 00:F48D: 90 07              BCC   LAB_2CAF          ; branch if FAC1<1
  7165                        
  7166 00:F48F: A9 10              LDA   #<LAB_259C        ; set 1 pointer low byte
  7167 00:F491: A0 F9              LDY   #>LAB_259C        ; set 1 pointer high byte
  7168 00:F493: 20 2E EF           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1
  7169                        LAB_2CAF
  7170 00:F496: A9 EF              LDA   #<LAB_2CC9        ; set pointer low byte to counter
  7171 00:F498: A0 F8              LDY   #>LAB_2CC9        ; set pointer high byte to counter
  7172 00:F49A: 20 7E F3           JSR   LAB_2B6E          ; ^2 then series evaluation
  7173 00:F49D: 68                 PLA                     ; restore old FAC1 exponent
  7174 00:F49E: C9 81              CMP   #$81              ; compare with 1
  7175 00:F4A0: 90 07              BCC   LAB_2CC2          ; branch if FAC1<1
  7176                        
  7177 00:F4A2: A9 D6              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
  7178 00:F4A4: A0 F8              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
  7179 00:F4A6: 20 D0 EC           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
  7180                        LAB_2CC2
  7181 00:F4A9: 68                 PLA                     ; restore FAC1 sign
  7182 00:F4AA: 10 16              BPL   LAB_2D04          ; exit if was +ve
  7183                        
  7184 00:F4AC: 4C 21 F3           JMP   LAB_GTHAN         ; else do - FAC1 and return
  7185                        
  7186                        ; perform BITSET
  7187                        
  7188                        LAB_BITSET
  7189 00:F4AF: 20 05 EC           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  7190 00:F4B2: E0 08              CPX   #$08              ; only 0 to 7 are allowed
  7191 00:F4B4: B0 20              BCS   FCError           ; branch if > 7
  7192                        
  7193 00:F4B6: A9 00              LDA   #$00              ; clear A
  7194 00:F4B8: 38                 SEC                     ; set the carry
  7195                        S_Bits
  7196 00:F4B9: 2A                 ROL                     ; shift bit
  7197 00:F4BA: CA                 DEX                     ; decrement bit number
  7198 00:F4BB: 10 FC              BPL   S_Bits            ; loop if still +ve
  7199                        
  7200 00:F4BD: E8                 INX                     ; make X = $00
  7201 00:F4BE: 01 11              ORA   (Itempl,X)        ; or with byte via temporary integer (addr)
  7202 00:F4C0: 81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
  7203                        LAB_2D04
  7204 00:F4C2: 60                 RTS
  7205                        
  7206                        ; perform BITCLR
  7207                        
  7208                        LAB_BITCLR
  7209 00:F4C3: 20 05 EC           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  7210 00:F4C6: E0 08              CPX   #$08              ; only 0 to 7 are allowed
  7211 00:F4C8: B0 0C              BCS   FCError           ; branch if > 7
  7212                        
  7213 00:F4CA: A9 FF              LDA   #$FF              ; set A
  7214                        S_Bitc
  7215 00:F4CC: 2A                 ROL                     ; shift bit
  7216 00:F4CD: CA                 DEX                     ; decrement bit number
  7217 00:F4CE: 10 FC              BPL   S_Bitc            ; loop if still +ve
  7218                        
  7219 00:F4D0: E8                 INX                     ; make X = $00
  7220 00:F4D1: 21 11              AND   (Itempl,X)        ; and with byte via temporary integer (addr)
  7221 00:F4D3: 81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
  7222 00:F4D5: 60                 RTS
  7223                        
  7224                        FCError
  7225 00:F4D6: 4C 57 E6           JMP   LAB_FCER          ; do function call error then warm start
  7226                        
  7227                        ; perform BITTST()
  7228                        
  7229                        LAB_BTST
  7230 00:F4D9: 20 BC 00           JSR   LAB_IGBY          ; increment BASIC pointer
  7231 00:F4DC: 20 05 EC           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
  7232 00:F4DF: E0 08              CPX   #$08              ; only 0 to 7 are allowed
  7233 00:F4E1: B0 F3              BCS   FCError           ; branch if > 7
  7234                        
  7235 00:F4E3: 20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
  7236 00:F4E6: C9 29              CMP   #')'              ; is next character ")"
  7237 00:F4E8: F0 03              BEQ   TST_OK            ; if ")" go do rest of function
  7238                        
  7239 00:F4EA: 4C 22 E3           JMP   LAB_SNER          ; do syntax error then warm start
  7240                        
  7241                        TST_OK
  7242 00:F4ED: 20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
  7243 00:F4F0: A9 00              LDA   #$00              ; clear A
  7244 00:F4F2: 38                 SEC                     ; set the carry
  7245                        T_Bits
  7246 00:F4F3: 2A                 ROL                     ; shift bit
  7247 00:F4F4: CA                 DEX                     ; decrement bit number
  7248 00:F4F5: 10 FC              BPL   T_Bits            ; loop if still +ve
  7249                        
  7250 00:F4F7: E8                 INX                     ; make X = $00
  7251 00:F4F8: 21 11              AND   (Itempl,X)        ; AND with byte via temporary integer (addr)
  7252 00:F4FA: F0 02              BEQ   LAB_NOTT          ; branch if zero (already correct)
  7253                        
  7254 00:F4FC: A9 FF              LDA   #$FF              ; set for -1 result
  7255                        LAB_NOTT
  7256 00:F4FE: 4C 27 F0           JMP   LAB_27DB          ; go do SGN tail
  7257                        
  7258                        ; perform BIN$()
  7259                        
  7260                        LAB_BINS
  7261 00:F501: E0 19              CPX   #$19              ; max + 1
  7262 00:F503: B0 48              BCS   BinFErr           ; exit if too big ( > or = )
  7263                        
  7264 00:F505: 86 78              STX   TempB             ; save # of characters ($00 = leading zero remove)
  7265 00:F507: A9 18              LDA   #$18              ; need A byte long space
  7266 00:F509: 20 68 E8           JSR   LAB_MSSP          ; make string space A bytes long
  7267 00:F50C: A0 17              LDY   #$17              ; set index
  7268 00:F50E: A2 18              LDX   #$18              ; character count
  7269                        NextB1
  7270 00:F510: 46 11              LSR   nums_1            ; shift highest byte
  7271 00:F512: 66 12              ROR   nums_2            ; shift middle byte
  7272 00:F514: 66 13              ROR   nums_3            ; shift lowest byte bit 0 to carry
  7273 00:F516: 8A                 TXA                     ; load with "0"/2
  7274 00:F517: 2A                 ROL                     ; shift in carry
  7275 00:F518: 91 AD              STA   (str_pl),Y        ; save to temp string + index
  7276 00:F51A: 88                 DEY                     ; decrement index
  7277 00:F51B: 10 F3              BPL   NextB1            ; loop if not done
  7278                        
  7279 00:F51D: A5 78              LDA   TempB             ; get # of characters
  7280 00:F51F: F0 0A              BEQ   EndBHS            ; branch if truncate
  7281                        
  7282 00:F521: AA                 TAX                     ; copy length to X
  7283 00:F522: 38                 SEC                     ; set carry for add !
  7284 00:F523: 49 FF              EOR   #$FF              ; 1's complement
  7285 00:F525: 69 18              ADC   #$18              ; add 24d
  7286 00:F527: F0 1C              BEQ   GoPr2             ; if zero print whole string
  7287                        
  7288 00:F529: D0 0F              BNE   GoPr1             ; else go make output string
  7289                              
  7290                        ; this is the exit code and is also used by HEX$()
  7291                        ; truncate string to remove leading "0"s
  7292                        
  7293                        EndBHS
  7294 00:F52B: A8                 TAY                     ; clear index (A=0, X=length here)
  7295                        NextB2
  7296 00:F52C: B1 AD              LDA   (str_pl),Y        ; get character from string
  7297 00:F52E: C9 30              CMP   #'0'              ; compare with "0"
  7298 00:F530: D0 07              BNE   GoPr              ; if not "0" then go print string from here
  7299                        
  7300 00:F532: CA                 DEX                     ; decrement character count
  7301 00:F533: F0 03              BEQ   GoPr3             ; if zero then end of string so go print it
  7302                        
  7303 00:F535: C8                 INY                     ; else increment index
  7304 00:F536: 10 F4              BPL   NextB2            ; loop always
  7305                        
  7306                        ; make fixed length output string - ignore overflows!
  7307                        
  7308                        GoPr3
  7309 00:F538: E8                 INX                     ; need at least 1 character
  7310                        GoPr
  7311 00:F539: 98                 TYA                     ; copy result
  7312                        GoPr1
  7313 00:F53A: 18                 CLC                     ; clear carry for add
  7314 00:F53B: 65 AD              ADC   str_pl            ; add low address
  7315 00:F53D: 85 AD              STA   str_pl            ; save low address
  7316 00:F53F: A9 00              LDA   #$00              ; do high byte
  7317 00:F541: 65 AE              ADC   str_ph            ; add high address
  7318 00:F543: 85 AE              STA   str_ph            ; save high address
  7319                        GoPr2
  7320 00:F545: 86 AC              STX   str_ln            ; X holds string length
  7321 00:F547: 20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
  7322 00:F54A: 4C B5 E8           JMP   LAB_RTST          ; check for space on descriptor stack then put address
  7323                                                      ; and length on descriptor stack and update stack pointers
  7324                        
  7325                        BinFErr
  7326 00:F54D: 4C 57 E6           JMP   LAB_FCER          ; do function call error then warm start
  7327                        
  7328                        ; perform HEX$()
  7329                        
  7330                        LAB_HEXS
  7331 00:F550: E0 07              CPX   #$07              ; max + 1
  7332 00:F552: B0 F9              BCS   BinFErr           ; exit if too big ( > or = )
  7333                        
  7334 00:F554: 86 78              STX   TempB             ; save # of characters
  7335                        
  7336 00:F556: A9 06              LDA   #$06              ; need 6 bytes for string
  7337 00:F558: 20 68 E8           JSR   LAB_MSSP          ; make string space A bytes long
  7338 00:F55B: A0 05              LDY   #$05              ; set string index
  7339                        
  7340                        ; *** disable decimal mode patch - comment next line ***
  7341                        ;      SED                     ; need decimal mode for nibble convert
  7342 00:F55D: A5 13              LDA   nums_3            ; get lowest byte
  7343 00:F55F: 20 7C F5           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
  7344 00:F562: A5 12              LDA   nums_2            ; get middle byte
  7345 00:F564: 20 7C F5           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
  7346 00:F567: A5 11              LDA   nums_1            ; get highest byte
  7347 00:F569: 20 7C F5           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
  7348                        ; *** disable decimal mode patch - comment next line ***
  7349                        ;      CLD                     ; back to binary
  7350                        
  7351 00:F56C: A2 06              LDX   #$06              ; character count
  7352 00:F56E: A5 78              LDA   TempB             ; get # of characters
  7353 00:F570: F0 B9              BEQ   EndBHS            ; branch if truncate
  7354                        
  7355 00:F572: AA                 TAX                     ; copy length to X
  7356 00:F573: 38                 SEC                     ; set carry for add !
  7357 00:F574: 49 FF              EOR   #$FF              ; 1's complement
  7358 00:F576: 69 06              ADC   #$06              ; add 6d
  7359 00:F578: F0 CB              BEQ   GoPr2             ; if zero print whole string
  7360                        
  7361 00:F57A: D0 BE              BNE   GoPr1             ; else go make output string (branch always)
  7362                        
  7363                        ; convert A to ASCII hex byte and output .. note set decimal mode before calling
  7364                        
  7365                        LAB_A2HX
  7366 00:F57C: AA                 TAX                     ; save byte
  7367 00:F57D: 29 0F              AND   #$0F              ; mask off top bits
  7368 00:F57F: 20 87 F5           JSR   LAB_AL2X          ; convert low nibble to ASCII and output
  7369 00:F582: 8A                 TXA                     ; get byte back
  7370 00:F583: 4A                 LSR                     ; /2  shift high nibble to low nibble
  7371 00:F584: 4A                 LSR                     ; /4
  7372 00:F585: 4A                 LSR                     ; /8
  7373 00:F586: 4A                 LSR                     ; /16
  7374                        LAB_AL2X
  7375 00:F587: C9 0A              CMP   #$0A              ; set carry for +1 if >9
  7376                        ; *** begin disable decimal mode patch ***
  7377                        ; *** insert
  7378 00:F589: 90 02              BCC   LAB_AL20          ; skip adjust if <= 9
  7379 00:F58B: 69 06              ADC   #$06              ; adjust for A to F
  7380                        LAB_AL20
  7381                        ; *** end   disable decimal mode patch ***
  7382 00:F58D: 69 30              ADC   #'0'              ; add ASCII "0"
  7383 00:F58F: 91 AD              STA   (str_pl),Y        ; save to temp string
  7384 00:F591: 88                 DEY                     ; decrement counter
  7385 00:F592: 60                 RTS
  7386                        
  7387                        LAB_NLTO
  7388 00:F593: 85 AC              STA   FAC1_e            ; save FAC1 exponent
  7389 00:F595: A9 00              LDA   #$00              ; clear sign compare
  7390                        LAB_MLTE
  7391 00:F597: 85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  7392 00:F599: 8A                 TXA                     ; restore character
  7393 00:F59A: 20 72 F1           JSR   LAB_2912          ; evaluate new ASCII digit
  7394                        
  7395                        ; gets here if the first character was "$" for hex
  7396                        ; get hex number
  7397                        
  7398                        LAB_CHEX
  7399 00:F59D: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  7400 00:F5A0: 90 0A              BCC   LAB_ISHN          ; branch if numeric character
  7401                        
  7402 00:F5A2: 09 20              ORA   #$20              ; case convert, allow "A" to "F" and "a" to "f"
  7403 00:F5A4: E9 61              SBC   #'a'              ; subtract "a" (carry set here)
  7404 00:F5A6: C9 06              CMP   #$06              ; compare normalised with $06 (max+1)
  7405 00:F5A8: B0 2A              BCS   LAB_EXCH          ; exit if >"f" or <"0"
  7406                        
  7407 00:F5AA: 69 0A              ADC   #$0A              ; convert to nibble
  7408                        LAB_ISHN
  7409 00:F5AC: 29 0F              AND   #$0F              ; convert to binary
  7410 00:F5AE: AA                 TAX                     ; save nibble
  7411 00:F5AF: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  7412 00:F5B1: F0 E4              BEQ   LAB_MLTE          ; skip multiply if zero
  7413                        
  7414 00:F5B3: 69 04              ADC   #$04              ; add four to exponent (*16 - carry clear here)
  7415 00:F5B5: 90 DC              BCC   LAB_NLTO          ; if no overflow do evaluate digit
  7416                        
  7417                        LAB_MLTO
  7418 00:F5B7: 4C F0 ED           JMP   LAB_2564          ; do overflow error and warm start
  7419                        
  7420                        LAB_NXCH
  7421 00:F5BA: AA                 TAX                     ; save bit
  7422 00:F5BB: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  7423 00:F5BD: F0 06              BEQ   LAB_MLBT          ; skip multiply if zero
  7424                        
  7425 00:F5BF: E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*2)
  7426 00:F5C1: F0 F4              BEQ   LAB_MLTO          ; do overflow error if = $00
  7427                        
  7428 00:F5C3: A9 00              LDA   #$00              ; clear sign compare
  7429                        LAB_MLBT
  7430 00:F5C5: 85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
  7431 00:F5C7: 8A                 TXA                     ; restore bit
  7432 00:F5C8: 20 72 F1           JSR   LAB_2912          ; evaluate new ASCII digit
  7433                        
  7434                        ; gets here if the first character was  "%" for binary
  7435                        ; get binary number
  7436                        
  7437                        LAB_CBIN
  7438 00:F5CB: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  7439 00:F5CE: 49 30              EOR   #'0'              ; convert "0" to 0 etc.
  7440 00:F5D0: C9 02              CMP   #$02              ; compare with max+1
  7441 00:F5D2: 90 E6              BCC   LAB_NXCH          ; branch exit if < 2
  7442                        
  7443                        LAB_EXCH
  7444 00:F5D4: 4C 57 F1           JMP   LAB_28F6          ; evaluate -ve flag and return
  7445                        
  7446                        ; ctrl-c check routine. includes limited "life" byte save for INGET routine
  7447                        ; now also the code that checks to see if an interrupt has occurred
  7448                        
  7449                        CTRLC
  7450 00:F5D7: AD 00 02           LDA   ccflag            ; get [CTRL-C] check flag
  7451 00:F5DA: D0 18              BNE   LAB_FBA2          ; exit if inhibited
  7452                        
  7453 00:F5DC: 20 18 F8           JSR   V_INPT            ; scan input device
  7454 00:F5DF: 90 0B              BCC   LAB_FBA0          ; exit if buffer empty
  7455                        
  7456 00:F5E1: 8D 01 02           STA   ccbyte            ; save received byte
  7457 00:F5E4: A2 20              LDX   #$20              ; "life" timer for bytes
  7458 00:F5E6: 8E 02 02           STX   ccnull            ; set countdown
  7459 00:F5E9: 4C 39 DC           JMP   LAB_1636          ; return to BASIC
  7460                        
  7461                        LAB_FBA0
  7462 00:F5EC: AE 02 02           LDX   ccnull            ; get countdown byte
  7463 00:F5EF: F0 03              BEQ   LAB_FBA2          ; exit if finished
  7464                        
  7465 00:F5F1: CE 02 02           DEC   ccnull            ; else decrement countdown
  7466                        LAB_FBA2
  7467 00:F5F4: A2 DC              LDX   #NmiBase          ; set pointer to NMI values
  7468 00:F5F6: 20 FF F5           JSR   LAB_CKIN          ; go check interrupt
  7469 00:F5F9: A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
  7470 00:F5FB: 20 FF F5           JSR   LAB_CKIN          ; go check interrupt
  7471                        LAB_CRTS
  7472 00:F5FE: 60                 RTS
  7473                        
  7474                        ; check whichever interrupt is indexed by X
  7475                        
  7476                        LAB_CKIN
  7477 00:F5FF: B5 00              LDA   PLUS_0,X          ; get interrupt flag byte
  7478 00:F601: 10 FB              BPL   LAB_CRTS          ; branch if interrupt not enabled
  7479                        
  7480                        ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
  7481                        ; automatically enable the interrupt when we exit
  7482                        
  7483 00:F603: 0A                 ASL                     ; move happened bit to setup bit
  7484 00:F604: 29 40              AND   #$40              ; mask happened bits
  7485 00:F606: F0 F6              BEQ   LAB_CRTS          ; if no interrupt then exit
  7486                        
  7487 00:F608: 95 00              STA   PLUS_0,X          ; save interrupt flag byte
  7488                        
  7489 00:F60A: 8A                 TXA                     ; copy index ..
  7490 00:F60B: A8                 TAY                     ; .. to Y
  7491                        
  7492 00:F60C: 68                 PLA                     ; dump return address low byte, call from CTRL-C
  7493 00:F60D: 68                 PLA                     ; dump return address high byte
  7494                        
  7495 00:F60E: A9 05              LDA   #$05              ; need 5 bytes for GOSUB
  7496 00:F610: 20 23 D8           JSR   LAB_1212          ; check room on stack for A bytes
  7497 00:F613: A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
  7498 00:F615: 48                 PHA                     ; push on stack
  7499 00:F616: A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
  7500 00:F618: 48                 PHA                     ; push on stack
  7501 00:F619: A5 88              LDA   Clineh            ; get current line high byte
  7502 00:F61B: 48                 PHA                     ; push on stack
  7503 00:F61C: A5 87              LDA   Clinel            ; get current line low byte
  7504 00:F61E: 48                 PHA                     ; push on stack
  7505 00:F61F: A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
  7506 00:F621: 48                 PHA                     ; push on stack
  7507                        
  7508 00:F622: B9 01 00           LDA   PLUS_1,Y          ; get interrupt code pointer low byte
  7509 00:F625: 85 C3              STA   Bpntrl            ; save as BASIC execute pointer low byte
  7510 00:F627: B9 02 00           LDA   PLUS_2,Y          ; get interrupt code pointer high byte
  7511 00:F62A: 85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
  7512                        
  7513 00:F62C: 4C E0 DB           JMP   LAB_15C2          ; go do interpreter inner loop
  7514                                                      ; can't RTS, we used the stack! the RTS from the ctrl-c
  7515                                                      ; check will be taken when the RETIRQ/RETNMI/RETURN is
  7516                                                      ; executed at the end of the subroutine
  7517                        
  7518                        ; get byte from input device, no waiting
  7519                        ; returns with carry set if byte in A
  7520                        
  7521                        INGET
  7522 00:F62F: 20 18 F8           JSR   V_INPT            ; call scan input device
  7523 00:F632: B0 09              BCS   LAB_FB95          ; if byte go reset timer
  7524                        
  7525 00:F634: AD 02 02           LDA   ccnull            ; get countdown
  7526 00:F637: F0 09              BEQ   LAB_FB96          ; exit if empty
  7527                        
  7528 00:F639: AD 01 02           LDA   ccbyte            ; get last received byte
  7529 00:F63C: 38                 SEC                     ; flag we got a byte
  7530                        LAB_FB95
  7531 00:F63D: A2 00              LDX   #$00              ; clear X
  7532 00:F63F: 8E 02 02           STX   ccnull            ; clear timer because we got a byte
  7533                        LAB_FB96
  7534 00:F642: 60                 RTS
  7535                        
  7536                        ; these routines only enable the interrupts if the set-up flag is set
  7537                        ; if not they have no effect
  7538                        
  7539                        ; perform IRQ {ON|OFF|CLEAR}
  7540                        
  7541                        LAB_IRQ
  7542 00:F643: A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
  7543 00:F645: 2C                 .byte $2C               ; make next line BIT abs.
  7544                        
  7545                        ; perform NMI {ON|OFF|CLEAR}
  7546                        
  7547                        LAB_NMI
  7548 00:F646: A2 DC              LDX   #NmiBase          ; set pointer to NMI values
  7549 00:F648: C9 93              CMP   #TK_ON            ; compare with token for ON
  7550 00:F64A: F0 11              BEQ   LAB_INON          ; go turn on interrupt
  7551                        
  7552 00:F64C: C9 B5              CMP   #TK_OFF           ; compare with token for OFF
  7553 00:F64E: F0 07              BEQ   LAB_IOFF          ; go turn off interrupt
  7554                        
  7555 00:F650: 49 A2              EOR   #TK_CLEAR         ; compare with token for CLEAR, A = $00 if = TK_CLEAR
  7556 00:F652: F0 0E              BEQ   LAB_INEX          ; go clear interrupt flags and return
  7557                        
  7558 00:F654: 4C 22 E3           JMP   LAB_SNER          ; do syntax error then warm start
  7559                        
  7560                        LAB_IOFF
  7561 00:F657: A9 7F              LDA   #$7F              ; clear A
  7562 00:F659: 35 00              AND   PLUS_0,X          ; AND with interrupt setup flag
  7563 00:F65B: 10 05              BPL   LAB_INEX          ; go clear interrupt enabled flag and return
  7564                        
  7565                        LAB_INON
  7566 00:F65D: B5 00              LDA   PLUS_0,X          ; get interrupt setup flag
  7567 00:F65F: 0A                 ASL                     ; Shift bit to enabled flag
  7568 00:F660: 15 00              ORA   PLUS_0,X          ; OR with flag byte
  7569                        LAB_INEX
  7570 00:F662: 95 00              STA   PLUS_0,X          ; save interrupt flag byte
  7571 00:F664: 4C BC 00           JMP   LAB_IGBY          ; update BASIC execute pointer and return
  7572                        
  7573                        ; these routines set up the pointers and flags for the interrupt routines
  7574                        ; note that the interrupts are also enabled by these commands
  7575                        
  7576                        ; perform ON IRQ
  7577                        
  7578                        LAB_SIRQ
  7579                        ;      CLI                     ; enable interrupts
  7580 00:F667: A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
  7581 00:F669: 2C                 .byte $2C               ; make next line BIT abs.
  7582                        
  7583                        ; perform ON NMI
  7584                        
  7585                        LAB_SNMI
  7586 00:F66A: A2 DC              LDX   #NmiBase          ; set pointer to NMI values
  7587                        
  7588 00:F66C: 86 78              STX   TempB             ; save interrupt pointer
  7589 00:F66E: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (past token)
  7590 00:F671: 20 76 DE           JSR   LAB_GFPN          ; get fixed-point number into temp integer
  7591 00:F674: A5 79              LDA   Smeml             ; get start of mem low byte
  7592 00:F676: A6 7A              LDX   Smemh             ; get start of mem high byte
  7593 00:F678: 20 4B DA           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
  7594 00:F67B: B0 03              BCS   LAB_LFND          ; if carry set go set-up interrupt
  7595                        
  7596 00:F67D: 4C 90 DD           JMP   LAB_16F7          ; else go do "Undefined statement" error and warm start
  7597                        
  7598                        LAB_LFND
  7599 00:F680: A6 78              LDX   TempB             ; get interrupt pointer
  7600 00:F682: A5 AA              LDA   Baslnl            ; get pointer low byte
  7601 00:F684: E9 01              SBC   #$01              ; -1 (carry already set for subtract)
  7602 00:F686: 95 01              STA   PLUS_1,X          ; save as interrupt pointer low byte
  7603 00:F688: A5 AB              LDA   Baslnh            ; get pointer high byte
  7604 00:F68A: E9 00              SBC   #$00              ; subtract carry
  7605 00:F68C: 95 02              STA   PLUS_2,X          ; save as interrupt pointer high byte
  7606                        
  7607 00:F68E: A9 C0              LDA   #$C0              ; set interrupt enabled/setup bits
  7608 00:F690: 95 00              STA   PLUS_0,X          ; set interrupt flags
  7609                        LAB_IRTS
  7610 00:F692: 60                 RTS
  7611                        
  7612                        ; return from IRQ service, restores the enabled flag.
  7613                        
  7614                        ; perform RETIRQ
  7615                        
  7616                        LAB_RETIRQ
  7617 00:F693: D0 FD              BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
  7618                        
  7619 00:F695: A5 DF              LDA   IrqBase           ; get interrupt flags
  7620 00:F697: 0A                 ASL                     ; copy setup to enabled (b7)
  7621 00:F698: 05 DF              ORA   IrqBase           ; OR in setup flag
  7622 00:F69A: 85 DF              STA   IrqBase           ; save enabled flag
  7623 00:F69C: 4C 97 DD           JMP   LAB_16E8          ; go do rest of RETURN
  7624                        
  7625                        ; return from NMI service, restores the enabled flag.
  7626                        
  7627                        ; perform RETNMI
  7628                        
  7629                        LAB_RETNMI
  7630 00:F69F: D0 F1              BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
  7631                        
  7632 00:F6A1: A5 DC              LDA   NmiBase           ; get set-up flag
  7633 00:F6A3: 0A                 ASL                     ; copy setup to enabled (b7)
  7634 00:F6A4: 05 DC              ORA   NmiBase           ; OR in setup flag
  7635 00:F6A6: 85 DC              STA   NmiBase           ; save enabled flag
  7636 00:F6A8: 4C 97 DD           JMP   LAB_16E8          ; go do rest of RETURN
  7637                        
  7638                        ; MAX() MIN() pre process
  7639                        
  7640                        LAB_MMPP
  7641 00:F6AB: 20 09 E2           JSR   LAB_EVEZ          ; process expression
  7642 00:F6AE: 4C F0 E1           JMP   LAB_CTNM          ; check if source is numeric, else do type mismatch
  7643                        
  7644                        ; perform MAX()
  7645                        
  7646                        LAB_MAX
  7647 00:F6B1: 20 DF F6           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
  7648                                                      ; pull FAC2 and compare with FAC1
  7649 00:F6B4: 10 FB              BPL   LAB_MAX           ; branch if no swap to do
  7650                        
  7651 00:F6B6: A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
  7652 00:F6B8: 09 80              ORA   #$80              ; set top bit (clear sign from compare)
  7653 00:F6BA: 85 B4              STA   FAC2_1            ; save FAC2 mantissa1
  7654 00:F6BC: 20 F0 EC           JSR   LAB_279B          ; copy FAC2 to FAC1
  7655 00:F6BF: F0 F0              BEQ   LAB_MAX           ; go do next (branch always)
  7656                        
  7657                        ; perform MIN()
  7658                        
  7659                        LAB_MIN
  7660 00:F6C1: 20 DF F6           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
  7661                                                      ; pull FAC2 and compare with FAC1
  7662 00:F6C4: 30 FB              BMI   LAB_MIN           ; branch if no swap to do
  7663                        
  7664 00:F6C6: F0 F9              BEQ   LAB_MIN           ; branch if no swap to do
  7665                        
  7666 00:F6C8: A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
  7667 00:F6CA: 09 80              ORA   #$80              ; set top bit (clear sign from compare)
  7668 00:F6CC: 85 B4              STA   FAC2_1            ; save FAC2 mantissa1
  7669 00:F6CE: 20 F0 EC           JSR   LAB_279B          ; copy FAC2 to FAC1
  7670 00:F6D1: F0 EE              BEQ   LAB_MIN           ; go do next (branch always)
  7671                        
  7672                        ; exit routine. don't bother returning to the loop code
  7673                        ; check for correct exit, else so syntax error
  7674                        
  7675                        LAB_MMEC
  7676 00:F6D3: C9 29              CMP   #')'              ; is it end of function?
  7677 00:F6D5: D0 05              BNE   LAB_MMSE          ; if not do MAX MIN syntax error
  7678                        
  7679 00:F6D7: 68                 PLA                     ; dump return address low byte
  7680 00:F6D8: 68                 PLA                     ; dump return address high byte
  7681 00:F6D9: 4C BC 00           JMP   LAB_IGBY          ; update BASIC execute pointer (to chr past ")")
  7682                        
  7683                        LAB_MMSE
  7684 00:F6DC: 4C 22 E3           JMP   LAB_SNER          ; do syntax error then warm start
  7685                        
  7686                        ; check for next, evaluate and return or exit
  7687                        ; this is the routine that does most of the work
  7688                        
  7689                        LAB_PHFA
  7690 00:F6DF: 20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
  7691 00:F6E2: C9 2C              CMP   #','              ; is there more ?
  7692 00:F6E4: D0 ED              BNE   LAB_MMEC          ; if not go do end check
  7693                        
  7694                                                      ; push FAC1
  7695 00:F6E6: 20 06 F0           JSR   LAB_27BA          ; round FAC1
  7696 00:F6E9: A5 B0              LDA   FAC1_s            ; get FAC1 sign
  7697 00:F6EB: 09 7F              ORA   #$7F              ; set all non sign bits
  7698 00:F6ED: 25 AD              AND   FAC1_1            ; AND FAC1 mantissa1 (AND in sign bit)
  7699 00:F6EF: 48                 PHA                     ; push on stack
  7700 00:F6F0: A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
  7701 00:F6F2: 48                 PHA                     ; push on stack
  7702 00:F6F3: A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
  7703 00:F6F5: 48                 PHA                     ; push on stack
  7704 00:F6F6: A5 AC              LDA   FAC1_e            ; get FAC1 exponent
  7705 00:F6F8: 48                 PHA                     ; push on stack
  7706                        
  7707 00:F6F9: 20 BC 00           JSR   LAB_IGBY          ; scan and get next BASIC byte (after ",")
  7708 00:F6FC: 20 ED E1           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
  7709                                                      ; else do type mismatch
  7710                        
  7711                                                      ; pop FAC2 (MAX/MIN expression so far)
  7712 00:F6FF: 68                 PLA                     ; pop exponent
  7713 00:F700: 85 B3              STA   FAC2_e            ; save FAC2 exponent
  7714 00:F702: 68                 PLA                     ; pop mantissa3
  7715 00:F703: 85 B6              STA   FAC2_3            ; save FAC2 mantissa3
  7716 00:F705: 68                 PLA                     ; pop mantissa1
  7717 00:F706: 85 B5              STA   FAC2_2            ; save FAC2 mantissa2
  7718 00:F708: 68                 PLA                     ; pop sign/mantissa1
  7719 00:F709: 85 B4              STA   FAC2_1            ; save FAC2 sign/mantissa1
  7720 00:F70B: 85 B7              STA   FAC2_s            ; save FAC2 sign
  7721                        
  7722                                                      ; compare FAC1 with (packed) FAC2
  7723 00:F70D: A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
  7724 00:F70F: A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
  7725 00:F711: 4C 44 F0           JMP   LAB_27F8          ; compare FAC1 with FAC2 (AY) and return
  7726                                                      ; returns A=$00 if FAC1 = (AY)
  7727                                                      ; returns A=$01 if FAC1 > (AY)
  7728                                                      ; returns A=$FF if FAC1 < (AY)
  7729                        
  7730                        ; perform WIDTH
  7731                        
  7732                        LAB_WDTH
  7733 00:F714: C9 2C              CMP   #','              ; is next byte ","
  7734 00:F716: F0 1B              BEQ   LAB_TBSZ          ; if so do tab size
  7735                        
  7736 00:F718: 20 C0 EB           JSR   LAB_GTBY          ; get byte parameter
  7737 00:F71B: 8A                 TXA                     ; copy width to A
  7738 00:F71C: F0 0A              BEQ   LAB_NSTT          ; branch if set for infinite line
  7739                        
  7740 00:F71E: E0 10              CPX   #$10              ; else make min width = 16d
  7741 00:F720: 90 45              BCC   TabErr            ; if less do function call error and exit
  7742                        
  7743                        ; this next compare ensures that we can't exit WIDTH via an error leaving the
  7744                        ; tab size greater than the line length.
  7745                        
  7746 00:F722: E4 64              CPX   TabSiz            ; compare with tab size
  7747 00:F724: B0 02              BCS   LAB_NSTT          ; branch if >= tab size
  7748                        
  7749 00:F726: 86 64              STX   TabSiz            ; else make tab size = terminal width
  7750                        LAB_NSTT
  7751 00:F728: 86 0F              STX   TWidth            ; set the terminal width
  7752 00:F72A: 20 C2 00           JSR   LAB_GBYT          ; get BASIC byte back
  7753 00:F72D: F0 1A              BEQ   WExit             ; exit if no following
  7754                        
  7755 00:F72F: C9 2C              CMP   #','              ; else is it ","
  7756 00:F731: D0 A9              BNE   LAB_MMSE          ; if not do syntax error
  7757                        
  7758                        LAB_TBSZ
  7759 00:F733: 20 BD EB           JSR   LAB_SGBY          ; scan and get byte parameter
  7760 00:F736: 8A                 TXA                     ; copy TAB size
  7761 00:F737: 30 2E              BMI   TabErr            ; if >127 do function call error and exit
  7762                        
  7763 00:F739: E0 01              CPX   #$01              ; compare with min-1
  7764 00:F73B: 90 2A              BCC   TabErr            ; if <=1 do function call error and exit
  7765                        
  7766 00:F73D: A5 0F              LDA   TWidth            ; set flags for width
  7767 00:F73F: F0 06              BEQ   LAB_SVTB          ; skip check if infinite line
  7768                        
  7769 00:F741: E4 0F              CPX   TWidth            ; compare TAB with width
  7770 00:F743: F0 02              BEQ   LAB_SVTB          ; ok if =
  7771                        
  7772 00:F745: B0 20              BCS   TabErr            ; branch if too big
  7773                        
  7774                        LAB_SVTB
  7775 00:F747: 86 64              STX   TabSiz            ; save TAB size
  7776                        
  7777                        ; calculate tab column limit from TAB size. The Iclim is set to the last tab
  7778                        ; position on a line that still has at least one whole tab width between it
  7779                        ; and the end of the line.
  7780                        
  7781                        WExit
  7782 00:F749: A5 0F              LDA   TWidth            ; get width
  7783 00:F74B: F0 06              BEQ   LAB_SULP          ; branch if infinite line
  7784                        
  7785 00:F74D: C5 64              CMP   TabSiz            ; compare with tab size
  7786 00:F74F: B0 03              BCS   LAB_WDLP          ; branch if >= tab size
  7787                        
  7788 00:F751: 85 64              STA   TabSiz            ; else make tab size = terminal width
  7789                        LAB_SULP
  7790 00:F753: 38                 SEC                     ; set carry for subtract
  7791                        LAB_WDLP
  7792 00:F754: E5 64              SBC   TabSiz            ; subtract tab size
  7793 00:F756: B0 FC              BCS   LAB_WDLP          ; loop while no borrow
  7794                        
  7795 00:F758: 65 64              ADC   TabSiz            ; add tab size back
  7796 00:F75A: 18                 CLC                     ; clear carry for add
  7797 00:F75B: 65 64              ADC   TabSiz            ; add tab size back again
  7798 00:F75D: 85 10              STA   Iclim             ; save for now
  7799 00:F75F: A5 0F              LDA   TWidth            ; get width back
  7800 00:F761: 38                 SEC                     ; set carry for subtract
  7801 00:F762: E5 10              SBC   Iclim             ; subtract remainder
  7802 00:F764: 85 10              STA   Iclim             ; save tab column limit
  7803                        LAB_NOSQ
  7804 00:F766: 60                 RTS
  7805                        
  7806                        TabErr
  7807 00:F767: 4C 57 E6           JMP   LAB_FCER          ; do function call error then warm start
  7808                        
  7809                        ; perform SQR()
  7810                        
  7811                        LAB_SQR
  7812 00:F76A: A5 B0              LDA   FAC1_s            ; get FAC1 sign
  7813 00:F76C: 30 F9              BMI   TabErr            ; if -ve do function call error
  7814                        
  7815 00:F76E: A5 AC              LDA   FAC1_e            ; get exponent
  7816 00:F770: F0 F4              BEQ   LAB_NOSQ          ; if zero just return
  7817                        
  7818                                                      ; else do root
  7819 00:F772: 20 F7 EF           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
  7820 00:F775: A9 00              LDA   #$00              ; clear A
  7821                        
  7822 00:F777: 85 77              STA   FACt_3            ; clear remainder
  7823 00:F779: 85 76              STA   FACt_2            ; ..
  7824 00:F77B: 85 75              STA   FACt_1            ; ..
  7825 00:F77D: 85 78              STA   TempB             ; ..
  7826                        
  7827 00:F77F: 85 AF              STA   FAC1_3            ; clear root
  7828 00:F781: 85 AE              STA   FAC1_2            ; ..
  7829 00:F783: 85 AD              STA   FAC1_1            ; ..
  7830                        
  7831 00:F785: A2 18              LDX   #$18              ; 24 pairs of bits to do
  7832 00:F787: A5 B3              LDA   FAC2_e            ; get exponent
  7833 00:F789: 4A                 LSR                     ; check odd/even
  7834 00:F78A: B0 0E              BCS   LAB_SQE2          ; if odd only 1 shift first time
  7835                        
  7836                        LAB_SQE1
  7837 00:F78C: 06 B6              ASL   FAC2_3            ; shift highest bit of number ..
  7838 00:F78E: 26 B5              ROL   FAC2_2            ; ..
  7839 00:F790: 26 B4              ROL   FAC2_1            ; ..
  7840 00:F792: 26 77              ROL   FACt_3            ; .. into remainder
  7841 00:F794: 26 76              ROL   FACt_2            ; ..
  7842 00:F796: 26 75              ROL   FACt_1            ; ..
  7843 00:F798: 26 78              ROL   TempB             ; .. never overflows
  7844                        LAB_SQE2
  7845 00:F79A: 06 B6              ASL   FAC2_3            ; shift highest bit of number ..
  7846 00:F79C: 26 B5              ROL   FAC2_2            ; ..
  7847 00:F79E: 26 B4              ROL   FAC2_1            ; ..
  7848 00:F7A0: 26 77              ROL   FACt_3            ; .. into remainder
  7849 00:F7A2: 26 76              ROL   FACt_2            ; ..
  7850 00:F7A4: 26 75              ROL   FACt_1            ; ..
  7851 00:F7A6: 26 78              ROL   TempB             ; .. never overflows
  7852                        
  7853 00:F7A8: 06 AF              ASL   FAC1_3            ; root = root * 2
  7854 00:F7AA: 26 AE              ROL   FAC1_2            ; ..
  7855 00:F7AC: 26 AD              ROL   FAC1_1            ; .. never overflows
  7856                        
  7857 00:F7AE: A5 AF              LDA   FAC1_3            ; get root low byte
  7858 00:F7B0: 2A                 ROL                     ; *2
  7859 00:F7B1: 85 5B              STA   Temp3             ; save partial low byte
  7860 00:F7B3: A5 AE              LDA   FAC1_2            ; get root low mid byte
  7861 00:F7B5: 2A                 ROL                     ; *2
  7862 00:F7B6: 85 5C              STA   Temp3+1           ; save partial low mid byte
  7863 00:F7B8: A5 AD              LDA   FAC1_1            ; get root high mid byte
  7864 00:F7BA: 2A                 ROL                     ; *2
  7865 00:F7BB: 85 5D              STA   Temp3+2           ; save partial high mid byte
  7866 00:F7BD: A9 00              LDA   #$00              ; get root high byte (always $00)
  7867 00:F7BF: 2A                 ROL                     ; *2
  7868 00:F7C0: 85 5E              STA   Temp3+3           ; save partial high byte
  7869                        
  7870                                                      ; carry clear for subtract +1
  7871 00:F7C2: A5 77              LDA   FACt_3            ; get remainder low byte
  7872 00:F7C4: E5 5B              SBC   Temp3             ; subtract partial low byte
  7873 00:F7C6: 85 5B              STA   Temp3             ; save partial low byte
  7874                        
  7875 00:F7C8: A5 76              LDA   FACt_2            ; get remainder low mid byte
  7876 00:F7CA: E5 5C              SBC   Temp3+1           ; subtract partial low mid byte
  7877 00:F7CC: 85 5C              STA   Temp3+1           ; save partial low mid byte
  7878                        
  7879 00:F7CE: A5 75              LDA   FACt_1            ; get remainder high mid byte
  7880 00:F7D0: E5 5D              SBC   Temp3+2           ; subtract partial high mid byte
  7881 00:F7D2: A8                 TAY                     ; copy partial high mid byte
  7882                        
  7883 00:F7D3: A5 78              LDA   TempB             ; get remainder high byte
  7884 00:F7D5: E5 5E              SBC   Temp3+3           ; subtract partial high byte
  7885 00:F7D7: 90 0E              BCC   LAB_SQNS          ; skip sub if remainder smaller
  7886                        
  7887 00:F7D9: 85 78              STA   TempB             ; save remainder high byte
  7888                        
  7889 00:F7DB: 84 75              STY   FACt_1            ; save remainder high mid byte
  7890                        
  7891 00:F7DD: A5 5C              LDA   Temp3+1           ; get remainder low mid byte
  7892 00:F7DF: 85 76              STA   FACt_2            ; save remainder low mid byte
  7893                        
  7894 00:F7E1: A5 5B              LDA   Temp3             ; get partial low byte
  7895 00:F7E3: 85 77              STA   FACt_3            ; save remainder low byte
  7896                        
  7897 00:F7E5: E6 AF              INC   FAC1_3            ; increment root low byte (never any rollover)
  7898                        LAB_SQNS
  7899 00:F7E7: CA                 DEX                     ; decrement bit pair count
  7900 00:F7E8: D0 A2              BNE   LAB_SQE1          ; loop if not all done
  7901                        
  7902 00:F7EA: 38                 SEC                     ; set carry for subtract
  7903 00:F7EB: A5 B3              LDA   FAC2_e            ; get exponent
  7904 00:F7ED: E9 80              SBC   #$80              ; normalise
  7905 00:F7EF: 6A                 ROR                     ; /2 and re-bias to $80
  7906 00:F7F0: 69 00              ADC   #$00              ; add bit zero back in (allow for half shift)
  7907 00:F7F2: 85 AC              STA   FAC1_e            ; save it
  7908 00:F7F4: 4C 61 ED           JMP   LAB_24D5          ; normalise FAC1 and return
  7909                        
  7910                        ; perform VARPTR()
  7911                        
  7912                        LAB_VARPTR
  7913 00:F7F7: 20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
  7914 00:F7FA: 20 D8 E4           JSR   LAB_GVAR          ; get var address
  7915 00:F7FD: 20 0F E3           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
  7916 00:F800: A4 95              LDY   Cvaral            ; get var address low byte
  7917 00:F802: A5 96              LDA   Cvarah            ; get var address high byte
  7918 00:F804: 4C 87 E7           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
  7919                        
  7920                        ; perform PI
  7921                        
  7922                        LAB_PI
  7923 00:F807: A9 EB              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
  7924 00:F809: A0 F8              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
  7925 00:F80B: 20 AA EF           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
  7926 00:F80E: C6 AC              DEC   FAC1_e            ; make result = PI
  7927 00:F810: 60                 RTS
  7928                        
  7929                        ; perform TWOPI
  7930                        
  7931                        LAB_TWOPI
  7932 00:F811: A9 EB              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
  7933 00:F813: A0 F8              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
  7934 00:F815: 4C AA EF           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1 and return
  7935                        
  7936                        ; system dependant i/o vectors
  7937                        ; these are in RAM and are set by the monitor at start-up
  7938                        
  7939                        V_INPT
  7940 00:F818: 6C 05 02           JMP   (VEC_IN)          ; non halting scan input device
  7941                        V_OUTP
  7942 00:F81B: 6C 07 02           JMP   (VEC_OUT)         ; send byte to output device
  7943                        V_LOAD
  7944 00:F81E: 6C 09 02           JMP   (VEC_LD)          ; load BASIC program
  7945                        V_SAVE
  7946 00:F821: 6C 0B 02           JMP   (VEC_SV)          ; save BASIC program
  7947                        
  7948                        ; The rest are tables messages and code for RAM
  7949                        
  7950                        ; the rest of the code is tables and BASIC start-up code
  7951                        
  7952                        PG2_TABS
  7953 00:F824: 00                 .byte $00               ; ctrl-c flag           -     $00 = enabled
  7954 00:F825: 00                 .byte $00               ; ctrl-c byte           -     GET needs this
  7955 00:F826: 00                 .byte $00               ; ctrl-c byte timeout   -     GET needs this
  7956 00:F827: D7 F5              .word CTRLC             ; ctrl c check vector
  7957                        ;     .word xxxx              ; non halting key input -     monitor to set this
  7958                        ;     .word xxxx              ; output vector         -     monitor to set this
  7959                        ;     .word xxxx              ; load vector           -     monitor to set this
  7960                        ;     .word xxxx              ; save vector           -     monitor to set this
  7961                        PG2_TABE
  7962                        
  7963                        ; character get subroutine for zero page
  7964                        
  7965                        ; For a 1.8432MHz 6502 including the JSR and RTS
  7966                        ; fastest (>=":") =  29 cycles =  15.7uS
  7967                        ; slowest (<":")  =  40 cycles =  21.7uS
  7968                        ; space skip      = +21 cycles = +11.4uS
  7969                        ; inc across page =  +4 cycles =  +2.2uS
  7970                        
  7971                        ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
  7972                        ; block is copied to it's destination, any non zero page address will do at assembly
  7973                        ; time, to assemble a three byte instruction.
  7974                        
  7975                        ; page 0 initialisation table from $BC
  7976                        ; increment and scan memory
  7977                        
  7978                        LAB_2CEE
  7979 00:F829: E6 C3              INC   Bpntrl            ; increment BASIC execute pointer low byte
  7980 00:F82B: D0 02              BNE   LAB_2CF4          ; branch if no carry
  7981                                                      ; else
  7982 00:F82D: E6 C4              INC   Bpntrh            ; increment BASIC execute pointer high byte
  7983                        
  7984                        ; page 0 initialisation table from $C2
  7985                        ; scan memory
  7986                        
  7987                        LAB_2CF4
  7988 00:F82F: AD FF FF           LDA   $FFFF             ; get byte to scan (addr set by call routine)
  7989 00:F832: C9 AC              CMP   #TK_ELSE          ; compare with the token for ELSE
  7990 00:F834: F0 0E              BEQ   LAB_2D05          ; exit if ELSE, not numeric, carry set
  7991                        
  7992 00:F836: C9 3A              CMP   #':'              ; compare with ":"
  7993 00:F838: B0 0A              BCS   LAB_2D05          ; exit if >= ":", not numeric, carry set
  7994                        
  7995 00:F83A: C9 20              CMP   #' '              ; compare with " "
  7996 00:F83C: F0 EB              BEQ   LAB_2CEE          ; if " " go do next
  7997                        
  7998 00:F83E: 38                 SEC                     ; set carry for SBC
  7999 00:F83F: E9 30              SBC   #'0'              ; subtract "0"
  8000 00:F841: 38                 SEC                     ; set carry for SBC
  8001 00:F842: E9 D0              SBC   #$D0              ; subtract -"0"
  8002                                                      ; clear carry if byte = "0"-"9"
  8003                        LAB_2D05
  8004 00:F844: 60                 RTS
  8005                        
  8006                        ; page zero initialisation table $00-$12 inclusive
  8007                        
  8008                        StrTab
  8009 00:F845: 4C                 .byte $4C               ; JMP opcode
  8010 00:F846: 00 D7              .word LAB_COLD          ; initial warm start vector (cold start)
  8011                        
  8012 00:F848: 00                 .byte $00               ; these bytes are not used by BASIC
  8013 00:F849: 00 00              .word $0000             ; 
  8014 00:F84B: 00 00              .word $0000             ; 
  8015 00:F84D: 00 00              .word $0000             ; 
  8016                        
  8017 00:F84F: 4C                 .byte $4C               ; JMP opcode
  8018 00:F850: 57 E6              .word LAB_FCER          ; initial user function vector ("Function call" error)
  8019 00:F852: 00                 .byte $00               ; default NULL count
  8020 00:F853: 00                 .byte $00               ; clear terminal position
  8021 00:F854: 00                 .byte $00               ; default terminal width byte
  8022 00:F855: F2                 .byte $F2               ; default limit for TAB = 14
  8023 00:F856: 00 03              .word Ram_base          ; start of user RAM
  8024                        EndTab
  8025                        
  8026                        LAB_MSZM
  8027 00:F858: 0D 0A 4D 65        .byte $0D,$0A,"Memory size ",$00
       00:F85C: 6D 6F 72 79 
       00:F860: 20 73 69 7A 
       00:F864: 65 20 00 
  8028                        
  8029                        LAB_SMSG
  8030 00:F867: 20 42 79 74        .byte " Bytes free",$0D,$0A,$0A
       00:F86B: 65 73 20 66 
       00:F86F: 72 65 65 0D 
       00:F873: 0A 0A 
  8031 00:F875: 45 6E 68 61        .byte "Enhanced BASIC 2.22p5",$0A,$00
       00:F879: 6E 63 65 64 
       00:F87D: 20 42 41 53 
       00:F881: 49 43 20 32 
       00:F885: 2E 32 32 70 
       00:F889: 35 0A 00 
  8032                        
  8033                        ; numeric constants and series
  8034                        
  8035                                                      ; constants and series for LOG(n)
  8036                        LAB_25A0
  8037 00:F88C: 02                 .byte $02               ; counter
  8038 00:F88D: 80 19 56 62        .byte $80,$19,$56,$62   ; 0.59898
  8039 00:F891: 80 76 22 F3        .byte $80,$76,$22,$F3   ; 0.96147
  8040                        ;##   .byte $80,$76,$22,$F1   ; 0.96147
  8041 00:F895: 82 38 AA 40        .byte $82,$38,$AA,$40   ; 2.88539
  8042                        ;##   .byte $82,$38,$AA,$45   ; 2.88539
  8043                        
  8044                        LAB_25AD
  8045 00:F899: 80 35 04 F3        .byte $80,$35,$04,$F3   ; 0.70711   1/root 2
  8046                        LAB_25B1
  8047 00:F89D: 81 35 04 F3        .byte $81,$35,$04,$F3   ; 1.41421   root 2
  8048                        LAB_25B5
  8049 00:F8A1: 80 80 00 00        .byte $80,$80,$00,$00   ; -0.5
  8050                        LAB_25B9
  8051 00:F8A5: 80 31 72 18        .byte $80,$31,$72,$18   ; 0.69315   LOG(2)
  8052                        
  8053                                                      ; numeric PRINT constants
  8054                        LAB_2947
  8055 00:F8A9: 91 43 4F F8        .byte $91,$43,$4F,$F8   ; 99999.9375 (max value with at least one decimal)
  8056                        LAB_294B
  8057 00:F8AD: 94 74 23 F7        .byte $94,$74,$23,$F7   ; 999999.4375 (max value before scientific notation)
  8058                        LAB_294F
  8059 00:F8B1: 94 74 24 00        .byte $94,$74,$24,$00   ; 1000000
  8060                        
  8061                                                      ; EXP(n) constants and series
  8062                        LAB_2AFA
  8063 00:F8B5: 81 38 AA 3B        .byte $81,$38,$AA,$3B   ; 1.4427    (1/LOG base 2 e)
  8064                        LAB_2AFE
  8065 00:F8B9: 06                 .byte $06               ; counter
  8066 00:F8BA: 74 63 90 8C        .byte $74,$63,$90,$8C   ; 2.17023e-4
  8067 00:F8BE: 77 23 0C AB        .byte $77,$23,$0C,$AB   ; 0.00124
  8068 00:F8C2: 7A 1E 94 00        .byte $7A,$1E,$94,$00   ; 0.00968
  8069 00:F8C6: 7C 63 42 80        .byte $7C,$63,$42,$80   ; 0.05548
  8070 00:F8CA: 7E 75 FE D0        .byte $7E,$75,$FE,$D0   ; 0.24023
  8071 00:F8CE: 80 31 72 15        .byte $80,$31,$72,$15   ; 0.69315
  8072 00:F8D2: 81 00 00 00        .byte $81,$00,$00,$00   ; 1.00000
  8073                        
  8074                        ;##   .byte $07               ; counter
  8075                        ;##   .byte $74,$94,$2E,$40   ; -1/7! (-1/5040)
  8076                        ;##   .byte $77,$2E,$4F,$70   ;  1/6! ( 1/720)
  8077                        ;##   .byte $7A,$88,$02,$6E   ; -1/5! (-1/120)
  8078                        ;##   .byte $7C,$2A,$A0,$E6   ;  1/4! ( 1/24)
  8079                        ;##   .byte $7E,$AA,$AA,$50   ; -1/3! (-1/6)
  8080                        ;##   .byte $7F,$7F,$FF,$FF   ;  1/2! ( 1/2)
  8081                        ;##   .byte $81,$80,$00,$00   ; -1/1! (-1/1)
  8082                        ;##   .byte $81,$00,$00,$00   ;  1/0! ( 1/1)
  8083                        
  8084                                                      ; trigonometric constants and series
  8085                        LAB_2C78
  8086 00:F8D6: 81 49 0F DB        .byte $81,$49,$0F,$DB   ; 1.570796371 (pi/2) as floating #
  8087                        LAB_2C84
  8088 00:F8DA: 04                 .byte $04               ; counter
  8089 00:F8DB: 86 1E D7 FB        .byte $86,$1E,$D7,$FB   ; 39.7109
  8090                        ;##   .byte $86,$1E,$D7,$BA   ; 39.7109
  8091 00:F8DF: 87 99 26 65        .byte $87,$99,$26,$65   ;-76.575
  8092                        ;##   .byte $87,$99,$26,$64   ;-76.575
  8093 00:F8E3: 87 23 34 58        .byte $87,$23,$34,$58   ; 81.6022
  8094 00:F8E7: 86 A5 5D E1        .byte $86,$A5,$5D,$E1   ;-41.3417
  8095                        ;##   .byte $86,$A5,$5D,$E0   ;-41.3417
  8096                        LAB_2C7C
  8097 00:F8EB: 83 49 0F DB        .byte $83,$49,$0F,$DB   ; 6.28319 (2*pi) as floating #
  8098                        ;##   .byte $83,$49,$0F,$DA   ; 6.28319 (2*pi) as floating #
  8099                        
  8100                        LAB_2CC9
  8101 00:F8EF: 08                 .byte $08               ; counter
  8102 00:F8F0: 78 3A C5 37        .byte $78,$3A,$C5,$37   ; 0.00285
  8103 00:F8F4: 7B 83 A2 5C        .byte $7B,$83,$A2,$5C   ;-0.0160686
  8104 00:F8F8: 7C 2E DD 4D        .byte $7C,$2E,$DD,$4D   ; 0.0426915
  8105 00:F8FC: 7D 99 B0 1E        .byte $7D,$99,$B0,$1E   ;-0.0750429
  8106 00:F900: 7D 59 ED 24        .byte $7D,$59,$ED,$24   ; 0.106409
  8107 00:F904: 7E 91 72 00        .byte $7E,$91,$72,$00   ;-0.142036
  8108 00:F908: 7E 4C B9 73        .byte $7E,$4C,$B9,$73   ; 0.199926
  8109 00:F90C: 7F AA AA 53        .byte $7F,$AA,$AA,$53   ;-0.333331
  8110                        
  8111                        ;##   .byte $08               ; counter
  8112                        ;##   .byte $78,$3B,$D7,$4A   ; 1/17
  8113                        ;##   .byte $7B,$84,$6E,$02   ;-1/15
  8114                        ;##   .byte $7C,$2F,$C1,$FE   ; 1/13
  8115                        ;##   .byte $7D,$9A,$31,$74   ;-1/11
  8116                        ;##   .byte $7D,$5A,$3D,$84   ; 1/9
  8117                        ;##   .byte $7E,$91,$7F,$C8   ;-1/7
  8118                        ;##   .byte $7E,$4C,$BB,$E4   ; 1/5
  8119                        ;##   .byte $7F,$AA,$AA,$6C   ;-1/3
  8120                        
  8121             0000F911   LAB_1D96    equ *+1             ; $00,$00 used for undefined variables
  8122                        LAB_259C
  8123 00:F910: 81 00 00 00        .byte $81,$00,$00,$00   ; 1.000000, used for INC
  8124                        LAB_2AFD
  8125 00:F914: 81 80 00 00        .byte $81,$80,$00,$00   ; -1.00000, used for DEC. must be on the same page as +1.00
  8126                        
  8127                                                      ; misc constants
  8128                        LAB_1DF7
  8129 00:F918: 90                 .byte $90               ;-32768 (uses first three bytes from 0.5)
  8130                        LAB_2A96
  8131 00:F919: 80 00 00 00        .byte $80,$00,$00,$00   ; 0.5
  8132                        LAB_2C80
  8133 00:F91D: 7F 00 00 00        .byte $7F,$00,$00,$00   ; 0.25
  8134                        LAB_26B5
  8135 00:F921: 84 20 00 00        .byte $84,$20,$00,$00   ; 10.0000 divide by 10 constant
  8136                        
  8137                        ; This table is used in converting numbers to ASCII.
  8138                        
  8139                        LAB_2A9A
  8140             0000F926   LAB_2A9B equ LAB_2A9A+1
  8141             0000F927   LAB_2A9C equ LAB_2A9B+1
  8142 00:F925: FE 79 60           .byte $FE,$79,$60       ; -100000
  8143 00:F928: 00 27 10           .byte $00,$27,$10       ; 10000
  8144 00:F92B: FF FC 18           .byte $FF,$FC,$18       ; -1000
  8145 00:F92E: 00 00 64           .byte $00,$00,$64       ; 100
  8146 00:F931: FF FF F6           .byte $FF,$FF,$F6       ; -10
  8147 00:F934: 00 00 01           .byte $00,$00,$01       ; 1
  8148                        
  8149                        LAB_CTBL
  8150 00:F937: 3C DC              .word LAB_END-1         ; END
  8151 00:F939: 78 DB              .word LAB_FOR-1         ; FOR
  8152 00:F93B: 84 E1              .word LAB_NEXT-1        ; NEXT
  8153 00:F93D: A9 DD              .word LAB_DATA-1        ; DATA
  8154 00:F93F: 67 E0              .word LAB_INPUT-1       ; INPUT
  8155 00:F941: 8C E4              .word LAB_DIM-1         ; DIM
  8156 00:F943: 86 E0              .word LAB_READ-1        ; READ
  8157 00:F945: D4 DE              .word LAB_LET-1         ; LET
  8158 00:F947: A6 DE              .word LAB_DEC-1         ; DEC             new command
  8159 00:F949: 08 DD              .word LAB_GOTO-1        ; GOTO
  8160 00:F94B: C7 DC              .word LAB_RUN-1         ; RUN
  8161 00:F94D: D7 DD              .word LAB_IF-1          ; IF
  8162 00:F94F: 5D DC              .word LAB_RESTORE-1     ; RESTORE         modified command
  8163 00:F951: EB DC              .word LAB_GOSUB-1       ; GOSUB
  8164 00:F953: 92 F6              .word LAB_RETIRQ-1      ; RETIRQ          new command
  8165 00:F955: 9E F6              .word LAB_RETNMI-1      ; RETNMI          new command
  8166 00:F957: 94 DD              .word LAB_RETURN-1      ; RETURN
  8167 00:F959: 3E DE              .word LAB_REM-1         ; REM
  8168 00:F95B: 3A DC              .word LAB_STOP-1        ; STOP
  8169 00:F95D: 47 DE              .word LAB_ON-1          ; ON              modified command
  8170 00:F95F: 9B DC              .word LAB_NULL-1        ; NULL            modified command
  8171 00:F961: A9 DE              .word LAB_INC-1         ; INC             new command
  8172 00:F963: B5 EC              .word LAB_WAIT-1        ; WAIT
  8173 00:F965: 1D F8              .word V_LOAD-1          ; LOAD
  8174 00:F967: 20 F8              .word V_SAVE-1          ; SAVE
  8175 00:F969: A1 E7              .word LAB_DEF-1         ; DEF
  8176 00:F96B: 3A EC              .word LAB_POKE-1        ; POKE
  8177 00:F96D: 56 EC              .word LAB_DOKE-1        ; DOKE            new command
  8178 00:F96F: A3 EC              .word LAB_CALL-1        ; CALL            new command
  8179 00:F971: D1 DC              .word LAB_DO-1          ; DO              new command
  8180 00:F973: 3A DD              .word LAB_LOOP-1        ; LOOP            new command
  8181 00:F975: 75 DF              .word LAB_PRINT-1       ; PRINT
  8182 00:F977: A1 DC              .word LAB_CONT-1        ; CONT
  8183 00:F979: C3 DA              .word LAB_LIST-1        ; LIST
  8184 00:F97B: C0 DA              .word LAB_CLEAR-1       ; CLEAR
  8185 00:F97D: 70 DA              .word LAB_NEW-1         ; NEW
  8186 00:F97F: 13 F7              .word LAB_WDTH-1        ; WIDTH           new command
  8187 00:F981: 44 DF              .word LAB_GET-1         ; GET             new command
  8188 00:F983: 7B EC              .word LAB_SWAP-1        ; SWAP            new command
  8189 00:F985: AE F4              .word LAB_BITSET-1      ; BITSET          new command
  8190 00:F987: C2 F4              .word LAB_BITCLR-1      ; BITCLR          new command
  8191 00:F989: 42 F6              .word LAB_IRQ-1         ; IRQ             new command
  8192 00:F98B: 45 F6              .word LAB_NMI-1         ; NMI             new command
  8193                        
  8194                        ; function pre process routine table
  8195                        
  8196                        LAB_FTPL
  8197             0000F98E   LAB_FTPM    equ LAB_FTPL+$01
  8198 00:F98D: 92 E3              .word LAB_PPFN-1        ; SGN(n)    process numeric expression in ()
  8199 00:F98F: 92 E3              .word LAB_PPFN-1        ; INT(n)          "
  8200 00:F991: 92 E3              .word LAB_PPFN-1        ; ABS(n)          "
  8201 00:F993: 08 E2              .word LAB_EVEZ-1        ; USR(x)    process any expression
  8202 00:F995: 0B E3              .word LAB_1BF7-1        ; FRE(x)          "
  8203 00:F997: 0B E3              .word LAB_1BF7-1        ; POS(x)          "
  8204 00:F999: 92 E3              .word LAB_PPFN-1        ; SQR(n)    process numeric expression in ()
  8205 00:F99B: 92 E3              .word LAB_PPFN-1        ; RND(n)          "
  8206 00:F99D: 92 E3              .word LAB_PPFN-1        ; LOG(n)          "
  8207 00:F99F: 92 E3              .word LAB_PPFN-1        ; EXP(n)          "
  8208 00:F9A1: 92 E3              .word LAB_PPFN-1        ; COS(n)          "
  8209 00:F9A3: 92 E3              .word LAB_PPFN-1        ; SIN(n)          "
  8210 00:F9A5: 92 E3              .word LAB_PPFN-1        ; TAN(n)          "
  8211 00:F9A7: 92 E3              .word LAB_PPFN-1        ; ATN(n)          "
  8212 00:F9A9: 92 E3              .word LAB_PPFN-1        ; PEEK(n)         "
  8213 00:F9AB: 92 E3              .word LAB_PPFN-1        ; DEEK(n)         "
  8214 00:F9AD: 00 00              .word $0000             ; SADD()    none
  8215 00:F9AF: 8C E3              .word LAB_PPFS-1        ; LEN($)    process string expression in ()
  8216 00:F9B1: 92 E3              .word LAB_PPFN-1        ; STR$(n)   process numeric expression in ()
  8217 00:F9B3: 8C E3              .word LAB_PPFS-1        ; VAL($)    process string expression in ()
  8218 00:F9B5: 8C E3              .word LAB_PPFS-1        ; ASC($)          "
  8219 00:F9B7: 8C E3              .word LAB_PPFS-1        ; UCASE$($)       "
  8220 00:F9B9: 8C E3              .word LAB_PPFS-1        ; LCASE$($)       "
  8221 00:F9BB: 92 E3              .word LAB_PPFN-1        ; CHR$(n)   process numeric expression in ()
  8222 00:F9BD: B9 E3              .word LAB_BHSS-1        ; HEX$(n)         "
  8223 00:F9BF: B9 E3              .word LAB_BHSS-1        ; BIN$(n)         "
  8224 00:F9C1: 00 00              .word $0000             ; BITTST()  none
  8225 00:F9C3: AA F6              .word LAB_MMPP-1        ; MAX()     process numeric expression
  8226 00:F9C5: AA F6              .word LAB_MMPP-1        ; MIN()           "
  8227 00:F9C7: 98 E3              .word LAB_PPBI-1        ; PI        advance pointer
  8228 00:F9C9: 98 E3              .word LAB_PPBI-1        ; TWOPI           "
  8229 00:F9CB: 00 00              .word $0000             ; VARPTR()  none
  8230 00:F9CD: 9D E3              .word LAB_LRMS-1        ; LEFT$()   process string expression
  8231 00:F9CF: 9D E3              .word LAB_LRMS-1        ; RIGHT$()        "
  8232 00:F9D1: 9D E3              .word LAB_LRMS-1        ; MID$()          "
  8233                        
  8234                        ; action addresses for functions
  8235                        
  8236                        LAB_FTBL
  8237             0000F9D4   LAB_FTBM    equ LAB_FTBL+$01
  8238 00:F9D3: 23 F0              .word LAB_SGN-1         ; SGN()
  8239 00:F9D5: AD F0              .word LAB_INT-1         ; INT()
  8240 00:F9D7: 40 F0              .word LAB_ABS-1         ; ABS()
  8241 00:F9D9: 79 F4              .word LAB_USR-1         ; USR()
  8242 00:F9DB: 72 E7              .word LAB_FRE-1         ; FRE()
  8243 00:F9DD: 91 E7              .word LAB_POS-1         ; POS()
  8244 00:F9DF: 69 F7              .word LAB_SQR-1         ; SQR()
  8245 00:F9E1: C9 F3              .word LAB_RND-1         ; RND()           modified function
  8246 00:F9E3: 27 EE              .word LAB_LOG-1         ; LOG()
  8247 00:F9E5: 2B F3              .word LAB_EXP-1         ; EXP()
  8248 00:F9E7: FD F3              .word LAB_COS-1         ; COS()
  8249 00:F9E9: 04 F4              .word LAB_SIN-1         ; SIN()
  8250 00:F9EB: 4D F4              .word LAB_TAN-1         ; TAN()
  8251 00:F9ED: 7F F4              .word LAB_ATN-1         ; ATN()
  8252 00:F9EF: 2F EC              .word LAB_PEEK-1        ; PEEK()
  8253 00:F9F1: 43 EC              .word LAB_DEEK-1        ; DEEK()          new function
  8254 00:F9F3: 88 EB              .word LAB_SADD-1        ; SADD()          new function
  8255 00:F9F5: A1 EB              .word LAB_LENS-1        ; LEN()
  8256 00:F9F7: 53 E8              .word LAB_STRS-1        ; STR$()
  8257 00:F9F9: CE EB              .word LAB_VAL-1         ; VAL()
  8258 00:F9FB: AC EB              .word LAB_ASC-1         ; ASC()
  8259 00:F9FD: 66 EB              .word LAB_UCASE-1       ; UCASE$()        new function
  8260 00:F9FF: 45 EB              .word LAB_LCASE-1       ; LCASE$()        new function
  8261 00:FA01: B7 EA              .word LAB_CHRS-1        ; CHR$()
  8262 00:FA03: 4F F5              .word LAB_HEXS-1        ; HEX$()          new function
  8263 00:FA05: 00 F5              .word LAB_BINS-1        ; BIN$()          new function
  8264 00:FA07: D8 F4              .word LAB_BTST-1        ; BITTST()        new function
  8265 00:FA09: B0 F6              .word LAB_MAX-1         ; MAX()           new function
  8266 00:FA0B: C0 F6              .word LAB_MIN-1         ; MIN()           new function
  8267 00:FA0D: 06 F8              .word LAB_PI-1          ; PI              new function
  8268 00:FA0F: 10 F8              .word LAB_TWOPI-1       ; TWOPI           new function
  8269 00:FA11: F6 F7              .word LAB_VARPTR-1      ; VARPTR()        new function
  8270 00:FA13: C9 EA              .word LAB_LEFT-1        ; LEFT$()
  8271 00:FA15: D2 EA              .word LAB_RIGHT-1       ; RIGHT$()
  8272 00:FA17: 01 EB              .word LAB_MIDS-1        ; MID$()
  8273                        
  8274                        ; hierarchy and action addresses for operator
  8275                        
  8276                        LAB_OPPT
  8277 00:FA19: 79                 .byte $79               ; +
  8278 00:FA1A: ED EC              .word LAB_ADD-1
  8279 00:FA1C: 79                 .byte $79               ; -
  8280 00:FA1D: D2 EC              .word LAB_SUBTRACT-1
  8281 00:FA1F: 7B                 .byte $7B               ; *
  8282 00:FA20: 68 EE              .word LAB_MULTIPLY-1
  8283 00:FA22: 7B                 .byte $7B               ; /
  8284 00:FA23: 30 EF              .word LAB_DIVIDE-1
  8285 00:FA25: 7F                 .byte $7F               ; ^
  8286 00:FA26: E7 F2              .word LAB_POWER-1
  8287 00:FA28: 50                 .byte $50               ; AND
  8288 00:FA29: 02 E4              .word LAB_AND-1
  8289 00:FA2B: 46                 .byte $46               ; EOR             new operator
  8290 00:FA2C: E8 E3              .word LAB_EOR-1
  8291 00:FA2E: 46                 .byte $46               ; OR
  8292 00:FA2F: F5 E3              .word LAB_OR-1
  8293 00:FA31: 56                 .byte $56               ; >>              new operator
  8294 00:FA32: AE E4              .word LAB_RSHIFT-1
  8295 00:FA34: 56                 .byte $56               ; <<              new operator
  8296 00:FA35: 96 E4              .word LAB_LSHIFT-1
  8297 00:FA37: 7D                 .byte $7D               ; >
  8298 00:FA38: 20 F3              .word LAB_GTHAN-1
  8299 00:FA3A: 5A                 .byte $5A               ; =
  8300 00:FA3B: 36 E3              .word LAB_EQUAL-1
  8301 00:FA3D: 64                 .byte $64               ; <
  8302 00:FA3E: 23 E4              .word LAB_LTHAN-1
  8303                        
  8304                        ; keywords start with ..
  8305                        ; this is the first character table and must be in alphabetic order
  8306                        
  8307                        TAB_1STC
  8308 00:FA40: 2A                 .byte "*"
  8309 00:FA41: 2B                 .byte "+"
  8310 00:FA42: 2D                 .byte "-"
  8311 00:FA43: 2F                 .byte "/"
  8312 00:FA44: 3C                 .byte "<"
  8313 00:FA45: 3D                 .byte "="
  8314 00:FA46: 3E                 .byte ">"
  8315 00:FA47: 3F                 .byte "?"
  8316 00:FA48: 41                 .byte "A"
  8317 00:FA49: 42                 .byte "B"
  8318 00:FA4A: 43                 .byte "C"
  8319 00:FA4B: 44                 .byte "D"
  8320 00:FA4C: 45                 .byte "E"
  8321 00:FA4D: 46                 .byte "F"
  8322 00:FA4E: 47                 .byte "G"
  8323 00:FA4F: 48                 .byte "H"
  8324 00:FA50: 49                 .byte "I"
  8325 00:FA51: 4C                 .byte "L"
  8326 00:FA52: 4D                 .byte "M"
  8327 00:FA53: 4E                 .byte "N"
  8328 00:FA54: 4F                 .byte "O"
  8329 00:FA55: 50                 .byte "P"
  8330 00:FA56: 52                 .byte "R"
  8331 00:FA57: 53                 .byte "S"
  8332 00:FA58: 54                 .byte "T"
  8333 00:FA59: 55                 .byte "U"
  8334 00:FA5A: 56                 .byte "V"
  8335 00:FA5B: 57                 .byte "W"
  8336 00:FA5C: 5E                 .byte "^"
  8337 00:FA5D: 00                 .byte $00               ; table terminator
  8338                        
  8339                        ; pointers to keyword tables
  8340                        
  8341                        TAB_CHRT
  8342 00:FA5E: 98 FA              .word TAB_STAR          ; table for "*"
  8343 00:FA60: 9A FA              .word TAB_PLUS          ; table for "+"
  8344 00:FA62: 9C FA              .word TAB_MNUS          ; table for "-"
  8345 00:FA64: 9E FA              .word TAB_SLAS          ; table for "/"
  8346 00:FA66: A0 FA              .word TAB_LESS          ; table for "<"
  8347 00:FA68: A4 FA              .word TAB_EQUL          ; table for "="
  8348 00:FA6A: A6 FA              .word TAB_MORE          ; table for ">"
  8349 00:FA6C: AA FA              .word TAB_QEST          ; table for "?"
  8350 00:FA6E: AC FA              .word TAB_ASCA          ; table for "A"
  8351 00:FA70: BC FA              .word TAB_ASCB          ; table for "B"
  8352 00:FA72: D5 FA              .word TAB_ASCC          ; table for "C"
  8353 00:FA74: EC FA              .word TAB_ASCD          ; table for "D"
  8354 00:FA76: 05 FB              .word TAB_ASCE          ; table for "E"
  8355 00:FA78: 14 FB              .word TAB_ASCF          ; table for "F"
  8356 00:FA7A: 1E FB              .word TAB_ASCG          ; table for "G"
  8357 00:FA7C: 2B FB              .word TAB_ASCH          ; table for "H"
  8358 00:FA7E: 31 FB              .word TAB_ASCI          ; table for "I"
  8359 00:FA80: 43 FB              .word TAB_ASCL          ; table for "L"
  8360 00:FA82: 68 FB              .word TAB_ASCM          ; table for "M"
  8361 00:FA84: 76 FB              .word TAB_ASCN          ; table for "N"
  8362 00:FA86: 88 FB              .word TAB_ASCO          ; table for "O"
  8363 00:FA88: 90 FB              .word TAB_ASCP          ; table for "P"
  8364 00:FA8A: A5 FB              .word TAB_ASCR          ; table for "R"
  8365 00:FA8C: D4 FB              .word TAB_ASCS          ; table for "S"
  8366 00:FA8E: FF FB              .word TAB_ASCT          ; table for "T"
  8367 00:FA90: 13 FC              .word TAB_ASCU          ; table for "U"
  8368 00:FA92: 24 FC              .word TAB_ASCV          ; table for "V"
  8369 00:FA94: 30 FC              .word TAB_ASCW          ; table for "W"
  8370 00:FA96: 3F FC              .word TAB_POWR          ; table for "^"
  8371                        
  8372                        ; tables for each start character, note if a longer keyword with the same start
  8373                        ; letters as a shorter one exists then it must come first, else the list is in
  8374                        ; alphabetical order as follows ..
  8375                        
  8376                        ; [keyword,token
  8377                        ; [keyword,token]]
  8378                        ; end marker (#$00)
  8379                        
  8380                        TAB_STAR
  8381 00:FA98: B8 00              .byte TK_MUL,$00        ; *
  8382                        TAB_PLUS
  8383 00:FA9A: B6 00              .byte TK_PLUS,$00       ; +
  8384                        TAB_MNUS
  8385 00:FA9C: B7 00              .byte TK_MINUS,$00      ; -
  8386                        TAB_SLAS
  8387 00:FA9E: B9 00              .byte TK_DIV,$00        ; /
  8388                        TAB_LESS
  8389                        LBB_LSHIFT
  8390 00:FAA0: 3C BF              .byte "<",TK_LSHIFT     ; <<  note - "<<" must come before "<"
  8391 00:FAA2: C2                 .byte TK_LT             ; <
  8392 00:FAA3: 00                 .byte $00
  8393                        TAB_EQUL
  8394 00:FAA4: C1 00              .byte TK_EQUAL,$00      ; =
  8395                        TAB_MORE
  8396                        LBB_RSHIFT
  8397 00:FAA6: 3E BE              .byte ">",TK_RSHIFT     ; >>  note - ">>" must come before ">"
  8398 00:FAA8: C0                 .byte TK_GT             ; >
  8399 00:FAA9: 00                 .byte $00
  8400                        TAB_QEST
  8401 00:FAAA: 9F 00              .byte TK_PRINT,$00      ; ?
  8402                        TAB_ASCA
  8403                        LBB_ABS
  8404 00:FAAC: 42 53 28 C5        .byte "BS(",TK_ABS      ; ABS(
  8405                        LBB_AND
  8406 00:FAB0: 4E 44 BB           .byte "ND",TK_AND       ; AND
  8407                        LBB_ASC
  8408 00:FAB3: 53 43 28 D7        .byte "SC(",TK_ASC      ; ASC(
  8409                        LBB_ATN
  8410 00:FAB7: 54 4E 28 D0        .byte "TN(",TK_ATN      ; ATN(
  8411 00:FABB: 00                 .byte $00
  8412                        TAB_ASCB
  8413                        LBB_BINS
  8414 00:FABC: 49 4E 24 28        .byte "IN$(",TK_BINS    ; BIN$(
       00:FAC0: DC 
  8415                        LBB_BITCLR
  8416 00:FAC1: 49 54 43 4C        .byte "ITCLR",TK_BITCLR ; BITCLR
       00:FAC5: 52 A8 
  8417                        LBB_BITSET
  8418 00:FAC7: 49 54 53 45        .byte "ITSET",TK_BITSET ; BITSET
       00:FACB: 54 A7 
  8419                        LBB_BITTST
  8420 00:FACD: 49 54 54 53        .byte "ITTST(",TK_BITTST
       00:FAD1: 54 28 DD 
  8421                                                      ; BITTST(
  8422 00:FAD4: 00                 .byte $00
  8423                        TAB_ASCC
  8424                        LBB_CALL
  8425 00:FAD5: 41 4C 4C 9C        .byte "ALL",TK_CALL     ; CALL
  8426                        LBB_CHRS
  8427 00:FAD9: 48 52 24 28        .byte "HR$(",TK_CHRS    ; CHR$(
       00:FADD: DA 
  8428                        LBB_CLEAR
  8429 00:FADE: 4C 45 41 52        .byte "LEAR",TK_CLEAR   ; CLEAR
       00:FAE2: A2 
  8430                        LBB_CONT
  8431 00:FAE3: 4F 4E 54 A0        .byte "ONT",TK_CONT     ; CONT
  8432                        LBB_COS
  8433 00:FAE7: 4F 53 28 CD        .byte "OS(",TK_COS      ; COS(
  8434 00:FAEB: 00                 .byte $00
  8435                        TAB_ASCD
  8436                        LBB_DATA
  8437 00:FAEC: 41 54 41 83        .byte "ATA",TK_DATA     ; DATA
  8438                        LBB_DEC
  8439 00:FAF0: 45 43 88           .byte "EC",TK_DEC       ; DEC
  8440                        LBB_DEEK
  8441 00:FAF3: 45 45 4B 28        .byte "EEK(",TK_DEEK    ; DEEK(
       00:FAF7: D2 
  8442                        LBB_DEF
  8443 00:FAF8: 45 46 99           .byte "EF",TK_DEF       ; DEF
  8444                        LBB_DIM
  8445 00:FAFB: 49 4D 85           .byte "IM",TK_DIM       ; DIM
  8446                        LBB_DOKE
  8447 00:FAFE: 4F 4B 45 9B        .byte "OKE",TK_DOKE     ; DOKE note - "DOKE" must come before "DO"
  8448                        LBB_DO
  8449 00:FB02: 4F 9D              .byte "O",TK_DO         ; DO
  8450 00:FB04: 00                 .byte $00
  8451                        TAB_ASCE
  8452                        LBB_ELSE
  8453 00:FB05: 4C 53 45 AC        .byte "LSE",TK_ELSE     ; ELSE
  8454                        LBB_END
  8455 00:FB09: 4E 44 80           .byte "ND",TK_END       ; END
  8456                        LBB_EOR
  8457 00:FB0C: 4F 52 BC           .byte "OR",TK_EOR       ; EOR
  8458                        LBB_EXP
  8459 00:FB0F: 58 50 28 CC        .byte "XP(",TK_EXP      ; EXP(
  8460 00:FB13: 00                 .byte $00
  8461                        TAB_ASCF
  8462                        LBB_FN
  8463 00:FB14: 4E AE              .byte "N",TK_FN         ; FN
  8464                        LBB_FOR
  8465 00:FB16: 4F 52 81           .byte "OR",TK_FOR       ; FOR
  8466                        LBB_FRE
  8467 00:FB19: 52 45 28 C7        .byte "RE(",TK_FRE      ; FRE(
  8468 00:FB1D: 00                 .byte $00
  8469                        TAB_ASCG
  8470                        LBB_GET
  8471 00:FB1E: 45 54 A5           .byte "ET",TK_GET       ; GET
  8472                        LBB_GOSUB
  8473 00:FB21: 4F 53 55 42        .byte "OSUB",TK_GOSUB   ; GOSUB
       00:FB25: 8D 
  8474                        LBB_GOTO
  8475 00:FB26: 4F 54 4F 89        .byte "OTO",TK_GOTO     ; GOTO
  8476 00:FB2A: 00                 .byte $00
  8477                        TAB_ASCH
  8478                        LBB_HEXS
  8479 00:FB2B: 45 58 24 28        .byte "EX$(",TK_HEXS    ; HEX$(
       00:FB2F: DB 
  8480 00:FB30: 00                 .byte $00
  8481                        TAB_ASCI
  8482                        LBB_IF
  8483 00:FB31: 46 8B              .byte "F",TK_IF         ; IF
  8484                        LBB_INC
  8485 00:FB33: 4E 43 95           .byte "NC",TK_INC       ; INC
  8486                        LBB_INPUT
  8487 00:FB36: 4E 50 55 54        .byte "NPUT",TK_INPUT   ; INPUT
       00:FB3A: 84 
  8488                        LBB_INT
  8489 00:FB3B: 4E 54 28 C4        .byte "NT(",TK_INT      ; INT(
  8490                        LBB_IRQ
  8491 00:FB3F: 52 51 A9           .byte "RQ",TK_IRQ       ; IRQ
  8492 00:FB42: 00                 .byte $00
  8493                        TAB_ASCL
  8494                        LBB_LCASES
  8495 00:FB43: 43 41 53 45        .byte "CASE$(",TK_LCASES
       00:FB47: 24 28 D9 
  8496                                                      ; LCASE$(
  8497                        LBB_LEFTS
  8498 00:FB4A: 45 46 54 24        .byte "EFT$(",TK_LEFTS  ; LEFT$(
       00:FB4E: 28 E3 
  8499                        LBB_LEN
  8500 00:FB50: 45 4E 28 D4        .byte "EN(",TK_LEN      ; LEN(
  8501                        LBB_LET
  8502 00:FB54: 45 54 87           .byte "ET",TK_LET       ; LET
  8503                        LBB_LIST
  8504 00:FB57: 49 53 54 A1        .byte "IST",TK_LIST     ; LIST
  8505                        LBB_LOAD
  8506 00:FB5B: 4F 41 44 97        .byte "OAD",TK_LOAD     ; LOAD
  8507                        LBB_LOG
  8508 00:FB5F: 4F 47 28 CB        .byte "OG(",TK_LOG      ; LOG(
  8509                        LBB_LOOP
  8510 00:FB63: 4F 4F 50 9E        .byte "OOP",TK_LOOP     ; LOOP
  8511 00:FB67: 00                 .byte $00
  8512                        TAB_ASCM
  8513                        LBB_MAX
  8514 00:FB68: 41 58 28 DE        .byte "AX(",TK_MAX      ; MAX(
  8515                        LBB_MIDS
  8516 00:FB6C: 49 44 24 28        .byte "ID$(",TK_MIDS    ; MID$(
       00:FB70: E5 
  8517                        LBB_MIN
  8518 00:FB71: 49 4E 28 DF        .byte "IN(",TK_MIN      ; MIN(
  8519 00:FB75: 00                 .byte $00
  8520                        TAB_ASCN
  8521                        LBB_NEW
  8522 00:FB76: 45 57 A3           .byte "EW",TK_NEW       ; NEW
  8523                        LBB_NEXT
  8524 00:FB79: 45 58 54 82        .byte "EXT",TK_NEXT     ; NEXT
  8525                        LBB_NMI
  8526 00:FB7D: 4D 49 AA           .byte "MI",TK_NMI       ; NMI
  8527                        LBB_NOT
  8528 00:FB80: 4F 54 B1           .byte "OT",TK_NOT       ; NOT
  8529                        LBB_NULL
  8530 00:FB83: 55 4C 4C 94        .byte "ULL",TK_NULL     ; NULL
  8531 00:FB87: 00                 .byte $00
  8532                        TAB_ASCO
  8533                        LBB_OFF
  8534 00:FB88: 46 46 B5           .byte "FF",TK_OFF       ; OFF
  8535                        LBB_ON
  8536 00:FB8B: 4E 93              .byte "N",TK_ON         ; ON
  8537                        LBB_OR
  8538 00:FB8D: 52 BD              .byte "R",TK_OR         ; OR
  8539 00:FB8F: 00                 .byte $00
  8540                        TAB_ASCP
  8541                        LBB_PEEK
  8542 00:FB90: 45 45 4B 28        .byte "EEK(",TK_PEEK    ; PEEK(
       00:FB94: D1 
  8543                        LBB_PI
  8544 00:FB95: 49 E0              .byte "I",TK_PI         ; PI
  8545                        LBB_POKE
  8546 00:FB97: 4F 4B 45 9A        .byte "OKE",TK_POKE     ; POKE
  8547                        LBB_POS
  8548 00:FB9B: 4F 53 28 C8        .byte "OS(",TK_POS      ; POS(
  8549                        LBB_PRINT
  8550 00:FB9F: 52 49 4E 54        .byte "RINT",TK_PRINT   ; PRINT
       00:FBA3: 9F 
  8551 00:FBA4: 00                 .byte $00
  8552                        TAB_ASCR
  8553                        LBB_READ
  8554 00:FBA5: 45 41 44 86        .byte "EAD",TK_READ     ; READ
  8555                        LBB_REM
  8556 00:FBA9: 45 4D 91           .byte "EM",TK_REM       ; REM
  8557                        LBB_RESTORE
  8558 00:FBAC: 45 53 54 4F        .byte "ESTORE",TK_RESTORE
       00:FBB0: 52 45 8C 
  8559                                                      ; RESTORE
  8560                        LBB_RETIRQ
  8561 00:FBB3: 45 54 49 52        .byte "ETIRQ",TK_RETIRQ ; RETIRQ
       00:FBB7: 51 8E 
  8562                        LBB_RETNMI
  8563 00:FBB9: 45 54 4E 4D        .byte "ETNMI",TK_RETNMI ; RETNMI
       00:FBBD: 49 8F 
  8564                        LBB_RETURN
  8565 00:FBBF: 45 54 55 52        .byte "ETURN",TK_RETURN ; RETURN
       00:FBC3: 4E 90 
  8566                        LBB_RIGHTS
  8567 00:FBC5: 49 47 48 54        .byte "IGHT$(",TK_RIGHTS
       00:FBC9: 24 28 E4 
  8568                                                      ; RIGHT$(
  8569                        LBB_RND
  8570 00:FBCC: 4E 44 28 CA        .byte "ND(",TK_RND      ; RND(
  8571                        LBB_RUN
  8572 00:FBD0: 55 4E 8A           .byte "UN",TK_RUN       ; RUN
  8573 00:FBD3: 00                 .byte $00
  8574                        TAB_ASCS
  8575                        LBB_SADD
  8576 00:FBD4: 41 44 44 28        .byte "ADD(",TK_SADD    ; SADD(
       00:FBD8: D3 
  8577                        LBB_SAVE
  8578 00:FBD9: 41 56 45 98        .byte "AVE",TK_SAVE     ; SAVE
  8579                        LBB_SGN
  8580 00:FBDD: 47 4E 28 C3        .byte "GN(",TK_SGN      ; SGN(
  8581                        LBB_SIN
  8582 00:FBE1: 49 4E 28 CE        .byte "IN(",TK_SIN      ; SIN(
  8583                        LBB_SPC
  8584 00:FBE5: 50 43 28 AF        .byte "PC(",TK_SPC      ; SPC(
  8585                        LBB_SQR
  8586 00:FBE9: 51 52 28 C9        .byte "QR(",TK_SQR      ; SQR(
  8587                        LBB_STEP
  8588 00:FBED: 54 45 50 B2        .byte "TEP",TK_STEP     ; STEP
  8589                        LBB_STOP
  8590 00:FBF1: 54 4F 50 92        .byte "TOP",TK_STOP     ; STOP
  8591                        LBB_STRS
  8592 00:FBF5: 54 52 24 28        .byte "TR$(",TK_STRS    ; STR$(
       00:FBF9: D5 
  8593                        LBB_SWAP
  8594 00:FBFA: 57 41 50 A6        .byte "WAP",TK_SWAP     ; SWAP
  8595 00:FBFE: 00                 .byte $00
  8596                        TAB_ASCT
  8597                        LBB_TAB
  8598 00:FBFF: 41 42 28 AB        .byte "AB(",TK_TAB      ; TAB(
  8599                        LBB_TAN
  8600 00:FC03: 41 4E 28 CF        .byte "AN(",TK_TAN      ; TAN(
  8601                        LBB_THEN
  8602 00:FC07: 48 45 4E B0        .byte "HEN",TK_THEN     ; THEN
  8603                        LBB_TO
  8604 00:FC0B: 4F AD              .byte "O",TK_TO         ; TO
  8605                        LBB_TWOPI
  8606 00:FC0D: 57 4F 50 49        .byte "WOPI",TK_TWOPI   ; TWOPI
       00:FC11: E1 
  8607 00:FC12: 00                 .byte $00
  8608                        TAB_ASCU
  8609                        LBB_UCASES
  8610 00:FC13: 43 41 53 45        .byte "CASE$(",TK_UCASES
       00:FC17: 24 28 D8 
  8611                                                      ; UCASE$(
  8612                        LBB_UNTIL
  8613 00:FC1A: 4E 54 49 4C        .byte "NTIL",TK_UNTIL   ; UNTIL
       00:FC1E: B3 
  8614                        LBB_USR
  8615 00:FC1F: 53 52 28 C6        .byte "SR(",TK_USR      ; USR(
  8616 00:FC23: 00                 .byte $00
  8617                        TAB_ASCV
  8618                        LBB_VAL
  8619 00:FC24: 41 4C 28 D6        .byte "AL(",TK_VAL      ; VAL(
  8620                        LBB_VPTR
  8621 00:FC28: 41 52 50 54        .byte "ARPTR(",TK_VPTR  ; VARPTR(
       00:FC2C: 52 28 E2 
  8622 00:FC2F: 00                 .byte $00
  8623                        TAB_ASCW
  8624                        LBB_WAIT
  8625 00:FC30: 41 49 54 96        .byte "AIT",TK_WAIT     ; WAIT
  8626                        LBB_WHILE
  8627 00:FC34: 48 49 4C 45        .byte "HILE",TK_WHILE   ; WHILE
       00:FC38: B4 
  8628                        LBB_WIDTH
  8629 00:FC39: 49 44 54 48        .byte "IDTH",TK_WIDTH   ; WIDTH
       00:FC3D: A4 
  8630 00:FC3E: 00                 .byte $00
  8631                        TAB_POWR
  8632 00:FC3F: BA 00              .byte TK_POWER,$00      ; ^
  8633                        
  8634                        ; new decode table for LIST
  8635                        ; Table is ..
  8636                        ; byte - keyword length, keyword first character
  8637                        ; word - pointer to rest of keyword from dictionary
  8638                        
  8639                        ; note if length is 1 then the pointer is ignored
  8640                        
  8641                        LAB_KEYT
  8642 00:FC41: 03 45              .byte 3,'E'
  8643 00:FC43: 09 FB              .word LBB_END           ; END
  8644 00:FC45: 03 46              .byte 3,'F'
  8645 00:FC47: 16 FB              .word LBB_FOR           ; FOR
  8646 00:FC49: 04 4E              .byte 4,'N'
  8647 00:FC4B: 79 FB              .word LBB_NEXT          ; NEXT
  8648 00:FC4D: 04 44              .byte 4,'D'
  8649 00:FC4F: EC FA              .word LBB_DATA          ; DATA
  8650 00:FC51: 05 49              .byte 5,'I'
  8651 00:FC53: 36 FB              .word LBB_INPUT         ; INPUT
  8652 00:FC55: 03 44              .byte 3,'D'
  8653 00:FC57: FB FA              .word LBB_DIM           ; DIM
  8654 00:FC59: 04 52              .byte 4,'R'
  8655 00:FC5B: A5 FB              .word LBB_READ          ; READ
  8656 00:FC5D: 03 4C              .byte 3,'L'
  8657 00:FC5F: 54 FB              .word LBB_LET           ; LET
  8658 00:FC61: 03 44              .byte 3,'D'
  8659 00:FC63: F0 FA              .word LBB_DEC           ; DEC
  8660 00:FC65: 04 47              .byte 4,'G'
  8661 00:FC67: 26 FB              .word LBB_GOTO          ; GOTO
  8662 00:FC69: 03 52              .byte 3,'R'
  8663 00:FC6B: D0 FB              .word LBB_RUN           ; RUN
  8664 00:FC6D: 02 49              .byte 2,'I'
  8665 00:FC6F: 31 FB              .word LBB_IF            ; IF
  8666 00:FC71: 07 52              .byte 7,'R'
  8667 00:FC73: AC FB              .word LBB_RESTORE       ; RESTORE
  8668 00:FC75: 05 47              .byte 5,'G'
  8669 00:FC77: 21 FB              .word LBB_GOSUB         ; GOSUB
  8670 00:FC79: 06 52              .byte 6,'R'
  8671 00:FC7B: B3 FB              .word LBB_RETIRQ        ; RETIRQ
  8672 00:FC7D: 06 52              .byte 6,'R'
  8673 00:FC7F: B9 FB              .word LBB_RETNMI        ; RETNMI
  8674 00:FC81: 06 52              .byte 6,'R'
  8675 00:FC83: BF FB              .word LBB_RETURN        ; RETURN
  8676 00:FC85: 03 52              .byte 3,'R'
  8677 00:FC87: A9 FB              .word LBB_REM           ; REM
  8678 00:FC89: 04 53              .byte 4,'S'
  8679 00:FC8B: F1 FB              .word LBB_STOP          ; STOP
  8680 00:FC8D: 02 4F              .byte 2,'O'
  8681 00:FC8F: 8B FB              .word LBB_ON            ; ON
  8682 00:FC91: 04 4E              .byte 4,'N'
  8683 00:FC93: 83 FB              .word LBB_NULL          ; NULL
  8684 00:FC95: 03 49              .byte 3,'I'
  8685 00:FC97: 33 FB              .word LBB_INC           ; INC
  8686 00:FC99: 04 57              .byte 4,'W'
  8687 00:FC9B: 30 FC              .word LBB_WAIT          ; WAIT
  8688 00:FC9D: 04 4C              .byte 4,'L'
  8689 00:FC9F: 5B FB              .word LBB_LOAD          ; LOAD
  8690 00:FCA1: 04 53              .byte 4,'S'
  8691 00:FCA3: D9 FB              .word LBB_SAVE          ; SAVE
  8692 00:FCA5: 03 44              .byte 3,'D'
  8693 00:FCA7: F8 FA              .word LBB_DEF           ; DEF
  8694 00:FCA9: 04 50              .byte 4,'P'
  8695 00:FCAB: 97 FB              .word LBB_POKE          ; POKE
  8696 00:FCAD: 04 44              .byte 4,'D'
  8697 00:FCAF: FE FA              .word LBB_DOKE          ; DOKE
  8698 00:FCB1: 04 43              .byte 4,'C'
  8699 00:FCB3: D5 FA              .word LBB_CALL          ; CALL
  8700 00:FCB5: 02 44              .byte 2,'D'
  8701 00:FCB7: 02 FB              .word LBB_DO            ; DO
  8702 00:FCB9: 04 4C              .byte 4,'L'
  8703 00:FCBB: 63 FB              .word LBB_LOOP          ; LOOP
  8704 00:FCBD: 05 50              .byte 5,'P'
  8705 00:FCBF: 9F FB              .word LBB_PRINT         ; PRINT
  8706 00:FCC1: 04 43              .byte 4,'C'
  8707 00:FCC3: E3 FA              .word LBB_CONT          ; CONT
  8708 00:FCC5: 04 4C              .byte 4,'L'
  8709 00:FCC7: 57 FB              .word LBB_LIST          ; LIST
  8710 00:FCC9: 05 43              .byte 5,'C'
  8711 00:FCCB: DE FA              .word LBB_CLEAR         ; CLEAR
  8712 00:FCCD: 03 4E              .byte 3,'N'
  8713 00:FCCF: 76 FB              .word LBB_NEW           ; NEW
  8714 00:FCD1: 05 57              .byte 5,'W'
  8715 00:FCD3: 39 FC              .word LBB_WIDTH         ; WIDTH
  8716 00:FCD5: 03 47              .byte 3,'G'
  8717 00:FCD7: 1E FB              .word LBB_GET           ; GET
  8718 00:FCD9: 04 53              .byte 4,'S'
  8719 00:FCDB: FA FB              .word LBB_SWAP          ; SWAP
  8720 00:FCDD: 06 42              .byte 6,'B'
  8721 00:FCDF: C7 FA              .word LBB_BITSET        ; BITSET
  8722 00:FCE1: 06 42              .byte 6,'B'
  8723 00:FCE3: C1 FA              .word LBB_BITCLR        ; BITCLR
  8724 00:FCE5: 03 49              .byte 3,'I'
  8725 00:FCE7: 3F FB              .word LBB_IRQ           ; IRQ
  8726 00:FCE9: 03 4E              .byte 3,'N'
  8727 00:FCEB: 7D FB              .word LBB_NMI           ; NMI
  8728                        
  8729                        ; secondary commands (can't start a statement)
  8730                        
  8731 00:FCED: 04 54              .byte 4,'T'
  8732 00:FCEF: FF FB              .word LBB_TAB           ; TAB
  8733 00:FCF1: 04 45              .byte 4,'E'
  8734 00:FCF3: 05 FB              .word LBB_ELSE          ; ELSE
  8735 00:FCF5: 02 54              .byte 2,'T'
  8736 00:FCF7: 0B FC              .word LBB_TO            ; TO
  8737 00:FCF9: 02 46              .byte 2,'F'
  8738 00:FCFB: 14 FB              .word LBB_FN            ; FN
  8739 00:FCFD: 04 53              .byte 4,'S'
  8740 00:FCFF: E5 FB              .word LBB_SPC           ; SPC
  8741 00:FD01: 04 54              .byte 4,'T'
  8742 00:FD03: 07 FC              .word LBB_THEN          ; THEN
  8743 00:FD05: 03 4E              .byte 3,'N'
  8744 00:FD07: 80 FB              .word LBB_NOT           ; NOT
  8745 00:FD09: 04 53              .byte 4,'S'
  8746 00:FD0B: ED FB              .word LBB_STEP          ; STEP
  8747 00:FD0D: 05 55              .byte 5,'U'
  8748 00:FD0F: 1A FC              .word LBB_UNTIL         ; UNTIL
  8749 00:FD11: 05 57              .byte 5,'W'
  8750 00:FD13: 34 FC              .word LBB_WHILE         ; WHILE
  8751 00:FD15: 03 4F              .byte 3,'O'
  8752 00:FD17: 88 FB              .word LBB_OFF           ; OFF
  8753                        
  8754                        ; opperators
  8755                        
  8756 00:FD19: 01 2B              .byte 1,'+'
  8757 00:FD1B: 00 00              .word $0000             ; +
  8758 00:FD1D: 01 2D              .byte 1,'-'
  8759 00:FD1F: 00 00              .word $0000             ; -
  8760 00:FD21: 01 2A              .byte 1,'*'
  8761 00:FD23: 00 00              .word $0000             ; *
  8762 00:FD25: 01 2F              .byte 1,'/'
  8763 00:FD27: 00 00              .word $0000             ; /
  8764 00:FD29: 01 5E              .byte 1,'^'
  8765 00:FD2B: 00 00              .word $0000             ; ^
  8766 00:FD2D: 03 41              .byte 3,'A'
  8767 00:FD2F: B0 FA              .word LBB_AND           ; AND
  8768 00:FD31: 03 45              .byte 3,'E'
  8769 00:FD33: 0C FB              .word LBB_EOR           ; EOR
  8770 00:FD35: 02 4F              .byte 2,'O'
  8771 00:FD37: 8D FB              .word LBB_OR            ; OR
  8772 00:FD39: 02 3E              .byte 2,'>'
  8773 00:FD3B: A6 FA              .word LBB_RSHIFT        ; >>
  8774 00:FD3D: 02 3C              .byte 2,'<'
  8775 00:FD3F: A0 FA              .word LBB_LSHIFT        ; <<
  8776 00:FD41: 01 3E              .byte 1,'>'
  8777 00:FD43: 00 00              .word $0000             ; >
  8778 00:FD45: 01 3D              .byte 1,'='
  8779 00:FD47: 00 00              .word $0000             ; =
  8780 00:FD49: 01 3C              .byte 1,'<'
  8781 00:FD4B: 00 00              .word $0000             ; <
  8782                        
  8783                        ; functions
  8784                        
  8785 00:FD4D: 04 53              .byte 4,'S'             ;
  8786 00:FD4F: DD FB              .word LBB_SGN           ; SGN
  8787 00:FD51: 04 49              .byte 4,'I'             ;
  8788 00:FD53: 3B FB              .word LBB_INT           ; INT
  8789 00:FD55: 04 41              .byte 4,'A'             ;
  8790 00:FD57: AC FA              .word LBB_ABS           ; ABS
  8791 00:FD59: 04 55              .byte 4,'U'             ;
  8792 00:FD5B: 1F FC              .word LBB_USR           ; USR
  8793 00:FD5D: 04 46              .byte 4,'F'             ;
  8794 00:FD5F: 19 FB              .word LBB_FRE           ; FRE
  8795 00:FD61: 04 50              .byte 4,'P'             ;
  8796 00:FD63: 9B FB              .word LBB_POS           ; POS
  8797 00:FD65: 04 53              .byte 4,'S'             ;
  8798 00:FD67: E9 FB              .word LBB_SQR           ; SQR
  8799 00:FD69: 04 52              .byte 4,'R'             ;
  8800 00:FD6B: CC FB              .word LBB_RND           ; RND
  8801 00:FD6D: 04 4C              .byte 4,'L'             ;
  8802 00:FD6F: 5F FB              .word LBB_LOG           ; LOG
  8803 00:FD71: 04 45              .byte 4,'E'             ;
  8804 00:FD73: 0F FB              .word LBB_EXP           ; EXP
  8805 00:FD75: 04 43              .byte 4,'C'             ;
  8806 00:FD77: E7 FA              .word LBB_COS           ; COS
  8807 00:FD79: 04 53              .byte 4,'S'             ;
  8808 00:FD7B: E1 FB              .word LBB_SIN           ; SIN
  8809 00:FD7D: 04 54              .byte 4,'T'             ;
  8810 00:FD7F: 03 FC              .word LBB_TAN           ; TAN
  8811 00:FD81: 04 41              .byte 4,'A'             ;
  8812 00:FD83: B7 FA              .word LBB_ATN           ; ATN
  8813 00:FD85: 05 50              .byte 5,'P'             ;
  8814 00:FD87: 90 FB              .word LBB_PEEK          ; PEEK
  8815 00:FD89: 05 44              .byte 5,'D'             ;
  8816 00:FD8B: F3 FA              .word LBB_DEEK          ; DEEK
  8817 00:FD8D: 05 53              .byte 5,'S'             ;
  8818 00:FD8F: D4 FB              .word LBB_SADD          ; SADD
  8819 00:FD91: 04 4C              .byte 4,'L'             ;
  8820 00:FD93: 50 FB              .word LBB_LEN           ; LEN
  8821 00:FD95: 05 53              .byte 5,'S'             ;
  8822 00:FD97: F5 FB              .word LBB_STRS          ; STR$
  8823 00:FD99: 04 56              .byte 4,'V'             ;
  8824 00:FD9B: 24 FC              .word LBB_VAL           ; VAL
  8825 00:FD9D: 04 41              .byte 4,'A'             ;
  8826 00:FD9F: B3 FA              .word LBB_ASC           ; ASC
  8827 00:FDA1: 07 55              .byte 7,'U'             ;
  8828 00:FDA3: 13 FC              .word LBB_UCASES        ; UCASE$
  8829 00:FDA5: 07 4C              .byte 7,'L'             ;
  8830 00:FDA7: 43 FB              .word LBB_LCASES        ; LCASE$
  8831 00:FDA9: 05 43              .byte 5,'C'             ;
  8832 00:FDAB: D9 FA              .word LBB_CHRS          ; CHR$
  8833 00:FDAD: 05 48              .byte 5,'H'             ;
  8834 00:FDAF: 2B FB              .word LBB_HEXS          ; HEX$
  8835 00:FDB1: 05 42              .byte 5,'B'             ;
  8836 00:FDB3: BC FA              .word LBB_BINS          ; BIN$
  8837 00:FDB5: 07 42              .byte 7,'B'             ;
  8838 00:FDB7: CD FA              .word LBB_BITTST        ; BITTST
  8839 00:FDB9: 04 4D              .byte 4,'M'             ;
  8840 00:FDBB: 68 FB              .word LBB_MAX           ; MAX
  8841 00:FDBD: 04 4D              .byte 4,'M'             ;
  8842 00:FDBF: 71 FB              .word LBB_MIN           ; MIN
  8843 00:FDC1: 02 50              .byte 2,'P'             ;
  8844 00:FDC3: 95 FB              .word LBB_PI            ; PI
  8845 00:FDC5: 05 54              .byte 5,'T'             ;
  8846 00:FDC7: 0D FC              .word LBB_TWOPI         ; TWOPI
  8847 00:FDC9: 07 56              .byte 7,'V'             ;
  8848 00:FDCB: 28 FC              .word LBB_VPTR          ; VARPTR
  8849 00:FDCD: 06 4C              .byte 6,'L'             ;
  8850 00:FDCF: 4A FB              .word LBB_LEFTS         ; LEFT$
  8851 00:FDD1: 07 52              .byte 7,'R'             ;
  8852 00:FDD3: C5 FB              .word LBB_RIGHTS        ; RIGHT$
  8853 00:FDD5: 05 4D              .byte 5,'M'             ;
  8854 00:FDD7: 6C FB              .word LBB_MIDS          ; MID$
  8855                        
  8856                        ; BASIC messages, mostly error messages
  8857                        
  8858                        LAB_BAER
  8859 00:FDD9: FD FD              .word ERR_NF            ;$00 NEXT without FOR
  8860 00:FDDB: 0E FE              .word ERR_SN            ;$02 syntax
  8861 00:FDDD: 15 FE              .word ERR_RG            ;$04 RETURN without GOSUB
  8862 00:FDDF: 2A FE              .word ERR_OD            ;$06 out of data
  8863 00:FDE1: 36 FE              .word ERR_FC            ;$08 function call
  8864 00:FDE3: 44 FE              .word ERR_OV            ;$0A overflow
  8865 00:FDE5: 4D FE              .word ERR_OM            ;$0C out of memory
  8866 00:FDE7: 5B FE              .word ERR_US            ;$0E undefined statement
  8867 00:FDE9: 6F FE              .word ERR_BS            ;$10 array bounds
  8868 00:FDEB: 7C FE              .word ERR_DD            ;$12 double dimension array
  8869 00:FDED: 8D FE              .word ERR_D0            ;$14 divide by 0
  8870 00:FDEF: 9C FE              .word ERR_ID            ;$16 illegal direct
  8871 00:FDF1: AB FE              .word ERR_TM            ;$18 type mismatch
  8872 00:FDF3: B9 FE              .word ERR_LS            ;$1A long string
  8873 00:FDF5: C9 FE              .word ERR_ST            ;$1C string too complex
  8874 00:FDF7: DC FE              .word ERR_CN            ;$1E continue error
  8875 00:FDF9: EB FE              .word ERR_UF            ;$20 undefined function
  8876 00:FDFB: FE FE              .word ERR_LD            ;$22 LOOP without DO
  8877                        
  8878                        ; I may implement these two errors to force definition of variables and
  8879                        ; dimensioning of arrays before use.
  8880                        
  8881                        ;     .word ERR_UV            ;$24 undefined variable
  8882                        
  8883                        ; the above error has been tested and works (see code and comments below LAB_1D8B)
  8884                        
  8885                        ;     .word ERR_UA            ;$26 undimensioned array
  8886                        
  8887 00:FDFD: 4E 45 58 54  ERR_NF      .byte "NEXT without FOR",$00
       00:FE01: 20 77 69 74 
       00:FE05: 68 6F 75 74 
       00:FE09: 20 46 4F 52 
       00:FE0D: 00 
  8888 00:FE0E: 53 79 6E 74  ERR_SN      .byte "Syntax",$00
       00:FE12: 61 78 00 
  8889 00:FE15: 52 45 54 55  ERR_RG      .byte "RETURN without GOSUB",$00
       00:FE19: 52 4E 20 77 
       00:FE1D: 69 74 68 6F 
       00:FE21: 75 74 20 47 
       00:FE25: 4F 53 55 42 
       00:FE29: 00 
  8890 00:FE2A: 4F 75 74 20  ERR_OD      .byte "Out of DATA",$00
       00:FE2E: 6F 66 20 44 
       00:FE32: 41 54 41 00 
  8891 00:FE36: 46 75 6E 63  ERR_FC      .byte "Function call",$00
       00:FE3A: 74 69 6F 6E 
       00:FE3E: 20 63 61 6C 
       00:FE42: 6C 00 
  8892 00:FE44: 4F 76 65 72  ERR_OV      .byte "Overflow",$00
       00:FE48: 66 6C 6F 77 
       00:FE4C: 00 
  8893 00:FE4D: 4F 75 74 20  ERR_OM      .byte "Out of memory",$00
       00:FE51: 6F 66 20 6D 
       00:FE55: 65 6D 6F 72 
       00:FE59: 79 00 
  8894 00:FE5B: 55 6E 64 65  ERR_US      .byte "Undefined statement",$00
       00:FE5F: 66 69 6E 65 
       00:FE63: 64 20 73 74 
       00:FE67: 61 74 65 6D 
       00:FE6B: 65 6E 74 00 
  8895 00:FE6F: 41 72 72 61  ERR_BS      .byte "Array bounds",$00
       00:FE73: 79 20 62 6F 
       00:FE77: 75 6E 64 73 
       00:FE7B: 00 
  8896 00:FE7C: 44 6F 75 62  ERR_DD      .byte "Double dimension",$00
       00:FE80: 6C 65 20 64 
       00:FE84: 69 6D 65 6E 
       00:FE88: 73 69 6F 6E 
       00:FE8C: 00 
  8897 00:FE8D: 44 69 76 69  ERR_D0      .byte "Divide by zero",$00
       00:FE91: 64 65 20 62 
       00:FE95: 79 20 7A 65 
       00:FE99: 72 6F 00 
  8898 00:FE9C: 49 6C 6C 65  ERR_ID      .byte "Illegal direct",$00
       00:FEA0: 67 61 6C 20 
       00:FEA4: 64 69 72 65 
       00:FEA8: 63 74 00 
  8899 00:FEAB: 54 79 70 65  ERR_TM      .byte "Type mismatch",$00
       00:FEAF: 20 6D 69 73 
       00:FEB3: 6D 61 74 63 
       00:FEB7: 68 00 
  8900 00:FEB9: 53 74 72 69  ERR_LS      .byte "String too long",$00
       00:FEBD: 6E 67 20 74 
       00:FEC1: 6F 6F 20 6C 
       00:FEC5: 6F 6E 67 00 
  8901 00:FEC9: 53 74 72 69  ERR_ST      .byte "String too complex",$00
       00:FECD: 6E 67 20 74 
       00:FED1: 6F 6F 20 63 
       00:FED5: 6F 6D 70 6C 
       00:FED9: 65 78 00 
  8902 00:FEDC: 43 61 6E 27  ERR_CN      .byte "Can't continue",$00
       00:FEE0: 74 20 63 6F 
       00:FEE4: 6E 74 69 6E 
       00:FEE8: 75 65 00 
  8903 00:FEEB: 55 6E 64 65  ERR_UF      .byte "Undefined function",$00
       00:FEEF: 66 69 6E 65 
       00:FEF3: 64 20 66 75 
       00:FEF7: 6E 63 74 69 
       00:FEFB: 6F 6E 00 
  8904 00:FEFE: 4C 4F 4F 50  ERR_LD      .byte "LOOP without DO",$00
       00:FF02: 20 77 69 74 
       00:FF06: 68 6F 75 74 
       00:FF0A: 20 44 4F 00 
  8905                        
  8906                        ;ERR_UV     .byte "Undefined variable",$00
  8907                        
  8908                        ; the above error has been tested and works (see code and comments below LAB_1D8B)
  8909                        
  8910                        ;ERR_UA     .byte "Undimensioned array",$00
  8911                        
  8912 00:FF0E: 0D 0A 42 72  LAB_BMSG    .byte $0D,$0A,"Break",$00
       00:FF12: 65 61 6B 00 
  8913 00:FF16: 20 45 72 72  LAB_EMSG    .byte " Error",$00
       00:FF1A: 6F 72 00 
  8914 00:FF1D: 20 69 6E 20  LAB_LMSG    .byte " in line ",$00
       00:FF21: 6C 69 6E 65 
       00:FF25: 20 00 
  8915 00:FF27: 0D 0A 52 65  LAB_RMSG    .byte $0D,$0A,"Ready",$0D,$0A,$00
       00:FF2B: 61 64 79 0D 
       00:FF2F: 0A 00 
  8916                        
  8917 00:FF31: 20 45 78 74  LAB_IMSG    .byte " Extra ignored",$0D,$0A,$00
       00:FF35: 72 61 20 69 
       00:FF39: 67 6E 6F 72 
       00:FF3D: 65 64 0D 0A 
       00:FF41: 00 
  8918 00:FF42: 20 52 65 64  LAB_REDO    .byte " Redo from start",$0D,$0A,$00
       00:FF46: 6F 20 66 72 
       00:FF4A: 6F 6D 20 73 
       00:FF4E: 74 61 72 74 
       00:FF52: 0D 0A 00 
  8919                        
  8920                        AA_end_basic
    13                        
    14                        ; put the IRQ and MNI code in RAM so that it can be changed
    15                        
    16             0000020D   IRQ_vec equ VEC_SV+2              ; IRQ code vector
    17             00000217   NMI_vec equ IRQ_vec+$0A   ; NMI code vector
    18                        
    19                        ; now the code. all this does is set up the vectors and interrupt code
    20                        ; and wait for the user to select [C]old or [W]arm start. nothing else
    21                        ; fits in less than 128 bytes
    22                        
    23                        
    24                        ;        .dsb    $FF60 - *, $FF
    25                                org $FF60
    26                        ; reset vector points here
    27                        
    28                        RES_vec
    29 00:FF60: 78                   SEI
    30 00:FF61: D8                   CLD                             ; clear decimal mode
    31 00:FF62: A2 FF                LDX     #$FF                    ; empty stack
    32 00:FF64: 9A                   TXS                             ; set the stack
    33                        
    34 00:FF65: 20 93 FF             jsr     INIT_RPB        ; clear PIC request command table
    35                        
    36                        ; set up vectors and interrupt code, copy them to page 2
    37                        
    38 00:FF68: A0 1C                LDY     #END_CODE-LAB_vec       ; set index/count
    39                        LAB_stlp
    40 00:FF6A: B9 B5 FF             LDA     LAB_vec-1,Y             ; get byte from interrupt code
    41 00:FF6D: 99 04 02             STA     VEC_IN-1,Y              ; save to RAM
    42 00:FF70: 88                   DEY                             ; decrement index/count
    43 00:FF71: D0 F7                BNE     LAB_stlp                ; loop if more to do
    44                        
    45                        ; now do the signon message, Y = $00 here
    46                        
    47                        
    48                        LAB_signon
    49 00:FF73: B9 D2 FF             LDA     LAB_mess,Y              ; get byte from sign on message
    50 00:FF76: F0 06                BEQ     LAB_nokey               ; exit loop if done
    51                        
    52 00:FF78: 20 AC FF             JSR     CONOUT                  ; output character
    53 00:FF7B: C8                   INY                             ; increment index
    54 00:FF7C: D0 F5                BNE     LAB_signon              ; loop, branch always
    55                        
    56                        LAB_nokey
    57 00:FF7E: 20 9C FF             JSR     CONIN                   ; call scan input device
    58 00:FF81: 90 FB                BCC     LAB_nokey               ; loop if no key
    59                        
    60 00:FF83: 29 DF                AND     #$DF                    ; mask xx0x xxxx, ensure upper case
    61 00:FF85: C9 57                CMP     #'W'                    ; compare with [W]arm start
    62 00:FF87: F0 07                BEQ     LAB_dowarm              ; branch if [W]arm start
    63                        
    64 00:FF89: C9 43                CMP     #'C'                    ; compare with [C]old start
    65 00:FF8B: D0 D3                BNE     RES_vec                 ; loop if not [C]old start
    66                        
    67 00:FF8D: 4C 00 D7             JMP     LAB_COLD                ; do EhBASIC cold start
    68                        
    69                        LAB_dowarm
    70 00:FF90: 4C 00 00             JMP     LAB_WARM                ; do EhBASIC warm start
    71                        
    72                        ;;;
    73                        ;;;     Console Driver
    74                        ;;;
    75                        
    76             00000001   CONIN_REQ     equ       $01
    77             00000002   CONOUT_REQ    equ       $02
    78             00000003   CONST_REQ     equ       $03
    79             00000004   STROUT_REQ    equ       $04
    80                        
    81                        ;  ---- request command to PIC
    82                        ; UREQ_COM = 1 ; CONIN  : return char in UNI_CHR
    83                        ;          = 2 ; CONOUT : UNI_CHR = output char
    84                        ;          = 3 ; CONST  : return status in UNI_CHR
    85                        ;                       : ( 0: no key, 1 : key exist )
    86                        ;
    87                        ; PIC18F47QXX I/F( zero page )
    88                        ; adr :
    89                        ;  18 : UREQ_COM        rmb     1       ; unimon CONIN/CONOUT request command
    90                        ;  19 : UNI_CHR         rmb     1       ; charcter (CONIN/CONOUT) or number of strings
    91                        ;  1A : CREQ_COM        rmb     1       ; unimon CONIN/CONOUT request command
    92                        ;  1B : CBI_CHR         rmb     1       ; charcter (CONIN/CONOUT) or number of strings
    93                        
    94                        
    95                        INIT_RPB
    96                                ; clear Reqest Parameter Block
    97 00:FF93: A9 00                lda     #0
    98 00:FF95: 85 18                sta     UREQ_COM
    99 00:FF97: 85 1A                sta     CREQ_COM
   100                        no_load                         ; empty load vector for EhBASIC
   101                        no_save                         ; empty save vector for EhBASIC
   102 00:FF99: 60                   RTS
   103                        
   104                        no_key
   105 00:FF9A: 18                   clc
   106 00:FF9B: 60                   RTS
   107                        
   108                        CONIN
   109 00:FF9C: A9 03                lda     #CONST_REQ
   110 00:FF9E: 20 A5 FF             jsr     wup_pic
   111 00:FFA1: F0 F7                beq     no_key
   112                        
   113 00:FFA3: A9 01                lda     #CONIN_REQ
   114                        
   115                        wup_pic
   116 00:FFA5: 85 1A                sta     CREQ_COM
   117 00:FFA7: CB                   wai                     ; RDY = 0, wait /IRQ detect
   118                        ;        nop
   119                        ;        nop
   120                        ;        nop
   121                        ;        nop
   122                        ;        nop
   123                        ;        nop
   124                        ;        nop
   125                        ;        nop
   126                        
   127 00:FFA8: A5 1B                lda     CBI_CHR
   128 00:FFAA: 38                   sec
   129 00:FFAB: 60                   RTS
   130                        
   131                        CONOUT
   132 00:FFAC: 85 1B                sta     CBI_CHR         ; set char
   133 00:FFAE: 48                   pha
   134 00:FFAF: A9 02                lda     #CONOUT_REQ
   135 00:FFB1: 20 A5 FF             jsr     wup_pic
   136 00:FFB4: 68                   pla
   137 00:FFB5: 60                   rts
   138                        
   139                        ; vector tables
   140                        
   141                        LAB_vec
   142 00:FFB6: 9C FF                .word   CONIN           ; byte in from simulated ACIA
   143 00:FFB8: AC FF                .word   CONOUT          ; byte out to simulated ACIA
   144 00:FFBA: 99 FF                .word   no_load         ; null load vector for EhBASIC
   145 00:FFBC: 99 FF                .word   no_save         ; null save vector for EhBASIC
   146                        
   147                        ; EhBASIC IRQ support
   148                        
   149                        IRQ_CODE
   150 00:FFBE: 48                   PHA                     ; save A
   151 00:FFBF: A5 DF                LDA     IrqBase         ; get the IRQ flag byte
   152 00:FFC1: 4A                   LSR                     ; shift the set b7 to b6, and on down ...
   153 00:FFC2: 05 DF                ORA     IrqBase         ; OR the original back in
   154 00:FFC4: 85 DF                STA     IrqBase         ; save the new IRQ flag byte
   155 00:FFC6: 68                   PLA                             ; restore A
   156 00:FFC7: 40                   RTI
   157                        
   158                        ; EhBASIC NMI support
   159                        
   160                        NMI_CODE
   161 00:FFC8: 48                   PHA                     ; save A
   162 00:FFC9: A5 DC                LDA     NmiBase         ; get the NMI flag byte
   163 00:FFCB: 4A                   LSR                     ; shift the set b7 to b6, and on down ...
   164 00:FFCC: 05 DC                ORA     NmiBase         ; OR the original back in
   165 00:FFCE: 85 DC                STA     NmiBase         ; save the new NMI flag byte
   166 00:FFD0: 68                   PLA                     ; restore A
   167 00:FFD1: 40                   RTI
   168                        
   169                        END_CODE
   170                        
   171                        LAB_mess
   172 00:FFD2: 0D 0A 36 35          .byte   $0D,$0A,"6502 EhBASIC [C]old/[W]arm ?",$00
       00:FFD6: 30 32 20 45 
       00:FFDA: 68 42 41 53 
       00:FFDE: 49 43 20 5B 
       00:FFE2: 43 5D 6F 6C 
       00:FFE6: 64 2F 5B 57 
       00:FFEA: 5D 61 72 6D 
       00:FFEE: 20 3F 00 
   173                                                                ; sign on string
   174                        
   175                        ; system vectors
   176                        
   177                        ;        .dsb    $FFFA - *, $FF
   178                                org $FFFA
   179                        
   180 00:FFFA: 17 02                .word   NMI_vec         ; NMI vector
   181 00:FFFC: 60 FF                .word   RES_vec         ; RESET vector
   182 00:FFFE: 0D 02                .word   IRQ_vec         ; IRQ vector
   183                        


      Lines assembled: 9103
      Errors: 0
