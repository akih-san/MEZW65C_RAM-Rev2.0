・ロードされているモニタの種類
mon 0: mon02
    1: mon16

cpu_flg 0: 6502
         1: 65816

setup_monitor()でcpu_flgに従って、mon02または、mon16をロードし起動する。
モニタは、起動後スリープコマンドwai状態になり、でファームに戻ってくる。

mon02, mon16は起動するとファイルヘッダのu_sw（mezID+0）を調べる。
ファームが
０を書き込んで起動した場合は、モニターの起動
１を書き込んだ場合は、BIOSコールを使用するロードされたアプリを起動
それ以外は、wai命令でスリープ状態になる。


（JSL実行時のスタック）
sp->
    PC(L)
    PC(H)
    PBR

load_program()
ファイルをロードし、ファイルヘッダー(header）情報をfhに取得する。
プログラムが動作可能な場合、次の３つをまず取得する。

fh.bios_sw = header->bios_sw;	0(standalone), 1(BIOS call), 2(monitor)
fh.load_p = header->load_p;		ロードアドレス（ファイルヘッダーの先頭アドレス）
fh.sw_816 = header->sw_816;		0: 6502 1:65816 2:両方で動作

header->bios_swがBIOS callな場合、fhには、モニタ情報が必要なので、BIOS callのファイルヘッダで
書き換えられてはならない。
BIOS callプログラムの情報は他に持つ必要がある。（他のBIOS call、スタンドアロンプログラムで
上書き、もしくはフラッシュ？が必要）

ロードコマンドはロードするために、ファイルヘッダーを見るが、fhには取り込まない。

ファイルヘッダーの情報を見るコマンド（show？）が必要

bios call プログラムを起動時（モニタから起動時）、デフォルトのユーザースタックを設定する。
6502の場合、$1c0～$1FFまでをmon02で使用することにする。（ユーザースタックは$1BFに設定。）
mon16はspは16ビットなので、mon16自身はワークDPの直下に設定する。ユーザースタックは
$1FFに設定。


